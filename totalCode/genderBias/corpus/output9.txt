  As discussed in #1247, the fact that `Endpoint` has default values of `.get` & `.requestPlain` can be a point of confusion when users are creating their own Endpoints. This is cool, thanks @SD10! Did you also check Demo project/Docs if it needs updating anywhere? @sunshinejr I meant to check the docs and forgot. I will shift this to WIP and take care of it. About the demo app -- I'm guilty of not even thinking about that. I will do this too üòÖ  No worries! We have 2 projects right now that we have to check whenever developing stuff so it happens often, to me as well. We should take care of consolidating them (#891) in the near future so it is easier for us.  ### Changes:

**Adds:**
`MoyaError.parameterEncoding(Swift.Error) case`

**Refactors:**
`urlRequest` -> `urlRequest()` (now throwing)

### Summary of Pull Request:

As discussed in #1247 I saw that it would be really easy to pass on the errors thrown when attempting to encode `URLRequest` parameters.

All that had to be done is convert `Endpoint`'s `urlRequest` property to a throwing function and pass the error to the `.failure` closure in `MoyaProvider.defaultRequestMapping`.

Personally, I'm not too fond of having to call `try` now when accessing an `Endpoint`'s `urlRequest`. Therefore, I mostly consider this "research" unless any of you think there's value in it.   @Legoless The parameters get applied inside of the provider's `requestClosure`. 
It is set to [`MoyaProvider.defaultRequestMapping`](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider%2BDefaults.swift) by default. 
It does this by calling the [`urlRequest`](https://github.com/Moya/Moya/blob/master/Sources/Moya/Endpoint.swift) property on `Endpoint`. @Legoless this is a great idea. In fact, I think we should remove all default parameters from `Endpoint.init` as all of them might get confusing. Would you be up for a PR maybe? :)

It will be a breaking change, but I think this is for a good cause. I agree, let's remove them so no one else faces this issue. @Legoless Thanks for the feedback and sorry for the confusion! @sunshinejr Do you think there's any value in making the `urlRequest` property throwing and then propagating the parameter encoding errors? 

Since `defaultRequestMapping` just converts a `URLRequest` to a `Result<URLRequest,Error>` we can pass on this information quite easily here. Just on my mind from looking at this part of the code.

If `urlRequest` is used frequently outside of this context -- having to use it with try could be too annoying ü§î  @SD10 seems like it would be quite helpful! If you have some free time to research this one I think it would be a great update of our error handling üëç  Closing this in favor of #1249  Hey @gumnym, thanks for the issue. However, this one is rather a Mapper problem, see this one here: [Mapper#105](https://github.com/lyft/mapper/issues/105) (probably `null` in your JSON payload). You can bump this issue so the creators of Mapper know that this is still a valid problem.

I'm gonna close this one, but if there is something else to it please don't hesitate to reopen it again üëç   I look at coverage
I do not see test on uploading multipart data, so I make one like I make the others
I do not know if there is a better place for this

I upload file and data to httpbin.org
And check the JSON data returned by the server. I see one think about multipart data
`MoyaProvider.performRequest` could do execute an `fatalError`

If I provide an empty array of multipart data. A test maybe could be done  a simple test for upload using httpbin.org website

see #1115 Thanks for the fixes, @phimage! Would you be up for cleaning the swiftlint warnings as well (I mean without warnings that require huge refactor like lines of code etc.)? Would be awesome. Any reason to not add swiftlint in project build phrase?
 



 @phimage I think we just didn't think about it, but one thing to keep in mind is that Carthage needs special settings for that phase so that lint does work only for our development phase and not in users projects. For reference, you can look at [Quick#693](https://github.com/Quick/Quick/issues/693), [Quick#694](https://github.com/Quick/Quick/pull/694) and [Nimble#409](https://github.com/Quick/Nimble/pull/409)

If you want to take a stab at it, go ahead :)  Fixes #1206. These aren't perfect, but I think this is good enough for now. Should cover most of current behaviors if not all of them. 

**Edit:** Woah, first time above 80% code coverage in at least half a year! üéâ   The [`Package.swift`](https://github.com/Moya/Moya/blob/9.0.0-dev/Package.swift) will need to update its [API](https://github.com/apple/swift-package-manager/blob/swift-4.0-branch/Documentation/PackageDescriptionV4.md). Changes to the Package should also be reflected in the Readme.  Removed Swift 2 and added Swift 4. :)

Closes #1186  Hey @BasThomas, how are we with the updates? üòâ  I'll take a look later today! @sunshinejr - is this what you meant? If not, I don't really know what should be done further... let me know :) This is good, thanks, @BasThomas! What we should do next, I think, is that we should check whether `3.*` is true for all 3.0 Swift versions that we have in this table. So I've imagined that if there is a problem with 3.0, we would have 2 rows: one for 3.0 (with Moya versions that are working for Swift 3.0) and one for 3.1-3.2 Swift (with Moya versions that work for Swift 3.1-3.2). Does it make sense?  That does make sense. I *think* that all versions should work fine with all `3.x` versions though. Why do you think they might not be? Oh, I was pretty sure that there was some issue that not all version were working correctly. So maybe let's just double check if it works? Will you have time to do that maybe, @BasThomas? Unfortunately not. Think that would involve downloading old versions of Xcode as well, right? :( I'm currently using Xcode 8.2.1 for 2.3 project, but it has probably 3.0.2 Swift and I can use 3.1.1 Swift toolchain there as well. On the other hand 3.2 & 4.0 Swift can be checked on Xcode 9.0 beta I think. This is unfortunately time consuming and I'm not sure when/if I can do it, so maybe someone with more free time could pick this one, @Moya/contributors?  So I've noticed that today the builds were failing for lack of AppleTV simulator. I've connected the dots and quickly found out it was a problem with new Xcode beta being rolled out on CircleCI. I've made a bug-report and already got an answer (more [here](https://discuss.circleci.com/t/xcode-9-beta-6-lacks-apple-tv-simulator/15643/2)).

TL;DR Xcode didn't include some simulators in the new beta so they have to rebuild an image, which will take some days. We just have to wait until its done. I'll leave this issue until its fixed, so we can point out from PRs that it is in fact our CI issue. **Update:** AppleTV with iOS 11 simulator probably won't be available in this beta for us, maybe we will get iOS 10.2 instead, I will remove AppleTV for now from Rake since we need tests working, when new simulator is added I will add it back.  The object is accessible, why not receive it.
At completion, some information into `Progress` object could be very useful  Awesome, thanks @karthikdash! üôå
Congratulations on your first contribution üòÉ PR looks good, thanks @karthikdash! You also did it to 9.0.0-dev branch, that's awesome too! üéâ 

However, I'm not sure whether it resolves the issue. From the conversation in the issues referenced I'm not sure what the Carthage installation step should look like. I guess that it was connected to Moya/Reactive extensions versions? ü§î Could you make a short description/todo-list in the issue, @BasThomas?  I *think* the issue has to do with incompatible Moya / ReactiveSwift versions; so it is kind of unrelated - meaning we can leave the issue open (awaiting user feedback) when this is merged.

I am now going to the process of setting up an app with Moya via Carthage to check if everything works as expected. Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @JeanVinge, thanks for the issue!

This is actually how multipart file uploads are encoded (details [here](https://www.w3.org/TR/html5/forms.html#multipart/form-data-encoding-algorithm)). And even if it weren't, we can't change it really as Alamofire (our dependency for doing network requests) does it for us [here](https://github.com/Alamofire/Alamofire/blob/5bd458ca09a57fb2999772745d6438585f5140a7/Source/SessionManager.swift#L666) - just before sending the upload request and after our request setup (thus changing the request in Moya won't do anything).

Let me know if you have more questions around this topic!

**Edit:** Closing this one, but please don't hesitate to reopen in case you have more questions.  Alamofire provide also `Progress` for `DataRequest`.

Any reason to not use it? _Maybe not available when implementing the new progress callback in Moya_

This PR is for 9.0.0-dev ask requested #1232

---

`Progress` could be also provided at the end with response
phimage/Moya@c13fcd6
I will PR that after the merge of this PR
 Changelog updated Need to merge my commit into one to keep git history clean or this is good for you? @phimage Nah, not needed, thank you very much for this PR! üéâ  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @neoD1, thanks for the issue. I guess you are right - we cannot support Swift 4.0 with RxSwift and Moya 9.0. This is because we probably gonna release it before Swift 4.0 and RxSwift 4, and after the new releases we will update our extensions. 

Right now we offer Moya core working with Swift 4.0 (on branch `9.0.0-dev` for a while yet) or Moya with Swift 3.2 that should work correctly with RxSwift 3.3+. Sorry for the inconvenience! 

If you have any more questions, let me know.  Alamofire provide also `Progress`for `DataRequest`.
Any reason to not use it? Maybe not available when implementing the new progress callback in Moya

Following that `Progress` could be also provided at the end with response
https://github.com/phimage/Moya/commit/c13fcd6ded55309cd6cf5e6d789f50420fedd04d @phimage Thank you for the PR üéâ I've only skimmed the changes but I know this will conflict with changes made to `TargetType` from #1147 in the `9.0.0-dev` branch. If we move forward on this PR, maybe you could submit your work to `9.0.0-dev`? Ok I can redo my commits for 9.0.0-dev 
and use my fork until release

PS: Any reason to not have swiftlint in build phase of xcode targets. I think I have added some trailing whitespaces  Hey @jdeanwaite, thanks for taking the time to come back and share the solution. This may be useful to other users üëç   This PR adds tests for Single+Response (for RxMoya), fixing issue #1227. 

This PR also:

- Wraps Test Helpers converting Response to Single/Observable under `RxTestHelpers.swift`.
-  Moves Test Helpers related to generating Test Images to `TestHelpers.swift`.
- Reorganize `TestHelpers.swift` with some `MARK`s and sectioning of helper methods / classes. Updated the Changelog and also did a "Build without Cache" for good luck üçÄ  @freak4pc I just cleared the cache and triggered a rebuild.
Anyways, thanks for taking care of this so Swiftly üòÜ There's some nice cleanup in there. Thanks for the review! @SD10 
I'll wait for CI to clear and @sunshinejr to review this and feel free to merge whenever üëç  By the way this "cache" issue is probably the fault of `scripts/bootstrap-if-needed.sh` ...  It looks like your program crashed at breakpoint, can you share what was outputted in the console? @xumoyan Sorry I don't exactly understand what you're trying to convey in your last message. The output you've posted looks like the result of setting a breakpoint. If there is a crash unrelated to the breakpoint, would you be able to provide us with the console output?    `Supporting files` directory included prints a warning and I get an error from not including `Foundation` in these two files, so this should fix it ü§û 

Also, we might need to add compatibility checks on our CI soon. Yikes ü§¶‚Äç‚ôÇÔ∏è 

> Module compiled with Swift 3.1 cannot be imported in Swift 3.2: /Users/distiller/Moya/Carthage/Build/tvOS/Alamofire.framework/Modules/Alamofire.swiftmodule/x86_64.swiftmodule
 Same error recently happened to me. I think @sunshinejr fixed it by clearing the build cache ü§î This error is gonna haunt me forever. Not sure why I always need to rebuild without cache. How does it get this old cache? Anyone has an idea? ü§î  First time i'm seeing CircleCI and can't say it feels very reliable thus far ü§î  Seems like you can just add a post hook to manually clear the cache. But still super annoying: https://circleci.com/docs/1.0/how-cache-works/#clearing-cache Clearing cache is not something I would pursue, since building dependencies each time might be too painful. I'm thinking if this is a temporary problem, since on master we have this old cache with 3.1, and on 9.0.0-dev we have new cache with 3.2. Maybe new PRs are getting cache from master and that's the problem? ü§î  Yeah that makes total sense, since I imagine the entire project reuses some of the same caches/machines? I guess we can "wait the pain out" until 9.0.0 is out next month, right? :)  Yeah that makes sense the docs updates / gardening of master matches the inconsistency of the error.
Next month?! üò± We're so close!!  Yeah, let's just wait that out until we merge it for next version (which should be a lot faster than one month üòÑ)  Hey @nhantrivinh,

There is a method on Moya response which you can use to filter a specific status code:
```Swift
    public func filter(statusCode: Int) throws -> Response
```
Let me know if this helps.
 The approach is up to you :)
If you want to catch the error, then maybe want to push a uialercontroller onto the view hierarchy?
Another option could be to try re-trying the request  @nhantrivinh Glad you were able to work this out üòÉ   @danwey We're working on it. Moya `9.0.0` will support Swift 4 and should be released soon. Hey @danwey. As @SD10 said we are working on it, in fact it is already done and is waiting for a release. In the meantime you have 2 workarounds (until we release next version of Moya):
1. You can use Swift 3.2 in Moya but 4.0 in your project (see more about it [here](https://github.com/Moya/Moya/issues/1189))
2. You can use our `9.0.0-dev` branch which should have Swift 4.0 support already, but bear in mind that it is our development branch and it is not the safest one (I would advise against using this one in production). 

Please let us know if you have some more questions around it :) @danwey do you use `swift4.0` branch of `RxSwift` in your `Podfile`? I'm not sure I understand you correctly, @danwey, but if you still want to use Swift 4.0 version of Moya and RxSwift, you should use our `9.0.0-dev` branch and RxSwift's `swift4.0` branch:
```rb
pod 'Moya/RxSwift', :git => 'https://github.com/Moya/Moya.git', :branch => '9.0.0-dev'
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'swift4.0'
```

Please keep in mind that these are both prerelease branches and might expect difficulties/bugs.  Hey there :)

I‚Äôve looked through the code and noticed that for some reason the RxSwift implementation creates an Observable using `Observable.create` and then uses `asSingle()` to convert it, instead of just using `Single.create` to begin with, so pushed this quick commit. 

There should be zero impact, as it's just an implementation detail. Sorry about the incorrect branch here ;) It auto-selected and I missed it. @sunshinejr 

*edit*: was sure a close & open of the PR would trigger a rebuild. ü§î  All green. Do we want a Changelog entry for this ? @sunshinejr  Just an internal fix without impact, don't think it needs a Changelog entry. :) Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. That was my thought as well. Thanks !  Thanks for cleaning up my mistake @freak4pc üôà Haha, no worries. My pleasure @AndrewSB üíØ   There were a few issues regarding multipart upload with parameters and how to do it (e.g. #1209). I feel like this is a good time to add an example to our [docs/Examples](https://github.com/Moya/Moya/tree/master/docs) directory, especially having a new release in place. What I'm thinking about is a document with one (or more) examples, but the one we need for sure is an image upload with additional parameters.

Let me know if something is not clear üëç  Hey @nhantrivinh! I can't remember if I saw a full example out there, so I'm gonna try to give it here. Basically you need to pass parameters only in `MultipartFormData` of a `task` property (if these aren't url parameters). 

For instance, if you want to pass gif data and `description` parameter, you would combine these like:

```swift
let gifData = MultipartFormData(provider: .data(data), name: "file", fileName: "gif.gif", mimeType: "image/gif")
let description = MultipartFormData(provider: .data("description of a gif".data(using: .utf8)!), name: "description")
let multipartData = [gifData, imageWidthData]
```

Now, you would just wrap it in the `task` property, like:
```swift
extension Giphy: TargetType {
    public var task: Task {
        switch self {
        case let .upload(data):
            let gifData = MultipartFormData(provider: .data(data), name: "file", fileName: "gif.gif", mimeType: "image/gif")
            let description = MultipartFormData(provider: .data("description of a gif".data(using: .utf8)!), name: "description")
            let multipartData = [gifData, imageWidthData]
            return .upload(.multipart(multipartData))
        }
    }
}

```

For Moya 9 the return type would be a little bit different (as the API is more verbose now):
```swift
return uploadMultipart(multipartData)
```

And that new API we would like to have in our docs. 

Hope it helps!   This should fix #1217. By mistake, new file was added to `Moya` target rather than `RxMoya`. Can you confirm, @Dschee, that it works on this commit?   I'm using the most current commit of the 9.0.0-dev Branch and I'm not using any reactive libraries. Since updating the dependency from my own fork (commit 4bcac8144fd438b9b93c2a9907a8581dfd899278) to commit 0c25037dcf2a4213124fe0a423656b14ee0209d4 I'm seeing the following error when building:

```
dyld: Library not loaded: @rpath/RxSwift.framework/RxSwift
  Referenced from: /Users/JamitLabs/Library/Developer/CoreSimulator/Devices/98DE006C-DE6C-45D2-9A42-4440CFD6DA9C/data/Containers/Bundle/Application/F1A76703-C1FA-4236-AD1B-7167A09B72F6/TreasuryManager.app/Frameworks/Moya.framework/Moya
  Reason: image not found
```

I have not included the RxSwift library into my project, but I don't want to since I'm not using reactive Moya. The inclusion is done via the current Carthage version. I would expect that error to not appear so I don't have to include RxSwift like it always worked before. Are you sure it worked before? I think there's no option to get an equivalent to the "subspecs" in CocoaPods, so you'd have to download everything. That should still not show the library not loaded error, though. ü§î, interesting. Check the PR (#1218) that was just opened.  No problem, thanks to you for testing 9.0.0-dev on Carthage so we have a feedback and we can fix bugs faster üôá 

Also, gonna close it in favor of #1218 then.  @ivangodfather The `stubClosure` argument for the `MoyaProvider` initializer is a closure that takes in a `TargetType` and returns `StubBehavior`. You can pass it a custom closure that switches on the cases of the target and returns the respective stub behavior that you'd like. Is this what you were looking for?

Example:
```Swift
let stubClosure = { (target: TargetType) -> Moya.StubBehavior in 
    switch target.path {
    case "endPointThatShouldReturnAStub404":
        return .immediate
    default:
        return .never
    }
}
``` @ivangodfather Sorry, I think I understand better now. The example was just that -- an example üòÑ.
What's wrong with your current approach? @ivangodfather Are you calling `setProvider()` before every request? @ivangodfather I think there may be some issues with the initialization of the `MoyaProvider`. 
```Swift
// Here when you're passing the new endpointClosure you're not giving it stubBehavior
// it defaults to `.never`
provider = MoyaProvider<TWApiProvider>(endpointClosure: endpointClosure)

// I think it should be
provider = MoyaProvider<TWApiProvider>(endpointClosure: endpointClosure, stubClosure: MoyaProvider.immediatelyStub)
```
Sorry I wasn't able to help but I will check back later üòû Let me know if you resolve this. @ivangodfather Did you see the edit in my most recent comment? It looks like you're overwriting the stub behavior you provided in the first initialization of `MoyaProvider`. @ivangodfather Can you see if this documentation helps? [Providers.md](https://github.com/Moya/Moya/blob/master/docs/Providers.md#advanced-usage)

Basically, your `stubClosure` handles the mapping of a `(TargetType)` -> `StubBehavior`.
This allows the MoyaProvider to have different stub behavior based on the target.

Similarly, the `endpointClosure` handles the mapping of a `(TargetType)` -> `Endpoint`.
This allows the MoyaProvider to have different endpoints based on the target.
You need this because you want to return a *404* response for some targets.

It looks like you will need both a custom `stubClosure` and `endpointClosure` to achieve the behavior you want. Am I making sense? 

My final recommendation is to maybe do your tests in a Unit Test Target. Then create a mock provider solely for testing in the `XCTestCase`.
  @ivangodfather I'm trying to tell you that you're not receiving the sample response closure because your `MoyaProvider` is defaulting to a stubBehavior of `.never`.

```Swift
// This line of code will not stub requests. It defaults to `.never`.
// This is why you are receiving an actual request and not stubbing.
provider = MoyaProvider<ApiProvider>(endpointClosure: endPointClosure)

// You need to provide a stub behavior to receive the sample response
provider = MoyaProvider<ApiProvider>(endpointClosure: endPointClosure, stubClosure: MoyaProvider.immediatelyStub)
```

Am I making sense? Nice to hear you've resolved the issue, and thanks for providing your implementation! üëç  This is in favor of #1172 and related to #1214.

I've added the `AuthorizationType` enum, updated the existing tests, and added a new one for `.basic` authorization.

### Thoughts:
The old implementation of `AccessTokenAuthorizable` added an authorization header of "Bearer" to all target types by default. We need to determine which authorization type we're going to default to - if any. The current tests represent defaulting to the case `.none` -- no headers added. This would be a breaking change to the current and default expected behavior.

What do you guys think?  It looks like the build error is from compiling the project in Xcode 8? Admittingly, I haven't been using Xcode 9 beta enough üòÖ  We've changed Xcode on CI from 8.3.3 to 9.0.0 and the there is still cache built with 8.3.3. I re-triggered your build without cache, @SD10, and it seems fine :)

About the PR - looks really nice! We don't really default to anything - if you don't implement the protocol and do not specify what `AuthorizationType` you need, you won't get any headers added. This is a breaking change, yes, but in different way. People now do not decide whether they want authorization or not, but rather if they want authorization, they need to specify which one. @sunshinejr I made the requested `tokenClosure` changes. If anyone else has any other changes or feedback just let me know. Once the implementation is agreed on I'll:
- [x] Update Docs
- [x] Add a CHANGELOG entry
- [x] Do you want me to add something in the MigrationGuide.md? üëç Code-wise seems good to me :) @sunshinejr I updated the documentation and the `CHANGELOG.md`. Let me know how those look. 
Also, let me know if you want me to write something in `MigrationGuide.md`. Yeah, I feel like we should add something to the `MigrationGuide`, especially if we have this file already created. I didn't closely check the PR, but from the brief overview it looks great üëç 

Also, now that I think about it, we should add few lines about migrating to new reactive APIs, but thats another issue.  @sunshinejr Done. Sorry for all the push spam. My rebase attempt failed so I just took care of the CHANGELOG conflict with a commit.

What do we need to add the the MigrationGuide.md for the Reactive API's? Just the fact that they're in the `reactive` and `rx` namespaces? I can add this in another PR. No problem, @SD10 üëç Is this PR still `WIP`? If you feel like this is ready for a review, we can remove the prefix so people can chime in :)

About migration guide and reactive providers - you are correct. We should stop using reactive providers and use `rx` and `reactive` namespaces instead. We could also point to this [PR from Ash in Eidolon](https://github.com/artsy/eidolon/pull/669), that covers migration from subclassing to composition.  @sunshinejr Yeah, I removed the WIP tag. I'll open a PR to work on the MigrationGuide for the reactive API sometime later today. @pedrovereza Changes made. Thank you for jumping in and giving me your review! Those were some great suggestions üòÉ   This was discussed in #1020, but I think it wasn't added yet. I found this one out by playing with new API and I certainly would love these to be in the next release (having to add `asObservable()` and loose all the nice `Single` API would be really sad).

Also, I've read that @AndrewSB wanted to do a generic protocol of some sort, I also thought about it, but I don't think there is an easy/clean way to do that. `RxSwift` uses similar approach to this one in PR (see [here](https://github.com/ReactiveX/RxSwift/blob/1314805175263ad8141054f6be21f6bbef224d2c/RxSwift/Traits/PrimitiveSequence.swift#L464-L475) for instance) üëã

Thanks for doing this @sunshinejr, let's also remove the functions that are on `ObservableType`, since the ones you've added on `PrimitiveSequence` should work for both `Single`s and `Observable`s Hmm, are you sure that it works for both @AndrewSB? I don't see it in code, but I might be missing something. From my understanding, observables are primitivetypes, but I'm not sure
either

I'll take a look soon
On Fri, Aug 11, 2017 at 10:33 AM ≈Åukasz Mr√≥z <notifications@github.com>
wrote:

> Hmm, are you sure that it works for both @AndrewSB
> <https://github.com/andrewsb>? I don't see it in code, but I might be
> missing something.
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1213#issuecomment-321873359>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dAq7ukf9591S5C_7WkJpsuXxRY23ks5sXJBrgaJpZM4O02ym>
> .
>
 https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Traits/PrimitiveSequence.swift#L60

It looks like PrimitiveSequence conforms to ObservableConvertibleType... so I was wrong, we need to keep the operators duped between Observable & Primitive :/ 

sais la vie Oh, you are right. Maybe we will get something better in the future, doesn't seem too clean to me as well. 

Nonetheless, thanks for the CR, @AndrewSB ‚ù§Ô∏è   Solves #1203. Also:
- Removed mentions of `RACSignal` - we removed in version 7.0.0
- Fixed some places where we were using `onNext` event instead of `onSuccess` for `Single` replacement in RxSwift
- Improved descriptions of RxSwift & ReactiveSwift in Readme

I wanted to bring back RxSwift examples as well, but these needs updating first. So we will add it later üëç For now I removed urls to them in `docs/Examples/Readme.md`, since these are not there anymore üòÑ 

Cheers! Thank you for the CR, @pedrovereza! ‚ù§Ô∏è   Hey @swordjoy. The code you posted is good for multipart uploading. If you want to add text to it, you should add it to the multipart data as well. For instance, if you wanted to add `width` parameter to the request, you would do:
```swift
mutDatas.append(MultipartFormData(provider: .data("100".data(using: .utf8)!), name: "width"))
```

Let me know if it resolves your issue or if you have some more questions around this topic :)  @riyanpratama Let me preface this by saying I don't know much about Carthage.
It looks like you're using `ReactiveSwift 1.0.0` and `DateScheduler` was added in version [1.1.0](https://github.com/ReactiveCocoa/ReactiveSwift/releases/tag/1.1.0).

I think that Moya `8.0.5` has a minimum ReactiveSwift requirement of `1.1.0`.

Let me know if this helps. You have a dependence on `ReactiveSwift` 1.0.0, but `Moya` needs 2.0.0. Did you add `github "ReactiveCocoa/ReactiveSwift" "1.0.0"` for a reason? I don't know why you get the error of the renamed `MoyaError` in the availability file. Which Swift version are you using? And which version of Xcode?  Hey @aelam,
The current documentation is representing Moya [v9.0.0-alpha.1](https://github.com/Moya/Moya/releases/tag/9.0.0-alpha.1). If you want to continue using Moya `8.0.5` you will need to use the `RxMoyaProvider`. Let me know if this helps üòÉ  Exactly what @SD10 said. You can browse the `8.0.5` documentation here: https://github.com/Moya/Moya/tree/4512a2a4bc8019cf006434378ac6a0640f34f35f/docs  We might need to check if our documentation is up-to-date (in branch 9.0.0-dev) with the changes to parameters/parameterEncoding/task from #1147. 


If someone is up for this task, please assign yourself so we won't dup our work. Cheers! üòâ  Documention Affected:
- [x]  [Basic.md](https://github.com/Moya/Moya/blob/4207ead20f3da590194b1be1d64d409316c083cf/docs/Examples/Basic.md)
- [x] [Targets.md](https://github.com/Moya/Moya/blob/4207ead20f3da590194b1be1d64d409316c083cf/docs/Targets.md)
- [x] [Endpoints.md](https://github.com/Moya/Moya/blob/4207ead20f3da590194b1be1d64d409316c083cf/docs/Endpoints.md)
- [x] [ArraysAsRootContainer.md](https://github.com/Moya/Moya/blob/aa33a0466d7333516691b3e5212c5acb41990928/docs/Examples/ArrayAsRootContainer.md)
- [x] [Providers.md](https://github.com/Moya/Moya/blob/4207ead20f3da590194b1be1d64d409316c083cf/docs/Providers.md)
- [x] [OptionalParameters.md](https://github.com/Moya/Moya/blob/4207ead20f3da590194b1be1d64d409316c083cf/docs/Examples/OptionalParameters.md)
- [x] [Assets.md](https://github.com/Moya/Moya/blob/aa33a0466d7333516691b3e5212c5acb41990928/docs/Examples/Assets.md)

It's important to know that a great deal of these has already been taken care of in #1147 so that should be the basis for which docs still need updating. 

If I can check any of these off the list when I have time I will.
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  What is your current Moya version? You can check in the `Podfile.lock`. And can you maybe also share the contents of your Podfile itself? I just set up a fresh projects and everything builds fine. Moya is using `8.0.5` there.  Hey @i-schuetz. Thank you for writing a complete guide how to fix the issue you encountered! :D This surely will help people with similar problems in the future, so again thank you for doing this.  Hey @edopelawi. Thank you for your really well written description of the issue! Glad you figured this out. üòâ   @ondev Have you been able to find any useful documentation? 
I recommend reading [Targets.md](https://github.com/Moya/Moya/blob/master/docs/Targets.md) and [Basic.md](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md). 

The `MoyaProvider` is generic over an object conforming to the `TargetType` protocol. 
Your `MoyaProvider` instance can make any number of requests to the underlying `TargetType`.  Nice one, @yangcaimu! Would you be able to remove these from Tests as well? Would be awesome :) Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @xumoyan. Thanks for the issue! However, this is a duplicate of #1189. Please see it as there is more info about this and current workaround. Basically you created a Swift 4.0 project, and we currently do not support it. You need to change Swift version of Moya to 3.2, or wait for 9.0 release (after #1193 merges).

Let me know if it resolves your problem :)  Hey @xavierXing. You would have to use your own `manager` in `MoyaProvider` for that one. You would then configure your certificate handling in it. You can see how we use it in our `defaultAlamofireManager`:
```swift
public final class func defaultAlamofireManager() -> Manager {
    let configuration = URLSessionConfiguration.default
    configuration.httpAdditionalHeaders = Manager.defaultHTTPHeaders
    
    let manager = Manager(configuration: configuration)
    manager.startRequestsImmediately = false
    return manager
}
```

Of course this one doesn't have certs handling in it. But you can just use the same setup as for self-signed certs in Alamofire.

Let me know if you have any more questions about it :) @xavierXing Hey, I have a [demo project that shows how to use self-signed certificates with Moya](https://github.com/pedrovereza/SelfSignedMoya). Let me know if you have any questions :wink:

Edit: You can also find more details in #992  Hey @xavierXing. Please post your code and we will try to help you :)  Right now #1193 will update our Swift support to Swift 3.1, 3.2 and 4.0. While it is awesome, we should do some checks to make sure we do not break these unintentionally. We can do builds for all of them, but I think checking for 3.2 & 4.0 compatibility should be enough. What do you guys think? I think those two would be enough. Then in September we can drop Swift 3 tests. **Update:** So I tried the new workflows API from CircleCI, but [seems like macOS is not yet supported there](https://discuss.circleci.com/t/os-x-macos-ios-support-on-circleci-2-0/16430). Thus, we probably need to fallback to rake.

**Edit:** I'm gonna unassign myself from that one for a while, if anyone have more free time to do it, feel free to assign yourself.  In this PR I've updated `NetworkLoggerPlugin` as it was the only reason Swift 4 compiler was having troubles with moya. I've also updated our CI to use Xcode 9. In the future we should look to support 2 builds - with Swift 3.2 & 4.0. 

Right now, with this changes, 9.0.0 release should support:
- Swift 3.1
- Swift 3.2
- Swift 4.0

I've tested it locally and it seems to be working correctly.

**Edit:** Oh, and also I've created a new **9.0.0-dev** branch.  Sure! Good catch, @pedrovereza, PR updated :)  @alfian0 How about using the case `statusCode(Response)` from the `MoyaError` enum? 

You can then get the `statusCode` property by extracting the associated value of `Response`. 
Let me know if this helps üëç

In Moya `9.0.0` (which should be released soon) you will also receive the response (if any) in the `.underlying` case. @alfian0 Unfortunately, if you need the `statusCode` in the `.underlying` error case, you'll have to wait for the Moya 9.0.0 release. Sorry :( This is possible with Moya [9.0.0-alpha.1](https://github.com/Moya/Moya/releases/tag/9.0.0-alpha.1) but keep in mind this version is still a pre-release. It will have official support in Moya `9.0.0` which is soon to come.  Hey @plam4u. Thanks for an issue!

I must admit that this is the first time I'm seeing this error and so my comment may not be useful at all. But, from my googling, I found 2 projects that use this error log and both use really similar codebase ([there](https://github.com/apigee/apigee-ios-sdk/blob/master/source/Classes/Services/ApigeeNSURLConnectionDataDelegateInterceptor.m) and [there](https://github.com/xplatsolutions/iOS-Network-Interceptor/blob/master/NetworkInterceptor/NetworkMonitor/XplatNSURLConnectionDataDelegateInterceptor.m)).

Are you sure these errors are from Alamofire? I'm not seeing  anything like that in their sources but maybe I just didn't search enough üòÑ   Hey @wz1383691. This is a duplicate of #1189. Basically we don't really have a Swift 4.0 support right now. Please head to #1189 for more info.  We should do that for our 9.0.0 release, gonna make sure people will have a clear view as of which version they can use for their app. Thanks for reporting, @Coeur üëç  ‚úÖ `8.0.5` with Xcode `8.3.3`
‚úÖ `8.0.5` with Xcode `9.0` (opened with the previous project)
‚ùå `8.0.5` with Xcode `9.0`
‚ùå `8.0.5` with Xcode `8.3.3` (opened with the previous project and Deployment target reset to `10.3`

So the first point should be OK: Swift 3.2 works on Xcode 9.  Can you update the Demo's Podfile.lock as well? Just can do so by running `pod update` in the `Demo` directory. Thanks üëç Awesome, thanks @larryonoff! :) Good job, @larryonoff! However, we might want to wait with this one after the #1181 merge, since there are multiple changes to reactive providers. If you could it would be awesome üëç  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @lhalcyon. It seems like we don't have that option right now, but to allow this behavior we could just add another parameter in [NetworkActivityClosure](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/NetworkActivityPlugin.swift#L12), from:
```swift
(_ change: NetworkActivityChangeType) -> Void
```
to
```swift
(_ change: NetworkActivityChangeType, _ target: TargetType) -> Void
```

and this way you could make conditional statements based on `TargetType`. Also, I think this would be a valuable addition to our codebase, so maybe you would you be up for a PR? üòâ   Hey @larryonoff! Your proposal is just in time for our 9.0.0 version üòÑ I think this one can get in as well, what do you guys think, @Moya/contributors?  Sounds good to me!
On Sat, Jul 22, 2017 at 3:35 AM ≈Åukasz Mr√≥z <notifications@github.com>
wrote:

> Hey @larryonoff <https://github.com/larryonoff>! Your proposal is just in
> time for our 9.0.0 version üòÑ I think this one can get in as well, what
> do you guys think, @Moya/contributors
> <https://github.com/orgs/Moya/teams/contributors>?
>
> ‚Äî
> You are receiving this because you are on a team that was mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/1182#issuecomment-317174538>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dFjjCxZclQaRMAkGpxoyNoOk9ZR4ks5sQdB3gaJpZM4OgHcz>
> .
>
 Cool! I think we should do it after #1181 merges onto master since there are many changes already.

Also, maybe you would be up for doing PR with the update, @larryonoff? üòâ  @larryonoff `carthage bootstrap`  Hey guys! üéâ 

I'm really excited to say that we are almost there! Just need to double check if this merge got everything we need for 9.0.0. This is a really long one, but don't be scared! Most of that codebase was reviewed in multiple PRs so this is just a final check to see if it's alright. Even if its not, we still got alpha/beta tests so no worries.

Cheers!

**Edit:** Also, related: #1075  Good ones, @pedrovereza! Updated both `Changelog` & comment for `headers` in `TargetType` üëç  Okay, I also fixed most of the issues from SwiftLint. The rest is either from Demo (which we might update as well, in another PR) or from things we know exist but we need time to refactor (like long `MoyaProviderSpec`) Hey @Moya/contributors, just a reminder that we'd love it if we could get another pair of eyes on that one. Pushing an alpha release this week would be üíØ  Thank you, @SD10! @pedrovereza, do you feel like you'd have time to validate this one as well? :)  Thank you so much, y'all! üéâ   Hey @dindonkey. You can use it the same way as any other `Observable`. Below is the simple test taken from `RxSwift` repository:
```swift
func testSequenceOf_complete_immediate() {
    let scheduler = TestScheduler(initialClock: 0)
    let res = scheduler.start {
        Observable.of(3, 1, 2, 4)
    }
    
    XCTAssertEqual(res.events, [
        next(200, 3),
        next(200, 1),
        next(200, 2),
        next(200, 4),
        completed(200)
    ])
}
```

This code above is a simple test from `RxSwift ` using `TestScheduler`. What you want to do is to replace `Observable` in `scheduler.start` method and then assert whatever you like:

```swift
    let res = scheduler.start {
        provider.request(target).observeOn(scheduler)
    }

    XCTAssertEqual(res.events, [
        next(200, response),
        completed(200)
    ])
```

This code above might not compile since I didn't try this one out, but the idea should be precise. Also don't forget to manipulate `stubClosure` in your tests üòÑ 

Let me know if it helped or if you have more questions about it üêº   This is a little gift, because I always need to implement my own function/extension that creates `URL` from `TargetType`. I figured that other people might find it useful too üòÑ  Would it not make more sense to make the `private` func public? Having this extension on `URL` feels a bit weird / hard to discover. Hmm, you might be right and it might be hard to discover manually. But I think you will find it from the docs anyways. But I'm open for a change üòÑ  I like the `URL` init over having to access a class method on `Endpoint`. It feels right.

I guess this raises the question of providing these kinds of utilities in Moya, considering I think we haven't extended Apple's frameworks thus far?

From [Targets.md](https://github.com/Moya/Moya/blob/master/docs/Targets.md):
```Swift
extension String {
    var urlEscaped: String {
        return addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
    }
}
```
I believe there also use to be one like this: 
(which I'm thankful is removed because it confused me when starting out and not seeing the bottom)
```Swift
extension String {
    var utf8StringEncoding: Data {
        return data(using: String.Encoding.utf8)!
    }
}
```

Just my two cents, to say we discussed it in the case someone adds another extension and tries to point to this as justification.
 Good point @SD10! I think that it might be a rare case that we extend Apple framework, but if we do, I feel like it has to be something unique to Moya. In this case, we are creating `URL` from a `TargetType`, which is only viable for `Moya` codebase. This way users shouldn't get confused since the type accepted by this `init` is important only for Moya users. In case of these other two extensions you showed, they may seem like standard library methods üòÑ  > I think that it might be a rare case that we extend Apple framework, but if we do, I feel like it has to be something unique to Moya.

This sounds like a good precedent üëç. Where to document it? Endpoints.md?

Endpoints.md...

----

The first might resemble the following:
```diff
let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
+   let url = URL(target: target).absoluteString
    return Endpoint(url: url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
}
```

This is actually the default implementation Moya provides. If you need something custom, like if your API requires custom parameter mapping, or if you're creating a test provider that returns non-200 HTTP statuses in unit tests, this is where you would do it.

```diff
+ Notice the URL(target:) initializer, Moya provides a convenient extension to create a URL from any TargetType.
```

...

 Yeah, I think `Endpoint` is the place where we use this extension and where you would need it for a basic implementation. Would you be up for updating the docs in another PR? :) Yeah @sunshinejr I'll take care of it tomorrow afternoon üëç What do you think about it, @BasThomas? :) üëç  Hey @mrachid. This is not the easiest thing to do, so I understand your pain. 

Could you please share what have you tried? The best would be code that you wrote with comments around places you had problems with. This way we could figure out the easiest way to help you in your specific scenario (configuration, abstraction layers etc.) @mrachid this conversation may help https://github.com/Moya/Moya/issues/748#issuecomment-260059360  Hey @zichenJack. Thanks for detailed explanation. This should be a fairly easy fix. As error says, the problem is because both `Moya` and `Swift` use type name `Error`. Having imported `Moya`, the compiler just gets confused as to what type do you really want. To make sure it gets a `Swift` one, just prefix the type with `Swift.`, like `Swift.Error`:

```swift
    func webView(_ webView: UIWebView, didFailLoadWithError error: Swift.Error) {
        print("UIWebView Error")
    }
```

and it should resolve the issue. I've tested it on a clean project using Moya 8.0.5 and Swift 3.1 and it worked correctly, but if you still encounter the issue, please let us know! üëç   Hey @GTMYang thanks for reporting this. Can you provide us with any more information?
i.e) Specific compile errors, your Swift version, Moya version Also, we'd be open to a PR that fixes the breakages üòÑ  @GTMYang Are you sure this is an issue with Moya? I can't find any reference to it in the error output.  Hey @ArthurAlvarez. This is a good one!

I must say that there is no _easy_ way to do it right now. We have an [AccessTokenPlugin](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/AccessTokenPlugin.swift), but it doesn't allow to change the token or refresh it easily.

I really like your solution though! What I could add to that is to save token duration and if you know it expired, just send a request for token and then a normal request. This way you can avoid 1 request that shouldn't be needed.

I feel like it could even be a good CocoaPod out of it - one that handles full OAuth in Moya. Many people implement their own at some point in time. I was thinking about plugin, but not sure we can do it with current plugin limitations. @ArthurAlvarez this conversation may help https://github.com/Moya/Moya/issues/748#issuecomment-264572164  So this should be a final step to merge queues (#762). I've moved the docs from `Readme.md` to its own `Threading.md` + added examples for both normal usage and `ReactiveSwift`. 

Also, I've checked the docs but didn't found anything on `queues` I needed to change, so it should be all set üëç  I like the content of `Threading.md`. Let's also add a link to it in the docs/README.md? 
Possibly right after the RxSwift & ReactiveSwift sections since it builds on them. Good catch, @SD10! Added this one as well.  Hey @yar1vn, thank you for the PR! Seems like a good idea of introducing Basic auth. Although, we might want to add this one to  our existing [AccessTokenPlugin](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/AccessTokenPlugin.swift). Because right now this plugin is not really flexible - you can't use both OAuth & Basic on different endpoints (sometimes it happens) - you either use it or not. 

I'm thinking about updating the `AccessTokenAuthorizable` protocol so it would look like:

```swift
enum AuthorizationType {
    case None
    case Basic
    case OAuth
}

public protocol AccessTokenAuthorizable {

    /// Declares whether or not `AccessTokenPlugin` should add an authorization header
    /// to requests. If it should, what type of authorization does this request need?
    var authorizationType: AuthorizationType { get }
}
```

And then it would be easy to append header based on the type specified:
```swift
    public func prepare(_ request: URLRequest, target: TargetType) -> URLRequest {
        guard let authorizable = target as? AccessTokenAuthorizable, authorizable.authorizationType != .None else {
            return request
        }

        var request = request
        switch authorizable.authorizationType {
            case .OAuth:
                request.addValue(authVal, forHTTPHeaderField: "Authorization")
            case .Basic:
                // add Basic header
        }
        return request
    }
```

This makes it really flexible to use and also this way we can really cover most of the use-cases in the networking layer with auths.

What do you think about it, @yar1vn?
 @yar1vn I believe @sunshinejr was just trying to mock up a good way to add this functionality considering the state of Moya's current API. 

The code he provided in the comment is a rough draft and may not even compile due to the switch statement not being exhaustive. There may be other things to implement such as updating docs/tests.

Maintaining a project requires a large effort and we're always encouraging new contributors. Small contributions have a snowball effect and save maintainers a great deal of time. 

Would you be interested in moving this forward? @yar1vn Sorry I'm not an expert in this area. Could we just switch on the `authValue` property to provide a different value based on the case of `AuthorizationType`? What I meant was to update what we have with `Basic` authorization on top of it. We can name it `Bearer` type, instead of `OAuth`, to describe it properly. We would just send a `Bearer` or `Basic` token in the header, so it makes sense to name it that way. And also, as @SD10 mentioned, to that we would also need to add tests, `Changelog` entry (with a breaking change) and check docs/update them accordingly.

Would you be up for that one, @yar1vn? Check out https://github.com/Moya/Moya/blob/master/docs/Development.md :)

And let us know if you need any help! Hey @yar1vn! Just a heads-up that we just released 9.0.0-alpha.1 version of Moya. We would be up for taking your PR in the next release, so if you'd have time to implement it in the near future it would be awesome üëç Thanks for taking this one!  Sure, @yar1vn. Thanks for your response. üêº  

Please let me know if you'll be able to do it this week, would be awesome! Otherwise we might just help you out since this is a breaking change and is a perfect fit for a new major release we are planning. This shouldn't take that long to make the changes to sources, tests, and docs.

@yar1vn If you end up not being able to get around to making the changes this weekend, would you like me to take care of it for you?

I'm not trying to rush you but it's always great to bundle as many breaking changes in a major release üòÖ  We don't want you to feel pressured to do this, @yar1vn, since nothing good happens from it. Thus, I think, that we should just take it from here and you can always contribute in the future when you have more free time. We will always have some tasks for starters, so don't worry about that :) Thanks for the initiative and your time spent on this one! üôá 

@SD10 could you please create an issue and then we can move there and close this one? :) Moving this to #1214.  Hey @Marcopohlo, thanks for the issue! 

Basically, what you want to accomplish doesn't really benefit from the fact you are using reactive provider (besides `retry`). You are transforming your `Signal` to a simple closure callback, where the whole point is to keep this object and make plethora of operations on it. If you want `ReactiveSwift` just for Moya and this adapter, I'd say that you should leave it and do something similar to our [current wrapper](https://github.com/Moya/Moya/blob/master/docs/Examples/WrappingInAdapter.md) (without reactive provider).

Although if you are using ReactiveSwift in your project quite extensively, I would suggest you take a different approach, a more reactive one. Please take a look at our [subclassing example](https://github.com/Moya/Moya/blob/master/docs/Examples/SubclassingProvider.md). This is in RxSwift, but conversion to ReactiveSwift should be pretty simple (`RxMoyaProvider` -> `ReactiveSwiftMoyaProvider`, `Observable` -> `Signal`/`SignalProducer`). 

This is also a subclassing example, but you could go with composition instead (especially because in Moya 9.0.0 we are deprecating reactive providers). A simple pseudo-code that would cover what I have in mind would be:

```swift
final class Networking<T: TargetType> {

    let provider: ReactiveSwiftMoyaProvider<T>
    
    init(provider: ReactiveSwiftMoyaProvider<T>) {
        self.provider = provider
    }
    
    func request(target: T) -> SignalProducer<Response, MoyaError> {
        return provider.request(target) // here you could add some logic for retrying/handling global errors etc.
    }
}
```

Also, if you'd do it, you could make a PR with example using ReactiveSwift - we would gladly take that one üòÑ 

Let me know if you still have some questions about it :) No problem, happy to assist! Did you have some more troubles there, @Marcopohlo?  Hey @sandeepbol. This is a good question!

Unfortunately, we do not have such solution built-in Moya core. This might change when we migrate to Swift 4, in fact there are already plans on implementing such functionality (#1135, #1147). For now you would have to do the object mapping to JSON manually. However, there are libraries out there that can help with that, like [Wrap by John Sundell](https://github.com/JohnSundell/Wrap) - you could give it a try.

Please let me know if you have any further questions regarding this topic!  Setting `parameterEncoding` in `endpointClosure` (first option) was an option long before `parameterEncoding` in `TargetType` (second option). The first one is more generic - you can have one closure that handles multiple providers/target types (so you can setup one encoding for an entire API or for some part of the endpoints), where the second one is more `TargetType` specific (sometimes you just want different encoding for one endpoint, not for a whole API, thus this option).

Also when you use both methods at the same time, the `endpointClosure` one will override the `TargetType` one, since it is executed after.

But both of them are setting the `ParameterEncoding`, which is the same functionality, but for kinda different use-cases. Also, because I think your issue is resolved for now, I'm gonna close this issue. If you find yourself getting more questions about Moya, don't hesitate to open a new one!   Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  ### Please don't merge until we create the backing label for this.

This fixes the problem where issues aren't being closed due to our previous label 'no recent activity' containing spaces. 

I literally set the label to `stale` but if someone would prefer another name discuss it here.

i.e) `no_recent_activity` or `no-recent-activity`  Hey @abeintopalo, thank you so much for this detailed explanation! Really awesome of you.

About the problem - yeah, we got 4 schemes and each one is gathering coverage data. It _should_ work just fine with _MoyaTests_ doing that, we gotta see and test. Would you be up for doing a PR? You would have to branch from `9.0.0-dev` and target that one in the PR, though. Thank you @abeintopalo! I'll try to get to it & test it whenever I have some free time. Maybe someone else will be free to check it before me, though! Also, from the PR it seems like codecov integration didn't break (I think), so it is a good sign üòÑ  I'm gonna close this one and we will focus on this matter in the PR @abeintopalo created (#1169). üëç     In this PR:
- [x] Updated tests for reactive extensions that were introduced here, #1153. Basically just updated the syntax and used `MoyaProvider`, but in `ReactiveSwift` extension I decided to leave tests that were subclassing `ReactiveSwiftMoyaProvider` or testes `TestScheduler` that we do not provide in new APIs.
- [x] Fixed a bug that was happening in RxSwift as well - double response for `requestWithProgress` in `ReactiveSwift` extension. Also added test so we do not miss it again üòÑ 

As always let me know what do you guys think!  Removed all the deprecated methods/types from Moya 8.0.0 Could anyone take a look at this one, @Moya/contributors? üêº  Wow, that was quick! Thanks guys!  So setting the `closeComment` variable to false had no effect. This leads me to believe we have a different problem. I took a look at the source and this is the method that gets the stale issues:

```javascript
  getStaleIssues() {
    const labels = [this.config.staleLabel].concat(this.config.exemptLabels);
    const query = labels.map(label => `-label:"${label}"`).join(' ');
    const days = this.config.days || this.config.daysUntilStale;
    return this.search(days, query);
  }
```

It looks like when it creates the `query` it wraps the label in quotes. Since the current `stale.yml` already provides these quotes I think it results in an invalid query. I suggest we remove them with this PR and see if it has any effect. Sorry for the PR spam üòì  I think, at this point, we might be better off opening an issue over at Stalebot, instead of doing this hit-and-miss approach. üòê  @BasThomas I agree, this was my last idea. I already have an open [issue](https://github.com/probot/stale/issues/43).   @pedrovereza What about setting `closeComment` to false to test if this problem is comment related or if we have another problem? I think the effects should be applied immediately if the PR is a success. @SD10 sounds good to me, let's see if it works now üòÖ   Related to #1071, #1157 and #1158.

Stale-bot is still not closing stale issues. I'm guessing this could be related to having markdown in the close comment ü§î.

Also confirmed that having `closingComment: false` worked on a test repo (https://github.com/pedrovereza/stale-bot-test/issues/1)  @pedrovereza I did find repos using both emojis and markdown inside of the `markComment`. None inside of the `closeComment` but I would assume the behavior would be similar.

[babel](https://github.com/babel/babel.github.io) uses emojis.
[hubotio](https://github.com/hubotio/hubot-redis-brain) uses markdown.

I created an issue [here](https://github.com/probot/stale/issues/43) in the stale repo asking for some troubleshooting support.

Nonetheless, let's give this a try. I think when updating the `stale.yml` file the changes should be applied immediately by `probot`.  @pedrovereza per your recommendation I've removed the emojis from the `stale.yml` configuration. I've been able to find other GitHub repos with the close comment feature working as of 3 days ago, but none containing emojis.

My only other concern would be the link inside the comment because of the colon.  I found [babel](https://github.com/babel/babel.github.io) is using emoji literals in their stale comments. 
Possibly writing üëç as `:+1:` could have thrown it off? I'm not too convinced.
I was skeptical of all colons (like the one in the link) but [hubotio](https://github.com/hubotio/hubot-redis-brain) is using links in their comments. I'll have to sleep on this and see if any thing has taken effect by morning.  ![screen shot 2017-07-03 at 2 14 49 pm](https://user-images.githubusercontent.com/7445580/27805395-02a22a70-5ffa-11e7-93b2-6e9dcde1ae5b.png)

I'm not sure if the discoloration in the syntax highlighting is what is causing `stale` to not close issues. I've compared our `stale.yml` to other projects and this is the only difference. Removing the emojis could work too. I think we will have to wait about an hour+ to see if Probot makes any changes. It might be good to open an issue over at Probot as well, to get them in the loop? https://github.com/probot/probot/issues @BasThomas Great idea, I just want to get a better handle on the problem before opening a premature issue. I'm not sure if it's the emojis or just any colon in the message body -- or even something else üòÖ   Hey @ledikari, this feature is planned to be release on Moya 9.0. See #993 :wink:  Hey @ledikari. @pedrovereza is right, in 9.0.0 the `underlying` case would be getting response as well, but right now you can just cast error to `Moya.Error` and parse the response data:
```swift
.catchError { error in
    if let error = error as? Moya.Error, body = error.response?.mapJSON() {}
}
```

the syntax might be off since I'm writing this from the bus, but the idea should be alright. üòÖ

Let us know if it helped! @ledikari Do you know which case the `MoyaError` is? 
You can use `errorResponse?.errorDescription` if you'd like.

The reason I'm asking is the `MoyaError.underlying` and `MoyaError.requestMapping` return nil for the `response` property. @ledikari It looks like you're receiving a `MoyaError.underlying`, so the response property will be `nil`.
You can view the output for `MoyaError.errorDescription` [here](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaError.swift).  @ledikari I don't believe so üò≠. As others have mentioned this feature will be available in Moya 9.0.0. Yes, we are sorry about that - just the `underlying` error & `body` needed in it was so uncommon we didn't really think about it till few months back. But we are closing in for the 9.0.0 version so please take a look at it once it is shipped. Sorry again for the inconvenience üò•  @ledikari @jeryRazakarison Yes, you can use the version of Moya that is under development if you'd like. I'd only suggest that you fork the repo and point to your own fork instead of relying on our `9.0.0-dev` branch as we can't guarantee it will *always* be stable :wink: @ledikari Not sure, we are tracking progress in #1075, but slowly getting there. I didn't recommend using our `9.0.0-dev` since there might be some breaking changes in the near future, so please use it at your own risk üëç   I somehow broke @MrAsterisco PR, really sorry about that. This is his PR from #1151. I also fixed the indentation.

<img width="350" alt="zrzut ekranu 2017-06-30 o 19 48 22" src="https://user-images.githubusercontent.com/5232779/27747803-1b0dba5e-5dcd-11e7-9415-a5309db9453f.png">

**Edit:** I've also invited you to the org @MrAsterisco, since our bot probably won't catch that specific case üòÑ   Hey @MrAsterisco. This is a very good question. Usually, I have a `refresh` observable that would cover that for me. So my usual stack would be somewhat similar to:
```swift
final class TestViewModel {
    
    let refresh: Observable<Void>
    let items: Observable<[Item]>
    
    private let provider: RxMoyaProvider<GitHub>
    
    init(refresh: Observable<Void>, provider: RxMoyaProvider<GitHub>) {
        self.refresh = refresh
        self.provider = provider
        
        self.items = refresh
            .flatMapLatest { [unowned self] in
                return self.provider.request(.zen)
                    .catchError() // logic for error catching here
            }
            .map(toArray: Item.self)
    }
}
```

This way every time `refresh` observable produces next element, my items refresh with it. This `refresh` observable might be also `Subject` or `Action`, whatever works for you. 

Let me know if it helped üëç  Hey @MrAsterisco. Yeah, it is one of the most common usages of reactive extensions. You don't necessarily need to make a `Variable`, you want to refresh your items based on some sort of event. This event could be passed to the view model from view controller and thus could trigger the refresh. E.g. you can pass observable that on each button click it refreshes the items:

```swift
let viewModel = TestViewModel(refresh: refreshButton.rx.tap.map { _ in })
```

However your idea could work as well. You could make your own subclass of MoyaProvider that covers a function of `repeatLastRequest()`, but it would require saving state in the normal, overridden `request` function. It could be tricky (probably needs some locks), but it should work. Of course! üëç  Let me know if I can be any help.  Related #963. This is a reimplementation of #1140. 

To-do:
- [x] Update documentation.
- [x] Tests.
- [x] Moya.xcodeproj fix.

To avoid code duplication I've created internal requests that are used by both reactive providers and new `rx.` & `reactive.` API. Although I'm not sure how we should go about testing this one. We still have tests for reactive providers that cover most of it I believe.

Please let me know what do you guys think!  Interesting idea ‚Äì I like it a lot. My only hesitation is that that some users (including myself) subclass the existing reactive subclasses (subclassing `RxMoyaProvider`) to introduce custom behaviour within the `request` methods. This implementation wouldn't allow for the same mechanism to be used, so we'd need to find some alternative. 

My gut says composition would be a good idea (so, instead of subclassing a provider, we would recommended containing it within a sort of provider-provider). If that's acceptable, we would just want to make sure that we have a migration guide before releasing 9.0. Happy to assist with any of this. This is a great idea. I'd love it if you could help with migration guide, @ashfurrow. Especially because we will only deprecate providers, without removing them, we might get more feedback on the change as well (and thus we could see what features are really used in Moya). Well, [Eidolon](https://github.com/artsy/eidolon) has become a sort of go-to implementation for how to do Rx with Moya. Why don't I migrate that over this week, and we can refer to the actual PR from the migration docs. It'll likely be a few days before I get to this, but I'll follow up üëç Great! Thank you, Ash üéâ Thanks guys for the review! The migration in Eidolon looks like was easier than expected - and that's awesome. I've committed some changes you guys requested - please take another look in your spare time üòÑ  Btw. anyone have an idea why is CI failing? ü§î  Hmm not sure what's going on. Can you test locally to see if it passes from within Xcode? From the command line with `rake test`? Ok I think, I fixed it (it actually passed from the state it was stuck on üòÑ ). There was a problem with project (I had to regenerate it using `framework-generate`. I'll bring that up in another issue) + problem with Carthage deps.  Thank you guys so much for the reviews and help! Thanks for picking this up, @sunshinejr!  Hey @codwam. Please let us know the details of your issue. For example it could be your `TargetType` setup, what are you trying to achieve and what is happening. For now we can't really help you with that info, unfortunately.  @codwam to make your request multipart-friendly, you need to have a `multipartBody` that is not empty and your `method` in `TargetType` must be one of the following:
```swift
.post
.put
.patch 
.connect
```

If you specify the following correctly, there should be no issue on our side. 

From the code you posted it seems like your backend wants `multipart` request on given endpoint, but you are just doing a `request` in case of no image - thus server does not allow the request. 

One of the fixes would be to just switch from optional `UIImage?` to just `UIImage`:
```swift
enum Router {
    case test(account: String, image: UIImage)
}
```


Let us know if it helped! Can you post the logs from Charles? Like the whole request you see? (headers, method, body)? It is not a must, @codwam, but having this check should help users when making a mistake by not specifying `multipartFormData`. If you really want to send an empty data, you could try with:
```swift
return .upload(.multipart([MultipartFormData(provider: .data(Data()), name: "serviceImg")]))
```

Let me know what you think :) Glad it helped! üéâ   Hey @MrAsterisco, thank you so much for this PR. üéâ  This is a really nice idea, however, from the user perspective, I often need this plugin to tell me exactly what is the body of a request I send to the API. So for me it would be not-so-obvious that Moya is doing some kind of decoding under the hood. 

Maybe we can figure out a way that user can opt-in (like parameter?) for that feature. Do you have any idea how we can achieve that? ü§î Looks good, @MrAsterisco! I've fixed some indentation in your PR, so now we need only 2 more things:
- [ ] Add `Changelog.md` entry
- [ ] Add a test case.

About `Changelog.md` entry, just need to add a new item in the `Next` column with the change you implemented. Example [here](https://github.com/Moya/Moya/pull/1020/files#diff-9b8fab691c00b9e5380b19ce882f3271) (it is not a breaking change, so without that **breaking change** label).

About test case, you can take a look how it is done for [formatting response data here](https://github.com/Moya/Moya/blob/master/Tests/NetworkLoggerPluginSpec.swift#L76-L85) and make something similar.

Let me know if it looks good for you. Also, do not hesitate to ask for help If you have any troubles with the above. We will try to assist with whatever you want. Seems good! Indent is quite off though, could you take care of that? :) AFAIK it's 4 spaces. :)  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Please look at my [comment here](https://github.com/Moya/Moya/pull/1147#issuecomment-312091964). Because of that and because we may have too many PRs opened at the same time and we want to make it easier for our contributors to find the ones that matter the most right, I'm gonna close it for now. We will continue the discussion later on.  I will go ahead and say we might not want to add it to 9.0.0 release since we have many breaking changes already (and few big ones). To make transition smoother we may just hold onto this one till after the release. This is a really big change and a great amount of work from @Dschee, so it would be awesome to get some feedback from @Moya/contributors in the meanwhile.

This PR helps with a lot of undefined behavior but from the user perspective it might look messy. We may need to think about this one a little bit more:
```swift
return .request(.parameters(["test1": "test", "test2": "test"]))
```
Looks kinda uncomfortable at first glance. And especially because it is the default use-case, we may think of a cleaner solution. Would one enum instead of 3 help? Not sure. Opinions? I looked this over and it seems to make sense to me.

I agree with @sunshinejr that it gets a lot more verbose at the call site... definitely not great. I'm wondering if instead of associating the new `RequestDataType` with the request enum case, we can extend the number of enum cases? like `requestWithData`, `requestWithParameters` etc?  I left you comments around most issues @Dschee. For flattening I agree we would need to flat upload & download types as well. I think we might do it in the same PR since naming convention in this one would be similar. 

Anyhow, I like the direction that this PR has taken. Keep it up :) Hey @Dschee, just a heads-up. I'll try to get to it ASAP and edit this comment. Thank you for the constant work on this one. üëç  Thanks, @Dschee! I'd love to have it, but we are still without tests and I'm not the only one to decide such things. Would love to get some feedback on it from @Moya/contributors, since it is almost finished now.

Also, sorry that I didn't mentioned it earlier, but would you rebase it to `9.0.0-alpha.1` branch, please?  I just barely got to skim this over but will take an in depth look this weekend. 
Some really cool work going on here! üòÉ Also, could you check CI, @Dschee, please? Seems like it is failng. We still need to update `docs/Examples/Basic.md` and possibly more in the examples section. While the examples are not pure documentation, `Basic.md` is a very important reference file. I'm actually not sure about `ArrayAsRootContainer.md` but it looks like more of a specialty example, so if it wasn't updated before a release I wouldn't mind too much. My biggest concern was `Basic.md` considering it is our `#1` most viewed documentation file. Thanks for taking care of this!    @Dschee I think what you've listed is fine. We don't need to add `unavailable` attributes to specific cases in the enum. The migration guide will cover this. Amazing work everyone, @Dschee especially! üí™  Oh no, I've meant that someone else should take a look at it as well :D Also, I'm not sure how can we test this one, since it is on a branch that does not belong to Moya, but to you. Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  When something changes in the `Sources` directory, there's a good possibility of us having to update or add a test in `Tests` as well. Giving a warning via Danger might be a good way to get a nudge in that direction if it's forgotten.

The [Dangerfile](https://github.com/Moya/Moya/blob/master/Dangerfile) should give you a good idea on how to add this. Fixed in #1146  I guess we could, but it would be a hassle that's not really worth it. Thanks for mentioning it though; I've added a check to see if a migration guide would be necessary for 9.0: https://github.com/Moya/Moya/issues/1075#issue-227035119 Yep, definitely. Although deprecating / making methods or variables unavailable and providing useful error messages goes a long way, too. :)  See https://github.com/Moya/Moya/pull/1142#issuecomment-310930345 Any idea as to what to call the "others"? I thought about it for a while, but couldn't get anything good enough. I came to a conclusion that we can just move `CommunityProjects.md`, `Development.md` & `Releasing.md` from `docs/` into the root directory for now (like with everything else that does not touch Moya usage itself). This idea is also supported by GitHub (they expect `Code of Conduct` & `Contributing` to be in the root dir as well).  Closes #1141  This is great idea, thank you, @BasThomas! Although, maybe rename it do something more verbose about it being in the "development" phase, rather than testing in Moya itself (`sampleData`, `stubbing` etc.)? Like `Development.md`? These are the steps that we can really use for development as well :D 

Also maybe we need to split documentation on usage of Moya and everything around it (like Community, Code of Conduct, Development, Releasing etc.)? ü§î  Both seem like a great idea. I'll create another issue for your second point! :)  Supersedes #963. (cc @kemchenj)

Also fixes #1144. Targeted this at the `master` branch by accident, changing the base branch to `9.0.0-dev` adds a bunch of commits. ü§î Also, from #963:

> Then let `MoyaProvider` conform to `ReactiveCompatible` and `ReactiveExtensionsProvider`, then we could change our code like this:

It seems like we can't use both of these protocols, seeing how they are implemented ([ReactiveCompatible](https://github.com/ReactiveX/RxSwift/blob/0b66f666ba6955a51cba1ad530311b030fa4db9c/RxSwift/Reactive.swift#L38); [ReactiveExtensionsProvider](https://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Sources/Reactive.swift#L9)). Or at least, I don't really see how to do so. Am I missing something there? Interesting CI failure:

```
‚ùå  /Users/distiller/Moya/Tests/ReactiveSwiftMoyaProviderTests.swift:190:92: argument 'stubScheduler' must precede argument 'stubClosure'

                provider = MoyaProvider<GitHub>(stubClosure: MoyaProvider.immediatelyStub, stubScheduler: testScheduler).reactive
                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

It seems like the parameter order differs from `ReactiveSwiftMoyaProvider` and `MoyaProvider`. üòØ @BasThomas you probably just need to extend `Reactive` (`RxSwift.Reactive` & `ReactiveSwift.Reactive`) and then we can skip using other providers and provide `request` method. @sunshinejr I've been trying to update the tests and verify if everything is working locally, but can't seem to get the tests running. For this I think I need to do a `swift build` and `swift test`, right? Problem is, `swift build` errors:

```bash
bas$ swift build
warning: refname '4.5.0' is ambiguous.
warning: refname '4.5.0' is ambiguous.
HEAD is now at 7fe7b91 Added release notes to the CHANGELOG and bumped the version to 4.5.0.
Resolved version: 4.5.0
warning: refname '1.1.3' is ambiguous.
warning: refname '1.1.3' is ambiguous.
HEAD is now at 92d73573 1.1.3
Resolved version: 1.1.3
warning: refname '3.2.3' is ambiguous.
warning: refname '3.2.3' is ambiguous.
HEAD is now at c844618 3.2.3
Resolved version: 3.2.3
/Users/bas/Documents/Programming/iOS/Moya/Packages/RxSwift/Package.swift:5:36: error: use of unresolved identifier 'ProcessInfo'
let RxTestIsTarget = buildTests || ProcessInfo.processInfo.environment["TEST"] == "1"
                                   ^~~~~~~~~~~
Foundation.NSProcessInfo:1:14: note: did you mean 'NSProcessInfo'?
public class NSProcessInfo : NSObject {
             ^
ApplicationServices.ProcessInfoRec:1:15: note: did you mean 'ProcessInfoRec'?
public struct ProcessInfoRec {
              ^
error: exit(1): /Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2016-05-31-a.xctoolchain/usr/bin/swiftc --driver-mode=swift -I /Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2016-05-31-a.xctoolchain/usr/lib/swift/pm -L /Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2016-05-31-a.xctoolchain/usr/lib/swift/pm -lPackageDescription -target x86_64-apple-macosx10.10 /Users/bas/Documents/Programming/iOS/Moya/Packages/RxSwift/Package.swift -fileno 3
```

Any idea? Is this an `RxSwift` issue? AFAIK, `NSProcessInfo` was renamed to `ProcessInfo` in Swift 3 an thus shouldn't error. @BasThomas We don't support `swift test` yet, it is on my todo list to make it work some day and there is an issue for that as well (#894). Right now we can use Carthage for it (`carthage update --platform iOS` should be fine) and then open Moya.xcodeproj and run the tests in. Should work fine, but if you encounter any issue let me know üëç 

**Edit:** About the `swift build` command, do you have an old toolchain somewhere? Maybe old Xcode? This command _should_ work ü§î  Interesting, I had two *really* old snapshots, though Xcode was just using the one bundled with Xcode; I wonder how it used one of those other snapshots when running `swift build`. ü§∑‚Äç‚ôÇÔ∏è Testing via Carthage works; I've created #1141 to make a short `.md` to document this. Added a DNM, as we would need to merge this into `9.0.0-dev`, not `master`, which seemed to cause [some issues](https://github.com/Moya/Moya/pull/1140#issuecomment-310914884) when trying to do so. woah, I just switched the base from master to 9.0.0-dev, and it looks like 9.0.0-dev is in dire need of a rebase :octocat:  Yeah, that's what I saw when switching the target branch as well. ü§î somebody's who's familiar with the recent commits on master should run
```
git checkout 9.0.0-dev
git rebase master
git push 9.0.0-dev
```

and the unrelated commits should disappear from this PR

On Mon, Jun 26, 2017 at 10:10 AM Bas Broek <notifications@github.com> wrote:

> Yeah, that's what I saw when switching the target branch as well. ü§î
>
> ‚Äî
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1140#issuecomment-311122243>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dERsXlpMpGdSYGGLQJFTDxp11mTfks5sH-YQgaJpZM4OEqVD>
> .
>
 I did the rebase on 9.0.0-dev and fixed conflicts on this branch, should be alright. In case something is wrong, I've got the copy of the 9.0.0-dev branch so it's all good üëç  And how are we with that extension change to `ReactiveCompatible`s, @BasThomas? What do you think? Kinda got buried in the process of this PR, so it is hard to follow the conversation :D Will take a look! I've just updated to use `ReactiveExtensionsProvider` and `ReactiveCompatible`. The build is expected to fail - I haven't updated all tests yet, and the extensions don't implement the `request()`. method yet.

Does anyone else want to look into that? As I don't have too much experience with Reactive, I feel some of you might be better for that job. :) Also, might both these extensions creating a type of `Reactive<MoyaProvider<Target>>` cause a problem somewhere? ü§î @BasThomas I might do one commit that will show what I had in mind, what do you think? In case something went wrong we can just remove it :D Definitely, go for it! I've done another update to the docs, meanwhile fixing #1144 as well. I did some work on that and it seems like we would need to add a protocol for `MoyaProvider` to make extensions happen, because we can't still do something like: 
```swift
extension Reactive where MoyaProvider {}
```

And also we would need to get rid of overriding `stubRequest` in `ReactiveSwift` provider - but I think that we established that queues are gonna implement it. I just made a comment on queues PR for that to make sure we do not forget about it. 

Due to it being a bigger change than 1 commit + a lot of discussion happened there, I think we should do another PR with clear state. What do you think, @BasThomas? Yeah, sure! @BasThomas @sunshinejr Should this closed in favor of #1153? ü§î  Yep!  Hey @syegin, just checking if everything is alright. Let me know if you need some help or you just don't have time to do it right now.  It is not yet merged, @codwam. I can take it from here (filling the tests & changelog), if @syegin won't in the near future.  @dangthaison91 It might be the case that this PR won't make it into 9.0.0 release, since we are in the middle of changing the `parameters/encoding/Task` in #1147. Basically the API will be more verbose and you would specify what to do based on a task.  This can be closed as #1147 is merged into 9.0.0-dev and will be into the new release soon. Thanks for your time, @syegin!   Hey @ercancelik. You are right - you cannot do it in `TargetType` _yet_. This is in our planned 9.0.0 release. Right now you can do it in `endpointClosure` (more details [here](https://github.com/Moya/Moya/blob/9.0.0-dev/docs/Endpoints.md#from-target-to-endpoint)), and after the release you can switch to the new parameter `headers` in `TargetType`.

Let us know if it helped!  Can someone confirm this as a bug?

If so, @syegin, would you be willing to do a PR to fix this? :) Hey @syegin, thank you for the issue. Seems like what you're saying might be the case - upload doesn't take parameters, just data, so in case of an `Endpoint`, we just add parameters and not append the data. Was trying to think of a fix and it seems like adding parameters from endpoint to the multipart data [here](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider%2BInternal.swift#L90-L92) might be sufficient. Also, we would need to add a test that covers this situation (probably asserting the data). 

Let us know if you want to take a stab at it, @syegin - we will try to help you in any way we can :) Now that I think about it, this fix will now transition from ignoring `parameters` in multipart upload to adding them to the request as well. But in normal upload `parameters` will still be ignored. This makes a lot of kinda-undefined behavior. But that's another problem (and I will open a new issue for that). I think we may accept it as a bug fix and release a 8.0.6 for now if needed.

About this changes - seems like a way to go! Please make a PR so we can discuss the implementation details üëç  This is being worked on at #1139, so I'm closing this one.  I think we can close this one in favor of #1147. Exactly what I was thinking üëç   First of all, thanks for looking into this! It seems like `JSONEncoder` returns `Data` and not `[String: Any]`, so I am not sure how we could use the encoder for parameters in that case; we really need a `[String: Any]` for parameters.

Also, I am not quite sure what `RequestData` would do over `parameters` and `parameterEncoding`?Does it offer anything other than combining these two?

Keep us updated on your progress, we'd love to see the possibilities. You might want to consider forking Moya and don't be afraid of trying things out there. üòÉ  Hey guys. I must admit I didn't read the whole conversation, but I'd suggest that we wait a little bit with planning this one. We are still focusing on releasing 9.0.0 first. Additionally, we build Moya on top of Alamofire, and these guys could also implement some `ParameterEncoding` interop with `Encodable` & `Decodable`, thus making our life easier (they change `ParameterEncoding` a lot). Swift 4 has a long way to go and time may play on our side. Although if we don't get any new API, enum idea with some tweaks seems good for me :) Swift 4 will probably be released around September, which means we still have a two+ months to go, during which Swift will still be in development and will have some fixes and improvements.

Once it is released, the transition to Swift 4 will probably be pretty fast indeed, so I think we should aim to support Swift 4 sometime in September / October. Earlier is better, and having a beta period would be great, so we can release a non-beta once Swift 4 is out of beta.  Actually, we have some undefined behavior in Moya already, so maybe we can start implementing the changes you talk about right now (and then add `Encodable` later for Swift 4.0). Because there is a problem between `task` & `parameters` & `parameterEncoding` (especially in upload, `parameters` & `parameterEncoding` do nothing in it), maybe we can merge it and create a room for `Encodable` in the future? I imagine something like this (while removing `parameters` & `parameterEncoding` properties):

```swift
enum Task {
    case request(RequestType) // that's new
    case download(DownloadType)
    case upload(UploadType)
}

// this whole enum would be new
enum RequestType {
    case data(Data) // may be used with Encodable later or/and maybe we can add .encodable case too
    case parameters([String: Any])
    case encoded(parameters: [String: Any], encoding: ParameterEncoding)
    case composite(urlParameters: [String: Any], bodyParameters: [String: Any])
}

// expanded current DownloadType a little
enum DownloadType {
    case destination(DownloadDestination)
    case parameters(DownloadDestination, parameters: [String: Any])
    case encoded(DownloadDestination, parameters: [String: Any], encoding: ParameterEncoding)
}

// this could stay the same as it is
enum UploadType {
    case file(URL)
    case multipart([MultipartFormData])
}
```
This is just expanding our current `Task` API to cover more cases. We could also merge it into one `enum` making it kinda more easy to use (just make sure the most common use-case, request, would be easy to use). The problem would be with `endpointClosure` - what would adding the `parameters` & `parameterEncoding` mean for `upload` & `uploadMultipart`? 

What do you think guys? The cases are:
1. I was thinking of producing a default parameter encoding to make it easier to use (most of the time you use one specific encoding), maybe it can be customizable in `MoyaProvider` like `provider.defaultParameterEncoding`, or maybe we should just use `URLEncoding.default` like it is in `endpointClosure` by default right now.
2. In the other two cases you can also specify parameters in your download requests. Download request is almost the same as normal one that doesn't save anything to disk, so we might also add these options to them if needed.
3. Yeah, this is the trickiest one - we probably need this parameter encoding there too.

So about PRs - I'm thinking about one big PR that we can target in the smaller PRs. This is because we probably can't do few PRs without breaking a build for some time. 

Also, I would love to hear feedback from more @Moya/contributors since it is kinda big change, and if we agree on something, we may want to implement it in 9.0.0 as well.  We forgot to change the documentation around new `RequestClosure` in some places. We need to double-check where we are using it, but for sure we have to update it in [Authentication.md](https://github.com/Moya/Moya/blob/master/docs/Authentication.md#oauth). Transition is rather simple, you can take a look at our tests [here](https://github.com/Moya/Moya/blob/aa33a0466d7333516691b3e5212c5acb41990928/Tests/MoyaProviderSpec.swift#L262-L270) to see how it is used now. [This](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#request-mapping) can be useful in case of explaining how the closure works nowadays.

Also, I think this might be good idea to introduce #starter-task (stolen from IGListKit üòÑ, thanks guys!), so I've added the label here.   I think making issues like these is a really good idea, so thanks for that! Also love the `starter-task`, but we already have the `good first step`. Should we remove that and start using `starter-task`? Also, although this is a nit, let's call it `starter task` to be in line with our other labels? We might want to see what "good first step" is used for, but for me it would be slithly different. E.g. I would use it for an idea that I have and that need improvements, where "starter task" would be rather concrete specification of what's needed, how to achieve that and possible caveats. 

Also, I'm in for changing "starter-task" to "starter task" to keep consistency üëç This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
 I'm sorry mr. stalebot, but we have to do this sometime in the future so I'm gonna reopen this. Maybe we should add `starter-task` to labels ignored by `stalebot`? ü§î  @sunshinejr What about adding the `documentation` tag instead? In case of documentation we use additionally `chore` tag which is ignored by `stalebot`. That leads me to a reason why this was closed by our bot üòÑ I'm gonna add labels where needed, right now I think all starter tasks are docs, so we should be fine for now.  Hey @bfjfm2. Thank you for bringing that up. I think we somehow missed updating some docs regarding this matter in some places, like [here](https://github.com/Moya/Moya/blob/master/docs/Authentication.md#oauth).

But our main [docs](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#request-mapping) should be up-to-date, so please take a look at them. You can also take a look at our tests that use this new closure [here](https://github.com/Moya/Moya/blob/aa33a0466d7333516691b3e5212c5acb41990928/Tests/MoyaProviderSpec.swift#L262-L270). Basically you can now specify if you want to pursue the request using `.success` case of `Result` type, or to fail the request using `.failure` case and passing the error down.

Let us know if it helped!

**Edit:** Also, because we need to update our docs around it, I've opened an issue #1134. If you resolve your problem and want to take stab at it, feel free to do so :) Glad it helped! üéâ  Hey @leo-lp, I'm assuming this is a mistake-PR so I'm gonna close it. If it's not, please describe what was your intention here and we will work things out üëç  Hey @XavierDK. You can create your own `Manager` and pass it to the `MoyaProvider`:
```swift
let configuration = URLSessionConfiguration.background(withIdentifier: "com.example.app.background")
let manager = Manager(configuration: configuration)
```

Let us know if it helps!

**Edit:** Also, see how the default `Manager` is created [here](https://github.com/Moya/Moya/blob/aa33a0466d7333516691b3e5212c5acb41990928/Sources/Moya/MoyaProvider%2BDefaults.swift#L24-L31). Glad it worked! üéâ   Hey @ranayahya - it doesn't seem like you're using Moya, right? ü§î
 In that case I am going to close this issue, as it is not related to Moya. What seems to be going wrong is that you are unwrapping (`!`) an optional value, which is `nil`. Check in Xcode on what line this happens (probably this one: `var request = URLRequest(url : URL(string: API)!)`?) If that's the case, it seems like the URL is invalid, in which case `URL(string: url)` returns `nil`.  Hey @BasantAshraf. Use `URLEncoding(destination: .queryString)` as your `parameterEncoding` and add `userName` & `password` as your parameters. Let us know if it worked!  We might want to add a custom ParameterEncoding example. See #1119 I think we could just point to [Alamofire docs](https://github.com/Alamofire/Alamofire#custom-encoding) instead ü§î  Yep, that'll do as well, I think. üòÉ  For sure! Still, I think that `ParameterEncoding` using some specific `Moya` configuration would be awesome as well.  Fixes #1110.

Was there a reason this was not enabled before?  When doing a search, it does seem like a lot of people just `return Data()`: https://github.com/search?q=%22var+sampledata%22+language:Swift+extension:.swift&type=Code&utf8=%E2%9C%93.

On it being a breaking change: we're releasing `9.0` soon, and with Swift 4 around the corner, there will probably be room to include this in `10.0` in the near future if we want to go this way. What do other @Moya/contributors think? Yup, makes sense to me.  Sounds good to me.

If we decide to make the change, I think we should make it part of `9.0` (even if it delays the release a bit), since we already included breaking changes in `TargetType`. @Dschee We are using [milestones to keep track](https://github.com/Moya/Moya/milestone/7?closed=1), but I'm not sure of the benefits GitHub Projects would give us (feels more like a kanban thing).

We are using branch `9.0.0-dev` for breaking changes going out in 9.0, and we basically rebase the changes on top of `master` from time to time, which will make the merge from `9.0.0-dev` to `master` easier when we decide to release it. PR #1124 was opened just to let more people double check that the rebase was good before pushing it to `9.0.0-dev`.

We should probably continue this discussion in a separate issue (if needed) so we don't hijack this one üòÖ  Anyone up for a PR? @SD10 We've had conversations about providing default implementations for common things, but in the end we agreed that, as a rule of thumb, we'd rather have the user explicity define (and understand) the behavior instead of relying on default implementations provided by us.

More in https://github.com/Moya/Moya/pull/1067#issuecomment-298128123 and #861 üòâ  @SD10 
> It's a large read but my takes from it are:
Forcing people to implement sampleData makes it harder to get Moya up and running
 sampleData is required prematurely (long before unit tests are written)
 Having sampleData in the TargetType bloats the file, especially with a complex API

I agree with all these points, but I don't think that defaulting `sampleData` is the best solution. I think that it should be removed from `TargetType` completely :wink:  Are there any dependency problems? What would the benefits of having a separate repository be for each submodule? I think having a separate repository per submodule introduces quite some challenges without solving any problems. 

On `Moya/ReactiveCocoa` and `Moya/ReactiveSwift`: yes, it might be time to remove the `ReactiveCocoa` subspec. It has been left after the rename for compatibility with Podfiles using `Moya/ReactiveCocoa`. The only downside is that we can't really inform those users that there is a new subspec name, and I am not sure how big the impact could be. They would basically get stuck at a maximum library version when we would remove it, without being warned of any new versions in any way.  A similar discussion happened in #345.

Couple of quotes:
https://github.com/Moya/Moya/issues/345#issuecomment-183493154
 > The only "real" fix for this is to have separate repos but we decided to not go that way in the past since it adds a lot of complexity for 2 extra files.

https://github.com/Moya/Moya/issues/345#issuecomment-183494797
>  we tried multiple repos but it got out of hand, quickly.

But I'm interested to hear what kind of dependency problems you're referring to.
 @Huang-Libo I can see the benefits it would bring for Carthage users, but I still agree with the conclusions from #345: the complexity it would add on maintenance side is too big. (more context in #215 and #169).

@Moya/contributors Thoughts?
  Yeah, same. Separate repos would help Carthage users but introduce a tonne of complexity for contributors. From my perspective, I would prefer to keep contributing to the library as easy as possible.

If we do decide to change the infrastructure of the project, I'm happy to help in any way I can. Just let me know;. I am going to close this for now as per the above comments, but thanks for bringing this up @Huang-Libo!  I merged changes from master into 9.0.0-dev, but there were some conflicts and I would love if you guys could take a look at it and make sure everything is okay :D

> Conflicts:
> - Cartfile.resolved
> - Demo/Podfile.lock
> -	Package.swift
> -	Tests/ErrorTests.swift
> -	Tests/MoyaProviderIntegrationTests.swift
> -	Tests/RxSwiftMoyaProviderTests.swift
> -	Tests/TestHelpers.swift
> -	docs/Examples/AlamofireValidation.md @sunshinejr Last time we rebased `9.0.0-dev` with `master`, which I feel may be easier ü§î
 @pedrovereza Yeah, I did that as well, but didn't push to the branch itself, but created a new one and did a PR since it was a big merge and wanted to make sure I didn't break anything. Also, this problem with Changelog is strange since there was no conflict in it ü§î @sunshinejr Oh I see, let's go ahead and just make a commit fixing the changelog then üòÑ  Fixed `Changelog.md` & `Package.swift` - thanks @pedrovereza! Also, I've checked once again and it _seems alright_, but another look wouldn't hurt :D  Hey all! I'm here to present my idea of improving Plugins and continue (kinda deadly) discussion from #985. 

Right now plugins:
- Are limited to one base type that has many functions that are not used and most of the time empty (but still executed).
- Are hard to expand (as a result of point above).
- Have limited functionality (as a result of points above).
- Do many things that `endpointClosure` & `requestClosure` do as well - making it ambiguous for users to use & for us to recommend a good practice.

Below is my proposition on to how make all of the above go away. Main idea is to remove `closures`, `manager` etc. from `MoyaProvider` and replace it with plugins. The first version may just introduce everything we need to a migration and then expand it as we go. Maybe we can even extract something from `TargetType`? ü§î 

### Types

```swift
// Base type

public protocol Plugin {}
```

```swift
// Current plugin methods extracted into Plugin types

public protocol RequestDelegatePluginType: Plugin {
    func willSend(_ request: RequestType, target: TargetType)
    func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType)
}

public protocol ResponseProcessingPluginType: Plugin {
    func process(_ result: Result<Moya.Response, MoyaError>, target: TargetType) -> Result<Moya.Response, MoyaError>
}
```

```swift
// `endpointClosure` & `requestClosure` & `stubbingClosure` into Plugin types

public protocol EndpointPreparingPluginType: Plugin {
    func prepare<T: TargetType>(endpoint: Endpoint<T>, target: T) -> Endpoint<T>
}

public protocol RequestPreparingPluginType: Plugin {
    func prepare(_ request: URLRequest, target: TargetType) -> URLRequest
}

public protocol ResponseStubbingPluginType: Plugin { // we may also remove this one and try to change `ResponseProcessingPluginType` a little bit to allow stubbing behavior :)
    func stubBehavior<T: TargetType>(_ target: T) -> StubBehavior
}
``` 

```swift
// Authentication moved from Request to Plugin type too

public protocol AuthenticationPluginType: Plugin {
    func authenticate(usingCredential credential: URLCredential) -> Self
}
```

### Migration from current closures
We could persist current closures as a default plugins, e.g. this `DefaultEndpointClosure` translated:
```swift
class DefaultEndpointPreparingPlugin: EndpointPreparingPluginType {
    
    func prepare<T>(endpoint: Endpoint<T>, target: T) -> Endpoint<T> where T: TargetType {
        return Endpoint(
            url: URL(for: target).absoluteString,
            sampleResponseClosure: { .networkResponse(200, target.sampleData) },
            method: target.method,
            parameters: target.parameters,
            parameterEncoding: target.parameterEncoding
        )
    }
}
```

### Problem - How to store plugins?
We might want only one plugin for some types (e.g. `ResponseStubbingPluginType`) and unlimited for other types (e.g. `RequestDelegatePluginType`). Having multiple of stubbing plugins or request/endpoint preparing plugins creates undefined behavior. I thought that we may use a type for storing it (we would then have some sort of value dependent types):
```swift
final class PluginsConfiguration {
    
    let endpointPreparation: EndpointPreparingPluginType?
    let requestPreparation: RequestPreparingPluginType?
    let stubBehavior: ResponseStubbingPluginType?
    ...
    
    init(stubBehavior: ResponseStubbingPluginType? = nil, endpointPreparation: EndpointPreparingPluginType = DefaultEndpointPreparingPlugin()...) {}
}
```

But even tho it gives us comfort with multiplicity of plugins for now (and who knows what the future holds :D), this is not scalable. Let's say I would have one plugin having implementation of three protocols - I would have to type it 3 times. Now let's say we want to expand with plugins - we may end up with 20 properties and counting.

The second solution would be just having an array of `Plugin` type in `MoyaProvider.init`. Now we can choose to e.g. make `asserts` in code to only have X number of plugins with given type. This is not the best, but this way we are sure we do not end up with undefined behavior.

If you guys have any other ideas it would be great to hear them. Also, if you are still reading this, thank you! This might be a big change, so I'd love every feedback I can get. If the whole idea is just not the right one for your taste - just say it. 

/cc @Moya/contributors 

Cheers! üéâ  Cool topic, thanks for bringing it up @sunshinejr!

I have a few things I'd like to bring up:

* I'm a bit concerned that the base protocol of plugins is empty. I'd rather have a protocol that explictly exposes what it can be used for, or no base protocol at all.
* Maybe as a symptom of the above, all plugins you used as example define different contracts. for instance, what do an `EndpointPreparingPluginType` and `ResponseStubbingPluginType` have in common? What's the benefit of having both as `Plugin`?
* Not sure about the second storing options. Having an array of `Plugin` would probably force us to know the exact type of plugin before using it, making the `Plugin` abstraction not so useful.

I think we first need to have a clear vision of what exaclty is a plugin for Moya. Is it something external to the core API, similar to our current `PluginType`, which deals only with request/response? Or is it something capable of changing the internal behavior of the framework (like `EndpointPreparingPluginType` and `RequestPreparingPluginType`)? Or both? Thank you so much for the feedback, @pedrovereza üëå 

About empty base protocol - it would be needed if we wanted to go with solution 2 to the problem - array of plugins. For the first solution it would be possible to avoid the base protocol if there wouldn't be a reason for keeping it.

About different contracts - I agree that these are different. But [we already have different contracts in our current PluginType](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugin.swift#L10-L22) and I've just built on top of that. Maybe we need to think if we still want multiple contracts, but I believe that it would open more possibilities, like e.g. eliminating closures.

About second option to storing problem - we would need to have collections/properties of given plugins anyways, because we need to know which plugin to invocate, e.g. before firing up the request, we could invocate some plugin type that can decide if the request should use network or use stubs.

And the last but not least - what should our `Plugin` be? Given the fact how we use it right now (both delegation and modification of some objects), I wouldn't shrink the capabilities, rather stick to them (or stretch if needed). This way we would be able to reduce some responsibilities of Moya core and extract them into plugins. We might need to be circumspect in selecting which plugins we can add and which we cannot, though. @colinta you could use one plugin that implements few protocols, or just use multiple plugins - your choice. The point of this idea was to refactor plugins to have the same functionality as now, but also be easily expandable to features like `endpointClosure` & `requestClosure` or authentication/stubbing/inflights. 

Protocols in my example are just stubs for what we can really do - the `endpoint` function could get the parameter from the other plugin that makes an `Endpoint` from `TargetType`.

Nonetheless, If anyone have a different idea I'd love to hear it. Because of scale of this improvement and lack of feedback/better alternatives, I'm closing this one. Maybe we will revisit it some time in the future.  ~~Thanks for noticing, @LeonardoCardoso! @Moya/contributors, should we release `8.0.6` to support this for version 8 still, or do we want to hold off on this for v9? Not sure if this would break anything?~~ @devxoul By using `~> 3.0` we are saying we can take anything from `3.0` up until `3.9`. The problem here is that our minimal version should be `3.5` now. 

We would still want to use `~> 3.5`, as `>= 3.0` means we could take, for example, version `4.0`, which would include breaking changes that we may not be ready to take. ~~This confuses me every time. Why does `3.5` not work at this point, then? `3.5` is in the range of `3.0` and `4.0`, so that should work? ü§î~~ @LeonardoCardoso, I just set up a test project and it seems to work fine with RxSwift. Alamofire seems not to be updated yet, though, and causes an error.

Have you tried `pod update`? A fresh install uses RxSwift 3.5. ```bash
$ pod install
Analyzing dependencies
Downloading dependencies
Installing Alamofire (4.4.0)
Installing Moya (8.0.5)
Installing Result (3.2.3)
Installing RxSwift (3.5.0)
Generating Pods project
Integrating client project
``` @BasThomas @LeonardoCardoso  Yea, just double checked that I have a dummy project that is using RxSwift 3.5 as well.

@LeonardoCardoso If `pod update` doesn't solve it for you, could you share the content of your `Podfile` and `Podfile.lock`?  target.baseURL.appendingPathComponent will convert '?' to '%3f'. 'urlQueryAllowed' will be perfect
eg."http://cdn2.jianshu.io/assets/default_avatar/13-394c31a9cb492fcb39c27422ca7d2815.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240" -> OK 
"http://cdn2.jianshu.io/assets/default_avatar/13-394c31a9cb492fcb39c27422ca7d2815.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240"  ->404 I was given a strange url  "https://www.XXX.net/buildAction.do?mbGetIndexJson&city=370200"
"/buildAction.do?mbGetIndexJson" -> path . The path contain '?'  

 @SD10 I know how to avoid this problem.
If  don't change the methodÔºåI must put "https://www.XXX.net/buildAction.do?mbGetIndexJson" as baseUrl. There is no 'path', there is no sense to use moya for network.
So I put forward this problem Can you share the code where you expect a `?` instead of `%3f`? The example URLs in your initial message are both the same and work fine. @SD10 @BasThomas  a sample  Demo [demo](https://github.com/GuiFoA/moyaDemo.git) @SD10  Good ideaÔºåthanks  When doing a POST request, we should use `URLEncoding.queryString` instead of `URLEncoding.default` (as explained by @sunshinejr in [#1119](https://github.com/Moya/Moya/issues/1119#issuecomment-307929162))  Moya Version - 8.0.5

When I create a string for my path like:

```
"/id/?access_token=ACCESSTOKEN"
```

The '?' gets converted to '%3F' in the url which is sent and the server can't read this. Is there a way to send the '?' rather than the encoded unicode?

**What I want to send as the URL:**

```
https://api.test.co.uk/v1-dev/test/3?access_token=e02fkjhbjb4faf363jn0bcbeca0fad4aff
```

**What is actually sent as the URL:**

```
Moya_Logger: [12/06/2017 11:31:20] Request: https://api.test.co.uk/v1-dev/test/3%3Faccess_token=e02fkjhbjb4faf363jn0bcbeca0fad4aff
```
 What's your `parameterEncoding`? @BasThomas The parameterEncoding is 

> URLEncoding.default

@haritowa The server needs the access token and limits to be in the url. Would using params allow for this? @pete183 Yes, `URLEncoding.default` will put your parameters in the url :wink: @pedrovereza @haritowa Thanks for the help, it works now! Just to add to it: `URLEncoding.default` will behave differently in `GET` and `POST` requests. In `GET` method you will, in fact, get parameters in URL, @pete183. In `POST` on the other hand, you will get parameters in body. You can specify if you want it all the time in the URL or body using different properties of `URLEncoding` - more on the matter [here](https://github.com/Alamofire/Alamofire/blob/master/README.md#parameter-encoding). @sunshinejr Please check #1120 üòÖ  @sunshinejr Does Moya have an easy way to send two parameters one in the URL and one in the body using a POST request? We don't have a method exclusively for this behavior, but you can use custom `ParameterEncoding`, that would decide whether the parameter should be in body/url/header. You can find instructions on creating your own encoding [here](https://github.com/Alamofire/Alamofire/blob/master/README.md#custom-encoding).

**Edit:** Now that I think about it, that would be a good addition to our examples. If you, @pete183, or someone else end up doing their own `ParameterEncoding`, we would love to have it added to our examples directory. @sunshinejr 

I think something like this would work:

```swift
public var parameters: [String: Any]? {
    var params:[String: Any] = [:]
    params["query"] = ["access_token":getAccessToken()]
    params["body"] = ["user_name":"Pete"]

    return params
}

public var parameterEncoding: ParameterEncoding {
    return CompositeEncoding()
}


struct CompositeEncoding: ParameterEncoding {
        
    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        guard let parameters = parameters else {
            return try urlRequest.asURLRequest()
        }
            
        let queryParameters = (parameters["query"] as? Parameters)
        let queryRequest = try URLEncoding(destination: .queryString).encode(urlRequest, with: queryParameters)
            
        if let body = parameters["body"] {
            let bodyParameters = (body as! Parameters)
            var bodyRequest = try JSONEncoding().encode(urlRequest, with: bodyParameters)
                
            bodyRequest.url = queryRequest.url
            return bodyRequest
        } else {
            return queryRequest
        }
    }
}
``` Yeah, I was thinking about something similar. Unfortunately, this way you have to remember about 2 root keys being kinda instructions for sub dictionaries. We can improve it a little bit making these dictionary keys static in the `CompositeEncoding`:

```swift
struct CompositeEncoding: ParameterEncoding {
    enum Keys {
        static let query = "query" 
        static let httpBody = "httpBody"
    }
    
    ...
}

public var parameters: [String: Any]? {
    return [CompositeEncoding.Keys.query: ["access_token": getAccessToken()],
            CompositeEncoding.Keys.body: ["user_name": "Pete"]]
}
```

Would you want to make a PR with this, @pete183? It would require adding this example to `docs/Examples` and linking it in the `docs/Examples/Readme.md`. During the next couple of days I'll have a look into this! Great, thank you! üéâ  @sunshinejr 

There's an issue when you want to provide an array of parameters in a url like this:

```
/user/17?access_token=8312961fdgdgfmwe3r4f&fields=account_id,photo
```

It actually gives you:
```
/user/17?access_token=8312961fdgdgfmwe3r4f&fields%5B%5D=account_id&fields%5B%5D=photo
```

Here is the swift code for loading the parameters into the url query:
```swift
params[ParamKeys.query] = ["fields": ["account_id", "photo"], "access_token":getAccessToken()]
``` I am not sure if this is supported. Take a look at the discussion in #597, specifically [this](https://github.com/Moya/Moya/issues/597#issuecomment-244824456) comment. Does that work? @BasThomas 

When implementing this url param
```
["fields": "[\"account_id\", \"photo\"]", "access_token":getAccessToken()]
```
It gives me this:

```
/user/17?access_token=2db2sdfnkjnefw334819fa&fields=%5B%22account_id%22%2C%20%22photo%22%5D
```

Rather than:
```
/user/17?access_token=2db2sdfnkjnefw334819fa&fields=account_id,photo
```
 @pete183 This is the expected behavior from Alamofire. From [URLEncoding docs](https://github.com/Alamofire/Alamofire/blob/c8700ac7ea6b7efa7200e2920bf528e88b4dbee6/Source/ParameterEncoding.swift#L67):
> Since there is no published specification for how to encode collection types, the convention of appending `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested dictionary values (`foo[bar]=baz`).

In order to achieve the format you want, you'd have to implement your own `ParameterEncoding`
 @pedrovereza 
Is it possible to tell URLEncoding to stop encoding a comma?

I've got the url to this at the moment:
```
/user/7?access_token=60323354sgnsldjnfs85a&fields=account_id%2Cphoto
````

And I need
```
/user/7?access_token=60323354sgnsldjnfs85a&fields=account_id,photo
```` @AkhilDad 

In the end I wrote a custom composite encoding. This allows for `,` to not be encoded. Within Moya, you will then need to choose this custom encoding: 

```swift
/// parameterEncoding: ParameterEncoding
/// - OAuth: URLEncoding.default
/// - Default: CompositeEncoding
public var parameterEncoding: ParameterEncoding {
    switch self {
        case .OAuth:
            return URLEncoding.default
        default:
            return CompositeEncoding()
    }
}
```

```swift
public struct CompositeEncoding: ParameterEncoding {
    
    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        guard let parameters = parameters else {
            return try urlRequest.asURLRequest()
        }
        
        let queryParameters = (parameters[ParamKeys.query] as? Parameters)
        
        var queryRequest = try URLEncoding(destination: .queryString).encode(urlRequest, with: queryParameters)
        
        if let body = parameters[ParamKeys.httpBody] {
            let bodyParameters = (body as? Parameters)
            var bodyRequest = try URLEncoding().encode(urlRequest, with: bodyParameters)
            //var bodyRequest = try JSONEncoding().encode(urlRequest, with: bodyParameters)
            bodyRequest.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
            bodyRequest.url = queryRequest.url
            
            return bodyRequest
        } else {
            return queryRequest
        }
    }
}




// MARK: URLEncoding
/// Creates a url-encoded query string to be set as or appended to any existing URL query string or set as the HTTP
/// body of the URL request. Whether the query string is set or appended to any existing URL query string or set as
/// the HTTP body depends on the destination of the encoding.
///
/// The `Content-Type` HTTP header field of an encoded request with HTTP body is set to
/// `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification for how to encode
/// collection types, the convention of appending `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending
/// the key surrounded by square brackets for nested dictionary values (`foo[bar]=baz`).
public struct URLEncoding: ParameterEncoding {
    
    // MARK: Helper Types
    /// Defines whether the url-encoded query string is applied to the existing query string or HTTP body of the
    /// resulting URL request.
    ///
    /// - methodDependent: Applies encoded query string result to existing query string for `GET`, `HEAD` and `DELETE`
    ///                    requests and sets as the HTTP body for requests with any other HTTP method.
    /// - queryString:     Sets or appends encoded query string result to existing query string.
    /// - httpBody:        Sets encoded query string result as the HTTP body of the URL request.
    public enum Destination {
        case methodDependent, queryString, httpBody
    }
    
    // MARK: Properties
    /// Returns a default `URLEncoding` instance.
    public static var `default`: URLEncoding { return URLEncoding() }
    
    /// Returns a `URLEncoding` instance with a `.methodDependent` destination.
    public static var methodDependent: URLEncoding { return URLEncoding() }
    
    /// Returns a `URLEncoding` instance with a `.queryString` destination.
    public static var queryString: URLEncoding { return URLEncoding(destination: .queryString) }
    
    /// Returns a `URLEncoding` instance with an `.httpBody` destination.
    public static var httpBody: URLEncoding { return URLEncoding(destination: .httpBody) }
    
    /// The destination defining where the encoded query string is to be applied to the URL request.
    public let destination: Destination
    
    // MARK: Initialization
    /// Creates a `URLEncoding` instance using the specified destination.
    ///
    /// - parameter destination: The destination defining where the encoded query string is to be applied.
    ///
    /// - returns: The new `URLEncoding` instance.
    public init(destination: Destination = .methodDependent) {
        self.destination = destination
    }
    
    // MARK: Encoding
    /// Creates a URL request by encoding parameters and applying them onto an existing request.
    ///
    /// - parameter urlRequest: The request to have parameters applied.
    /// - parameter parameters: The parameters to apply.
    ///
    /// - throws: An `Error` if the encoding process encounters an error.
    ///
    /// - returns: The encoded request.
    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        var urlRequest = try urlRequest.asURLRequest()
        
        guard let parameters = parameters else { return urlRequest }
        
        if let method = HTTPMethod(rawValue: urlRequest.httpMethod ?? "GET"), encodesParametersInURL(with: method) {
            guard let url = urlRequest.url else {
                throw AFError.parameterEncodingFailed(reason: .missingURL)
            }
            
            if var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false), !parameters.isEmpty {
                let percentEncodedQuery = (urlComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
                urlComponents.percentEncodedQuery = percentEncodedQuery
                urlRequest.url = urlComponents.url
            }
        } else {
            if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil {
                urlRequest.setValue("application/x-www-form-urlencoded; charset=utf-8", forHTTPHeaderField: "Content-Type")
            }
            
            urlRequest.httpBody = query(parameters).data(using: .utf8, allowLossyConversion: false)
        }
        
        return urlRequest
    }
    
    /// Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
    ///
    /// - parameter key:   The key of the query component.
    /// - parameter value: The value of the query component.
    ///
    /// - returns: The percent-escaped, URL encoded query string components.
    public func queryComponents(fromKey key: String, value: Any) -> [(String, String)] {
        var components: [(String, String)] = []
        
        if let dictionary = value as? [String: Any] {
            for (nestedKey, value) in dictionary {
                components += queryComponents(fromKey: "\(key)[\(nestedKey)]", value: value)
            }
        } else if let array = value as? [Any] {
            for value in array {
                components += queryComponents(fromKey: "\(key)[]", value: value)
            }
        } else if let value = value as? NSNumber {
            if value.isBool {
                components.append((escape(key), escape((value.boolValue ? "1" : "0"))))
            } else {
                components.append((escape(key), escape("\(value)")))
            }
        } else if let bool = value as? Bool {
            components.append((escape(key), escape((bool ? "1" : "0"))))
        } else {
            components.append((escape(key), escape("\(value)")))
        }
        
        return components
    }
    
    /// Returns a percent-escaped string following RFC 3986 for a query string key or value.
    ///
    /// RFC 3986 states that the following characters are "reserved" characters.
    ///
    /// - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
    /// - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
    ///
    /// In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
    /// query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
    /// should be percent-escaped in the query string.
    ///
    /// - parameter string: The string to be percent-escaped.
    ///
    /// - returns: The percent-escaped string.
    public func escape(_ string: String) -> String {
        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
        let subDelimitersToEncode = "!$&'()*+;="
        
        var allowedCharacterSet = CharacterSet.urlQueryAllowed
        allowedCharacterSet.remove(charactersIn: "\(generalDelimitersToEncode)\(subDelimitersToEncode)")
        
        var escaped = ""
        
        //==========================================================================================================
        //
        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
        //  hundred Chinese characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
        //  info, please refer to:
        //
        //      - https://github.com/Alamofire/Alamofire/issues/206
        //
        //==========================================================================================================
        if #available(iOS 8.3, *) {
            escaped = string.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet) ?? string
        } else {
            let batchSize = 50
            var index = string.startIndex
            
            while index != string.endIndex {
                let startIndex = index
                let endIndex = string.index(index, offsetBy: batchSize, limitedBy: string.endIndex) ?? string.endIndex
                let range = startIndex..<endIndex
                
                let substring = string.substring(with: range)
                
                escaped += substring.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet) ?? substring
                
                index = endIndex
            }
        }
        
        return escaped
    }
    
    private func query(_ parameters: [String: Any]) -> String {
        var components: [(String, String)] = []
        
        for key in parameters.keys.sorted(by: <) {
            let value = parameters[key]!
            components += queryComponents(fromKey: key, value: value)
        }
        #if swift(>=4.0)
            return components.map { "\($0.0)=\($0.1)" }.joined(separator: "&")
        #else
            return components.map { "\($0)=\($1)" }.joined(separator: "&")
        #endif
    }
    
    private func encodesParametersInURL(with method: HTTPMethod) -> Bool {
        switch destination {
        case .queryString:
            return true
        case .httpBody:
            return false
        default:
            break
        }
        
        switch method {
        case .get, .head, .delete:
            return true
        default:
            return false
        }
    }
}



extension NSNumber {
    fileprivate var isBool: Bool { return CFBooleanGetTypeID() == CFGetTypeID(self) }
}
``` @AkhilDad This is to send it as a path, it's just that in Alamofire, they call it parameter encoding. If you give me a sample of the path which you would like to send data too, I could create it.  Hmm, this is an interesting one. Not sure what to think of it yet. Thanks for the issue, @SD10 - this is a really good idea. Having standardized encoding/decoding by Swift standard library, I think it is natural for us to implement a basic map method that would cover this behavior. However, for now we don't have any Swift 4.0 branch and we are in the middle of Moya 9.0 release, so we might want to wait with that implementation.  Thanks for taking the initiative @SD10! That sounds great, we'll update this issue once we cut a 9.0 release üòÑ   Continues #762 

Hopefully I didn't miss any `queue` üòÑ  üëèüëç  Hey @k8mil. You are right - by default `POST` method would add parameters to the body. But there is an option to brute-force it in the query string: you would have to use `URLEncoding(destination: .queryString)` as your `parameterEncoding`. More on this matter you can find [here](https://github.com/Alamofire/Alamofire/blob/master/README.md#parameter-encoding).  Hey @KieSun. This is really strange. [We have tests around progress](https://github.com/Moya/Moya/blob/master/Tests/MoyaProviderSpec.swift#L700-L742), but if you found an edge case which our tests do not cover - please let us know with more detailed description. Even better if you could write a test for that. Right now, I can't really help you based on this information. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 There is no test about upload progress, only download progress 

But I made an unit test on httpbin and we receive progress info
https://github.com/phimage/Moya/commit/765113a198d3058235a2197b9c5f9757cdc72aa5 Hey, thanks @phimage! Can you open a PR so we can add that test? That'd be awesome! Yes I will do it
I have 3 commits, maybe 3 or 2 PR to do, and all about "progress", so potentially a lot of conflicts if I do not make it one after another.
First one is #1232, I must convert it for 9.0.0-dev  In this PR:
- Added Assets setup (all credits goes to @scottrhoyt, from #968).
- Added two examples that weren't in the Readme (Alamofire automatic validation & Creating an authorization plugin)
- Removed unnecessary **Advanced** prefix - we weren't consistent with it and it is hard to judge what is advanced and what is not - let's just stay with one "Basic" example.

As always, let me know what do you guys think. Cheers! üéâ   Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @mrfarukturgut , `JSONResponseDataFormatter` is not part of Moya. We have the function [implemented in our Demo app](https://github.com/Moya/Moya/blob/5678a4c66ad779b15173315b0c2e300d0e3d9ba9/Demo/Shared/GitHubAPI.swift#L6), you'd need to implement the function on yours :wink:  I think we should be able to add this in Moya. I'll take a look. Thanks for bringing this to our attention! I've opened #1127.  Hey @eliacamposilvan. Thanks for filling in an issue.

Is this issue happening on other versions of Moya as well? Can you use our `NetworkLoggerPlugin` in your `MoyaProvider` or any other tool like `mitmproxy` to make sure it's Moya issue, not a server issue? Logs from that would be really helpful. It would be even better if you could prepare demo project where this issue exist so I can investigate more. Don't worry about it, glad you figured it out! üéâ  Also, from the logs it seems like there is no body in the response, might want to check that out as well. 

Please feel free to reopen if you find something that might be a Moya problem anyways.   This is great üëç Also, can we maybe make a Danger rule to avoid `=====` & `------` and use `#` in .md files? ü§î 

**Edit:** I see your üëç , does it mean you're gonna do this in this PR @BasThomas? :D or let's just do another one? Let's open a separate one for that. üòÉ I'd need to dive into SwiftLint for that though, so if you'd like to do that, feel free. Does SwiftLint actually work with non-`.swift` files? üòÆ Haha, probably not, I've meant Danger but well, that happened üòÖ Hah, of course. Let me think of a nice way to check.  So I was doing a release today and found out that the instructions weren't as clear as I thought it would be. I've added some examples, note for `ZSH` users & format it a little bit. 

[Preview](https://github.com/Moya/Moya/blob/releasing-patch/docs/Releasing.md) ü§î, never saw this, but it seems like we're using `----` style and `#` style headers all around the place. I can open  a PR soon changing these all to the `#` notation? That, at least to me, is a bit cleaner. Thoughts? Yeah, good idea. Let's make it consistent :)  Last few PRs were to the Tests directory and thus our MoyaBot reminded me that we need to take care of this directory with SwiftLint as well. Of course, these are test cases, so the rules in this directory might been a little bit loosen up. That's why I've added another config file with less strict rules in there. If you don't agree with (not) having some rule on the list, let me know. 

I've also fixed most of the errors, but there are 2 left. These are about file length & type length, but I believe we don't need to exclude these rules. I'm more keen to refactor a bit `MoyaProviderSpec`, because there is a room for that.  What is it exactly where you encounter an error? Can you clarify what doesn't work as expected?  Rationale: #1071. 

~~(I'm gonna comment in the PR my opinions, bear with me for a sec :D)~~
**Edit:** Finished my feedback, I'd love to hear your opinion on this! Maybe not for now, but I was thinking: can we lock issues with x comments after being closed? Looking at the [lib file](https://github.com/probot/stale/blob/master/lib/stale.js), I think there is no `lock()` method and any other that are needed for this to happen. Although I love the idea and we can try to add an Issue or PR if someone is more skilled in .js than me üòÖ  @BasThomas read my mind. Locking would be awesome, let's create that issue üòÑ  GitHub apparently doesn't support locking (yet)... https://github.com/probot/stale/issues/16#issuecomment-291862121 ... but there seems to be a plugin that *does* work? I can't really find out how this would work: https://github.com/lee-dohm/lock. Thanks for all this work though, @sunshinejr! This seems like a great addition. üéâ I've updated the PR:
- Added `confirmed bug` & `chore` in exempt labels.
- Renamed stale label to `no recent acitivity`
- Changed the comments for marking & closing.
- Added days we waited for the response in an issue.

Let me know what do you guys think :)
 Fair trade :D Should be good to go üëç   As per title. Nimble introduces version 7.0.0 with new Predicate API. Additionally, thanks to this update, we've got a little nicer error messages üêº 

from:
> Assertions: expected to match, got <imageMapping(Status Code: 200, Data Length: 0)>

to:
> Assertions: expected to <jsonMapping(Status Code: 200, Data Length: 0)>, got <imageMapping(Status Code: 200, Data Length: 0)>

(also I've updated the Cartfile to match Nimble 7.0.0) (Don't worry about this SwiftLint warnings: I've got a next PR lined up, with all fixes. Just need to do some gardening before :D)  Hey @longshihua, this is a good one. Testing is our top priority, so we should've better documentation around that. We are working on it, but in the meantime... 

If we are talking about testing with `sampleData` in unit tests, [you can see it in our tests how we do it here](https://github.com/Moya/Moya/blob/master/Tests/MoyaProviderSpec.swift#L15). Basically we use `stubbingClosure` and check the data from the response. If we are talking about testing without using any stubbing option built in in Moya, we have these as well. For that purpose we use [OHHTTPStubs](https://github.com/AliSoftware/OHHTTPStubs), you can see how we do it [here](https://github.com/Moya/Moya/blob/master/Tests/MoyaProviderSpec.swift#L711).

Hope it helps!  This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  It would be really cool if we could create a Playground / Playground Book to guide new users through the library. Doing this via Playgrounds allows us to easily guide the user along the process with live examples and inline comments.

Is this something people would like to see? Good idea. I really like the way RxSwift did its [Rx.playground](https://github.com/ReactiveX/RxSwift/tree/master/Rx.playground). We could use our documentation & examples to create some chapters (initial idea): Setup -> Basic usage -> Closures -> Stubbing -> Tests -> Plugins -> Advanced usage.

But then, having in mind we wanted to make a website(#1079), having also docs with examples, we would have to find a way of maintaining it all, or choose something we actually can maintain ü§î  That'd be awesome, @SD10!

On maintaining everything: yeah, this will definitely be some more work. But as @SD10 brought up, having "compiling documentation" makes it easier to spot errors and fix them.

I am also still not sure about the website, but let me comment about that in its ticket. This looks cool, @SD10! Made two comments in there, other than that I love it. I think there should be a fine line between reusing existing docs and making the walkthrough feel more like a learning process.  As per #1094. This bug should be fixed, I've also added a test case to check correct number of events.  Hey @Re-cover! Thank you so much for filling in an issue.

I'm investigating it and seems like a problem on our end. I have a fix for that already, just need to write some tests. Gonna reference it here once I do the PR.  I've made a PR with the fix, #1095. I'm gonna close this one in favor of this PR. If you'd still have the problem after this PR is merged, please reopen this issue. Thanks again!  In this PR:

1. Add .git suffixes. Rationale: [Stencil#84](https://github.com/kylef/Stencil/pull/84) and [Stencil#101](https://github.com/kylef/Stencil/issues/101). Basically really similar situation in our case. `ReactiveSwift` has `Result` as a dependency with `.git` suffix in `Package.swift`, and we also have `Result` dependency - but without `.git` in `Package.swift`. It might also resolve our problem in [SPM-compat](https://github.com/apple/swift-source-compat-suite/pull/35).
2. Add `Package.pins` to `.gitignore`, as per [SPM docs](https://github.com/apple/swift-package-manager/blob/master/Documentation/Usage.md#automatic-pinning). Nice! Could this also fix #1072 / https://github.com/apple/swift-source-compat-suite/pull/35? Seems like this might have been the issue there.  It _might_, we will have to test it once this is merged.  Should we also add the git suffix to the Readme SPM instructions for Moya itself? Other than that, this LGTM. Oh, right! Thanks, I'm on it.  Done üëç   Hey guys! In this PR:

- [x] Fix error that wouldn‚Äôt build MultiTarget Demo.
- [x] Remove warnings and unnecessary optionals in MultiTarget Demo.

Cheers! üéâ   Hmm, that is a vital PR not only in fixing typos, but finding out that our tests needs linting as well. Gonna do it in the next PR.   Hey @ZHDeveloper. I'm not sure if I understood your question correctly: you want to access request parameters after getting the response? If yes, it should be possible, but not so easy. 

Our `Response` object has a `request` property that contains a `URLRequest` object in it. Now, depending on the parameter encoding, you would have to extract the parameters yourself: get parameters from the `request.url` if the request was using `URLEncoding`, maybe access the `request.httpBody` if it was using `POST` method. 
Below is a snippet how to get to `request` property from firing up the Moya request:

```swift
func downloadZen() {
    provider.request(.zen) { result in
        if case let .success(response) = result {
            let request = response.request // now do some logic with `URLRequest` object
        }
    }
}
```

However, you may try to get your parameters _just before the request_. We have a `requestClosure` that does the mapping from `Endpoint` to `URLRequest` and you can extract them from this place as well. An example of that is in our tests, [here](https://github.com/Moya/Moya/blob/dfa3568fd7727c99feeebb8156a53a915844ee72/Tests/MoyaProviderSpec.swift#L556-L575).

Hope it helps! Let us know if something wasn't clear or you need more help on that matter.  Can you post your code where this error is shown? How did you end up solving the problem?  Hi @longshihua,

you have a few options here. The way I usually do is to create a static function on property that returns a provider to me. I usually do this in a separate `struct` or `class` in way that I can have a separate implementation for tests if necessary.

Something like this:

```swift
struct HTTPServiceProvider {
    static var shared:  RxMoyaProvider<HTTPService> = {
        let endpointClosure = { (target: HTTPService) -> Endpoint<HTTPService> in
            let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
                return defaultEndpoint.adding(newHTTPHeaderFields: ["Accept":"application/json"])
            }
        provider = RxMoyaProvider<HTTPService>(endpointClosure: endpointClosure)
    }()
}
```

But I suppose you can also use your `setupProvider` making it static in the struct above and call it from your view controller. 

A third option would be to have the `setupProvider` as a function in an `extension` of `UIViewController`, but I would not recommend this one as it's the least clear IMHO. On a side note, dealing with header fields will (hopefully) be easier in `9.0.0` (see #1067) :wink: I'm gonna close this issue for now, but if you'll have more questions about this topic, please feel free to reopen it whenever üëç    Thanks again, keep it up!   üòçüôå Btw, our 100th member of Moya organization! üéâüéâüéâ Haha, membership in the best community out there :>  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Thank you, @jawwad! üéâ   Hi, @Deniallugo!

Have you tried using one of the authorization plugins? Maybe that would be easier. You can find the [documentation here](https://github.com/Moya/Moya/blob/master/docs/Authentication.md). @Deniallugo I'm gonna close this. Feel free to reopen if you're still having problems with it.  As per #1078. Name **Community.md** is taken in our root directory so I didn't want to pick the same (the distinction might be key). Right now I've chosen **CommunityProjects.md** but I'm open to suggestions. 

Also I wasn't sure how can we word/point from **Readme.md** to **CommunityProjects.md**, so if you have any suggestions, please also let me know.

I've also added NetClient project from @alexruperez as a first Library üéâ 

Cheers!  I think this is a good first step, we can take improvements (if any) in PRs.

Thanks for the work @sunshinejr!  Do you think we, @Moya/contributors, can create a Vision document? This would help us create some clear goals for the project as well as giving the community and users a better idea of what we expect of this project going forward.

What do you think? And more concrete: what should be in it?

FAQ: 
Separating subspecs into repositories
Model decoding: soon with Apple's APIs
https://github.com/Moya/Moya/issues/1126#issuecomment-312125039 üëç 

We could start with maybe using something we already have. I think the first paragraph of our Readme (till the **Sample Project**) with some changes could be a good start. I think we should prioritize Vision document, as it will be really helpful in reviewing new features/ideas for contributors as well as making sure that idea someone has is a good fit for Moya. 

Pinging you, @ashfurrow, as your contribution here would be invaluable. Could any of you guys start this one and we can go from there in a PR?  Cool cool ‚Äì I've got some time this weekend, I'll see what I can do üëç Hey ‚Äì still haven't gotten around to this. Requires some dedicated thinking time. Will do my best üëç No problem Ash, please take your time. And thanks for letting us know üëç  This totally fell off my radar ‚Äì going to prioritize it this weekend.   Hey @iOSUser110. Is this JSON you provided your response, or do you want to construct a request with these parameters in it? It is really strange, could you give us the specific code for `parameters` that you return, @iOSUser110 ? @iOSUser110 what do you have set on your `parameterEncoding`? This situation described by @mpsnp only makes sense to me if you're using `URLEncoding`. @iOSUser110 I don't think it's advised to use `URLEncoding` for complex data types like this one. If you're able to change it to a `POST` with `JSON` format it would be much better. I'm not sure how I would do a workaround to make it work with `URLEnconding`. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Hey guys! In #1078, @orta made a good point that maybe we should think about a website for Moya. What do you think about it, @Moya/contributors? ü§î 

Personally, I don't have much experience with that, so we would need to have someone taking care of that project.

 What would be the advantage compared to a list in the repo? Or maybe: what would we want to get out of a website apart from just a list of project built with / on top of / extending Moya? Also, as @juliengdt mentioned, I think doing so with Jekyll would be pretty nice, as I think most of us (?) already have some experience with it. I think we don't have to constraint it only to the community around Moya (projects/extensions/etc), but we can also show examples/tutorials/documentation there as well. We could also show how we do open source or how to start contributing. We'd have everything in docs, but website may be an alternative way of presenting the important stuff. But that makes me wonder, can we connect the website with our markdown docs fairly easy? Would it be time-consuming to maintain it?  I've helped out with similar sites like this one: https://github.com/RxSwiftCommunity/rxswiftcommunity.github.io Jekyll is great, Middleman is also great. Whatever people are familiar with sounds good to me.  Great! I think we can start with a skeleton in Jekyll as a first step. Does anyone here want to take a stab at it?  Hey all! Recently there was a PR #1065, where @alexruperez wanted to let the world know his library is compatible with Moya. Personally, I think this is awesome, but unfortunately it was listed against "Community Extensions" in our Readme. There are many awesome projects around Moya, which may or may not be "an extension" (which can also be arbitrary). Can we do something about it, @Moya/contributors? My few propositions:

1. Leave the sections as it is, but accept everything related to Moya.
2. Change the name of the section to some more generic one and accept PRs accordingly. 
3. Make a new doc with everything around Moya (extensions/libraries compatible with Moya/abstractions/projects(?)) and link it from Readme.
4. Maybe use wiki [like Quick does it](https://github.com/Quick/Quick/wiki)?
5. Let's just stay with what we've got, no need for a change.

I think the goal is to make people know that we ‚ù§Ô∏è all the work around Moya and make them feel appreciated in some way or another. The question is how to do it? ü§î Great idea, thanks for some initial thoughts @sunshinejr!

1. Seems OK, but might grow a bit big long term.
2. Seems even better than `1.`, without any downsides.
3. This seems like a great option to me. Easily expandable, and when linking from the Readme, it's also easily accessible.
4. I have a feeling wikis are not often used nor seen. I can't remember the last time I've looked a wiki for anything else than documentation (for reference, I used it when browsing [Freddy](https://github.com/bignerdranch/Freddy/wiki) documentation).
5. I think the other options are all better, so let's change things for the better. üòÉ  Thanks for starting the discussion @sunshinejr üôå 

I vote for 3. I like the idea of 3! üôå  I'm in for 3 Great, seems like another doc is a way to go :) Thank you all for the feedback! Gonna tackle that one later today. Let me know if I can help in any way :) Seems like a good idea! I'm gonna open a new issue for that as well. Closing in favor of #1082.  Fixes #1070.  Mentioned in #1070

Makes Danger `warn` about missing changelog entry instead of `fail` (which causes the build to fail and can be confusing  to new contributors)
  After #762 is ready and merged, we should look at releasing `9.0.0`! üéâüöÄ

- [x] Queues (#762)
- [x] `rx.request` / `reactive.request` (#1140, #1153, #1163)
- [x] Removing deprecated methods/types from 8.0.0  (#1162)
- [x] Check 8.0 -> 9.0 migration with an old project and check if the fix-its work as expected / there is need for a migration guide
 I think it is time to focus more on this release in the near future. There were multiple issues regarding our new introductions in 9.0.0 and Swift 4 is on the horizon. I'd love to have queues changes (#762) in, and if we can, `rx.request` & `reactive.request` from #963 and `sampleData` from #1126 as well. These are quite big breaking changes so I think we could try and wait for that, but we might want to just go without them if it takes too much time. What do you guys think? Yeah, I think we should try to get 9.0.0 out of the door soonish, also to avoid having 10.0.0 being around the corner immediately.

I feel like the queue changes are first priority. `rx.request` and `reactive.request` are not that difficult to implement (I think?). As both are breaking changes, it would be nice to have them both in one release.

I think the `sampleData` is a little less of a priority, and we might want to put that into 10.0.0 if it takes too long. Exactly my point of view as well. Let's just try and finish queues, then pursue `rx.request` & `reactive.request` (which shouldn't be hard to implement, but if it turns out there is something in the way, we might want to skip it as well). If we can get `sampleData` PR in the meantime - great. If not, we may release 9.0.0 anyways. I was thinking of a migration strategy to go from `RxMoyaProvider` to `MoyaProvider.rx` and from `ReactiveSwiftMoyaProvider` to `MoyaProvider.reactive`, but couldn't think of any where we can have a fix-it. Then I thought of something else. What we **can** do, is deprecate `RxMoyaProvider` and `ReactiveSwiftMoyaProvider`'s `init`s and make them private in 10.0.0, therefore having a more user-friendly migration as well as a transition with deprecation. Yeah, that's a good idea, let's do it üëç  I'm thinking of merging `9.0.0-dev` into master after we merge queues & removing deprecations. What do you guys think? @sunshinejr I think that's a good idea. #1126 SampleData still needs some time and I think there are enough changes in 9.0 as is. I recommend we move it to 10.0 to not hold up this release.  Removed sample data from the todo-list and checked availability point since it has been recently merged. ~Only queues left (which probably needs a double-check only)~ and a final check for the entire release.

I also think it might be a good idea to do a beta release before the official one. Seems like quite a lot has changed! üòÑ 

**Edit:** Queues merged! Now we need to merge changes from master & 9.0.0-dev. I will try to do it on the weekend! Update! üéâ 
 
I've managed to merge changes from master & 9.0.0. I Must say it wasn't _that_ easy, but I think I've got everything in the end. I'm gonna make a PR in a sec, because it would be awesome to double check we got everything. Especially reactive providers with tests, since we had 2 PRs side by side, with one being in master and second one in 9.0.0-dev, so I had to merge them manually.

Also, I think that we should do alpha release instead of beta first. Why? There is this PR #1147, it progressed really fast from zero to almost ready state. I'm not sure if we can squeeze this one in 9.0.0, we gotta think about it for sure, but making an alpha release gives us more flexibility. +1 on the alpha.  We can also think about adding Swift 4.0 support. From what I've seen we just need to change `NetworkLoggerPlugin` init, because it uses `fileprivate` method as a default parameter, thus Swift 4 compiler complains. Simple fix would be to use optional `output` parameter with `nil` as a default argument and in case `nil` is passed, use `NetworkLoggerPlugin.reversedPrint`. This way compiler shouldn't complain anymore üòÑ 

This might be a good idea just after an alpha merge since we probably don't want to mess with that PR anymore üòÑ  Seems like a great idea, especially when it would be that simple. No reason to make it another major version bump just for Swift 4.  Okay everyone, alpha is merged. I'm gonna do a release in a bit üéâ  Thanks for all the hard work you've been putting into this, @sunshinejr! üí™ 9.0.0-alpha released! Thanks to everyone involved üí™üí™üí™

We can try to focus on the next release now üòÑ Apart from bugs/patches we'd need to do, we could:
- Update `NetworkLoggerPlugin` to make Moya compatible with Swift 4.0
- If we update our codebase to support Swift 4.0, we shoud update our CI setup to build both 3.X version and 4.0.
- Add #1147 (+ documentation/tests).
- Update AccessTokenPlugin to accept `Basic` or `Bearer`. This should be covered by @yar1vn from #1172.

What do you think guys? Something to add, something to remove?  @sunshinejr When referring to the next release, are you talking about `9.0.0-beta` or `10.0.0`? Oh, I mean in 9.0.0 context - beta.1/alpha.2, depends how we feel about what we can still add to the pile. On availability / fix-its: check https://github.com/Moya/Moya/pull/890. Example: https://github.com/Moya/Moya/issues/888#issuecomment-270004469 We are closing in for the next release! üéâ  I think the last PR that is needed (from the code perspective) is #1241. We've come really far with this one! 

The only question I'm having is whether we should release `alpha.2` or `beta.1`? Do we have more breaking changes that we want to include in this release? ü§î  @sunshinejr Thanks for taking care of those unit tests üí™ I think we should go with `beta.1`. I don't have any more breaking changes personally and I don't think we should hold up the release for much longer. There's been more issues regarding Swift 4 recently and people looking to use some of the changes made in `9.0.0`. That's what I was thinking as well! We need to speed up with the process a little bit, we can add more breaking changes in the 10.0 from now on. Thanks for the input, @SD10!

So, we've got tests merged in (we've got a lot of improvement lately thanks to @phimage), I'm gonna release `beta.1` in a while! üéâ  Beta 1 released! Thanks to everyone that played even a small part in it! üéâ üéâ üéâ 

Now it's time to make sure it is all working well before final release. üòÑ  Thanks for all the effort, everyone - and @sunshinejr in particular. üôå Thank you for all your hard-work @sunshinejr @BasThomas üç∫ üéâ  Thank you all to review my PR and for the hard-work

> to make sure it is all working well

To achieve this I make a new PR about multipart part upload ;)  Can you post an example of your use case? I think - but I can't find it right now - we are using `NSError`s on purpose. Maybe someone of the @Moya/contributors knows or can point to a discussion on that?

If we do indeed want to end up changing this, It'd be awesome if we can take this with us in the `9.0.0` release. I think I was implementing this one and I'm also positive there was a reason for `NSError`, but I don't remember right now and I don't see any downsides as well. Thus I think we can try changing it to just an implementation of `Error` type. At least we can do a PR and see what happens. Especially with 9.0.0 version that is in the making. Do you want to take a stab at that, @Zeeker?  Possibly related: https://github.com/Moya/Moya/issues/437#issuecomment-198780649 and https://github.com/Moya/Moya/issues/478 Oh right, I was talking about this one for sure! Thanks, @pedrovereza. 

However, I was mistaken, this is a different error here. The problem was with underlying error in request/response, here is a problem with sample response. However, it is kinda similar problem, because normally this should be an underlying `NSError` (a network error)... 

Now that I think about it, maybe we can go with `MoyaError` here? Moya has an `.underlying` error already, which takes an `NSError` if needed. Although how would we go about custom errors? ü§î This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  yup, that would be awesome! Do you want try to make a pull request against apple's repository?  Thanks for looking into this, @aksswami! üòÄ  This has been merged on Apple's side. @aksswami, thank you so much for picking this up! @BasThomas so it was, in fact, this `.git` suffix bug? Maybe we should let the world know somehow, this was found by an accident ü§î  I think so? Maybe better to ask over at https://github.com/apple/swift-source-compat-suite/pull/35; @lplarson fixed it (by updating just the hash as far as I understand, so I think the `.git` suffix did the trick. Huh, now where should we raise an issue, on SPM or SPM-compat? ü§î  Good question. I'd just start from the Compat PR, and go from there? Or going straight to the mailing list is also an option. Right, gonna just comment on the PR what was wrong in our project then. :+1:  I recently saw @KrauseFx's talk on scaling open source communities (great talk, I'd recommend it to everyone who's doing anything at all in open source). https://news.realm.io/news/tryswift-felix-krause-scaling-open-source-communities-github-management

One of my big take aways was fastlane's fastlane-bot. Which would automatically follow up with issues and close them if there was no response.
Right now, a couple of contributors have been manually doing that, but I think it would be awesome if we could add some of fastlane-bot's functionality to our bot so we don't have to politely close stale issues

Any thoughts from other contributors? Does anyone want to take a shot at implementing that for MoyaBot? I really like this - though looking at fastlane-bot's [repository](https://github.com/fastlane/issue-bot), I have no idea how it would work implementing it. Does anybody have an idea, or should we go ahead and file an issue there? We can wait for [Peril](https://github.com/danger/peril) from @orta. It looks really promising. It is not fully stable yet, but it can already post on issues AFAIK. Peril does look really nice, let's wait for that to be usable Just came across this: https://github.com/probot/stale ü§î  This one is really cool! I think we can try to do it. What do you think, @Moya/contributors?

**Edit:** Also, can we do it using MoyaBot? Sure, this would be really nice! Re: MoyaBot: I think you should ping @ashfurrow to ask if that's possible. :) Ye, and this one is looking cool. The question is if we want/can use MoyaBot for that. Also, we would need someone to do a PR with config. Let's just start with something and we will adjust values in a PR if needed. üòÜ
I'm happy this is happening! I was talking with Ash and we've figured that MoyaBot would need a write access so it would be better to use different bot or someone else's access token. Thus, it might be better just to install this stale bot and go from that. I'm gonna do a PR with some default values for config so we can discuss it there üëç  Awesome! üëä I've opened a PR#1101 with the config, please let me know what do you guys think!

What we need to get this bot running:
- [x] #1101 merged.
- [x] Re-visit issues that might have need a label to not flag it.
- [x] Install the bot & iterate with the feedback.

Is there something I didn't think about? ü§î  That sounds good to me. Thanks for figuring this out!!

On to-do 2, let's wait to add labels until we've iterated on the bot, just
in case we end up not liking it
On Thu, May 25, 2017 at 8:21 AM ≈Åukasz Mr√≥z <notifications@github.com>
wrote:

> I've opened a PR#1101 with the config, please let me know what do you guys
> think!
>
> What we need to get this bot running:
>
>    - #1101 <https://github.com/Moya/Moya/pull/1101> merged.
>    - Re-visit issues that might have need a label to not flag it.
>    - Install the bot & iterate with the feedback.
>
> Is there something I didn't think about? ü§î
>
> ‚Äî
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/1071#issuecomment-304037990>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dFodJSG0iR_dKP_AKOVN3RAbcAP6ks5r9Zx2gaJpZM4NQHMU>
> .
>
 I've revisited some issues anyways - I've flagged most of documentation ones to leave it as it is, because it is important that we have these open and add it in the future. If you guys want to make last review, I'm gonna try to launch the bot tomorrow morning or so. @sunshinejr thanks for taking the time! ‚ù§Ô∏è  Bot added - let see how it goes :D Wanted to make a quick summary after a month, but seems like our bot is stuck? Maybe wrong configuration? Anyone sees something strange [here](https://github.com/Moya/Moya/blob/master/.github/stale.yml)? Because in issue like #1056, label was added 28 days ago, which means 14 days ago it should be closed, but it is still open ü§î  @sunshinejr The configuration looks correct to me. Do you think its a permission issue considering it can comment on issues but not close them? 

The link in the `closeComment` looks like it causes a different syntax coloring -- could this be an issue?

EDIT: I created #1157 in case üëç nice catch, @SD10. Can you take care of that issue and see if this PR helped? Because from the permission side it looks like it has everything it needs:
<img width="781" alt="zrzut ekranu 2017-07-03 o 22 23 23" src="https://user-images.githubusercontent.com/5232779/27806997-41992dac-603e-11e7-8be5-e9e05e303948.png">
 @sunshinejr Thanks for checking the permissions. This change is already merged in. It may take some time to determine if this changes anything. There's little and no official documentation on _when_ probot will scan the issues. Some info [here](https://github.com/probot/stale/pull/41) if anyone is interested.

I'll continue watching this until it's resolved. Great, thank you Steven! üçª  I think the problem is with our label having spaces. 
The method used to grab stale issues at probot/stale doesn't wrap the label in quotes when performing the search query to find closable issues. I created a [PR](https://github.com/probot/stale/pull/44) at stale to fix this (if it is the problem üòÖ). @SD10 That's exactly what I was testing https://github.com/pedrovereza/stale-bot-test/issues/2 üòÑ @pedrovereza You read my mind! I was going to ask you to please test this there üëç  @pedrovereza What do you think about changing our label to one without spaces? The support at stale looks limited. I don't think they'll be merging that PR anytime soon. @SD10 I'm ok waiting a bit longer for them to take a look at the PR. But if we decide to change the label, we need to revisit [all the ones currently marked by the bot](https://github.com/Moya/Moya/issues?q=is%3Aissue+is%3Aopen+label%3A%22no+recent+activity%22).

@sunshinejr @AndrewSB @BasThomas thoughts? üòÑ  This should be as easy as changing the name of one label & updating the StaleBot config, correct? If so, and if its gonna fix the bot, I am up for the change üëç I also don't mind waiting few days before we make a change, but seeing from the Issues/PRs it might be quite some time before they merge it. @sunshinejr We would probably have to resolve all the current issues manually. 

Updating a label is an action that will update the last modified date of an issue. Issues that are currently marked as `no recent activity` won't get marked with the new label until 45 days after they were marked with the first label üòê

It would work immediately for all issues not already marked. But if we rename the label to something without spaces, then the update date shouldn't change (since it is the same label object but a different name) and if we change name of the label in the config, the bot should catch that one as well, right? 

For instance, we could change label name to `no-recent-activity` or `no_recent_activity` in both Issues & bot config (until they fix the issue). Or am I missing something obvious here? üòÑ  The API has an "[updated_at](https://developer.github.com/v3/issues/#list-issues-for-a-repository)" for issues. This *might* (?) be updated when a label changes? I'm not sure. We can try changing the label name and bot config, worst case we'll have to close them manually (which was the original plan anyway) üòÑ  Well, we can (probably) make sure it will work! üòÑ 

I've just tested it on my [test repo](https://github.com/sunshinejr/IssuesTest). My steps to reproduce:
1. Create a new label with space, `"new label"`
2. Create an issue with this label.
3. Check `updated_at` field (since from [here](https://github.com/probot/stale/blob/master/lib/stale.js#L41) I understand that it queries based on `updated_at` field). Date: `2017-07-10T15:05:36Z`
4. Rename the label to a label without space, `"new_label"`.
5. Check `updated_at` field again. Date: `2017-07-10T15:05:36Z`, which is the same as before.

_(Note: I was using this [request](https://api.github.com/repos/sunshinejr/issuesTest/issues) to test it.)_

So if the data is correct and I didn't miss anything, whenever we change the label, the `update_at` field of the issue is not updated. Therefore, we can assume we won't need to take care of all the issues above. 

That was fun! üòÑ  I actually think it does the query using the `updated` search qualifier:
i.e) `is:issue is:open updated:>2017-07-10`

I think that PR should've taken effect immediately, so I'm thinking there's a stateful issue.
Regardless, I think that was the right step so let's see how the next marked issue is handled. It looks like probot has stopped slacking off üòÖ. 
I don't know if we want to keep this issue open to discuss the merit of this automation tool or close it now that the bot has completed a full cycle. I'm up for closing this issue now that the bot is finally working :tada:

We originally wanted @MoyaBot to do the job, but I don't think the effort to deploy our own bot is worth it.

@MoyaBot: nothing personal ‚ù§Ô∏è  The issue was created to integrate the bot, and because it is both integrated and working now, there is a reason to close it üòÑ We can create another issue for things related to this bot if something pops up.  

Thanks everyone for feedback & help! üéâ  I saw that over at Fastlane, there's actually another step locking an issue some time after an issue has been closed. Would it be possible to add this as well? And then maybe add another comment before locking that asks to create a new issue? Is that also using probot/stale, @BasThomas? I think we had this conversation here at #1101 and it wasn't possible, but using another plugin could work (though I don't know if we can do it without deploying it). Ah. No, it uses their Fastlanebot. Let's hold off on this for now then; not that important   Hey @zhaoyunyi. Is it still happening? If yes, please provide more code to us. Most valuable would be your `endpointClosure`, `requestClosure`, `plugins` and `.customAlamofireManager()`. Or if you have time, it would be awesome to have a test demo project that this behavior occurs at. I can't say what's wrong without more context, sorry. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Implements #1046 (and #1058).

How to add header fields to a request is a question that shows up in issues every once in a while (e.g. #510, #1003, #208). The answers always mention a custom `endpointClosure` to add the fields to the header request. In fact, [this is suggested in the docs as well](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint).

However, having the header fields specified in the `TargetType` makes the whole process easier (and more obvious). Which raises a couple of questions: 

1. Is there any reason for us not to specify header information inside `TargetType`?
2. Is the usage of headers not as common as I think it is and it's better to leave the `endpointClosure` as the official way? Assuming most people don't need to specify headers at all, adding it to `TargetType` just forces an implementation of headers that would return `nil`. 

If we decide to go forward with the change, we still need to:

- [x] Update Changelog
- [x] Update documentation @Moya/contributors Let me know what you think :wink: Loving it, seeing as I've implemented this like, 8x in different projects. Should we add a default of `nil` to the `TargetType`? I think that would make sense, given that most requests currently don't implement this. @justinmakaila Yea, having it defaulting to `nil` makes sense to me. I actually tried that at first, but was having some trouble overriding the value in the tests. Probably missed something, will give it another try üòÑ  ü§î, I remember that we actually didn't want to implemented / default this ourselves. @BasThomas I'd be interested in re-hashing that discussion here; I've had to implement this myself a handful of times and it's particularly annoying. I think it's save to say that MOST private APIs will require some sort of authentication and it seems a little ridiculous to have the `Endpoint` initializer be considerate of state, given that most of the state is already incorporated in `TargetType`. @justinmakaila I think @BasThomas was talking about whether or not we should default `headers` to `nil` üòÑ 

@BasThomas I think the discussion happened in #861 @pedrovereza @BasThomas Ahh, sorry, I misunderstood. I remember the no defaults conversation... I mean, I guess this will get wrapped up in 9.0, so breaking changes are legit... I just got excited and wanted to start using it immediately :) @pedrovereza: love this change, I've also overrode the endpointClosure multiple times for HTTP auth stuff. so I think adding it is a great change

I am against providing a default implementation though, I think it's important forcing consumers of Moya to implement every part of the protocol. Not doing so obfuscates the simplicity of creating a provider (being confused on how to get started with headers, for example).

Even if one isn't planning to use headers (or sampleData, as was mentioned in #861), I think a consumer should still have to explicitly decide what should be returned from them Great, so I think we all agree having no default is better üôå  üëçüèª
On Fri, Apr 28, 2017 at 21:19 Pedro Vereza <notifications@github.com> wrote:

> Great, so I think we all agree having no default is better üôå
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1067#issuecomment-298138033>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ABkCVIW-_GgCRLoLceRrh4B-fEcSnJwmks5r0pAQgaJpZM4NJexz>
> .
>
 why has danger been failing so often on PRs? @AndrewSB We configured it to [fail on missing changelog entries](https://github.com/Moya/Moya/blob/master/Dangerfile#L18) @pedroverrza: can we set danger to have a more descriptive failure?
Or add it as a separate integration, not through circle ci? So danger &
tests can run and be seen independent of one another?
On Sat, Apr 29, 2017 at 4:31 AM Bas Broek <notifications@github.com> wrote:

> *@BasThomas* commented on this pull request.
>
> We should update the docs as well.
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1067#pullrequestreview-35494761>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dJZf14ZqxPgLMFnbbSxk7Cd6OiPPks5r0x-DgaJpZM4NJexz>
> .
>
 It's possible to run Danger on a separate CI, but Danger also posts a comment using the @MoyaBot with a description of what went wrong (it updates that comment on subsequent runs). Customizing the error message is totally doable, let me know if I can help.  I think I made all the updates needed in the docs. Can someone double check? :wink:  Hey @ivanmkc. I've just tested a similar case, using `RxMoyaProvider`, upload task and `endpointClosure` without any conditional statements, and seems like every time Moya is adding correct parameters. By the code there is also no difference whether you are using `upload` or `request` task, our `request` method will just get the endpoint from `endpointClosure` if there is any. 

I'm gonna close this issue for now, however, if you are certain that this issue exist, please create an example project that I can test against, and reopen the issue.   Just my own opinion: I don't think it's an `extensions` for Moya, it's just a library `Compatible with Moya`. I don't think it's a right place for it. But good work anyway. What does NetClient do? I took a look at the README, but I had trouble seeing why I'd use it over just Alamofire or just Moya. Maybe a section saying "Why would someone use this over just Alamofire"

It seems like a nice piece of work though üëç  I also think this is not an extension to Moya, so unfortunately I'm gonna close this PR. 

However, it doesn't mean we can't include your library in our Readme. Maybe we need to rethink how we promote libraries/extension that work with Moya? For now we have only extensions, how about libraries, projects, abstractions? For instance, [Quick uses wiki](https://github.com/Quick/Quick/wiki), and other libraries may have some ideas for this kind of promoting.

I'm gonna open an issue for that, we'd love it if you could help us with that matter, @alexruperez. Thanks again for the nice work!   Hey, I think what you need was added in #993. The change is targeted to be released in version 9.0 :wink:  @iOSUser110 We still don't have an estimate for when 9.0 will be released, as we're still including some breaking changes to it.

What you can do is use a fork of the Moya repo with a branch pointing to a3f0c526ddaf9c10b8044e5121f6272e06e31c27. You can then update your dependency to use your fork and branch:

Cocoapods:

```ruby
pod 'Moya', :git => 'https://github.com/iOSUser110/Moya.git', :branch => '<your branch>'
```

Carthage:

```ruby
github "iOSUser110/Moya" "<your branch>"
```

Please don't point directly to our `9.0.0-dev` as this branch is under active development and is being constantly rebased (which will change commit hashes and may be not be always stable) @iOSUser110 First you need to fork Moya repo and fetch it locally. Then run these commands inside your fork of Moya:

```
git checkout -b temp a3f0c52
git push origin temp
```

The name of the your branch in this case is `temp`, feel free to name it as you like  @konnorbeard: which error? Did you forget to paste in the message? @konnorbeard Could you try using 7.0.4 and see if the issue still happens? ü§î  @konnorbeard Hm, that's weird. I know you mentioned you're on Swift 2.3, but can you confirm that 7.0.1 won't work as well because it's targeted as 2.2? @konnorbeard Did you find a fix for this? I'm gonna close this issue due inactivity, feel free to reopen with new info. No problem @konnorbeard! Thank you for taking your time to explain what was wrong. It can help someone in the future :)  Hi @geraldeersteling, sorry for the late response. Moya depends on Alamofire in terms of pinning, more on the matter you can see [here](https://github.com/Alamofire/Alamofire/blob/master/README.md#security). After the manager setup you have to assign correct `SessionManager` to the `MoyaProvider` initializer.

Apart from that we have some methods you might be interested in, in [Plugin type](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugin.swift#L15). If there is nothing you are interested of, maybe you have an idea how to add it to Moya? If yes, please let us know, maybe we can work something out.

Cheers! Wow, thank you for detailed explanation, @geraldeersteling. Glad you figured it out. Good job! üí™  Hey @gmoalvarez. That is a really interesting question. What you can do is to make also one wrapper-class around all the tasks in the pipeline before parsing response. In your case it would be:

```swift
func request(target: Target) {
    return provider
        .request(target)
        .take(1)
        .filterSuccessfulStatusCodes()
        .retry(2)
}
```

and then create multiple classes that do the request & mapping like your `MyClient` class does. It would be then useful in case you want to expand your preparation to request, or tearDown after. E.g. you can see how we can use a quite powerful wrapper with token extractor [here](https://github.com/Moya/Moya/blob/master/docs/Examples/SubclassingProvider.md).

Hope it helps!  I'm declaring a `TargetType` extension. I'm providing parameters for all the items in the enum, but for one of the items, I need the parameters to be return as an array, not a dictionary.

This might explain better:
````swift
var parameters: [String: Any]? {
    switch self {
    case .doSomething(let ArrayOfStrings):
        return ArrayOfStrings
    }
}
````

I'm using `JSONEncoding` and I need to be able to return an array. @gmoalvarez No, I need to return an array, but the variable will only let me return a dictionary object. For example, look at the input that the GitHub API needs: https://developer.github.com/v3/issues/labels/#add-labels-to-an-issue But those are not parameters, right? That's just the URL. @BasThomas Well, if I use `JSONEncoding` for ParameterEncoding, wouldn't the parameters be sent as JSON? Maybe, I'm incorrect. @gmoalvarez Awesome, but just to make sure, if I'm just using dictionary objects rather than an array, can I use JSONEncoding? I think you can use `JSONEncoding` for your parameters in that case, yep!  @jayesh15111988 Yes, let's continue the discussion in #1046 :wink:  Hey @Blackjacx. `NetworkLoggerPlugin` uses `request.debugDescription()` to print the given request. This function is using headers from `request.allHTTPHeaderFields`, but also configuration headers from current Alamofire session. To get them as well, just use the line below:
```swift
let configurationHeaders = provider.manager.session.configuration.httpAdditionalHeaders
let additionalHeaders = response.request?.allHTTPHeaderFields
```

Hope it helps! Yeah, that seems correct. I think we can improve that one. Would you be up for making a PR? :) This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  @GTMYang: In our implementation, `[String: Any]?` is equivalent to a json array. What type did you want to pass in instead? This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Let's get the linting issues fixed, and maybe write some tests. 

Then we can merge this into `optional-response-thread-param`, and continue the discussion on which queue/scheduler primitive to use in #762 Cool, it would be awesome to get those RxSwift tests then! Maybe someone else can add them for ReactiveSwift later.

Things pending before we merge to `optional-response-thread-param`
- [x] write tests for RxSwift
- [x] fix the overriding initializer and change the `MoyaProvider` initializer to take a queue as well So I'm trying to understand... this is the queue that will be used by Alamofire for callbacks as a hook back into Moya, whereas the remaining Scheduler property is in place for delivery of whatever reactive abstraction you use? That's correct @justinmakaila. So then if you're using the vanilla `MoyaProvider`, you pass a thread. But if you're using an `RxMoyaProvider`, you'd pass in the Rx abstraction of a thread - a scheduler, and we want to implement whatever the equivalent is for ReactiveSwift as well.

For rationale and example usage, check out #762 Let's re-examine that assumption: that you can't get a queue from a scheduler.
Schedulers internally use DispatchQueues to do their work ([here's](https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Schedulers/MainScheduler.swift#L23) how the MainScheduler uses a queue).

Let's make an issue on RxSwift's repo asking if theres any way to grab it, since right now, it is private Yeah I agree. The queue passed to Alamofire doesn't necessarily have to be the same one as our Reactive `Scheduler`, all that really matters is that we provide this init option so people can move their request building/handling off of the main queue and into a dedicated background queue (if desired). @haritowa: yeah, CI failed because there's no changelog for this. We're working on making that more clear to contributors.

For now, can you just add an entry to the changelog, and then we can see how the tests do? I got really busy with work, sorry about that @haritowa!  I'm wondering whether the parameter name `queue` isn't too vague and if e.g. `callbackQueue` wouldn't help with recognizing for what exactly is this queue used. Thoughts?  Cool! What do you guys think @AndrewSB, @justinmakaila? Yes, I think `callbackQueue` is a better name. It takes away any ambiguity.

@haritowa, do you think we can improve the `queue` parameter in the `request` method as well? What do you think is a better option? The CI failure is legit, seems like `RxSwiftMoyaProviderTests`needs a second review üòÑ  that was broken by me -- I'll fix it now. Sorry!

I prefer callbackQueue too Seems like @AndrewSB fixed the build! Now the only things to do before the merge: 
- Fix the **Chanelog.md** conflicts (basically add the new line to **Next** column instead of **8.0.4**, because **8.0.4** was released)
- Change the name of `queue` to `callbackQueue` (wherever we can)

Does that seem right? üòÑ yup, that does! Then we can figure out docs and usage instructions in #762  @haritowa Are these two points, that I wrote above, something you have time to do in the near future? If not, I might try to help :) @sunshinejr @AndrewSB @haritowa I fixed the conflict in the changelog (used Github web interface to do it, that's why the commit message is bad üòï )

Does it make sense to merge this PR into `optional-response-thread-param` and take the `queue` renaming (and docs) in #762? ü§î  I think so üëç Probably in another PR tho, that would point to `optional-response-thread-param`. But I'm in. Yeah, lets merge this into `optional-response-thread-param`, and then do another PR also targeted to `optional-response-thread-param` that handles the renaming and docs üëå  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Hey @balancin, this looks like more of an [`Argo`](https://github.com/thoughtbot/Argo) question, asking the people over at [`Moya-Argo`](https://github.com/wattson12/Moya-Argo) may also yield good results.
Sorry I can't be more helpful! I haven't used Argo for a while üòï  Fixes #1049 

When a `TargetType`'s `path` is empty, `URL.appendingPathComponent` may introduce trailing `/`, which may not be wanted.

From the [docs](https://developer.apple.com/reference/foundation/url/1780239-appendingpathcomponent): 
> This function performs a file system operation to determine if the path component is a directory. If so, it will append a trailing /. If you know in advance that the path component is a directory or not, then use func appendingPathComponent(_:isDirectory:).

Using `appendingPathComponent(_:isDirectory:)` doesn't seem to solve the problem (note `somepath/?`)

```swift
import Foundation

let urlString = "https://google.com/123/somepath?X-ABC-Asd=123"
let url = URL(string: urlString)!

url.absoluteString //"https://google.com/123/somepath?X-ABC-Asd=123"
url.appendingPathComponent("").absoluteString //"https://google.com/123/somepath/?X-ABC-Asd=123"
url.appendingPathComponent("", isDirectory: false).absoluteString //"https://google.com/123/somepath/?X-ABC-Asd=123"
```

I think that having an empty `path` is not usual, but as seen in #1049 it may be necessary. These changes shouldn't cause side effects for non-empty `path`s. awesome job @pedrovereza üòÑ  Wouldn't this be a breaking change? @BasThomas Feels like a bug fix to me. I think the expectation when `path` is empty is that the `baseURL` will be used unchanged (which was not happening).

Do you feel it's a breaking change? If so, why? Yes, it's a bugfix, but the "buggy" behavior may be (?) expected. And if that would be the case, this would change that expectation. I see, you're saying that someone may be relying on this buggy behavior for something. But I'd say there are probably workarounds to avoid the issue ü§î 

I'd still not call it a breaking change as the API contract has not changed, and the current behavior seems odd and probably is not expected.

@AndrewSB @sunshinejr thoughts on that? I'd say not breaking. It's a bug fix

On Mon, Apr 17, 2017 at 7:31 AM Pedro Vereza <notifications@github.com>
wrote:

> I see, you're saying that someone may be relying on this buggy behavior
> for something. But I'd say there are probably workarounds to avoid the
> issue ü§î
>
> I'd still not call it a breaking change as the API contract has not
> changed, and the current behavior seems odd and probably is not expected.
>
> @AndrewSB <https://github.com/AndrewSB> @sunshinejr
> <https://github.com/sunshinejr> thoughts on that?
>
> ‚Äî
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1053#issuecomment-294496325>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dBfs_efXVlVvG6cW74L0tqBCyUOGks5rw3eugaJpZM4M-fqL>
> .
>
 Sure, let's treat this as a bugfix then. üòÉ  I'm trying to create an `TargetType` extension, but I keep getting an error: `Use of undeclared type 'foo'`

````swift
extension GitHub: TargetType {
}
```` I forgot about declaring the enum.  Can you run it on a simulator? If you can, can you check if other projects run on your iPhone? @myafer: line 19 that's highlighted in your project doesn't show up in our Repo (`NetworkTarget` doesn't exist, [here's](https://github.com/Moya/Moya/blob/8.0.3/Demo/Demo/ViewController.swift#L15) that file on our repo). Maybe you added that line by mistake?

I'd recommend
1. deleting derived data
2. deleting the Moya/ directory and recloning from GitHub Since there is no activity in that matter, I'm gonna close this issue. Feel free to reopen if this error occurs again.  It's possible in theory. We'd need to implement what people talked about in #556: basically abstract out the network engine to not just use Alamofire

We'd be open to a PR that does this, and theres a chance some other contributors might be interested in helping out üòÑ   Hey @k8mil, can you check if it works as expected when you change your `baseURL` to be just https://google.com and `path` to return `/123/somepath?X-ABC-Asd=123`? Hey @k8mil thanks for the detailed explanation and examples üëç 

I think I have a fix in #1053, care to take a look? üòâ  Very interesting use case. Thanks for implementing this @pedrovereza üòÑ   Hey @haritowa: I'm not sure I totally understand your question, but it sounds like youre looking for something similar to #1032. If that's the case, we have #762, and we'd love your help üòÑ  That all sounds good to me @haritowa: it makes sense to be able to do that on a `provider`-basis and `request`-basis üòÑ 

You're right, we need to add this to both RxMoya & ReactiveMoya.

Scheduler is an Rx concept, its just an abstraction on queues and (for all intents and purposes here) can be thought as equivalent to queues.


I'd be more than happy to review a PR üëç this is something I've wanted for a while too No worries @haritowa - take your time. üòÉ   Hey @douglastaquary thanks for sharing your solution, this may be useful for others as well!

Cheers from Brazil üòâ   @EvilNOP Thanks for raising the idea üôå  I've created #1067 with an initial implementation for `headers` inside `TargetType`. Feel free to review it and let us know what you think üòâ   Implemented in #1067  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Nice! That was easy. Can you add this to the Changelog as well?

By the way, thanks for the really clear description. Greatly appreciated! :) ü§î, you should change the initializer as well, I think. Why are we targeting this at `9.0.0`, actually? Is this breaking in any way? @AndrewSB @juliengdt Well, it seems like it *is* a breaking change (see failed tests). Could you update them as well, @juliengdt? It technically is breaking though, is it not? The `Response` class is not private and can be instantiated by the user (just like we did in the tests). Yep, as @BasThomas said, it is a breaking change, thus making it obvious in Changelog would be awesome :) Agreed on tagging this as a breaking change

@juliengdt Good job and thanks for the contribution! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  This attempts to fix #1039 

Let's see if CI passes on this commit Getting different errors! This looks like progress.

It seems as if Swift 3.1 the _non breaking_ update, broke our tests. Right now, I can see that our `NetworkLoggerPlugin.init` calls in our tests are broken.

<img width="1403" alt="screen shot 2017-04-03 at 5 59 59 pm" src="https://cloud.githubusercontent.com/assets/3814772/24637615/618865fe-1897-11e7-8dfa-54ec6824ed03.png">

The compiler error looks like it's related to the `output` param in the initializer.

```swift
public init(verbose: Bool = false, cURL: Bool = false, output: @escaping (_ separator: String, _ terminator: String, _ items: Any...) -> Void = NetworkLoggerPlugin.reversedPrint, responseDataFormatter: ((Data) -> (Data))? = nil) {
        self.cURL = cURL
        self.isVerbose = verbose
        self.output = output
        self.responseDataFormatter = responseDataFormatter
}
```

The definition says its expecting `output: @escaping (_ separator: String, _ terminator: String, _ items: Any...) -> Void`, but our initializer is just taking one param (`printing` in the screenshot), from the closure, and incorrectly not handling the other ones.

Does anyone who's more familiar with the `NetworkLoggerPlugin` or these tests know why that may be?

Feel free to take a shot at adding a commit onto this branch if you know how to fix the tests üòÑ
Make sure you're running Xcode 8.3! @AndrewSB Good job! I almost got it right in https://github.com/Moya/Moya/commit/eefcf600139ed8fb787d5c936c0277fc024902ad, but only updated the dependencies I thought were causing the issue üòÑ 

And I'd say we can skip the unused arguments in the closure. Actually, I was hopping that `_, _, printing` would do the trick, but [it didn't](https://circleci.com/gh/Moya/Moya/1338) and I'm not sure why ü§î  That was a good move @pedrovereza

Yeah, I thought that was really strange too- why weren't we `_, _`ing those params previously?

I just don't know much about that piece of the codebase, so I was hoping another contributor could jump in and enlighten us üòõ @AndrewSB Ok, so it seems like `printing` actually groups all arguments

![image](https://cloud.githubusercontent.com/assets/1916041/24640599/8abbe40a-18ce-11e7-8c6e-daa2e470f9ac.png)

In fact, the `Any...` argument is accessed as `printing.2` in the test. I didn't know it was possible and (in the very quick search I did) could not find references about this feature.

Doesn't fix the problem but at least we know why it worked üòÑ 
 Maybe a stupid question, but how do I run the tests from Xcode now? Can't seem to do so from the Demo project, and opening the framework's `xcodeproj` complains of `Alamofire` missing (which makes sense, right?) Also, though this should probably be tackled in another PR, updating the dependencies causes a bunch of warnings in the Demo project. Pedro: what scares me is that previously we just had `printing`, and from what I can infer from the contents of the test, it looks like it was an array, not a tuple (with three elements).
I'll do a git blame and figure out who wrote those tests when I'm back on a computer tonight- to ask the OG author what they think we should do


Bas: command-U when you're on one of the Moya targets should run the tests > and from what I can infer from the contents of the test, it looks like it was an array, not a tuple (with three elements).

I think it was a tuple ü§î 

```swift
 let stringArray: [String] = printing.2.map { $0 as? String }.flatMap { $0 }
```
Isn't `printing.2` returning the third argument (the array of `Any`)?

But you're right, if we can find who wrote the test just to confirm the intention it'd be better üëç  Ohh, I missed that.

If that's how the tests are, then I feel pretty confident with just
continuing as we were
I wonder why the tests regressed with swift 3.1 then ü§î
On Tue, Apr 4, 2017 at 2:14 PM Pedro Vereza <notifications@github.com>
wrote:

> and from what I can infer from the contents of the test, it looks like it
> was an array, not a tuple (with three elements).
>
> I think it was a tuple ü§î
>
>  let stringArray: [String] = printing.2.map { $0 as? String }.flatMap { $0 }
>
> Isn't printing.2 returning the third argument (the array of Any)?
>
> But you're right, if we can find who wrote the test just to confirm the
> intention it'd be better üëç
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1043#issuecomment-291633764>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dPI8DCIbGqSG-7nfLOUE0za4HRi_ks5rsrKLgaJpZM4MyPC7>
> .
>
 @AndrewSB: Ah, but that is then complaining of Alamofire not being there. Which gives me an error, and cancels the tests. @BasThomas what's the complaint? Saw this PR had been sitting here for a bit, so I tried to see if I could help out.

Currently the syntax looks like this:
```swift
plugin = NetworkLoggerPlugin(verbose: true, output: { printing in
  let stringArray: [String] = printing.2.map { $0 as? String }.flatMap { $0 }
  ...
})
```
To reach the same functionality this will work:
```swift 
plugin = NetworkLoggerPlugin(verbose: true, output: { (_, _, printing: Any...) in
  let stringArray: [String] = printing.map { $0 as? String }.flatMap { $0 }
  ...
})
```
Hope this helps! @BenEmdon Awesome! I totally missed the `printing:` part üòÑ 

Do you feel like pushing a commit with this fix on branch `fix-carthage-ci-fail`? üòâ  @pedrovereza sure! üôåüëè great teamwork, thanks for the fix!  ### Resolves the following SwiftLint issues:

<img width="798" alt="screen shot 2017-04-03 at 1 40 47 pm" src="https://cloud.githubusercontent.com/assets/11095731/24622503/43d87522-1873-11e7-9e80-fa3cf0f17b25.png">

Just thought Id clean it up because it's spamming everyone's PRs üòÑ  This change doesn't affect any functionality. Does something still need to be added to the changelog? Nah, I think you're good @BenEmdon. Thank you again! üéâ 

**Also,** sorry @sendyhalim for clicking on you, didn't see that _"reviewers suggestions"_ popup before üòÖ  Fixes link to [`Code of Conduct.md`](https://github.com/Moya/contributors/blob/master/Code%20of%20Conduct.md) by replacing the spaces in url with [url encoded characters](https://www.w3schools.com/tags/ref_urlencode.asp). Hey @BenEmdon! Thanks for the changes! üéâ
These warnings do not have anything to do with this PR so I'm gonna merge this anyways :) Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  This seems like a good idea to me @juliengdt! Do you want to try branching off `9.0.0-dev` and implementing the change? No pressure if you're not comfortable with that üòÑ 

The two potential hurdles I see are
1. We're currently grabbing the `URLResponse` from Alamofire, does Alamofire expose a `HTTPURLResponse` as well?
2. Some small difference b/w URLResponse and HTTPURLResponse that makes the latter unusable for some reason we haven't thought off yet

We can get a couple of reviewers on the PR to validate that its a good idea, and if they agree, we'd be more than happy to merge this in üëç  Seems like Alamofire does give us an `HTTPURLResponse`. üòÉ https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider.swift#L147 üëä
Awesome!
On Tue, Apr 4, 2017 at 2:20 AM JulienGdt <notifications@github.com> wrote:

> I edit the issue + did the PR.
>
> ‚Äî
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/1040#issuecomment-291442898>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dFQDo2gyamQ09CE1zGIYc8nqEmFvks5rsgtagaJpZM4Mxspi>
> .
>
 As it has been implemented, yep!

Thanks again :)  If you initialize your `NetworkLoggerPlugin`, its `cURL` flag is set to `false` by default. Initializing it like `NetworkLoggerPlugin(cURL: true)`, `willSendRequest` should print the `cURL`. Does that help? Cool, thanks @BasThomas I'll close the issue :wink:   I don't think Moya can build on Linux, even the Alamofire can't build yet. https://github.com/Alamofire/Alamofire/issues/1935 Because there is no official network request framework for swift in Linux yet. The swift server-side group still not coding anything yet.  Hey @LarsJK! Thanks for the changes! üéâ 
These warning doesn't have anything to do with this PR so I'm gonna merge this anyways :)  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Nice, thanks @LarsJK!  Hey @Blackjacx, awesome to see that you're thinking about doing some local validation before hitting the network üëå

I've used www.GitHub.com/Ben-G/Validated in the past to great effect. Basically I create a `PhoneNumber` type and I change my parameter type to be a `PhoneNumber` (`case validatePhoneNumber(number: PhoneNumber)`)  Hey @lizhihui0215 , unfortunately Swift enums do not support inheritance. From [the docs](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#), highlight by me:

> A class can inherit methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a subclass, and the class it inherits from is known as its superclass. **Inheritance is a fundamental behavior that differentiates classes from other types in Swift**.

[This answer on StackOverflow](http://stackoverflow.com/a/40823730) that may be helpful @lizhihui0215: yes, but its not the most user friendly. Check out this issue on Result: https://github.com/antitypical/Result/issues/76, and make sure you also read the discussion they link off to in `LlamaKit`.

Come back here if you're still trying to figure out how to compose your own error type that augments `MoyaError` I think this should be resolved, if there are still questions about this topic, please feel free to reopen whenever.  So happy you've made this issue! This is a feature we were looking to implement for RxMoya. Here's the pull request: https://github.com/Moya/Moya/pull/762

Let me know if you have any other questions, or if you're interested in implementing the functionality we're missing üòÑ  Let's continue discussion for this on #762, closing this for now  - Convert project to single schema target.
- Update deps for better swift 3.1 support.

Fix #818 What does this do over #967? @BasThomas theoretically not much, the purpose is the same, but in this case i converted manually, without script.

Also i updated the dependencies for better compatibility with Swift 3.1 and remove some deprecation warnings... Demo was updated too.

This PR is target to 9.0.0 I think we can take the deprecation warning in master, as it's not a breaking change. We actually have #1027 to do it :wink:

I also think that converting to a single scheme is not a breaking change and we should take it in master (which makes me think that we should continue #967 instead).

The dependencies update is good, but is it a breaking change? If not, I'd vote for merging into master so we can release it before 9.0 Closed in favor of #967   Hey @iballan could you provide more details on how you're encoding the parameters in the URL? Are you trying to send parameters in the URL and in the request body as well?

It'd be great if you could share some code that illustrates the issue :wink: @iballan Can you change your implementation of `path` to be:

```swift
 var path : String {
        switch self {
        case .products(let id_category): 
            return "products"
        }
    }
```

and `parameterEncoding` to:

```swift
var parameterEncoding: ParameterEncoding {
	    switch self {
	        case .products:
	            return URLEncoding.default
	        default:
	            return JSONEncoding.default 
	    }
    }
```

These changes will leave your code similar to the example we have in the [docs](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md) on how to send parameters in the URL when doing a POST request (see `.updateUser`)

 This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 Hey @iballan, we recently noticed that the documentation I pointed you to was wrong (we fixed in #1120). üòÖ 

Could you try using `URLEncoding.queryString` instead of `default`? I have set up an [example on how to send parameters in the URL using POST](https://github.com/pedrovereza/MoyaCarthage/blob/master/MoyaCarthage/ViewController.swift). Can you try this one out and make sure it works for you? ü§î   Are you implementing an optimistic UI (i.e. you're going to show an update has _succeeded_ before it actually comes back from the network)? If so, moving your network requests into a separate queue will make it very hard to tie back server validation/network failures back to the original callee (from my experience, YMMV).

I'd recommend instead when your user edits/adds item A, you do

```swift 
func updateA(newA: AType) -> Observable<AType> {
  return Observable.concat([
    saveDataToRealm(newA),
    saveDataToNetwork(newA)
  ])
}
```

and what will happen is, first your data will be saved to Realm, on completion of that, you'll get a `.next` even from your `updateA()` observable, and simultaneously your network request will kick off. At this point, you can update your UI to be optimistically successful. (hundreds of) Milliseconds later you should get back the second network request, which will show itself is a `.next`and `.complete`, where you can now make the optimistic success an actual success.
Also, if there was an error, you'd be able to handle the error at the callsite, instead of trying to associate it back to the callsite from your queue

So you call `updateA()`, you get
```
.next(realm)
.next(network)
.complete
```

There is the chance for a race condition though, but you should be returned the latest model from the network in `updateA()`. So as long as your UI uses that as the source of truth, your user will be able to see the race condition and fix it

So, I'm not sure this was the answer you were looking for, just another approach Hmm, yeah, if I understand what you're doing, yes. More or less.

What I would do is just mark that entity as having a pending sync in Realm, (and then have a background process that periodically goes and tries to upload pending syncs), like you said üòÑ 

If you save that request (in memory) to a list of requests to be retried once the network has been established, you may run into some non deterministic behavior, either by sending the sync multiple times (one from the realm background process, another from the in memory queue waiting for network reconnection), or risk dropping the queue from in memory if the app is quit before you persist to realm.

I'd recommend just going the persistent save + background processing route, and maybe even building a custom `OfflineSync` class that handles all your network requests if your app relies heavily on offline syncing  üòÑ  Hey @camcoding, take a look at #980. @scottrhoyt gave some ideas on how to change the `baseURL` dynamically @camcoding My first impression was that you could use the basic logic of #980 to achieve what you need, because in #980 the steps are:

1 - Make a request to a `baseURL`
2 - Extract the next `baseURL` from the response of the first call
3 - Use the extracted url as `baseURL` for the second request

And this could go on for several requests.

For your scenario, I'm assuming you can first try the local home address (which should fail when the user is remote):

1 - Make a request to `baseURL` using the local address
2 - If the request fail, switch `baseURL` to the remote address and make the request again

Once you know where the user is (home vs remote), you could probably store this information in your app and avoid making two requests every time if they are remote, and just make it once a while to check if they changed location.

Does that make sense in your case? @camcoding Can you  write a custom provider that subclasses `RxMoyaProvider`  and implement the logic in the custom provider? ü§î 

I'm not too familiar with RxSwift, but if this approach is not too complicated (or impossible), you'd get the logic nicely wrapped in a single place :wink:  In #978 you can see some ideas to have dynamic urls... I made a quick poc with the subtarget protocol and the dynamic provider... Maybe we can integrate that functionality in 9.0.0... WDYT? Yup, #978 should have a solution, if you're still having issues @camcoding, reopen this and we'd be happy to help üëç   Fixes #1018 

Our podspec claims we can take any version of ReactiveSwift equal or greater than 1.0. 
ReactiveSwift deprecated `DateSchedulerProtocol` in 1.1, which caused warnings when linting our pod.

Output of `pod lib lint`:

```
    - WARN  | [Moya/ReactiveCocoa,Moya/ReactiveSwift] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:9:32: warning: 'DateSchedulerProtocol' is deprecated: renamed to 'DateScheduler'
    - NOTE  | [Moya/ReactiveCocoa,Moya/ReactiveSwift] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:9:32: note: use 'DateScheduler' instead
    - WARN  | [Moya/ReactiveCocoa,Moya/ReactiveSwift] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:15:60: warning: 'DateSchedulerProtocol' is deprecated: renamed to 'DateScheduler'
    - NOTE  | [Moya/ReactiveCocoa,Moya/ReactiveSwift] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:15:60: note: use 'DateScheduler' instead
````

This PR replaces the usage of `DateSchedulerProtocol` with `DateScheduler` and bumps the minimum version of ReactiveSwift to 1.1

I wasn't sure if this requires a change in `Package.swift`, as I feel that adding a `minorVersion` would pin the dependency to that minor (as in, not as a minimum version, but that version exactly). Is that correct? ü§î 
 @pedrovereza from [swift.org](https://swift.org/package-manager/#example-usage):

```swift
import PackageDescription

let package = Package(
    name: "DeckOfPlayingCards",
    targets: [],
    dependencies: [
        .Package(url: "https://github.com/apple/example-package-fisheryates.git",
                 majorVersion: 1),
        .Package(url: "https://github.com/apple/example-package-playingcard.git",
                 majorVersion: 1),
    ]
)
```

> Each dependency specifies a source URL and version requirements. The source URL is a URL accessible to the current user that resolves to a Git repository. The version requirements, which follow Semantic Versioning (SemVer) conventions, are used to determine which Git tag to check out and use to build the dependency. The version requirements, which follow Semantic Versioning (SemVer) conventions, are used to determine which Git tag to check out and use to build the dependency. For of both the FisherYates and PlayingCard dependencies, **the most recent version with major version equal to 1 (for example, 1.0.0) will be used.**

That being sad I think it is safe to assume we don't _need_ to update our Package.swift file.  @sunshinejr thanks for merging! Also, we're having some issues with the build, check #1039 :wink:  Can you give us a code example? @Moya/contributors, can anyone take a look at this? Might this be a bug with our Reactive implementation?  Can you please post your Podfile and its [dependency graph](https://github.com/CocoaPods/CocoaPods/issues/3611#issuecomment-106081707)? What if you only add `pod Moya`, removing Alamofire? Alamofire is included with Moya. And what is your deployment target in Xcode?  Could you provide an api sample? Closing this due to inactivity, please come back if you're still having issues @iOSUser110! We'd love to help get this working for you üòÑ   Yes, that's possible! Have a look at the [providers docs](https://github.com/Moya/Moya/blob/cb99411423b6e9b292f9f238bef1969f406793ff/docs/Providers.md#providers):

> That's it! The `request()` method returns a `Cancellable`, which has only one public function, `cancel()`, which you can use to cancel the request. @nguyentrai2011 You could store the request_1 like
```swift
let request_1 = MoyaRequestXXXXX
```
then before you call request_2 call, just call `request_1.cancel()`. 
You also can add the request into an array. Then before you make new request, just use `requestArray.forEach({ $0.cancel() })`. @BasThomas Is the SessionManager can make a better solution for this situation? Unfortunately, I don't know. If you need it rather universal, meaning that at any moment in the app, only 1 request can be fired up at once, you would need to implement your own logic for that, using e.g. `OperationQueue`. 

However, if you want it for only one, special case, you could make use of `requestClosure`. You could fire up `request_1` in that closure with a check that you are firing `request_2`. Now based on the response from `request_1`, you can decide whether `request_2` should be performed or not using [this closure](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider.swift#L34). Unfortunately this way you probably can't propagate the response from `request_1` easily and thus this is a workaround.  Would you like the user of your app to retry the request? You can show an alert for them to do so yourself when a request has failed. Also, if you're using ReactiveMoya/RxMoya, they both include built in ways of retry failed requests You should be able to use Reactive / Rx just for the retrying part, no need to use it in your app as a whole. :)  change from
```swift
let WebServiceProvider = MoyaProvider(plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])
```
to
```swift
let endpointClosure = { (target: ShopperPlusAPI) -> Endpoint<ShopperPlusAPI> in
    let headers = [] // change this as you need
    let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
    return defaultEndpoint
        .adding(newHTTPHeaderFields: headers)
}
let WebServiceProvider = MoyaProvider(endpointClosure: SPProvider.endpointClosure, plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])
```
 I'm gonna close this issue due to inactivity, but feel free to reopen whenever.  Continues #1016 as we had some issues merging the original branch with `9.0.0-dev` @AndrewSB Is it worth adding in the changelog that we bumped the minimum version of RxSwift to 3.3? ü§î  Yeah, I guess that wouldn't hurt. I went ahead and added it. @BasThomas Thanks! üëç  Ugh, that Swiftlint issue... what's their reasoning behind that? I think `let _ =` is better than `!= nil`. Thoughts? Doing `let _ =` is just a way to check if an `Optional` value is `nil` or not. I personally prefer `!= nil` because the check is obvious.

This is not a strong opinion so I'm ok with whichever we agree to use :wink: ü§î. I think both are equally obvious, and like `let _ =` for looking cleaner (imho). Let's deal with it later. Don't think its that important right now. FWIW, the Swiftlint rule is `unused_optional_binding`. Once again thanks for fixing the merging issues @pedrovereza! üéâ Yeah, thanks a bunch @Pedrovereza!
On Fri, Mar 24, 2017 at 8:27 AM Bas Broek <notifications@github.com> wrote:

> Once again thanks for fixing the merging issues @pedrovereza
> <https://github.com/pedrovereza>! üéâ
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1020#issuecomment-289055097>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dLLl3Onm14sXQFTCxDgQu7PBK5YWks5ro-DrgaJpZM4MlpGj>
> .
>
 @pedrovereza thanks for this! I think maybe this extension also has to be modified? https://github.com/Moya/Moya/blob/master/Sources/RxMoya/Observable%2BResponse.swift @scottrhoyt I think you're right ü§î 

@AndrewSB Did we miss the extension @scottrhoyt pointed out or is there a reason to keep returning `Observable`? @scottrhoyt: thanks for catching that!

Here's what I think: the functions in `Observable+Response.swift` are extensions on any type of `Observable<Response>`. I think it's totally valid to have a producer that sends multiple `.next` events to an `Observable<Response>` (for example, I could have a request processor, which is of type `Observable<Response>`, through which I pass every single response that goes through my client).

I thought it best not to assume that _every_ `Observable<Response>` should be constrained to `Single`, and that's a choice a consumer of this library should make, by doing `.asSingle()` after using one of the operators Ok I understand that intention. Should we duplicate this as an extension on `PrimitiveType` too so that users can still do something like:

```swift
provider.request(.myRepos)
  .filterSuccessfulStatusCodes()
  .subscribe()
  .disposed(by: disposeBag)
```

Or would the recommended approach be to do:

```swift
provider.request(.myRepos)
  .asObservable()
  .filterSuccessfulStatusCodes()
  .asSingle()
  .subscribe()
  .disposed(by: disposeBag)
```

? I see your pain point. We should also probably extend Single to have the same functions. I wonder if theres a common superclass/protocol we could extend? I'm not sure how the Rx project does it.

I'll look into doing a common extension tomorrow, but feel free to give it a shot as well üòÑ  Oh, just noticed that you know what the superclass is - `PrimitiveType`

Yes, lets make them functions on that  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Thanks! üéâ  @evermeer Thanks for pointing that out! We'd be happy if you could send us a PR with the fix :wink: I'll hit it, it's a two second fix @pedrovereza @evermeer Pulling master from here and using the specified dependencies via the Cartfile and Podfile, I'm seeing that we're not using a version of ReactiveSwift that has the `DateSchedulerProtocol` deprecation. Are you perhaps pointing to the master of ReactiveSwift? @justinmakaila running `pod lib lint` shows the warning for me.  We had an acidental merge of `9.0.0-dev` into `master`, which caused #993 to be merged in `master` (see #1013). However, as #993 had to be reverted in `master` (#1015), merging `master` into `9.0.0-dev` takes the revert of #993 as well.

This PR is the result of merging `master` into `9.0.0-dev`, cherry-picking 249e436ab1c32f212a195afbe411fe5234aba81f and fixing the entry in the changelog. Thanks for fixing this, @pedrovereza. This looks good. Thanks @pedrovereza  Implements #1011, and changes the signature of RxMoyaProvider.request to return a `Single<Response>` instead of an `Observable<Response>`.

cc/ @andreyfel @damienrambout: would love both of you to sign off on this before it's merged in This is breaking and should go in `9.0.0` and not master, right? Also, some Cocoapods package versions don't match up with Cartfile anymore. @BasThomas: In its current state, it is breaking, retargeted to `9.0.0-dev`. Can you match the Cocoapods package versions that I missed?

@andreyfel: I don't know if adding another choice to a very simple module is a smart idea long-term. I feel as though we should either stick with Observable and not make this change, or embrace RxSwift's new semantics and publish Single. But not try to solve both inelegantly
After understanding the change, the easy path to migrate to the new RxMoya syntax will simply be for a consumer to extend `RxMoyaProvider` and supply a method that returns an `Observable<Response>`, which `.asObservable()`'s the new `RxMoyaProvider.request` I think we should first deal with #1013 (which is also reverting #993) @AndrewSB please rebase @AndrewSB can you rebase against `9.0.0-dev` and reapply your changes? (See #1017) :wink: All rebased! cc/ @gperdomor can you approve?
Also, @andreyfel, if you have any thoughts following up on what I said above , that would be awesome

I need to fix a couple tests to get CI passing, working on them soon üòÑ  #993 is still reverted in this PR @gperdomor @AndrewSB Hey, I fixed the branch by cherry-picking all changes on top of `9.0.0-dev`: https://github.com/Moya/Moya/commits/observable-single-9.0

We can:

1 - Open a new PR from that branch
2 - Push force to `observable-single`, meaning everyone will have to delete the branch locally and fetch again (but we keep this PR)

I'm ok either way üòÑ  Option 1 is more cleaner i guess I'm not a user of RxSwift, but just cruising through their API (you know, trying to form an educated opinion), it looks like `Single<MoyaResponse>` IS the most analogous structure to represent a network request, unless the request is repeating, in which case, `Observable` would make sense. In the case of a repeating request however, it should be on the developer to format their signal in that way.

Realistically, I don't think we should not embrace this change just because our API already utilizes `Observable`, but rather note it as a breaking change and release.

Forcing people to make changes to existing code bases to implement the best practices from one of our dependencies for a new version should be expected, and as @AndrewSB mentioned, you can just add `asObservable()` if you're a client who wants to continue to use `Observable`. Thank you for sharing your thoughts @justinmakaila!

@pedrovereza: I'm lazy, and I don't see the harm in #2, but feel free to go ahead with whichever one makes you more comfortable @BasThomas @AndrewSB @gperdomor @justinmakaila @andreyfel 
Hey I created #1020 to avoid more branch issues. Please continue the discussion in that PR and use branch `observable-single-9.0` for new additions. I'll delete `observable-single`to avoid confusions :wink: Thanks Pedro üòä
On Wed, Mar 22, 2017 at 11:34 AM Pedro Vereza <notifications@github.com>
wrote:

> Closed #1016 <https://github.com/Moya/Moya/pull/1016>.
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/1016#event-1011047362>, or mute the
> thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dLgc60B1bdVsvKubatVJR95BZ8QDks5roWmggaJpZM4MfFHB>
> .
>
  Reverts accidental merge of branch `9.0.0-dev` into `master`.
See #1013

This reverts commit 23be21483154bfed6b2a851cee8c6eb0ea66212f, reversing
changes made to 4ac60f04c4771375a77069ef06f8655cde12975d. Thanks @pedrovereza!   Not sure if it was intentional, but 23be21483154bfed6b2a851cee8c6eb0ea66212f merged branch `9.0.0-dev` into `master`. If that's correct, we can delete branch `9.0.0-dev` ü§î  Wow, that was a conflict GitHub wanted to resolve on this PR. Didn't mean to do that... üòî @BasThomas No worries, #1015 should undo it :wink: Ok, the changes from #993 are already in `master` but reverted in #1015, that's why git won't try to apply #993 again. I think we have to merge this as-is an reapply 249e436ab1c32f212a195afbe411fe5234aba81f on `9.0.0-dev`  Hey @moto0000. Unfortunately, this is something we didn't introduce yet in our API. Upload especially is something we are still working on. However, I think this would be a nice feature. Would you be up for doing the PR with implementation? :) This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Feel free to take a stab at implementing this! Would this be a breaking change or would/should it coexist with the `Observable`-implementation? `Single<>` sounds incredible! I brought something similar up as an issue a few months ago, I'm so excited they implemented something that solved the same problem.

I'll take a shot at this üòÑ  Implemented in #1020  See #966 for details.  Great question @PMExtra üòÑ 

First, you wouldn't be disposing the `RxMoyaProvider` as a whole, you'd dispose a (or a number) of subscriptions created by the `RxMoyaProvider` which represent pending network requests. More of a naming issue, but it could cause a misunderstanding with what you're actually doing.

So you should dispose subscriptions when you're no longer interested in them. In your case, thats when you'd no longer like to send heartbeats to your server.
If you only want to send heartbeats when a specific view controller is alive, then you should add it to the vc's dispose bag, otherwise you should add it to a long living disposeBag, maybe of a class that belongs to your AppDelegate (like your `NetworkManager`, or something like that)

Let us know if you have any other questions about this üëç   no, you not need create a provider for each request... You need only one provider :D...   **Version** `8.0.2`

I feel kinda stupid to be asking the seemingly simple question, but I simply can't figure it out.

I need to post some JSON to an API endpoint, where some values need to be `nil`. Here's an example:

```json
{
    "key1": "someString",
    "key2": null
}
```

However, the `parameters` property of the `TargetType` protocol only accepts `[String, Any]?` and not `[String, Any?]?`, so how do you achieve this? Thanks @vzsg. But I'm curious as to why you need to use some old `NSObject` subclass in a Swift dictionary, when we have optionals?

Also, what is the easiest way to unwrap the optional values when constructing the `parameters` dictionary then? Let's say I have an object
```swift
struct LineupPlayer {
    let id: Int
    let user : User?
}
```
doing the following
```swift
extension LineupPlayer : ParameterRepresentation {
    var representation: [String : Any] {
        return ["id": id, "user": user?.representation ?? NSNull()]
    }
```
results in a compile error `Generic parameter 'T' could not be inferred`, since the nil-coalescing operator tries to operate on two different types.

How would you recommend to do this? Doing

```swift
extension LineupPlayer : ParameterRepresentation {
    var representation: [String : Any] {
        return ["id": id, "user": (user?.representation as? Any`) ?? NSNull()]
    }
```

compiles, but now I get [this error](https://github.com/Alamofire/Alamofire/issues/1693#issuecomment-285937335) üôÑ  I'm so confused! It's just a `protocol`

```swift
protocol ParameterRepresentation {
    var representation : [String : Any] { get }
}
```

Because the API only accepts `null`, not `{ }`, when there is no value @jessearmand. I got it working now. Thanks everyone üôè  Great! Could you post your fix to the problem here as well, @philipengberg? Might be helpful for other people in the future.    Oh hai it's me again.

So, we have a few fixes that could be released already:

- #966 fixed the Swift 3.1 compatibility, and [some people are already trying XCode 8.3 beta](https://github.com/Moya/Moya/issues/952#issuecomment-284999253).
 **This fix is not listed in the changelog**, I think it should be. (Changelog entry added in #1010)

- #979 fixed the output of `reversedPrint`

- #1002 fixed a memory leak when stubbing

cc. @Moya/contributors  also, this changes needs to be integrated in 9.0.0 branch... @gperdomor I think that when we decide to release 9.0, we will merge the branch with master, so 9.0 will have everything until 8.x, plus the breaking changes for 9.0. Does that make sense?

EDIT: Oh, think I get what you mean. Have this changes in 9.0 branch so we develop on an up-to-date branch üëå  Yes... On the other hand, do that, reduce the possibility of conflicts, we don't know how many PR will merge to master or 9.0.0, but eventually this could produce more conflicts depending on how many breaking changes was introduced in 9.0.0
 @soundbites I think we just need to get #1010 merged and we should be good to go. @pedrovereza, is it intentionally a tag and not a release? @BasThomas The release script first creates a tag and then a release. It takes a while and is still running üòÉ 

Edit: https://github.com/Moya/Moya/releases/tag/8.0.3    @jorgelp94 you can use a endpoint closure. Check [Endpoints.md](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md)

> You can add parameters or HTTP header fields in this closure. For example, we may wish to set our application name in the HTTP header fields for server-side analytics.

```swift
let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
    let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
    return defaultEndpoint.adding(newHTTPHeaderFields: ["APP_NAME": "MY_AWESOME_APP"])
}
let provider = MoyaProvider<GitHub>(endpointClosure: endpointClosure)
```
In your case you need use RxMoyaProvider instead MoyaProvider  Seems like the `request` for plugin in stub mode never complete so just cancel it. It fix the memory leak issue. Related to https://github.com/Moya/Moya/issues/1000  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  @hartbit  Were you not able to find the [docs](https://github.com/Moya/Moya/blob/master/docs/Providers.md#stubclosure)? It's pretty clear on how to stub the requests.

When you create an instance of the `MoyaProvider`, add `stubClosure:`.
`let provider = MoyaProvider<MyTarget>(stubClosure: MoyaProvider.immediatelyStub)`

It might be a good idea to make finding these things easier. I can see why this is confusing. There doesn't seem to be a centralized section for testing. It's scattered among providers, basics, etc. 

I'll see what I can do to improve this but I'm guessing it's a week before I'll be able to do a write up. I'm assigning this issue to myself but if anyone can complete it before me - feel free.  I think you will have better luck if you make the `language` and `sort` query parameters constants in the `parameters` return as opposed to hard coding them in the path. That way they don't escaped as you are seeing. Let us know if that works for you!  You should pass a `stubClosure` to `MoyaProvider` on instantiation. There are some default ones:

* `neverStub` (default)
* `immediatelyStub`
* `delayedStub`

e.g.

```swift
let provider = MoyaProvider<MyApi>(stubClosure: MoyaProvider.immediatelyStub)
``` @sevrazzmatazz Hey, the usage is actually on the docs ([here](https://github.com/Moya/Moya/blob/master/docs/Providers.md#stubclosure)). Any ideas on how we could make this easier to find? ü§î  @Moya/contributors Issue #1001 also discusses the difficulty of finding the docs on stub closures. I'm going to close this.  Handling object deserialization in general has been discussed, but currently is on the roadmap per se. So I don't think deserializing XML and parsing that into an RSS model is in the near future.

That being said, I took a look the library you referenced and I don't think it would be terribly hard to port it to Moya. 90% of the code would be reusable--you would just need to write the extensions for `Moya.Response` which should be pretty straightforward. I think if you were interested in that, it could be a very valuable addition to our community extensions.

Another option you have is to extend Alamofire with ReactiveSwift--I'd be surprised if such a library doesn't already exist. That also should be straightforward, especially since Alamofire already uses a `Result`-like pattern. I'm gonna close this issue due to inactivity, but feel free to reopen whenever.  This reverts commit ca5c9fed3a6ad4bb8be9a5d882bb202782910ac1, reversing
changes made to 4160bb6a1611386a469e9b2b0d2a07fe1ef9c461. @BasThomas, @ashfurrow, @scottrhoyt:

I can't possibly believe that this is correct; the Cartfile is totally wrong. I ran the command I posted in #996: `git revert -m 1 ca5c9fe` and popped this onto a branch... any ideas?  @Moya/owners 

Can someone help me undo the latest commit to master? I can't force push to a protected branch, wondering if there was some other way than manually undo-ing it, which I'm open to because I messed it up.

ü§¶‚Äç‚ôÇÔ∏è  @Moya/contributors as well I'm trying to use `git revert`, but I'm not entirely familiar. The `... reset` `... push -f` didn't work I ran `git revert master -m 1`, but haven't pushed it yet because i don't want to undo the wrong stuff. A revert generates a new commit, to be safe it'd be best to put that commit in a PR, if that works for you? I'm happy to do it but I'm away from a computer right now.  Hey @justinmakaila, are you familiar with how to generate a reverse commit? As @ashfurrow mentioned, you should be able to push that to `master` without force pushing anything. If you need any help or would like me to do it,  post the hash of the commit you want reversed and I can do it. Thanks! I would think this concerns `ca5c9fed3a6ad4bb8be9a5d882bb202782910ac1`, right @justinmakaila? Exactly, @BasThomas. 

@scottrhoyt, @ashfurrow, I'm fine with PR'ing it, I just wanna make sure the command I'm running is legit.

Quick patch: Is there any reason we allow direct pushes to master? I know, realistically, I should have watched what I was pushing to, but is there anyway we can protect against this in the future? Yup, cool so on a branch you do `git revert ca5c9fed3a6ad4bb8be9a5d882bb202782910ac1`, save the default commit message, and then push your branch to do a PR as usual.

We allow pushes to master because the release script, which modifies the changelog and podspec, commits and pushes. With this being automated, maybe there's an opportunity to change that. 

Let me know if I can help or further clarify anything üëç @ashfurrow Well here's the fun part... `ca5c9fe` is actually a merge commit... I had my own fork of Moya with tweaks for whatever version of ReactiveSwit I was using. I pulled in `upstream` (this repo), and merged, then, thinking I was pushing to my branch, accidentally typed `git push upstream master` which pushed whatever just got merged in with whatever out of date changes I had.

The parents of the commit are  `4160bb6` + `b0a70e2`, where `b0a70e2` is the commit that I want to revert master back to (i.e. undo whatever was merged in from `4160bb6`.

I believe the proper revert command would be `git revert -m 1 ca5c9fe`, which gives me the message:
```
Revert "Merge in master"

This reverts commit ca5c9fe..., reversing changes made to 4160bb6...
```
I'm a little tentative to pull the trigger right now, seeing as I've already ruined our history a bit ;).

I'm going to create a new fork (I don't trust the history of my old one anymore...), create a new branch, run the revert command above, and then file a PR. Try diffing the branch with the reverted commit against the last commit before your accidental one. Yikes, I've never successfully reverted a merge commit except through the GitHub UI. Hmm. Any advice here would be welcome. @Moya/contributors after further review, it looks like my branch was used as the base, and the "merge" was really just a fast forward, that looks weird because my branch was used last the base.

I changed one of my projects to point to master, and have been using it with seemingly no issue. Ultimately, I think this demonstrates that we need to lock down the master branch and ensure that the only code that can get into master is via PR and approval from the organization. I agree with Justin about locking down master, especially since the Moya
organization is huge, which introduces more potential points of failure. Is
the release script the only consumer committing directly to master? Can we
have it make a Pull Request instead?

On Fri, Mar 3, 2017 at 3:03 AM Justin Makaila <notifications@github.com>
wrote:

> Ultimately, I think this demonstrates that we need to lock down the master
> branch and ensure that the only code that can get into master is via PR and
> approval from the organization.
>
> ‚Äî
> You are receiving this because you are on a team that was mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/994#issuecomment-283788926>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dKXew-BYKg2aq7F5ck9pDwXDw5_8ks5rhzW0gaJpZM4MPIc3>
> .
>
 GitHub's control over branch protection looks fairly granular ‚Äì we we automate the release, get @ashfurrowbot or @moyabot or someone's bot to push, and whitelist them as having direct push access. We've been discussing automating our release process a bit in https://github.com/Moya/Moya/issues/983 but could someone open a new issue for just it? Yeah, if we can do releases via @moyabot, that'd be awesome! There may be a complication using @moyabot actually. It's purposefully not a member of the org because it has its personal access token to access repos public (it _has no repos_ to access, so it's fine). It needs this for Danger integration. Hmm. I can't really use @ashfurrowbot either for the same reason. Not sure about next steps. Well, I suppose on the other hand, as long as we can't force push, then we won't be able to do anything absolutely irreversible. It just might be a major pain to do so... Yeah, we'd have to modify our deploy script because it currently updates the changelog and podspec, commits those changes, and pushes. If we did something else like using PRs for those changes, and then tag post-merge, then CI can just push to CocoaPods and make a GitHub release. Sounds like a plan to me! Alternatively, we could use deploy keys instead of using personal access tokens; it's more involved but we can automate away the PR process. 

@scottrhoyt would you be interested in making those changes? Happy to help but I'm also keen to see the project grow on its own, without me :smile: Sure, @ashfurrow. My other workload has picked up a bit, so it might be a few days before I can look at this, but happy to give it a go. Cool cool, much appreciated. No pressure remember!  Does anyone have an idea on how to revert the accidental push? I think that would be good to figure out as well. @BasThomas The issue (I believe) was that I was running my own fork, and my own version of master, so when I went to merge in, it used my branch as the base, and merged in this repo's master, which pretty much just merged my four month old commits into the history.

I attempted to use the standard suggested `git revert` and whatnot, but since my branch was the base for the merge, it was threatening to undo months of work on this branch.

Given that context, if anyone who understands git a little better has an idea, it should be pretty easy to drop those commits from the history (I was literally just tweaking the Cartfile to match ReactiveSwift with the version of ReactiveCocoa I was using), then that would provide a more accurate representation of development over time, but I'm not sure if it's necessary, given that all of the files I edited were definitely manipulated and changed since I last touched them. Yeah, I didn't notice any file changes in the project itself, so it should be fine. I think this should be resolved, so I'm gonna close it for now.  I tried to solve #975 

 @BasThomas Done! üëç  @scottrhoyt, in the branch / PR, this has already been done, right? https://github.com/gperdomor/Moya/blob/1ac84d7387703d552f51ac41e9d0c7c16cb577c2/Sources/Moya/MoyaError.swift#L32
Not sure why you are referring to the main repo? Oops. Thanks @BasThomas. I missed it. Sorry @gperdomor. Looks good! We should also not forget to update the docs to reflect this change, although I think we can do so in another PR.  **DON'T MERGE YET**... I forgot test the Demo, i don't know if runs or not... But i can't do it now... i will do it tonight @scottrhoyt I update the docs and integration tests... The Demo works without changes Hmm we might want to start a separate changelog section for 9.0.0 instead of making it seem like this change is on `master`. But this PR is target to 9.0.0 branch, not to master, so everything in Next section is obviously referent to 9.0.0, at least for me can we merge this?... I propose create a milestone for the `9.0.0` Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. @nikans Moya has been around almost as long as Swift has been public, our error handling as evolved as Swift's has :wink:   I could be wrong, but I believe this is more of an App Transport Security issue. Have you tried searching for information/solutions regarding that? Hmm. Well, I'm not sure I can think of where Moya might be interfering with this. Moya runs network requests through Alamofire which in turn uses `URLSession`. I believe this is a configuration that should be happening at the `URLSession` level, but possibly there is something to do at the Alamofire level. [Here is a link](https://github.com/Alamofire/Alamofire#security) to Alamofire's security section that covers some ATS and common issues with self-signed certificates. @camcoding You can use `ServerTrustPolicyManager` from Alamofire:

```swift
let serverTrustPolicies: [String: ServerTrustPolicy] = [
    "your host exactly": .disableEvaluation
]

let manager = Manager(
    configuration: URLSessionConfiguration.default,
    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
)

let provider = MoyaProvider<YourService>(manager: manager, plugins: [NetworkLoggerPlugin(verbose: true)])
```

The only problem is that `ServerTrustPolicyManager` doesn't take wildcards in the policies, meaning that you would need to specify the host, which is fine when you're testing locally but won't work for your users.

From `ServerTrustPolicyManager` source code:

```swift
    /// Returns the `ServerTrustPolicy` for the given host if applicable.
    ///
    /// By default, this method will return the policy that perfectly matches the given host. Subclasses could override
    /// this method and implement more complex mapping implementations such as wildcards.
    ///
    /// - parameter host: The host to use when searching for a matching policy.
    ///
    /// - returns: The server trust policy for the given host if found.
    open func serverTrustPolicy(forHost host: String) -> ServerTrustPolicy? {
        return policies[host]
    }
```

What you can do to disable certificate validation is to subclass `ServerTrustPolicyManager` and return `.disableEvaluation` for all hosts:

```swift
class CustomServerTrustPoliceManager : ServerTrustPolicyManager {
    override func serverTrustPolicy(forHost host: String) -> ServerTrustPolicy? {
        return .disableEvaluation
    }

    public init() {
        super.init(policies: [:])
    }
}
```

and the usage becomes:

```swift
let manager = Manager(
    configuration: URLSessionConfiguration.default,
    serverTrustPolicyManager: CustomServerTrustPoliceManager()
)

let provider = MoyaProvider<YourService>(manager: manager, plugins: [NetworkLoggerPlugin(verbose: true)])
```

Let us know if this solves the problem for you :wink: @camcoding Oh, right. Forgot to mention you also need this in your Info.plist:

![image](https://cloud.githubusercontent.com/assets/1916041/23478752/100d924a-fea1-11e6-968e-5b0f3c38c984.png)
 @camcoding I created a simple project using Moya to access a website that uses a self signed certificate: https://github.com/pedrovereza/SelfSignedMoya. 
There is also a branch that uses `RxMoyaProvider`: https://github.com/pedrovereza/SelfSignedMoya/tree/rxExample

Both use the `CustomServerTrustPoliceManager` described above, plus the entries in the Info.plist.

Can you confirm this project works for your endpoints as well?  What are you referring to exactly? Where do you get an error? Also, which dependency manager are you using? This looks like an old release, hopefully everything should be fixed in our latest. Please reopen if you're still having issues @coderRMS!    Changed `Moya.Error` in [Basic](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md) to `MoyaError`. Changed `verbose` in [Plugins](https://github.com/Moya/Moya/blob/master/docs/Plugins.md#built-in-plugins) to `isVerbose`. Thanks @dannymout !  I'm making a request in Moya, I'd like to see the request URL, is this possible? Do you mean logging it to the console? If so, checkout `NetworkLoggerPlugin`. @scottrhoyt If you don't mind answering, how would I use `NetworkLoggingPlugin` to do what I need to do? Sure, you just initialize a `NetworkLoggingPlugin` and pass it to the `plugins` parameter of your `MoyaProvider` initializer. (e.g. `plugins: [NetworkLoggerPlugin()]`). @scottrhoyt @gperdomor Perfect. Didn't know that is how it worked, thanks.  This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Thanks for the contribution @yanamura3!

I have to think about this one for a second. Something feels a little off about transforming an `AFError` into a `MoyaError` like this. I don't know that it is a bad approach, it just feels unique as to how we handle other underlying errors. Also, having it depend on `validate` and possibly not doing the transform if a response doesn't exist feel a bit too non-deterministic.

On the other hand, this is a clever way to get the changes necessary for #975! It is technically a breaking change, though. If someone wrote code that looks for the a `AFError. responseValidationFailed` embedded in a `MoyaError.underyling`, their code will break with this update. Worse, it would probably be silent--no compiler error.

In the light that it would be a breaking change, I'm leaning towards it being better to just add an optional `Response` value to `MoyaError.underyling`, but that's not a strong opinion.

Would love to hear what other @Moya/contributors think of this approach. @scottrhoyt check  #993 please, i add the response to `MoyaError.underyling` @yanamura3 this was solved in #993 :D  Nitpicking üôà Just saw all the issues you closed, really nice work @scottrhoyt üëå  I would like to set up CircleCI to automatically deploy prebuilt frameworks for Carthage on tagged released. I haven't done so for CircleCI yet, but I'm quite familiar with the process on Travis. I believe Circle build tagged releases, correct? Do any @Moya/contributors think this is a bad idea?

In order to execute this I believe I will need a OAuth token with permissions to modify releases. @Moya/owners or @ashfurrow do you think you could assist with this? I'm okay with automating things, that's a bit distinct from releasing prebuilt libraries. I've avoided them until Swift has ABI stability but it's definitely up for discussion. @scottrhoyt I've added you as an owner of the Moya org so you should be set to handling setup yourself. Let me know if I can help ‚Äì I've been stepping back gradually but I'm happy to help where I can! Thanks @ashfurrow! I share your concerns for Swift ABI compatibility, which is why I introduced a PR for Carthage to only use prebuilt binaries when they are compatible with your local version of Swift (https://github.com/Carthage/Carthage/pull/1755). This is has been merged and will deploy soon with the next Carthage release. With this feature, a Carthage consumer of Moya will at worst have the same behavior as current (building Moya), but may also benefit further from a prebuilt binary.  @iShawnWang thanks for reporting this and creating a repro project. I can confirm that I experienced the same compiler crash from that project. I haven't had a chance to look into it much further, however, because these sorts of compiler crashes can take a while to debug üòû . In the past when I have experienced this it has been related to issues with generics (many times having to do with generics and inheritance). I don't know if that is the issue here or not though, but it's my first guess. Have you had a chance to see if this behavior is the same when compiling with Swift 3.1? Thank you for your help, @hugweb! üëç I think this should be resolved, so I'm gonna close it. If you still have questions about this topic, @iShawnWang, please feel free to reopen whenever.  This was introduced recently in f90429587b92a57d33ed7019fc80b5a082aac7b2.

@BasThomas Any reason why we'd want to keep them separated in the instructions? ü§î  I think it may have just been a copying error from the Cocoapods instructions. @scottrhoyt Yea, that may be the case. Just wanted to double check with him because these changes normally come after a PR/issue and maybe there was a discussion we don't remember. I think I misunderstood the instructions and made an error here. Thanks for fixing this, @Lutzifer! üôå Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  The main issue for you is to solve having a `TargetType` with a dynamic `baseURL`. Some ideas on how to do this are covered in #978. For the purposes of this example I am going to assume you have a `struct MooApi: TargetType` that takes a `URL?` to use as it's `baseURL`. If given `nil` it  has access to a default `URL`. Then it would look something like this:

```swift
struct MooApi: TargetType {
  let defaultURL = < defaultURL >
  let url: URL?

  var baseURL: URL { return url ?? defaultURL }

  /* TargetType */
}

let provider = MooProvider<MooApi>(token: accessToken)

func followTheURLs(url: URL? = nil) -> Observable<JSONDocumentManyObjects<LibraryItem>> {
  return provider.request(MooApi(url: url))
    .filterSuccessfulStatusAndRedirectCodes()
    .mapObject(type: JSONDocumentManyObjects<LibraryItem>.self)
    .flatMap { jsonDocumentManyObjects in
      if let url = jsonDocumentManyObjects.nextURL {
        return followTheURLs(url: url)
      } else {
        return Observable.just(jsonDocumentManyObjects)
      }
    }
}

followTheURLs()
      .subscribe { event in
        switch event {
        case .next(let element):
          print("next: \(element.url)")
        case .error(let error):
          print("error: \(error)")
        case .completed:
          print("completed")
        }
      }
      .addDisposableTo(disposeBag)
```

Now a couple of points:
  * If your `MooApi` has different endpoints then you'll need an additional strategy here. Look at #978 for ideas.
  * I'm not exactly sure about how this recursive flat mapping will propagate errors. You'll want to test that.
  * It might be possible to instead do this with an Observable of Observables, but I'm not sure it would be much simpler.  @jessearmand you can tag your PRs with `#trivial` to not trigger this Danger warning. However, I think a nice fix like this should be in the Changelog. If you look at the document, the top heading is "Next". This is the space for changes the currently only exist on `master`. Currently, there are none, but you can go ahead and make the first entry! Thanks! And thanks for the contribution! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  @gregpardo you can treat the `baseUrl` like the other parameters and use a switch statement to load it. It would look something like this:

```swift
enum MyApi: TargetType {
  case login(baseUrl: URL)

  var baseUrl: URL {
    switch self {
    case let .login(baseUrl):
      return baseUrl
    }
  }

  /* TargetType implementation */
}
```

But if you know the other base URL's at compile time, I would recommend using a separate `enum` to drive those:

```swift
enum Server {
  case northAmerica
  case europe
  
  var baseUrl: URL {
    switch self {
    case .northAmerica:
      return <north america URL>
   case .europe:
      return <europe URL>
    }
  }
}
enum MyApi: TargetType {
  case login(server: Server)

  var baseUrl: URL {
    switch self {
    case let .login(server):
      return server.baseUrl
    }
  }

  /* TargetType implementation */
}
```

Does that answer your question? @gperdomor maybe I can help you further if I understand a bit more about your use case. If you don't know the `URL`s at compile time, how do you retrieve them? Ah, I see, so then I think the singleton idea make a lot of sense.

Another idea that would be slightly more complicated but eliminate the need for a singleton:

```swift
struct DynamicTarget: TargetType {
  let baseURL: URL
  let target: TargetType

  var path: String { return target.path }
  var method: Moya.Method { return target.method }
  /* ... */
}

class DynamicProvider: MoyaProvider<DynamicTarget> {
  let baseURL: URL

  // add initializer to take `baseUrl` and call super with the rest of the arguments

  func request(_ subTarget: TargetType, completion: ((Result<Response, MoyaError>) -> Void)? = nil) {
    let dynamicTarget = DynamicTarget(baseUrl: baseUrl, target: subTarget)
    super.request(dynamicTarget, completion: completion)
  }
}
```

Does that make sense? That way you initialize the provider once with the URL and from there you can just pass regular `TargetType`s to it. Another option is to create a `protocol` that has all the properties of `TargetType` except a `baseUrl`, you could then use that in this structure and avoid needing to put garbage `URL`s in for all the regular `TargetType`s.

```swift
protocol SubTarget {
  var path: String { get }
  var method: Moya.Method { get }
  /* ... */
}

struct DynamicTarget: TargetType {
  let baseURL: URL
  let subTarget: SubTarget

  var path: String { return subTarget.path }
  var method: Moya.Method { return subTarget.method }
  /* ... */
}

class DynamicProvider<Target: SubTarget>: MoyaProvider<DynamicTarget> {
  let baseURL: URL

  // add initializer to take `baseUrl` and call super with the rest of the arguments

  func request(_ subTarget: Target, completion: ((Result<Response, MoyaError>) -> Void)? = nil) {
    let dynamicTarget = DynamicTarget(baseURL: baseURL, subTarget: subTarget)
    super.request(dynamicTarget, completion: completion)
  }
}
```

There are a number of variations around this idea, but `struct` `TargetType`s would be the key. `let baseURL: URL` should satisfy a protocol requirement of `var baseURL: { get }`. I used it in such a way [here](https://github.com/Moya/Moya/blob/sh_targettype_defaults/Source/Target.swift#L44).

(there are some small mistakes in my example like `baseUrl` instead of `baseURL` that you will need to fix, but the concept works) There is some similar functionality in `MultiTarget` and I proposed another idea that has some overlap, but that wasn't accepted. In neither case would it have solved this issue. In general I would say most users of Moya are interacting with a single `baseURL` per target, so I don't think there is a ton of need for this to be native. But if we continue to get requests like this, we can consider adding it. @gperdomor yes, I have used something similar to the singleton method in some of my projects. It has worked quite well.

The `SubTarget` protocol definitely adds some maintenance overhead, but I believe it to be pretty small. If those maintenance concerns are bigger to you than having a garbage `URL` in the code, then you could easily do something like this:

```swift
protocol SubTarget: TargetType { }

extension SubtTarget {
  var baseURL: URL { return URL(string: "http://YouShouldNeverUseThisURL.com/")! }
}
``` No, not directly I believe, but maybe you can provide a `fileprivate` protocol extension in the test file that overrides all `TargetType` `sampleData` (haven't tried that). What I do is provide an override for the endpoint closure that provides data only in testing. The advantage to this approach to is that you can simulate different responses per test and even simulate things like different HTTP status codes or network errors.

I generally simplify this by creating a testing subclass of `MoyaProvider` that takes a `responseClosure` which maps the `Target` to a `EndpointSampleResponse`, then I construct the `EndpointClosure` with this. It looks something like this:

```swift
class TestProvider<Target: TargetType>: MoyaProvider<Target> {
  init(responseClosure: ((Target) -> EndpointSampleResponse)? = nil) {
    var endpointClosure: EndpointClosure
    
    if let responseClosure = responseClosure {
      endpointClosure = {
        target in

        let sampleResponseClosure: Endpoint<Target>.SampleResponseClosure = {
          return responseClosure(target)
        }

        return Endpoint(
          url: target.baseURL.absoluteString,
          sampleResponseClosure: sampleResponseClosure,
          method: target.method,
          parameters: target.parameters,
          parameterEncoding: target.parameterEncoding,
          httpHeaderFields: nil
        )
      }
    } else {
      endpointClosure = MoyaProvider<Target>.defaultEndpointMapping
    }

    super.init(endpointClosure: endpointClosure, stubClosure: MoyaProvider.immediatelyStub, plugins: [])
  }
}
```

**Note this also stubs immediately and makes no attempts to put anything into the HTTP header fields, so change that behavior as necessary.**

The usage then looks like this:

```swift
  enum TestTarget: TargetType {
    case success, failure

    // Implement TargetType
  }

  let responseClosure: (TestTarget) -> EndpointSampleResponse = {
    target in

    switch target {
    case .success:
      return .networkResponse(200, fixture("ApiSuccess"))
    case .failure:
      return .networkResponse(400, fixture("ApiFailure"))
    }
  }

  let provider = TestProvider<TestTarget>(responseClosure: responseClosure)
```

**Note I am using a helper function here `fixture(_:)` that loads sample data from fixture files.**

Let me know if that helps. Unfortunately, I have only used this method in closed source projects, so I am unable to provide a link.

For the approach I outlined above, you wouldn't need a new `TargetType` for each endpoint, you would just need a new `responseClosure` anytime you want to change the behavior of sample data. In essence you achieve very similar results to `OHHTTPStubs` but you can utilize the `enum` semantics of the `TargetType` itself to write more declaratively. That being said, I know many people that use `OHHTTPStubs` and have good success with that route. There are a number of ways to do it. You could create a `responseClosure` for successes and one for failures. Or you could create a function that returns a `responseClosure` based on a `successful` flag if you need more control over the failure case. Here is what 2 separate closures looks like:

```swift
  let successfulResponseClosure: (Session) -> EndpointSampleResponse = { target in
    switch target {
    case .login:
      return .networkResponse(200, fixture("LoginSuccess"))
    case .tokenRefresh:
      return .networkResponse(200, fixture("TokenRefresh"))
    case .logout:
      return .networkResponse(200, fixture("Logout"))
    }
  }

  let successfulProvider = TestProvider<Session>(requestClosure: successfulResponseClosure)

  /* ... Run Your Success Tests ... */

  let failedResponseClosure: (Session) -> EndpointSampleResponse = { _ in
    return .networkResponse(404, fixture("BadRequest"))
  }

  let failedProvider = TestProvider<Session>(requestClosure: failedResponseClosure)

  /* ... Run Your Failing Tests ... */
``` It looks like that solved your problem @gperdomor, let us know if you still need any help with this! Closing for now üòÑ   As noticed in #957  @shuijinliuxi, you have 2 options for getting to the `URLRequest`:

* Utilize a custom `RequestClosure` in your provider to construct the request with any modifications needed.
* Create a `PluginType` that uses the `prepare` method to make any modifications to the `URLRequest` and add that to your provider.

Also if you need to modify the caching policy, you can construct an `Alamofire` `SessionManager` with a custom `URLSession` using a `URLSessionConfiguration` that modifies the caching policy to your liking. This can then be given to a `MoyaProvider` to use instead of the default. But you might be fine with the defaults as well.  Maybe @scottrhoyt can help you with this one.  @mrtj unfortunately I don't have any easy answers for you on this one. Using Alamofire's validation takes a lot of control out of Moya's hands. The way I see it, you have a couple of options, but they aren't simple.

1. Modify Alamofire's validation error to also expose the response. This could be via filling an issue/PR with them or creating your own fork.
2. Modify Moya's `TargetType.validate` property to return an optional integer range to validate with. A `nil` value indicates no validation while a range is forwarded to Alamofire's `validate(statusCode:)` that would go around [this section](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider+Internal.swift#L200-L216). This would require you to fork Moya.
3. Build request retrying functionality into Moya.

Option 1 would probably be valuable to the wider Alamorefire community, but I think it might be hard to get a breaking change like that through in any reasonable timeline for you. You would also have to maintain separate forks of both Alamofire and Moya.

Option 2 is the quickest and easiest for you, and you could submit a PR back to us for consideration. However, I don't personally love the solution for Moya in general because it's going to help propagate this pattern of spreading out error handling between Alamofire, Moya, and the dependent application. It feels like a bad separation of concerns to me, but other's may feel differently about that.

Option 3 would be the hardest but of possibly the most value to the Moya community. We go through some lengths to hide Alamofire from end users. If we can eliminate one more use case--and a big one at that--for users to dig into Alamofire and deal with the attendant consequences, I think that would be a big win. I'm sorry @mrtj, I mistakenly assumed that at that point Alamofire was just returning a `AFError. responseValidationFailed(reason: . unacceptableStatusCode(Int))`. If it is also returning a response with data then indeed you could modify `MoyaError.underlyingError` to have an optional `Response` parameter that can be forwarded to custom error handling.

Why don't you give that a try and report back your findings? We can open up a PR as well, but since this would be a breaking change, it might be a bit before we can include it upstream. FWIW, I think in this case it should definitely be corrected to also include `data` in Moya, and we should consider releasing a `9.0` for it. What would be the downsides of doing it this quick after `8.0`? I don't see there being a ton @BasThomas. If this were a bigger breaking change I would say the downside would be forcing user's to deal with breaking changes to receive future fixes, but in this case the fix would be pretty minor and maybe not even affect a large portion of users. If we go that route I would propose we start a pre-release cycle for 9.0 so that @mrtj and others with this use case can get support quickly while we work out what other things--if any--should go in 9.0. How about we open another issue to discuss? üëç great idea  @mrtj @BasThomas, I just created the `9.0.0-dev` branch so we can accept PRs there. @mrtj, if you have gotten the solution above to work, would you mind submitting a PR to that branch so we can get your work included in the next major release of Moya? üëç  Solved in #993 so this can be closed  Hey @shuijinliuxi, can you test if the parameters are valid before making the request? Something like:

```swift
if (parameterAreValid(key, id: consId) {
  provider.request ... // Make request here
}
else {
  //show alert
}
```  Hey @albertml, if I understood correctly, you want the parameters to be sent as JSON instead of having them in the URL. Is that correct?

If so, you should use `JSONEncoding.default` as your `parameterEncoding`, e.g.:

```swift
public var parameterEncoding: Moya.ParameterEncoding { return JSONEncoding.default }
```  I noticed this when reading #970   You beat me to it, @bjarkehs. üòÖ ü§î, `7.0.4` actually targets Swift 2.3. I think the documentation over at https://github.com/Moya/Moya/tree/7.0.1 is better for Swift 2.2. Go ahead and update to Swift 3. You won't regret it. In the meantime, you could of course use an older version of the Object Mapper as well, such as [v1.0.5](https://github.com/AvdLee/Moya-SwiftyJSONMapper/releases/tag/1.0.5) of the SwiftyJSONMapper?  Hi guys i have this response from my call (using latest moya) . this only happened in GET i already encoded my string to make sure the url escaped but why the url response in the log keep using percent ? anyone can give any solutions ?

i want to made this %3F into ? , i already set in the APIProvider to removingpercentencoding but keep happening..

```
"Moya_Logger: [16/02/2017 13:01:16] Response: <NSHTTPURLResponse: 0x60000022ad80> { 
URL: https://someurl.com/v1/presets%3Funflatten=1

```
Thanks Done, solved by myself by edit the url endpoint... @Ank49 cool man.. sorry just read it.. My approach little bit different. I edit the urlendpoint something like this
```

//setting the header
        let endpointClosure = { (target: API) -> Endpoint<API> in
            let url = target.baseURL.appendingPathComponent(target.path).absoluteString.removingPercentEncoding!
            let defaultEndpoint = Endpoint<API>(URL: url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
            return defaultEndpoint.adding(httpHeaderFields: ["Accept": "application/json", "Content-Type" : "application/json", "Authorization" : token!, "X-Fingi-Signature":authSign], parameterEncoding: JSONEncoding.default)
        }
        
```  Thanks for the PR @fjcaetano! I'm going to pull the discussion into this PR.

Before I address some of the questions you have in #959, can you walk me through the use case you are trying to solve that doesn't lend itself to using `DownloadDestination` to declare where you want your file downloaded to? What do you think about having your `TargetType` case take a parameter on where to store the resulting download? Then you can construct the `DownloadDestination` in the `task` computed property. That way you would declaratively tell the request where to store the downloaded file and capture that location in your response closure (which is likely near the call site that you supplied the destination URL). Yeah, I don't think what you are proposing is unreasonable at all @fjcaetano. I just want to explore what is possible currently before considering expanding the API surface area. Thanks for walking me through your use case.

I don't think constructing the destination `URL` for the downloaded file outside of `TargetType` is necessarily a problem. In some cases it might be the right way to do it. You could certainly still construct the `URL` inside of `TargetType` as well, but having the capability to pass the destination `URL` to `TargetType` is a more general solution.

So in your use case, how do you plan on specifying that the files should be downloaded to the Documents directory? And how do you specify what the file should be named in the documents directory? In other words, how do you figure out the `URL` that would eventually be in the proposed `destinationURL`? Ah, I see. Thanks for sharing.

So, I do think that the question of whether or not to include a `destinationUrl` needs further consideration, and I would love to get the opinions of other @Moya/contributors.

On the other hand, for your particular use case, I might recommend a different architecture. Because the location of these files needs to be deterministic, I think that recommends specifying the destination `URL` declaratively even more. Having access to this `URL` would serve useful for other things like checking whether or not the file has already been downloaded before downloading it again. You could extract this from the asset `URL` as you say, or you could just construct the remote `URL`s differently. I imagine something like this:

```swift
fileprivate static let assetDir: URL = {
  let directoryURLs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
  return directoryURLs.first ?? NSTemporaryDirectory()
}()

enum Assets: TargetType {
  case star
  case checkmark

  var baseURL: URL { /* ... */ }

  var assetName: String {
    switch self {
    case .star: return "star.png"
    case .checkmark: return "checkmark.png"
    }
  }

  var path: String {
    return "/assets/" + assetName
  }

  var localLocation: URL {
    return assetDir.appendingPathComponent(assetName)
  }

  var downloadDestination: DownloadDestination {
    return { _, _ in return (self.localLocation, .removePreviousFile) }
  }

  var task: Task {
    return .download(downloadDestination)
  }

  /*
    Rest of TargetType
  */
}

class AssetLoader {
  let provider = MoyaProvider<Assets>()

  init() { }

  func load(asset: Asset, completion: ((Result<URL, MoyaError>) -> Void)? = nil) {
    if FileManager.default.fileExists(atPath: asset.localLocation.path) {
      completion?(.success(asset.localLocation))
      return
    }

    provider.request(asset) { result in 
      switch result {
      case .success:
        completion?(.success(asset.localLocation))
      case let .failure(error):
        return completion?(.failure(error))
      }
    }
  }
}
``` @fjcaetano üëç. I think that refactor sounds like a good idea because then you can centralize the responsibilities of managing assets into a single object--and I like that separation of concerns. I could see it also being beneficial to you if decide to do asset preloading, batch downloading, etc. It could really be a nice replacement for ODR.

Let's keep this PR open though and see if we can get more feedback on this for other use cases, and thanks again for your contribution! I'm gonna close this one due to inactivity. Thank you for taking your time for this PR though, @fjcaetano. 

To give my opinion about this one, I'm not sure `destinationURL`, which is `nil` most of the time (for normal `request` & sample data), is the best way to implement it. Maybe an enum property that would be having special metadata based on the task type would be better? Not sure. What i know for sure is that this example with assets by @scottrhoyt should be added to our examples. 

**Edit:** I've added a PR with new example, #1113.  Based on the discussion in #818 I have finally converted `Moya.xcodeproj` to use a single target for all platforms. The idea comes from the people over at PromiseKit, they even published a [blog post about converting to a single scheme](http://promisekit.org/news/2016/08/Multiplatform-Single-Scheme-Xcode-Projects/).

I've been working on scripting the ideas from the post above using [`xcodeproj`](https://github.com/CocoaPods/Xcodeproj) and the results can be seen in the tool I created called [framework-generate](https://github.com/petester42/framework-generate). I used `framework-generate` to generate a new `Moya.xcodeproj` file by using a specification that can be found [here](https://gist.github.com/petester42/7ad0312dd1c1dcff780f2f95936200ea). 

I wasn't sure if I should add a dependency to Moya for `framework-generate` and the specification file. So let me know what everyone thinks about the change to single target for all platforms and also adding `framework-generate` as a dependency.

 @aaroncrespo @petester42 , code coverage is being tracked. The shortcut for testing is nice to have. Anyway to bring that back? First error is just that you need to put an entry in the `CHANGELOG`.

Second error is probably getting confused with the new project structure, thinking dependencies have changed the libraries are no longer in the "Linked Libraries" section but instead are found via a platform specific framework search path.

First warning won't go away because of the # of lines changed in the PR, that's fine.
Second warning is a reminder to add some documentation for big new features, but this doesn't warrant that.

So basically just worry about the `CHANGELOG`. Now, in general, I love this idea and want to see it happen. But I have to confess I'm a novice with this sort of conversion.

Some of my questions:
 * Will this work with both Carthage and Cocoapods? And have both been tested?
 * Does this method work with Carthage prebuilt binaries incase we want to introduce that for Moya?
 * Are there any other downsides to this?
 * This won't be breaking for anyone will it?
 @scottrhoyt: I'm not an expert, but I think it **should** just make maintaining the Moya.xcodeproj a lot easier.

> Will this work with both Carthage and Cocoapods? And have both been tested?

It works fine with Cocoapods & Carthage ([PromiseKit](https://github.com/mxcl/PromiseKit/tree/swift-3.0) has one target and they support both + SPM). 

> Does this method work with Carthage prebuilt binaries incase we want to introduce that for Moya?

I'm not sure about this one. I think it should - since all we're doing is merging the targets, which should just mean we need to build the one target for each device type - but we should test before merging.

> Are there any other downsides to this?

Just that what we're doing isn't officially supported by Apple. http://promisekit.org/news/2016/08/Multiplatform-Single-Scheme-Xcode-Projects/ is a great resource on this idea

> This won't be breaking for anyone will it?

Not to my knowledge Thanks for your thoughts @AndrewSB! I definitely like the maintenance reducing-nature of this. I'd like to see us get a prebuilt binary out (opened #983 to address), but if that is incompatible with this, I think I would rather have this. Especially since build caching and "only rebuild on change" behavior is in the near term Carthage pipeline, so prebuilt frameworks will lose a certain amount of their benefit. @petester42 I'd love to get this merged in. Do we just have those three issues left?

> ‚åò + U for the targets
> Code coverage is now enabled again
> Carthage framework copy script is now part of the source control. So after rebasing this & fixing CI, this should be ready to go. 

If no one else has taken a stab at resolving conflicts by tomorrow, I'll give it a shot and add some contributors as reviewers for this before we merge in üòÑ  I rebased, but we were still having a conflict, so I merged Podfile.lock. Going to get this CI passing and then we should be good to go üòÑ  Apparently something is wrong with Danger, but it looks like a nonsensical error. The Dangerfile on this branch matches the one on `master`. Can a @Moya/contributors who's familiar with Danger try to debug this? Thank you everyone for your work! I'm excited that we got this merged in üòÅ  Closes #952   Just to clarify @ftp27, what version of Moya are you using? The behavior for plugins to modify requests was introduced in 8.0.0. Also, a couple of other things to check. Are you using an endpoint closure or request closure to modify the request at all? Is there any chance that middleware on your server might be stripping the authorization headers? Thanks for the information @ftp27. If you aren't using anything but this code, then you don't have to worry about the closures I mentioned.

I can confirm that plugins do work with GET requests. However, if you can share a project that reproduces this problem, I would be happy to help you debug. @ftp27 Hey, I tried the project locally and it seems to work fine ü§î 

This is the request log in [Charles](https://www.charlesproxy.com/): 

```
GET /api/v1/services/book HTTP/1.1
Host	tcars.indev-group.eu
Connection	keep-alive
Accept	*/*
User-Agent	moyaTest/1.0 (eu.indevgroup.moyaTest; build:1; iOS 10.2.0) Alamofire/4.3.0
Accept-Language	en;q=1.0
Authorization	Token eb1b505e8634d19a2ece786274bdfbe23925d223
Accept-Encoding	gzip;q=1.0, compress;q=0.5
```

The output from `NetworkLoggerPlugin` is similar to one you shared (includes the Authorization header).

Do you think it could be something with wireshark itself? @ftp27 Ugh, that's weird. Can you confirm the same thing happens with other header fields? Something like:

```swift
request.addValue("Token " + token, forHTTPHeaderField: "TestHeader")
```

I'm not sure why it would be different, but I'm running out of ideas. I can attest to plugins being able to insert authorization headers for GET requests because I'm using it for that in production.

Perhaps Wireshark is filtering Authorization headers for some reason? Can you try inspecting the request via another method (like Charles)? @scottrhoyt Yep, [we tried that](https://github.com/Moya/Moya/issues/965#issuecomment-279696119). I was also able to reproduce the issue of not seeing the Authorization header in Charles, even though I saw it on my first attempt.

I still think that the header is being sent in the request and not showing up in wireshark/Charles for some reason. Sorry ü§¶‚Äç‚ôÇÔ∏è . Should have read better!

@pedrovereza I agree. I'm running out of other ideas. Can we look at the server logs themselves to check? Or change the url to https://httpbin.org/get and see what it sends back? @scottrhoyt Good idea on using https://httpbin.org üôå 

As seen in Charles:

```
REQUEST CONTAINING AUTHORIZATION

GET //get HTTP/1.1
Host	httpbin.org
Connection	keep-alive
Accept	*/*
User-Agent	moyaTest/1.0 (eu.indevgroup.moyaTest; build:1; iOS 10.2.0) Alamofire/4.3.0
Accept-Language	en;q=1.0
Authorization	Token eb1b505e8634d19a2ece786274bdfbe23925d223
Accept-Encoding	gzip;q=1.0, compress;q=0.5
```

And response from https://httpbin.org/get
```json
{
	"args": {},
	"headers": {
		"Accept": "*/*",
		"Accept-Encoding": "gzip;q=1.0, compress;q=0.5",
		"Accept-Language": "en;q=1.0",
		"Authorization": "Token eb1b505e8634d19a2ece786274bdfbe23925d223",
		"Host": "httpbin.org",
		"User-Agent": "moyaTest/1.0 (eu.indevgroup.moyaTest; build:1; iOS 10.2.0) Alamofire/4.3.0"
	},
	"origin": "201.47.197.212",
	"url": "https://httpbin.org/get"
}
```

I could not reproduce the case of not seeing the field in the request but seeing it in the response.  I think I probably don't need this method But if I deleted he appears does not conform to the protocol 'TargetType' if you don't delete I don't know how to implement the method
![Uploading 3.43.47.png‚Ä¶]()

 Hey, what method is it you are talking about? It seems like your image didn't get uploaded. For `task`, you normally return `.request`: https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md#basic-usage Not awkward at all! Did that resolve your issue? :)  Hey, would something like this work for you?

```swift
extension MoyaProvider {
    class func withDefaultPlugins() -> MoyaProvider<Target> {
        return MoyaProvider<Target>(plugins: [NetworkLoggerPlugin(verbose: true)])
    }
}
```

Usage:

```swift
let provider = MoyaProvider<MyService>.withDefaultPlugins()
``` @kemchenj Oh, I see.

So, would moving the extension to `RxMoyaProvider` be enough?
```swift
extension RxMoyaProvider {
    class func withDefaultPlugins() -> RxMoyaProvider<Target> {
        return RxMoyaProvider<Target>(plugins: [NetworkLoggerPlugin(verbose: true)])
    }
}
```
Or do you need `withDefaultPlugin` available for both `MoyaProvider` and `RxMoyaProvider`?

*Not saying that your changes are good/bad, just trying to understand the use case* üòÑ
 @kemchenj no problem, don't worry about that. About your idea with conforming to protocols: I love it. Would you be up for doing the PR with this idea implemented? :)

About `final` on `MoyaProvider` - I'm not sure about that. People may rely on subclassing it. I also really like `.rx` and `.reactive`! Okay, @BasThomas took a stab at it, I'm gonna close this one then. Thank you so much @kemchenj for you work, we really appreciate it! üôá   According to the [changelog](https://github.com/Moya/Moya/blob/master/Changelog.md), there were slight changes made to the capitalization of `newHttpHeaderFields`. I've updated the docs to reflect the change.

Solves #961 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  @fjcaetano, I am having a bit of a hard time wrapping my head around the use case and implications of introducing this since I don't normally use download tasks in Moya. If the solution is pretty straightforward, what do you think about opening up a PR with the feature to further discussion? Closing this one in favor of #968.  Hey @moonorblue. It would be unlikely that your data was base64 encoded unless you explicitly put it that way. I think what you most likely want is:

```swift
let string = String(data: data, encoding: .utf8)
```

Alternatively you can put a helper function in `TargetType` for that. You can check out how that was done in this PR: #881. Oh, yeah @moonorblue. Sorry, disregard what I said about the `String` transform. My head was stuck in my own project. You just need to return the `Data` so just use `Data(contentsOf:)`. Copy and pasting that code from the PR should work fine for you.  Did you add an `EndpointClosure` or `ResponseClosure` to the provider that might be adding these? Is the original logging output you show from your server? Is it possible that your server is mapping those extra fields? It could be happening in middleware somewhere. Your `curl` is url encoding the parameters instead of submitting them as JSON in the body though. Could that make a difference? Well, I'm still not sure that it is on the client side. For one, I don't know where that `authentication` key would even be coming from. My guess is that the server is using some middleware to create an `authentication` object based on what is in the body of the request.

You can try this theory out by using Alamofire against your own server to see if you see the same behavior.  The POST example in `Basic.md` currently sends the parameters encoded in the URL. I don't think this is the most common way of sending parameters in a POST request ü§î  

I believe the usual case is to send parameters in the request body as JSON. Having this in the most basic example may be more helpful to people using Moya for the first time. @vzsg Good question! 

What are the most basic (and common) cases that we should cover in this example? We don't have a GET with URL query parameters as well ü§î  This example you've added is good, but we could also add the basic `URLEncoding` below/above the example with `JSONEncoding`, imho. @sunshinejr You mean adding just a note on how the POST request would look like if `URLEncoding` was used instead? I was thinking about doing one more request with different type of encoding, maybe just below the one with user, and then make a comment how would it look like. But your suggestion works as well, make a comment how could it look like with `URLEncoding`. @sunshinejr Doing another request feels more complete üëç 

Added a new endpoint to update a user passing the parameters in the URL, let me know what you think (cc. @vzsg) Should be good now üòÑ   Your `ParameterEncoding` for `.login` should be `JSONEncoding.default`:

```swift
public var parameterEncoding: Moya.ParameterEncoding {
    return JSONEncoding.default 
}

```  Thanks for bringing that up though! We should put that on our radar for Swift 3.1 release @Moya/contributors. This is true indeed; Swift 3.1 should be source compatible with 3.0. @ened as long as we can verify that doing so still offers the fix-its when trying to use the renamed methods, I think that is reasonable. Thanks everyone. PR inbound. This fix has not been included in a release yet, right @scottrhoyt?  I think [Artsy's Eidolon](https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/ArtsyAPI.swift) should give you an idea of how it looks like in a real product. [Here](https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/ArtsyAPI.swift) is where their API is defined using Moya. That's the approach I use as well. In order to keep the boiler plate down in the many `TargetType`s that I create, I also introduce some defaults for `TargetType` as seen in #861.  Yep. Just drop something like [this](https://github.com/Moya/Moya/blob/e1eda4b5d637f8a4bba1519f2f3176fb2bc508fb/Source/Target.swift#L32) in.  Heads-up in the meantime - you can highlight the syntax in the code snippets with ```swift at the start. :) Interested to hear what other @Moya/contributors think about this.

I would still lean towards saying that unless Moya gets in the game of deserializing objects, this is the purview of Moya Extentsions. This could be added via an extension on `MoyaProvider`. However, an approach like this does have the advantage of creating a common interface for extension providers, and, thus, allows them to standardize their own interfaces.

I think one reason this hasn't been a bigger issue is that I think a large percentage of the user base is using the reactive providers, which already provide a cleaner interface for response handling and object deserialization through Moya extensions. There's also probably some legacy reasons since the current callback pattern aligns closely with Alamofire's. I still don't have a position on this matter.

My first thought was to agree with @scottrhoyt:
>I would still lean towards saying that unless Moya gets in the game of deserializing objects, this is the purview of Moya Extentsions. 

Extended support for parsing feels a bit outside the scope of Moya, which is nicely pointed in the Readme: 
>  So the basic idea of Moya is that we want some network abstraction layer that sufficiently encapsulates actually calling Alamofire directly.

On the other hand, if you check all plugins listed in the Readme, only MoyaSugar is not about JSON serialization:

>Moya-ObjectMapper - ObjectMapper bindings for Moya for easier **JSON serialization**
Moya-SwiftyJSONMapper - SwiftyJSON bindings for Moya for easier **JSON serialization**
Moya-Argo - Argo bindings for Moya for easier **JSON serialization**
Moya-ModelMapper - ModelMapper bindings for Moya for easier **JSON serialization**
Moya-Gloss - Gloss bindings for Moya for easier **JSON serialization**
Moya-JASON - JASON bindings for Moya for easier **JSON serialization**
Moya-JASONMapper - JASON bindings for Moya for easier **JSON serialization**
Moya-Unbox - Unbox bindings for Moya for easier **JSON serialization**
MoyaSugar ‚Äì Syntactic sugar for Moya
Moya-EVReflection - EVReflection bindings for Moya for easier **JSON serialization** (including subspecs for RxSwift and ReactiveCocoa)
Moya-Marshal - Marshal bindings for Moya for easier **JSON serialization**

Is this an indication that we should be giving better support for JSON serialization? Why does everyone feel like they have to build their own? 

This can be seen as a missing feature, but also as *flexibility*: parsing can be done in several ways and you can pick the one that fits your app better. A while ago I was trying to make something similar (make an option to `TargetType` that can map the response), but given tools of Swift 2.2 I wasn't satisfied with any of my results. 

Unfortunately with your proposition and passing parser to request function it makes _me_ responsible for remembering how should I parse the response every time, so I still need some abstraction layer over Moya to get what I want (thus I don't see much pros in this one). Although as @scottrhoyt said, this have an advantage with option to make a standard protocol for object parsing. @pedrovereza 

I think the quantity of JSON parsing extensions is just representative of how many popular JSON deserialization libraries there are. That is indicative of how for a while no single best practice had emerged in crossing the weakly typed/strongly typed gap. It seems now that a single pattern has emerged in multiple libraries.

Actually, what I would like to see is a Swiftier implementation of `NSCoding` that all these libraries could leverage or perhaps interface directly with `JSONSerialization`. It would be great to have better basic language support for object serialization that cares at least as much about JSON as PLIST.

As for better support of object serialization in Moya, that would mean either:
1. Writing our own JSON deserialization
2. Including one of more of the current JSON libraries as dependencies

It's hard for me to argue for 1 when we haven't written our own Alamofire. And doing 2 would come with the responsibility of recommending a best choice of library(s). I don't know if there is one right now. The last time I made this choice, I just picked the one that was already in my dependency graph. As an aside, it is interesting that the highest level of abstraction in this stack is really the Moya extension you choose for JSON deserialization. Drop that in your Cartfile/Podspec and you get everything else you need. My thoughts: https://xkcd.com/927/
On Wed, Feb 8, 2017 at 9:39 AM Michael Sanderson <notifications@github.com>
wrote:

> The idea is to take Moya the last mile, so clients don't have to do
> parsing in their completion blocks at the call site. I think @pedrovereza
> <https://github.com/pedrovereza> 's comment that's what nearly all the
> extensions do reflects that. In this generic solution, since there's no way
> through Swift's type system to have enums vend closures returning different
> types, the call site still needs to know which parser to use. Putting the
> parser in the function signature removes one concern from the completion.
>
> (This is obviously less of a concern for the reactive variations that use
> lenses throughout their entire structure. Of course it could be moved up
> for them as well.)
>
> As @scottrhoyt <https://github.com/scottrhoyt> said allowing extensions
> to standardize their own interfaces would be a benefit and allow better
> integration. Because of generics this needs to be done carefully, as the
> generic function parameters func request(TargetType, (Response) -> T,
> completion (T) -> Void)don't hold up when passed a generic
> function--legitimately, because all type information is gone. Typing the
> completion block only sometimes fixes this.
>
> Actually, browsing through the extensions it seems like all of them work
> by requiring T to conform to some protocol -able for the library, usually init(_
> json: JSON)? Assuming the compiler could be instructed what the type is,
> it would be possible to have a protocol init(from response:
> Moya.Response) throws and put the requirement in the generic function
> constraint.
>
> However, maybe it's my experience parsing terrible JSON but I would be
> against creating the expectation that JSON parsing can be accomplished
> automatically from endpoint-magic-object. There's a gap between
> endpointJSON and model, that clients need to be explicitly and consciously
> bridge. The place to do that is the TargetType, but that was a dead end for
> enums.
>
> In the case of completion blocks it makes sense that the knowledge of how
> to get the response into the app domain should have been made as part of
> the call. Baking *the option* to provide a parser of choice -- an option,
> because this would be able to live alongside the existing method and
> immediately use into it -- would make Moya more end-to-end by covering the
> final distance.
>
> ‚Äî
> You are receiving this because you are on a team that was mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/950#issuecomment-278202738>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dCOtObOkVw2WqdCSy7OdpQJyvrHmks5raRzJgaJpZM4L2xjp>
> .
>
 > I love XKCD, and assume people are taking the moment to laugh at this classic.

@michaelsand Yes, I was honestly laughing at the comic itself, no intention to make fun of your proposal. Apologies if it sounded that way.
 I was just happy that I wasn't the only one laughing about the state of JSON deserialization in Swift! :) Your ideas are truly welcome @michaelsand. This is what pushes the project forward. @michaelsand I'm sorry about how l made you feel by posting a comic. I had no intention of disrespecting you, or the proposal you clearly have put a lot of thought into.

I'm not working right now, so I haven't been spending as much time keeping up with the project, when I glanced at your issue in an email it was the first thing my mind jumped to.
I should have provided substantive feedback, and put greater thought into how simply posting a comic would have come across in this situation.

I hope I haven't tainted your opinion of this community and that you're still excited to contribute to this project. I'm still 100% against Moya taking an opinionated stance on how to handle responses. It's easy for us to extend the `Response` type with more properties from the `NSURLSession` or even the `NSHTTPResponse`, but it gets incredibly nasty when we start saying "this is how you really wanted the data to be" and start adding all sorts of JSON/XML/(insert response format here) parsers and types for handling those. The worst thing we can do, by providing a native parser, is force it on our users, thus removing the flexibility of the library and introducing some wild wild west for working around such an opinion.

As @sunshinejr mentioned, there's still going to be some abstraction implemented. With the reactive providers, you can easily extend the reactive types to process the response, and I think that consumers of the default `MoyaProvider` should be doing the something similar.

One implementation suggestion is to provide serialization closures, which get passed to the `MoyaProvider`:
```swift
func zenResponseHandler(result: Result<Moya.Response, Moya.Error>) {
  /// Handle the zen response
}

provider.request(.zen, completion: zenResponseHandler)
```
Another suggestion would be to extend the `MoyaProvider` and implement your own `request` methods:
```swift
extension MoyaProvider {
  func requestZen() -> Result<MyResponse, MyError> {
    return provider.request(.zen) { result in
      /// Process the response
    }
  }
}
```

I completely understand the motivation, but what I've found in the multiple projects and applications I've built that use Moya is that there is no single one-size-fits-all solution. Never have I pulled a serialization layer from a previous project and used it in a future project.

*EDIT:*
As OP mentioned, wouldn't it be possible to just extend the `Response` type to provide custom mapping functions to transform to custom types?
```swift
extension Response {
  func mapObjects<T>() -> throws [T] {
    guard let myResponseType = MyType(data) else { throw .mapError }
    return myResponseType
  }
}
``` FWIW, my perspective is that of a `ReactiveMoya` user. I guess the way I'm viewing Moya is that it takes in a `TargetType` and it gets you a `Response`. I get the response, check it for errors, map it into some result and send it on it's way.

Taking on @colinta's challenge for a dissenting opinion:

```swift
public func authenticate(type: AuthType, username: String, password: String) {
    provider.request(.auth(type, username: username, password: password), completion: { result in
        do {
            let response = try result.dematerialize()
            let authToken = try response.mapAuthenticationResponse()
            /// Store the auth token
            /// Update the UI
        } catch let error as AuthenticateError {
            /// Show an alert
            self.showAlert(title: error.title, message: error.message)
        } catch {
            /// Handle other errors
        }
    })
}

extension Moya.Response {
    func mapSwiftyJSON() throws -> JSON {
        let json = try mapJSON()
        return JSON(json)
    }
    
    func mapAPIResponse() throws -> MyAPIResponse {
        let json = try mapSwiftyJSON()
        return MyAPIResponse(json: json)
    }
    
    func mapAuthenticationResponse() throws -> String {
        do {
            let response = try mapAPIResponse()
        } catch {
            throw AuthenticateError.underlying(error)
        }

        if response.isError {
            /// Parse and throw an Authenticate Error
            throw AuthenticateError.invalidPassword("Password is invalid")
        }
        
        if let authToken = response.data["authToken"] {
            return authToken
        }
        
        throw AuthenticateError.invalidToken("Could not find valid auth token")
    }
}

enum AuthenticateError {
    case invalidToken(String)
    case invalidUsername(String)
    case invalidPassword(String)
    case underlying(MoyaError)
    
    var title: String {
        return "Uh-oh"
    }
    
    var message: String {
        switch self {
        case let .invalidPassword(message):
            return message
        case let .invalidUsername(message):
            return message
        }
    }
}
```

The more I look into this, the more I realize that this is just a recreation of what the reactive users already have (in terms of [this](https://github.com/Moya/Moya/blob/master/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift#L26-L34)).

I think this is mostly an improvement for the users who don't use any of the extensions. I like the opt-in/opt-out functionality, and the non-breaking aspect of it. I guess my main point is that this functionality is currently achievable by extending the `Response`, though it's not immediately obvious.

*Edit*
Updated to reflect concerns from @michaelsand regarding throwing errors of certain types... I really dislike the concept of `throw`ing in Swift because, in most cases, you have to have domain information to know what kind of Error the function is going to throw, given the fact that the `Error` type isn't dictated in the method signature. We've bumped up against the limit of what is possible with generics in Swift. The compiler needs type information sooner or later. IMO the safest and DRYest way to do that is to wrap the provider in an object that provides type information and deserialization. I know it doesn't feel as nice as we'd like it to, but neither does the unconstrained polymorphism of the other options or creating one `TargetType` per return type. The above options can help you write that wrapper, but I would say a better separation of concerns is to put the extension on the response deserializer itself by allowing it to ingest `Data` and then pass it `Response.data`. Alternatively you could just use the output from `mapJSON`, a dictionary that nearly all the libraries support.

As an aside, I assumed that the reason we don't see `dematerialize` used more often was that we were using `Alamofire.Result` and not `Result.Result`. [I see I am wrong](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider.swift#L2). We should probably add that to our Cartfile explicitly instead of relying on it being there (from ReactiveSwift, I think). I'll open up a PR for that. @scottrhoyt Comment on your aside regarding Result: We need to be mindful about the version numbers. Since ReactiveSwift also relies on it, we need to keep that in sync with their version, especially for the users that are using the binary distribution (i.e. me). @michaelsand I agree with a lot of what you said, especially around the free-floating `AuthenticateError`. However, I don't think calling the other functions is a deal, particularly because the `Error` stays as a `MoyaError` until you hit the `mapAPIResponse()`.

 As I mentioned, it's not the prettiest in regards to error handling, but that could easily be changed to work like so (this is untested sudo-code, my brain compiler gives it the üëç):
```swift
extension Response {
  func mapAuthenticationResult() -> Result<String, AuthenticateError> {
    do {
      let authToken = try mapAuthenticationResponse()
      return .success(authToken)
    } catch error as AuthenticateError {
      return .failure(error)
    } catch {
      return .failure(.underlying(error))
    }
  }
}

```
IMO, the most valuable part of the `parser` function is the type information that can be provided.

That said, since we would be changing the call site to pull the correct parser and apply it, I'm leaning with @scottrhoyt that we should just wrap the provider and modify it to work accordingly with completion blocks.

Wrapped Example:
```swift
struct NetworkProvider {
  struct Parsers {
    static func authentication(type: AuthType) -> ((Moya.Response) -> String) {
      return { response in
        /// Transform response
      }
    }
  }

  var provider: MoyaProvider<MyAPI>
  func request(target: MyAPI, parser: (Moya.Response) -> T, completion: Result<T, MoyaError>) {
    provider.request(target) { result in
      do {
        let response = try result.dematerialize()
        completion(.success(parser(response)))
      } catch {
        completion(.failure(.underlying(error)))
      }
    }
  }
}

let provider = /// Create some provider
let networkProvider = NetworkProvider(provider)

networkProvider.request(.auth(.signIn, username, password), NetworkProvider.Parsers.authentication(.signIn)) { result in
  /// TODO: Handle the result
}
```
In-line Example:
```swift
public func authenticate(type: AuthType, username: String, password: String) {
    let parser = Parsers.authentication(type)
    provider.request(.auth(type, username: username, password: password), completion: { result in
        do {
            let response = try result.dematerialize()
            let authToken = parser(response)
            /// Store the auth token
            /// Update the UI
        } catch let error as AuthenticateError {
            /// Show an alert
            self.showAlert(title: error.title, message: error.message)
        } catch {
            /// Handle other errors
        }
    })
}
``` Thank you @michaelsand for the thoughtful idea and discussion. I personally would love to have you contribute to Moya wherever/whenever you'd like! I'm gonna close this one for now since there is no activity, but feel free to reopen it whenever.  Cool project! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  I share your desire to find a way to inject return type information into the `TargetType`s themselves, @michaelsand. This is definitely a creative approach to doing so within the constraints that Swift gives us. On the other hand, it adds considerably complexity. What I would ask is do you think this system of callbacks is better than injecting the type information in a wrapping layer? Something like this:

```swift
class GitHubClient {
  let provider = MoyaProvider<GitHubApi>()

  func getZen(completion: (Result<String, Error>) -> Void) {
    provider.request(.zen) { completion(parseString($0)) } // using your `parseString` function
  }
}
```

I understand this approach is removing the return type information from the `TargetType` by a degree, but I think the advantage is a simpler `TargetType` set up and simplicity at the call site while not expanding the API surface area. The other advantage to the wrapper approach is that the pattern is compatible with `RxMoyaProvider` and `ReactiveMoyaProvider`. It is hard for me to see the direct analog for the callback solution you proposed. That is an interesting idea. However, if the `parseAndComplete` `completion` isn't strongly typed, then you still need to supply the type information for the response deserialization at the call site with no compile-time guarantees. In general, that is a similar situation as we are in right now when using the Moya extensions for object deserialization. 

Also, while it is a natural extension to have a `TargetType` provide information on what return type is expected, I think it might be going too far to have `TargetType` also provide the information on how to deserialize a `Response`. Right now `TargetType` knows nothing about how requests are processed, and this proposal would suggest that it become aware of at least `Response` and the mechanisms used to deserialize it (likely a 3rd party library). This responsibility seems better placed at the `MoyaProvider` layer or above.

The proposal then comes down to:
1. Establish a way to document what return type is expected in `TargetType`
2. Provide better completion handler usability for `MoyaProvider` when both the return type and method of deserialization are known

I think 1 can be accomplished in any number of ways. I would say 2 is up to the creators of Moya extensions since I don't see any reason why they can't create a similar extension on `MoyaProvider`.

Because of the impedance mismatch between a weakly typed internet and a strongly typed Swift, it will always be incumbent on the developer to introduce the specific knowledge necessary to resolve that discrepancy. I sadly don't see a way of ever providing a generic construct for that if the tool is an `enum`.  As discussed in #946 Now we're at it, how do the Reactive extensions work with SwiftPM? I think we can keep it as `pod 'Moya'` (we always want people to be using the latest version, I feel) Yeah, that might be even better. Does SwiftPM work like that as well? It seems like we need to at least provide a `majorVersion` [there](https://github.com/apple/swift-package-manager/blob/master/Documentation/Reference.md#package-dependency).  Fixes #942  Good point @bjarkehs; we actually rely on Alamofire 4.1 (https://github.com/Moya/Moya/pull/797) Changes seem good üíØ 

Should we plan a new release or is it too soon? Makes sense to do a patch release I think üëç  Seems like a problem with these lines in Podspec:
```
ss.dependency "RxSwift", "~> 3.1.0"
ss.dependency "Alamofire", "~> 4.2.0"
```

change to `~> 3.0` and `~> 4.0` accordingly, could fix the problem, but there might be a reason why we have it this way (I'm out of the loop lately). Because of this we should discuss the fix with @Moya/contributors first. We could just higher up the versions of pods as well. Let's see if we can update our dependencies. It would actually be really nice to have some sort of dependency update check somewhere to keep us up to date. What do you think, @Moya/contributors? Should I create a separate issue? Or we should do what @sunshinejr suggested, using just `~> 3.0` and `~> 4.0` respectively. Not sure what is the best option here. I would go with @sunshinejr's suggestion for the time being. @andreyfel Moya 8.0.2 was release and should fix your problem. Can you please update and let us know if you still have issues? :wink:  Fixes #811 

@ashfurrow [gave us the answer](https://github.com/Moya/Moya/issues/792#issuecomment-262812613) in #792: the semver regex should accept an optional `-beta.a`.

I didn't hardcode it `beta` to give us the flexibility to go with `alpha`, `rc` or whatever makes sense in future versions.  Nice! üôå  This looks pretty interesting @migue1s. Do you think it's related to #819 as well?

It would be really awesome if you'd make a Pull Request with your change, so people can discuss your solution, and we can get your bug fixed! @migue1s, @vaunus the problem with double `onNext` event after `filterCompleted` should be resolved after #1095. We still need to find the issue with hanging in the progress. If any of you guys have time and want to help us, PR would be greatly appreciated. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
 Hey @PatrickSCLin, do you still encounter double `onNext` event? What version of Moya do you use? Is it with RxSwift? Would you be able to make a new test project where this issue happens, @PatrickSCLin?  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Since your friend's website builds page URLs using query parameters, you will probably want to use the `parameters` property to supply this information as well:

```swift
var path: String {
  return ""
}

var parameters: [String: Any]? {
  switch self {
    case .index(let page):
      return ["action": "index", "page": page]
  }
```

and make sure you use a `URLEncoding` for `parameterEncoding`. Expanding @scottrhoyt response:

```swift
enum MobileAPI {
    case index(page: Int)
}

extension MobileAPI : TargetType {
    public var baseURL: URL { return URL(string: "http://mobileapi.blah.info")! }

    public var path: String {
        return "/1/"
    }

    public var method: Moya.Method {
        return .get
    }
    
    public var parameters: [String : Any]? {
        switch self {
            case .index(let page): return ["action": "index", "page": page]
        }
    }
    
    public var sampleData: Data { return Data() }
    
    public var task: Task { return .request }
    
    public var validate: Bool { return true }
    
    public var parameterEncoding: Moya.ParameterEncoding { return URLEncoding.default }
}
```

Usage:

```swift
        let mobileAPIProvider = MoyaProvider<MobileAPI>()

        mobileAPIProvider.request(.index(page:1)) { result in
            switch result {
            case let .success(response):
                // do something with response
            case let .failure(error):
                print(error)
            }
        }
```

This produces the request you want:
`["Moya_Logger: Request: http://mobileapi.blah.info/1/?action=index&page=1"]`

Let us know if you have more questions :wink:  Hey @tosbaha, thank you for making an issue üòâ 

I'd recommend starting out by taking a look at #748. I had a discussion with someone else who had a similar questions about Authorization.
After that, take a look at @scottrhoyt's contribution (https://github.com/Moya/Moya/pull/893). It has a plugin for AccessTokens.

For loading a resource with retryability, it's as simple as `.retry(2)` (to retry twice when you're using RxMoya). Moya doesn't offer any custom functionality for retrying, so all of your retrying has to be done through RxSwift. There are some great resources for using RxSwift's retry, that you can find in the first couple resources [here](http://lmgtfy.com/?q=rxswift+retry)

Come back with any lingering questions you have üòÑ 
We'll be happy to help you out Closing this due to inactivity, let us know if you still need help @tosbaha   This is an interesting proposal. I'm curious what other @Moya/contributors think.

My initial reaction is that this decomposition of `TargetType` would only be truly valuable if the separate protocols were useful for something other than being inherited by `TargetType`. If we are saying that all these things are necessary to have a `TargetType` and they aren't useful for anything else, then I maintain that they should be part of the `TargetType` itself.

The primary benefit of this decomposition is to provide a framework for structuring your implementation of `TargetType`, but it is a very loose framework at that since I could also do this:

```swift
extension GitHubUserContent: TargetType, TargetURLType, TargetHTTPMethodType, TargetParametersType, TargetSampleDataType, TargetValidationType {}

extension GitHubUserContent {

  public var baseURL: URL { return URL(string: "https://raw.githubusercontent.com")! }
  public var path: String {
    switch self {
    case .downloadMoyaWebContent(let contentPath):
      return "/Moya/Moya/master/web/\(contentPath)"
    }
  }
}

extension GitHubUserContent {

  public var method: Moya.Method {
    switch self {
    case .downloadMoyaWebContent:
      return .get
    }
  }
  public var parameters: [String: Any]? {
    switch self {
    case .downloadMoyaWebContent:
      return nil
    }
  }
  public var parameterEncoding: ParameterEncoding {
    return URLEncoding.default
  }
}

extension GitHubUserContent {

  public var sampleData: Data {
    switch self {
    case .downloadMoyaWebContent:
      return animatedBirdData() as Data
    }
  }
}

extension GitHubUserContent {

  public var task: Task {
    switch self {
    case .downloadMoyaWebContent:
      return .download(.request(DefaultDownloadDestination))
    }
  }
}
```

And neither of these strike me as having much more benefit than what is possible now:

```swift
extension GitHubUserContent: TargetType {}

// MARK: - URL construction

extension GitHubUserContent {

  public var baseURL: URL { return URL(string: "https://raw.githubusercontent.com")! }
  public var path: String {
    switch self {
    case .downloadMoyaWebContent(let contentPath):
      return "/Moya/Moya/master/web/\(contentPath)"
    }
  }
}

// MARK: - Method and Parameters

extension GitHubUserContent {

  public var method: Moya.Method {
    switch self {
    case .downloadMoyaWebContent:
      return .get
    }
  }
  public var parameters: [String: Any]? {
    switch self {
    case .downloadMoyaWebContent:
      return nil
    }
  }
  public var parameterEncoding: ParameterEncoding {
    return URLEncoding.default
  }
}

// MARK: - Sample Data

extension GitHubUserContent {

  public var sampleData: Data {
    switch self {
    case .downloadMoyaWebContent:
      return animatedBirdData() as Data
    }
  }
}

// MARK: - Tasks

extension GitHubUserContent {

  public var task: Task {
    switch self {
    case .downloadMoyaWebContent:
      return .download(.request(DefaultDownloadDestination))
    }
  }
}
``` If the goal is to decrease the verbosity in a `TargetType` file, my recommendations would be to consider:
* Break up the API into multiple `TargetType`s, separated by file
* Potentially separate large `TargetType`s into multiple files. `parameters` and `sampleData` might be profitable opportunities to introduce another file.
* Use an approach similar to suggested in #861 for defaulting the trivial properties for a specific `TargetType`. Great! Thanks for following up @manas-chaudhari. That's actually an approach I wind up using as well!  Glad to hear. Thanks!  The build badge was reflecting the status of the latest build in Circle CI, which very often is not on branch `master`.

This changes the badge to reflect the status of `master`.

  This pull requests adds a progress parameter to the reactive providers to track progress changes of upload & download tasks. Currently it's impossible to track these changes and to use the same Moya provider for download & upload tasks. Ah indeed, I've fixed that. Also updated for the SwiftLint issue. Two tests seem to be failing:
```
a_subsclassed_reactive_provider_that_tracks_cancellation_with_delayed_stubs__cancels_network_request_when_subscription_is_cancelled, expected to be true, got <false>
```
```
provider_with_SignalProducer__a_subsclassed_reactive_provider_that_tracks_cancellation_with_delayed_stubs__cancels_network_request_when_subscription_is_cancelled, expected to be true, got <false>
``` Hmm, you're right. It's strange though, as it's executing exactly the same request method, only with the progress parameter added.

I'll look into it further tomorrow! Ok, I've fixed the tests, everything seems to be OK now. The only thing I want to discuss here, is that another solution is already available for progress tracking:

```swift
func requestWithProgress(token: Target) -> SignalProducer<ProgressResponse, MoyaError>
```

However, this doesn't really fit in our JSON parsing functionalities and needs some more code to write on our side to make it easy to track progress.

With this pull request we're introducing another way of tracking progress, which is quite more easy to use and feels simpler.

How do you guys think about this?
 The implementation in the PR makes sense to me. I am all for any suggestions to make the progress handling more straight forward in the reactive providers. However, I am not sure this is the right direction to take. A goal of the observer pattern is to replace the callback pattern. So, to have our reactive providers use elements of both the observer pattern and the callback pattern seems muddled to me. This would encourage the propagation of both observables and callbacks in the users' code.

Perhaps we could refine the current approach with `ProgressResponse`? Instead of it being a `struct` with a `Response?` and a `Progress?`, it could be:

```swift
enum ProgressResponse {
  case progress(Double)
  case response(Response)
}
```

That would simplify handling of progress/response emissions. In fact, we could go further and provide reactive operators like `onlyProgress()` and `onlyResponse()` that could flatmap the `Observable<ProgressResponse>` into a `Observable<Double>` and `Observable<Response>`, respectively. This would go further to support separating the flow of progress and response without needing to introduce inconsistent patterns.

While the change to `ProgressResponse` would be a breaking change, we could still provide those operators right now as an easier way to deal with `ProgressResponse` until we migrate to the `enum` approach in 9.0. Oops @leoneparise. I totally missed that we had the `filterCompleted()` and `filterProgress()` operators already. Thanks for pointing that out! I'm not sure the naming is unambiguous though (e.g. RxOptional's `filterNil()` takes optionals out of the observable, we follow the opposite semantics). Good discussion, I agree with the above. We'll look further into implementing it using the suggested methods. Thanks!  Hi guys i am using newest Moya version and swift 3.0
I have question, can we return some values in a function which will call a provider request ?
I need it bcs i will use that values in objective-c bridging, since i will use it for react-native .
The below code i use always return "" instead of dict that will be filled inside provider.request

```swift
public func setupRx() -> Any {
        
        provider = RxMoyaProvider<GitHub>()
        var dict : Any? = ""
        
        provider.request(.bible).subscribe { event in
            switch event {
            case let .next(response):
                //image = UIImage(data: response.data)
                do{
                    dict = try response.mapJSON()
                    try print("Dict is : ", dict)
                }catch {
                    print("Something wrong");
                }
            case let .error(error):
                print("Error : ",error)
            default:
                break
            }
        }
        return dict
}


//BRIDGING CODE in Obj-C for react-native

RCT_EXPORT_METHOD(connectToHub
                  
                  :(RCTPromiseResolveBlock)resolve
                  :(RCTPromiseRejectBlock)reject)
{
    RCTMain * helloWorld = [RCTMain newInstance];
    //call setupRx
    NSString *test = [helloWorld setupRx];
    //always nil never get the value from API that has been called inside setupRx
    NSLog(@"Test Dictionary return : %@", [helloWorld setupRx]);
    [self.bridge.eventDispatcher sendAppEventWithName:@"onHubConnected" body:nil];
}
```
Thank you..
 @vzsg Thank you so much sir.. Your solution using completion block is worked. Now i could get result in my obj-c bridging..  That's a good question, @gunterhager.

Before we investigate making this information available via the request closure, can you see if creating a custom `PluginType` would suit your needs? A `PluginType` has a `prepare` function that is called once the `URLRequest` has been created and is given an opportunity to return a modified request. `prepare` also accepts the target, so I believe you have the information needed there to meet this use case. What do you think? Great @gunterhager! Happy to help.    As seen in #923, some paths are now incorrect, as we changed the project's structure as part of supporting SPM.  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  Fixes #757

The issue on Circle CI [was fixed](https://discuss.circleci.com/t/os-x-build-image-update-xcode-8-2/9355) :tada:

I had to make a few changes to include not only the device name but also the OS version. Not sure if I took the best approach, suggestions are welcome :wink: Another idea for how to make this run a little smoother is to swap out the `build test` [here](https://github.com/Moya/Moya/pull/922/files#diff-52c976fc38ed2b4e3b1192f8a8e24cffR117) for a `build-for-testing test`. I have noticed better results that way as it delays the call to open the simulator until the test target has already been built. Therefore you are less likely to have a timeout issue.  Hey @Tolriq, this is not a stupid question at all. The behavior you are experiencing is not very well defined. The basic issue is that your `RxMoyaProvider` is being deallocated before the request can be processed. This is because it is a local variable that goes out of scope and the `Observable` it produces does not retain the provider strongly. This is related to #844 and the behavior that was changed in #905.

Since the new behavior hasn't been released yet, try pointing your dependency manager at the `master` branch to see if it behaves how you are expecting it to.

Also, storing a provider locally may not be a bad idea regardless. But instead of dynamically creating a new one each time you call `kodiHostHaveAddon`, can you instead just create a single provider and use it in multiple requests?

 ```ruby
pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'master'
``` Glad to hear it worked, @Tolriq! No release date set, but given that this issue has come up a couple of times, I think this could warrant `8.0.1`, what do you think @Moya/contributors? @scottrhoyt 8.0.1 makes sense to me. Should we open an issue to discuss? Yeah, I'd say go for it @pedrovereza. Closing this @Tolriq. Let us know if you have any other issues.  #911 might provide some insight.  Possibly ref #911   I haven't tried this before, but looking [here](https://github.com/Moya/Moya/blob/master/Sources/RxMoya/RxMoyaProvider.swift#L61) it appears the request will be cancelled if the `Observable` is disposed. So can you try disposing the `Observable`? Was that able to help you out @GorbAnthony? If so, can you close this issue please? Thanks.  Good catch! Any idea what's up with [CI failing](https://circleci.com/gh/Moya/Moya/1177?utm_campaign=vcs-integration-link&utm_medium=referral&utm_source=github-build-link)? It seems like the identifiers for the simulators have changed?  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  > The key deliverable here is the documentation.

Yup, this PR is only docs, which can only really help. I'm going to merge and we can refine later if we add first-class support into the library. Thanks again! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Cool! I'm happy the community saw value in this. @manas-chaudhari, we'll look for your next PR which implements the documentation we've added üòÑ   As @bjarkehs suggests, writing a custom `ParameterEncoding` could be a great idea. However, I might prefer searching for a `token` parameter to in `parameters` to url encode and then encode the rest as JSON--as opposed to taking the `token` as an initializer argument. However, that's a personal style and use case decision.

Another option would be to create a `PluginType` to do this. It would work similarly to `AccessTokenPlugin` so take a look [here](https://github.com/Moya/Moya/blob/master/docs/Authentication.md#bearer-http-auth) for docs and [here](https://github.com/Moya/Moya/blob/master/Sources/Moya/Plugins/AccessTokenPlugin.swift) for implementation. I'll close this issue since it's been inactive for a while. Feel free to reopen if you still have questions, @kristiyandobrev @kristiyandobrev I think what you're looking for is what @scottrhoyt suggested:

>I might prefer searching for a token parameter to in parameters to url encode and then encode the rest as JSON.

Basically, if you have an endpoint like:

```swift
enum API {
    case example(id:String, name:String, lastName: String)
}
```

In order to make a request to `api/resource/:id` passing `name` and `lastName` as json body, you have to:

* Encode `id` on the url

```swift
    public var path: String {
        switch self {
        case .example(let id, _, _):
            return "api/resource/\(id)"
        }
    }
```

* Pass `name` and `lastName` as parameters

```swift
    public var parameters: [String : Any]? {
        switch self {
        case .example(let _, let name, let lastName):
            return ["name": name, "lastName": lastName]
        }
    }
```

* Encode parameters as json

```swift
    public var parameterEncoding: Moya.ParameterEncoding { 
        switch self {
        case .example:
            return JSONEncoding.default 
        }
   }
``` @kristiyandobrev were you able to make the request as you wanted?   As discussed in #907  I was more concerned with this before RxSwift and ReactiveSwift were reliably offering framework downloads. I think it is less of an issue now. There are still some benefits to not expanding our users' dependency graphs, but I think those are outweighed by the additional maintenance and release coordination headaches that will come will the 3 repo approach. I'd love to see carthage offer an option similar to a subspec (especially since it is possible with SPM), but I recognize that is going against the grain of carthage's simplicity. Yup, I agree with @scottrhoyt, it seems like a non issue now. 

Feel free to re-open if anyone would like to go into this further üòÑ   Hmm, this means we should use:

```
github "Moya/Moya"
```

for Moya,

```
github "Moya/Moya"
github "Moya/RxMoya"
```

for RxMoya, and

```
github "Moya/Moya"
github "Moya/ReactiveMoya"
```

.. right? If that's the case, we might want to add these examples as we did with CocoaPods, to make it even more clear. @BasThomas, in order to do that we would need to pull those out in to separate repos. We've had that discussion before, and we can revisit it. The argument for keeping them all in one place is that it's far easier to maintain. But I'm not doing much maintenance nowadays, y'all are, so we can split them up if that's what the team thinks is right.  It's not an bad idea. At least from the perspective that `RxSwift` and `ReactiveSwift` are heavyweights and allowing our carthage users the choice of whether or not to include them in their dependency graph could be nice. It does create a whole set of maintenance headaches though. üò¨ So it's no clear win. Aye, that's the tradeoff: it's easier for Carthage users but harder for us. Moya's benefited from a tonne of community contributions, and the easier we can make that the better. But I don't like shifting the burden to users either. This could be something to discuss in a Hangout or Skype call, let me know and I can organize it.

EDIT: Though we should take into account the likely shift away from CocoaPods and Carthage towards SPM, which works with the current set up.  I think I'm partial to leaving them as is for the time being. A lot has changed in the structure of this project and we just released 8.0.0. This would mean 9.0.0 right away, and more maintenance. Let's hope that Rx and Reactive continue to provide reliable framework downloads and that we get ABI stability sooner rather than later to ease the burden on the users.

I'm open to changing that opinion though and would be available to do a call as well. As a Carthage user, I'm very fond of switching into two separate repos, but as @ashfurrow mentioned, there's an impending shift towards the native package manager. Any work spent breaking up the repos is likely to conclude with SPM becoming widely adopted.

I'm in favor of keeping it as is, unless there was some tricky configuring we could do with `Cartfile`s in separate repositories.

i.e.:
Moya/ReactiveMoya hosts a repo with a Cartfile that specifies reliance on a specific branch of Moya, which includes a `Cartfile` for those dependencies.

Cartfile in Moya/ReactiveMoya
```
github "Moya/Moya" "reactive-moya"
```

Cartfile in Moya/Moya on "reactive-moya"
```
github "ReactiveCocoa/ReactiveSwift" ~> 1.0
/// ... The remainder of Moya's dependencies
```

However, this feels like it has it's own set of problems I haven't fully considered... Hmm. With regards to the move towards SPM, I just want to make sure we don't put the cart before the horse. There are currently severe limitations to using SPM in building an App for Apple platforms. From what I've read, the story *may* be different come Swift 4.0 in late 2017. Am I missing something? Because it seems like we're the better part of a year and 100,000s of collective builds away from being able to consider being SPM-first. Is there some news I'm not aware of in terms of the SPM roadmap?

BTW, I am guilty of hijacking this PR. Which looks good to me!  üòâ No, we're on the same page. This has been on the table for the better part of a year and a half while I've been contributing.

The only real pain point comes from waiting on Carthage to build dependencies that aren't in use. That can be mitigated (in part) by distributing binary frameworks, but that's always dependent on the build system used at the point of distribution (nothing like waiting 30 minutes for your dependencies to build only to have it fail because a binary distribution was compiled with Swift 3.0 instead of Swift 3.0.2).

it's a tough problem, because it's only relevant to our Carthage users. CocoaPods users have had this ability pretty much since the libraries inception. Any changes that are made for Carthage users can't effect CP users, I learned that the hard way when I came on. One of my first in-depth PRs broke CP support while attempting to address this issue.

We totally hijacked the thread. I think the PR looks good, and is required instruction. I'm good to merge in, and we can open an issue to further this discussion... in fact, I think there already is one somewhere... Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. I *am* open for providing multiple repo's to make the users' lives easier. I think SPM will still take a while to catch on, and in the meantime, I think we should consider this. Would gladly join a call to discuss the implications. I feel like keeping them together is the easiest thing to do right now. I've felt bullish on SPM for over 6 months now, but I do know using it is still a ways out.

I'm down for a call as well, but I think we should let this sit until someone else brings it up (unless one of you feel very strongly about making the change to multiple repos). Hopefully then we'll have a more informed perspective on the possibilities of SPM at that point    Hmm. That's interesting. I'm thinking about what should be the correct behavior here.

Maybe the Observable should strongly capture the `RxMoyaProvider`? It seems like the ability to make the request should be tied to the lifecycle of the `Observable`, not of the provider. Any other thoughts @Moya/contributors? This PR makes sense to me, we should probably have been doing this from the start üëç @sadiq81 could you add a changelog entry for us? Thanks for the PR! @sadiq81 Thanks a lot for the pull request! Would you mind adding a note to the changelog?  @sadiq81 In your master branch, add a line to `Changelog.md` at the top that describes the bug you fixed. Commit it and push it up to add it to this PR üëç I think I agree with @scottrhoyt, it doesn't seem best practice to strongly capture the provider when making a request.
The provider should be held on by some other object, and the response should only be acknowledged if the provider is still listening for it.

This may be sort of nitpicky though. Merging this would make the common case simpler (why is my request never responding), but could potentially create memory leaks for more complicated implementations (I set my `provider = nil`, but I can see that it hasn't been deallocated, wut)  Aye. I'm leaning towards merging this, the common case makes sense to optimize for. Let's give it one more day to discuss objections, but I think we've covered everything now.  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  There are some features in #861 that would make this easier to do with Moya, but we haven't decided on whether to include them or not yet. If you are interested in including it yourself, you can take a look at how `SingleURLTarget` is implemented and can potentially use that in your own code.

Otherwise, I'd say Alamofire is the way to go. @dannymout were you able to solve this? Or should we keep this issue open? @scottrhoyt Well, I eventually figured this out, but if you can get this feature added, it would be useful.  https://github.com/Moya/Moya/issues/888#issuecomment-270403554  I got some feedback about our use of SPM, so I'm updating our package description and readme to reflect those changes. I might not have interpreted the feedback correctly, so feedback would be üëç Specifically:

- SPM ignores directories that start with `.`.
- Our sources are stored in `Sources` so we don't need to exclude `Demo` explicitly.
- `.Target(name: "Moya")` can be replaced with `"Moya"` for succinctness. This is a stylistic choice that's up for discussion.

Also updated our Swift version support matrix to reflect 8.0's final release (üéâ) Hmm, we might want to add a Danger rule to keep CP+Carthage+SPM in sync (as we did in #808).    A little bit of a nitpick üôà, but just updates the build shield to be the same style as the rest.  This adds some documentation around `Endpoint`, `Image`, `Response`, and `MultiTarget`. We might want to unify the header docs at one point just for consistency (only `///` or your approach with `/**`), but lets leave that for another time. Thus far my approach is to use `///` for single line documentation comments and `/**` for multiline documentation comments, but I agree we should make sure it is consistent. I was having trouble getting the markdown (e.g. `- parameters:` to correctly register on multiline with `///`. You might have to use `- parameter name: name does thing` per parameter with `///`: see http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/. Ah, that might be it then. In that case, I think:

```swift
/**
 function

 - parameters:
    - x: Is an x
    - y: Is a y
*/
```

might be a touch more human readable than

```swift
/// function
///
/// - parameter x: Is an x
/// - parameter y: Is a y
```

Especially for many parameters. But that's just personal preference. I could go either way. I agree, but I think I like `///` above `/**`. üòõ   I think some changes from #884 may have been accidentally dropped in rebasing #880. I re-added the changes (thanks @petripartanen) and added some documentation to the error cases.  Just a small change to `EndpointSpec` to achieve higher test coverage through utilizing the convenience functions.    This is cleaning up a leftover after #885.  Following through with the promise of #813, this PR adds a new `PluginType` called `AccessTokenPlugin`. This plugin can be added to a `MoyaProvider` to add authorization headers of the form:

```
Authorization: Bearer <token>
```

By default, this plugin will add the auth header to all `TargetType`s. However, if you want to control this behavior, you can have your `TargetType` conform to `AccessTokenAuthorizable` and provide `var shouldAuthorize: Bool { get }`.  Good question; the properties of `MoyaProvider` are `let` because Swift encourages properties to be `let` by default. We've never had a reason to make them `var`. If you need to modify the behaviour of the `endpointClosure`, you can use an `if` statement in the closure that checks for a condition to behave one way or another, for example in a variable outside the closure. You can also attach that variable as an associated value on your Target enum class.

Hope that helps! Let us know if we can clarify anything.  Closing due to inactivity. Let us know if you still have questions, @EvilNOP :wink:  This Pull Request has been created for @Moya/contributors to discuss the pros and cons of a 2 xcodeproj vs 1 xcodeproj project structure.

Currently, we have two xcodeproj's in Moya. One, `Moya.xcodeproj` contains our source code and tests, and the other `Demo/Demo.xcodeproj` contains two example projects (`Demo` and `DemoMultiTarget`).

Here's what I think (and what was gathered from the conversation in #885)

### Pros of going one-project
1. Better discoverability of the demo projects - they're right there when you open Moya.xcodeproj and you don't have to dig for them
1. Simplicity of just having one xcodeproj

### Cons of going one-project
1. Having an example/demo project in separate sub folder and project is in line with CocoaPods best practices and most libraries do it this way
2. A higher potential for *.xcodeproj's merge conflicts. Keeping separate projects will allow people to contribute to Demo code and core library code simultaneously with less risk that the Carthage-driving project will get corrupted.

Its also worth noting that making this change will move us to will have the effect of making Moya more of a carthage-first library instead of cocoapods-first library, since the Demo code will by default be working off of a carthage integration and not a cocoapods integration Good notes describing the change ‚Äì my inclination is to move Moya towards being an SPM-first library, does this PR make sense in that context?  @ashfurrow I feel the same way, Carthage affords itself to SPM, and the project structure between the two are almost interchangeable.

Merging this PR would get us closer to that point. The lingering difference to make us truly SPM-first, would be 
1. To finish up #643
2. to use SPM to pull down dependencies ourselves, which we currently aren't doing, mostly because we don't have #643 merged, but also because SPM - as it is now - doesn't build `.frameworks`, it compiles to an executable (`*.build`). Here's what Result looks like compiled, for example 

<img width="881" alt="screen shot 2017-01-02 at 4 59 32 pm" src="https://cloud.githubusercontent.com/assets/3814772/21598197/f8e81fca-d10c-11e6-8ad6-86b03ec6ad41.png">

To be honest, I'm not sure how people are using SPM compiled dependencies for iOS apps, I've seen people that have dragged the `*.swift` files that SPM fetched into their projects, but not the `.build` files.
I don't think SPM is at that point yet, but when it is, we should be ready to go üòÑ  IMO Both directory/project structures are compatible with carthage and SPM. We can make carthage work with either structure and SPM doesn't really care about xcodeproj's. It is driven off of the sub directory structure under Sources and how that translates into modules. I don't think it uses projects at all-it can only generate a simple one if you ask it to.

This change will move us more out of line with CocoaPods standards as mentioned. And we should consider the consequences to testing the cocoapods integration and Demo project build. Changing documentation to instruct users to do a `carthage bootstrap` to try out the Demo project will also make Moya more carthage-first. @scottrhoyt you're right, both layouts are compatible with all 3 package managers. I've been using the word compatible when what I really mean is in the spirit of, which is definitely a matter of opinion, and not right and wrong.

I'm also biased since I've never really used CocoaPods (I started programming a couple months before Swift came out, and other than iOS hello world esque apps, I've always used Carthage). So the upside to have `Demo` in it's own directory is lost on me Thank you for the reviews. Do you want to take a shot at those changes @scottrhoyt? Otherwise I can take care of them some time tomorrow 

What do you guys think? Should we wait a couple days to see what the other contributors think?

As it stands now, this PR is only a matter of preference, it has no functional benefit. Perhaps in the future, when we're using the SPM to generate our xcodeproj, it might. But theres a chance that SPM will change their implementation in the interim, and having only 1 xcodeproj will not matter. Yeah, I totally get that. I haven't been a CocoaPods user in a while. It's been a change for me to work on a library that has--until now--been cocoapods-first.

For me the advantage has less to do with directory structure and more to do with merge conflicts. The rule of thumb is to break up the XML-based files (e.g. xcodeproj's and storyboards) into smaller files to minimize the conflict resolution mess. Gotcha, I do the same thing with my storyboards (the project Im working on now has 9). I hadn't thought of/heard of splitting up xcodeproj's to reduce merge conflicts. I'll look into that @AndrewSB, I can take a shot at those in the next couple of days. I have a couple of other things I am working on at the moment. I also need a bit of a break from making CI changes. Iterating on builds that take 10-20 minutes gets exhausting üò©. So if you'd like to take a stab first, then go for it and shoot me any questions you might have.

One of the things to decide is what the testing strategy looks like here. Previously we were testing that the Demo project built using CocoaPods (implicitly validating our pod). 

With this scheme, if we want to replace that functionality and/or do a carthage integration test as well, then we will need to write some integration tests as you suggested. Such tests probably involve generating a new xcode project for the Demo code on the fly, but there might be something more clever that can be done. I might also consider removing the "PRO" of 

> Swift package manager expects there to be one xcodeproj in the root of the project.

... because I don't think SPM cares about Xcode projects at all. You can have zero or many. It's just going to build what you tell it to in the directory structure and `Package.swift`. People less familiar with SPM might think this is getting us closer to SPM compatibility when we already are compatible and this is more of a stylistic/project philosophy choice.  Haha, I totally understand. Thank you for all you did speeding up CI, its noticeable üòÑ 

Yeah, we do need to rethink our package manager integration tests. 
Lets prioritize the 8.0 release while we wait for a couple more people to give us their thoughts, meanwhile thinking of how to better test.
I'm on a flight on Wednesday, so I can write those tests and validate locally while I don't have internet, and then we can finish this PR up towards the end of the week. I think thats enough time for everyone to give their thoughts.

You're right, I'll move that from the pros üòÑ  ## TODO

- [ ] Update circle.yml to pass, moving the Demo project expectation from `Demo/Demo.xcodeproj` to `Moya.xcodeproj`
- [ ] Write (hopefully parallelized) tests on CI to validate CocoaPods, Carthage & SPM validity (lets make this is **separate PR**)
- [ ] Update docs for new Demo project location & Carthage instead of CocoaPods instructions
 Currently we test the integrity of our CocoaPods integration by compiling the Demo project. By moving the Demo project to the main project, it will no longer be testing any integrations because it will use the local project instead. So if we don't add another integration test to this PR, it will be a regression.

Maybe a good way to break this up into PRs without regressing is to replace the integration test with another integration test and then open up a new PR that is concerned with the other two integration tests and parallelizing them. What do you think about that strategy? If we want to go SPM-first, we might also consider resolving #894. After changing structure to SPM-first, changing project to single target, now we can think about consolidating Demos. How do you feel about it, @AndrewSB? That sounds great! I can finish this up (probably) early next month, but anyone else who's motivated to make this happen should feel free to take charge üòä  This PR implements availability tags for the changed function names from the Swift 2 to Swift 3 migration.

This makes the lifes of users making the switch easier, as the compiler provides fix-its for the functions that need renaming (as seen [here](https://github.com/Moya/Moya/issues/888#issuecomment-270004469))

The tags added are as follows

- [x] Renamed endpointByAdding(parameters:httpHeaderFields:parameterEncoding) to adding(parameters:httpHeaderFields:parameterEncoding)
- [x] Renamed endpointByAddingParameterEncoding to adding(newParameterEncoding:)
- [x] Renamed endpointByAddingParameters to adding(newParameters:)
- [x] Renamed endpointByAddingHTTPHeaders to adding(newHttpHeaderFields:)
- [x] Renamed StructTarget to MultiTarget
- [x] Renamed notifyPluginsOfImpendingStub(request:) to notifyPluginsOfImpendingStub(for:)
- [x] Renamed request(token:) to simply request(:_) (ReactiveSwift)
- [x] Renamed filterStatusCodes(:) to filter(statusCodes:) (and filterStatusCode(:) to filter(statusCode:))
- [x] willSendRequest renamed to willSend
- [x] didReceiveResponse renamed to didReceive
- [x] Renamed ReactiveCocoaMoyaProvider to ReactiveSwiftMoyaProvider

~~The yet-to-be-done functions have been commented out:~~

- ~~`extension ReactiveSwiftMoyaProvider` has a `Use of undeclared type 'ReactiveSwiftMoyaProvider'` error;~~
- ~~`public func filterStatusCodes(range: ClosedInterval<Int>) throws -> Response` has a `'ClosedInterval' has been renamed to 'ClosedRange'` error.~~

~~... and I have no idea how to fix either of these.~~ Cool! Looks great. I'm fine with leaving those commented out for documentation's sake, up to you. Could we provide an empty `ReactiveSwiftMoyaProvider` implementation that's marked as unavailable maybe?  But we **do** [use it](https://github.com/Moya/Moya/blob/ea331f79c534db1334b93b0d5526bfeb5227a6d1/Source/ReactiveSwift/ReactiveSwiftMoyaProvider.swift#L8), and it should not be unavailable, right? And if we do leave them commented out, I'd like to add an explanation for that before merging. It would also be **awesome** if somebody could test this (by converting a pre-8.0.0 project to this branch. Hmm, I suppose we can just fix `public func filterStatusCodes(range: ClosedInterval<Int>) throws -> Response has a 'ClosedInterval' has been renamed to 'ClosedRange' error.` by changing `ClosedInterval` to `ClosedRange`, as the compiler will see that error first (probably?) and the signatures then match. Been able to fix the two remaining functions as well. Imported `ReactiveSwift` et voil√†.

If someone could help me squashing these commits, please let me know. Think it can use some cleanup, but I am not sure how to proceed myself. Welp, CI is failing. @scottrhoyt @AndrewSB any idea why the files can't be found? I get the same error building just the framework locally, using the `Demo.xcworkspace` works fine. I'll take a look, @BasThomas. I think when you merged `master` after #885 (c22ef57f6364a1d0efb304916b2acd3929852319), you resolved the merge conflicts in the Xcode project by inserting the old references back into the project along with the new ones. I think this should branch should be rebased off of `master` resolving those conflicts with the new references. Do you want to give that a try or I can do it if you'd like? Xcode project merge conflicts are üò≠. `Demo.xcworkspace` will still work fine because it uses a cocoapods integration that doesn't rely on the main Xcode project. If you could do so, please go ahead. I'd probably have closed this and started with a clean slate at this point, especially because there's only one file change. üôà

@`Demo.xcworkspace`: thought as much. Surely. I'll probably have that done in ~30 minutes. I will let you know. @BasThomas, I rebased and pushed to `swift3-availability-2` just so you can check to see if it still looks good to you. If it does, I will delete that branch and push here. Sound good? I also fixed some problems with combining Availability info for Moya and ReactiveMoya. Yes, looks good! Thanks for the help @scottrhoyt! I think this should be good to go now.  Oh, one more thing: we might want to move the `Moya.Error` unavailability tag to the `MoyaAvailability.swift` file instead of letting it "linger" in `MoyaErrror.swift`. Can someone review and merge? Also, I think we can release `8.0.0` once merged! üéâ Or we could just keep them. We'll see. :) I agree they will be a great addition for the migration and certainly useful for a while. But when the changes have sat for a while it might be nice to reduce the API surface area (primarily for code completion), reduce instances of `fatalError()` in the code base, and get a percentage point of test coverage back if no one needs them anymore. :)    This PR is meant to aid with #885. Also Closes #870. This is what is does:

* moves `Tests` to root dir
* moves test targets from Demo.xcworkspace to Moya.xcodeproj
* switches CircleCI to run tests from the main project
* adds a CircleCI task to build the Demo project
* greatly speeds up build time by caching carthage builds (~ 50%)
* fixes an error where `rake test:carthage` wasn't actually testing the current commit What I understand from this is 
1. You moved the tests into Moya.xcodeproj
2. You actually got the tests to run & updated Rake things, and cocoapods things, and implemented caching

If we could cherrypick all the` 2` commits from this branch onto `redo-spm-layout`, and then merge this into #885, then we'll have this PR done, and 2/3 of the TODOs on #855 done as well

If you're onboard with ‚òùÔ∏è, then I'll start helping choose which commits are needed, and we can revert/delete the ones implemented in #885 It's a little bit more than that. Let me take a stab at combining them. I know how to make the changes again. I'll push the commits right to your branch. awesome, I'll take a look üëç  I've deleted the branch; please restore if needed! All good. Thanks. Uneeded now.  Picks off where #698 left off. Closes #870.

My concerns:

- [x] **Test to make sure the project is still CocoaPods compatible** I'm not familiar with Cocoapods, so the new layout is done to Carthage & SPM best practices, but it would be awesome to have a cocoapods person test it and make sure everything still woks :)
- [x] **Update README**: I'm sure some of the instructions will have changed, locations of Demos & Tests, pulling down dependencies for Demos, etc.
- [x] **Update CI for new test locations**: The tests are currently failing because the tests CircleCI is expecting are no longer in the same. I also have them setup to pull dependencies down with Carthage instead, so we need to set that up. @BasThomas: I remember you offering to take a look

Future enhancements:
- Use `swift test` once #643 is merged
- [x] Implement the Carthage caching strategy @scottrhoyt & I discussed in #870 Cool. I actually just started a branch to work on the tests portion today. It also included migrating CircleCI to test out of Moya.xcodeproj and speeding up builds by caching carthage and fixing the problem from #870. Take a look and maybe we can figure out how to combine them üëç. Haha, I was actually editing my comment to add that as an enhancement!

I have 3-4 more commits to finish up on this PR, and after which I'll branch off to take a shot at #870. How far did you get? Haha. ü•á Priceless. 

Pretty much done on my end. I had to implement the cache because the builds slow down majorly once we need to use carthage for testing. I was just figuring out how to fix the `rake test:carthage` task so that it also would be speedier. I don't think it is really even doing what is intended right now since it's checking out an old tag instead of building the current commit. Take a look at `sh_move_tests` branch. I've also been testing it with cocoapods to make sure nothing breaks there and I added a new task to build the Demo project just to ensure it builds since nothing else is doing that now. Cool, that sounds great.

I'm going to get the tests building locally, and then I think I'm done with this PR.
I'm seeing a strange error with Result, have you seen anything like it?

<img width="993" alt="screen shot 2017-01-01 at 8 57 23 pm" src="https://cloud.githubusercontent.com/assets/3814772/21584770/f2ae4696-d064-11e6-8d15-b9eb26ce6ab6.png">

I made sure I was using a current version of Result (I have 3.1.0 checked out), I've never seen Result used without an error type specialization No, I haven't run in to that. Just opened up a PR to facilitate comparing and getting this all integrated. Build times are greatly sped up. üòÅ #886  FWIW, check out https://github.com/antitypical/Result/issues/77 for the Result error. Although you're specifying `Moya` here, I think it might still be a failed lookup between `Result` and `Alamofire`'s `Result` type. ü§î @scottrhoyt: sounds great! Oh wow, I just saw all the work you put into #886 üò´ I'm sorry about superseding it!
@BasThomas: thanks for the link, https://github.com/antitypical/Result/issues/77#issuecomment-231423891 was perfect  @scottrhoyt: I think this is ready to go. We just need to deal with the 3 TODOs above, and then add any learnings you have from #886 

For #886: We could either have fewer commits redone here, or you can rebase #886 onto this branch and we can merge it here. What do you think? No worries @AndrewSB. I actually have all 3 of those sorted in #886 already in addition to the cache improvements. Oh awesome! Should I close this then and help review your pull request instead?  Well, I only handled all the concerns on the testing side, I haven't done anything with the rest of the SPM work. So it might be easiest to rebase the rest of your SPM work off of my branch. But another option would be to try and port the other fixes I made to this branch. You started a lot of the SPM work, so I'm good to go either way. I'm just looking forward to faster builds and being able to run tests easier while developing! üëç  That sounds great to me too. Let me give your PR a look over to see what you've implemented so I can try to figure out what we should include from both @AndrewSB I finished combining our work. There were really only two areas where we conflicted:

* I kept the Demo targets where they were instead of moving them into the main Moya library project. If we leave it where it is, I don't think anything in the docs needs to change.
* We don't need to use a `carthage copy-frameworks` to copy the frameworks for test targets. A simple copy files build phase will do.

Let me know if you have a strong opinion on either of those.

All the other commits are just cleaning up, getting CircleCI working, and getting CocoaPods working. I checked again and can't find anywhere in the docs where paths need to be updated--as long as the Demo projects stay where they were. Let me know what you think and thanks for the teamwork! ü§úüí•ü§õ Fixed all the CI errors except this one from Danger:

<img width="2400" alt="screen shot 2017-01-02 at 1 40 14 am" src="https://cloud.githubusercontent.com/assets/4259250/21587050/af4652e0-d08c-11e6-97a5-fc8935679922.png">

Not quite sure what to do about that one. @ashfurrow mentioned [that might be a Danger bug](https://github.com/Moya/Moya/pull/861#issuecomment-269779701).  Just rebased this to fix merge conflicts.

@ashfurrow, do you have any idea on that Danger bug? @scottrhoyt I still have a feeling that an entry in the changelog will fix it ü§î  Thanks @pedrovereza! Let's see if that fixes it. @scottrhoyt this looks really great, awesome to come on and see that the PR's checks are passing üòÑ 

Reviewing code now @scottrhoyt: Really great work. This all looks good to me. 
Only thing that may be nice would be for us to squash some commits

I also saw that you marked README changes as done, but I didn't see any changes. Is that because they weren't required? I remember @scottrhoyt saying somewhere he thought it wasn't needed; can't seem to find it now though. I perused the documentation and have come to the same conclusion.
Well then the only thing left is for @scottrhoyt to squash some of his commits üòÑ then I think we're ready to merge this (assuming Danger is happy, I'm not sure how to see that status) Oh wait, I just noticed one thing: Previously, I had deleted the Demo.xcodeproj and .xcworkspace and moved everything into Moya.xcodeproj (the Demos were put into a Demo group inside Moya.xcodeproj).
Your merge, @scottrhoyt, seems to have undone that. Was that purposeful? Or should I redo the integration of the 2 xcodeprojs? Haha. It is a commit overload üôà. Some of those can definitely get squashed. I will take a look at that shortly.

Yeah, @AndrewSB, keeping the Demo project separate was intentional. There are a number of reason's I think it's good to keep them separate:

* Carthage is driven off of the main Moya.xcodeproj, so I think it's a good idea to keep that as lean as possible.
* Having an example/demo project in separate sub folder and project is in line with CocoaPods best practices and most libraries do it this way, so I think it is more in line with user expectations.
* Merge conflicts are not fun in *.xcodeproj's, so keeping separate projects will allow people to contribute to Demo code and core library code simultaneously with less risk that the Carthage-driving project will get corrupted.

What do you think are the reasons for putting the Demo code in the main project? Building the Demo project is also our current method of checking that CocoaPods didn't break. So if we combine the projects, we might need a different approach to that. Hmm... Having one xcodeproj is a strong opinion that I weakly hold. I'm willing to change, but here's what I think

> Carthage is driven off of the main Moya.xcodeproj, so I think it's a good idea to keep that as lean as possible.

It is, but Carthage only looks at the shared targets inside of Moya.xcodeproj. As long as we don't share the Demo targets, it won't have any impact on Carthage at all.

> Having an example/demo project in separate sub folder and project is in line with CocoaPods best practices and most libraries do it this way, so I think it is more in line with user expectations.

That makes sense for CocoaPods best practice. I wasn't aware of it.
I'm not sure about this, but I think most Carthage-first projects include the Demo within the same xcodeproj, and I think spm is the same way, especially with their `generate-xcodeproj` command. I'll do some research and get back to you

> Merge conflicts are not fun in *.xcodeproj's, so keeping separate projects will allow people to contribute to Demo code and core library code simultaneously with less risk that the Carthage-driving project will get corrupted.

Merge conflicts are a headache, but from my experience they're pretty rare. 
Apart from commits like this where we radically change project layout, most changes to xcodeproj's are just adding or removing a file. Which usually don't conflict, or if they do, are trivial to resolve by setting the merge strategy to union. Your point on validating cocoapods is real though.
Is there any way to validate cocoapods without having a separate xcodeproj?

How important do you think it is for us to run integration tests to make sure we're not broken through our package managers on every `master` commit?
 I've started to feel like it's (at least to some extent) overkill. And its going to be even worse when we're also validating that SPM works on each commit
I'm going to go back and see why we added the Carthage validation on each commit

Update: we added Carthage sanity checking in https://github.com/Moya/Moya/pull/630, and the reason why was because we missed https://github.com/Moya/Moya/issues/629.

What do you think about testing our package managers in parallel? Either on Travis, or telling Circle to perform our tests in parallel with our spm & cocoapods bootstraps We can do a `pod lib lint` to lint it locally (make sure it compiles).  @ashfurrow awesome! So that fixes the validation problem.

@scottrhoyt: RxSwift is the only large project I could find that just has one xcodeproj and includes their Demos & Examples as part of the one project. Some other projects don't include Demos (ReactiveSwift, Result), while Alamofire has a separate xcodeproj. I think RxSwift does an exceptional job with project structure, and that's where my fondness for the one-project-approach comes from I could be misunderstanding how sharing of schemes works, but doesn't unsharing a scheme normally put it in `.xcuserdata` or somewhere else that we normally gitignore?

I would disagree on merge conflicts. I think the majority of the merge conflicts I have solved have been in *.xcodeproj's. It's one of the reasons why bigger tech companies don't use them at all.

`pod lib lint` is an alternative to validating that the pod spec isn't broken. However, it doesn't test that it is complete and the advantage to what we are doing now is that it also validates that the Demo project continues to build correctly from CocoaPods. This means that we can have more confidence in the CocoaPods install being complete and `pod try Moya` is working. For example before #869 MultiTarget.swift was missing from Carthage installs because nothing was testing that it was being included via Carthage and the base project could still build fine without it.

So given that what we have is working correctly and has some advantages, I'm just trying to understand the advantages of changing it to be in one merged project. I definitely understand why we needed to get the tests as part of the main project, but the Demo targets don't seem obvious to me. > I could be misunderstanding how sharing of schemes works, but doesn't unsharing a scheme normally put it in .xcuserdata or somewhere else that we normally gitignore?

Sharing schemes is just checking [this box](https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW3) in the Scheme manager (Carthage talks about it [here](https://github.com/Carthage/Carthage#share-your-xcode-schemes)). Unshared schemes are still totally visible to users, and runnable. Not gitignored 


> I would disagree on merge conflicts. I think the majority of the merge conflicts I have solved have been in *.xcodeproj's. It's one of the reasons why bigger tech companies don't use them at all.

Totally valid. I don't have the experience of working at a large company, so I'm probably not qualified to contribute on the severity of merge conflicts. But, regardless of whether we have one or two xcodeprojs, we're still going to get merge conflicts. Having two xcodeproj's might make the conflicts smaller, or space them out to some extent, but it won't get rid of them #xcodeprojmergeconflictsheretostay üò≠

> For example before before #869 example MultiTarget.swift was missing from Carthage installs because nothing was testing that it was being included via Carthage and the base project could still build fine without it.

Can we write an integration test that verifies that the built targets have all the files we expect it to have? Something that would have caught `MultiTarget.swift` being orphaned?
If there is, I think we should write it, but I don't see how having one or two projects would affect ‚¨ÜÔ∏è

> So given that what we have is working correctly and has some advantages, I'm just trying to understand the advantages of changing it to be in one merged project.

To me there are two benefits
1. Simplicity. 
Even though sharing iOS code is heavy right now (i.e. you cant just throw up a few `.swift` files up on GitHub, you need to deal with an xcodeproj, and targets, etc.) I like being able to see the entire project at once. For a while, I didn't even realize Moya had a Demo or Tests, since they were hidden away somewhere I don't usually look.
That was the same motive you had for moving the tests into the main project, so they're easier to access

2. SPM expects & generates only one xcodeproj per package I don't have anything more to add to the conversation, but wanted to note a) this is a really great discussion, I'm sure other libraries are having similar ones and we should consider writing a blog post about this PR, and b) I'd really like to thank everyone for providing such thoughtful, respectful comments. This kind of conversation makes Moya a joy to work with, and sets a high bar for the rest of the iOS community. Thank you all. Thanks to everyone here! I'm honored to be able to talk with such skilled people at such a high level. Even with some butting of heads, I think we all win in the end. This is a model of how open source iOS can be done! ‚ù§Ô∏è

I'm pretty sure sharing a scheme is more than that check box. I believe it actually moves the scheme from `xcuserdata` to `xcshareddata` (as seen [here](http://mgrebenets.github.io/xcode/2014/05/29/share-xcode-schemes)). Usually `xcuserdata` is completely gitignored. If it is working differently here, then I must be not understanding something. But either way, I think the shared scheme issue isn't a huge deal because right now I think carthage ignores everything except framework targets.

If we move the Demo code into the main Moya project, the Demo code will by default be working off of a carthage integration and not a cocoapods integration, so building it will not have the effect of validating that the Demo project builds via CocoaPods. I think the corresponding changes to configuration and documentation will have the effect of making Moya more of a carthage-first library instead of cocoapods-first. I'm not opposed to that at all, I actually prefer carthage over cocoapods usually (it's how I integrate Moya), but it's a good sized change nonetheless.

I don't think we will be using SPM to generate or build our xcodeproj's any time soon because we need to specifically tailor the xcodeproj to a carthage integration. I don't think that's what you'd get if you let SPM manage it.

Ultimately, despite my defense of the 2 project solution, I'm not stuck in the mud on this one either. And I do love only having one Xcode window open for a project üòÅ. So, what I'm going to propose is since this currently doesn't change the Demo location from where it is in code and documentation, we merge this as is (after some commit squashing). Then we can create another PR around moving the Demo targets if that still seems like a good idea. In that PR we can debate the relative merits and change our testing scheme to better accommodate the decision. This PR is overweight as is and this might be a good way to contain it a bit. What do you guys say to that? Likewise, its a pleasure to work with you guys üòÑ

I have a feeling you might be right about schemes affecting the `xcuserdata` to `xcshareddata`, I'm not totally sure what the implementation details of checking the "Shared" checkbox is either.

That sounds good to me, this PR is starting to get bloated. Lets get this merged and talk about it in another PR. I can create one as soon as we merge this into master Great! Give me 20 or 30 minutes to squash commits where appropriate and then we can get this bad boy approved and merged. I think people will enjoy the quality of life improvements in here. Thanks for your help @AndrewSB! That's a bit more manageable now. Let me know if you think it needs further compacting. That looks great üòÑ 
I'll get started with the `Demo/` PR

EDIT: created #891   FYI, the test code can be found in the Demo dir. Do a `pod install` and open up the Demo workspace to access and run the test code. Yeah, tests don't add a lot here, except maybe for `underlyingError`. And if you're gonna test that, then maybe just include the trivial tests for the others for an easy coverage win? ü§î What do you think? Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Yeah, I suppose we can add some trivial tests to bump the percentage, although, like I said, it's pretty trivial. ü§∑‚Äç‚ôÇÔ∏è  So this one is a pretty big breaking change, and that could be a decent reason to not do it. I figure we should consider it before 8.0.0 though.

There are a number of reasons I think we should do this though:
  * More idiomatic
  * Fixes ambiguities in code completion and semantics with `Swift.Error`
  * No more verbose than needing to namespace `Moya.Error` everywhere
  * Helps to resolve a class of issues where a failure to namespace `Moya.Error` leads to conformance errors or unintended behavior
  * Eliminates the need to namespace `Swift.Error`

Basically, it has been my experience that overloading Swift standard library type names causes extraneous üëø for maintainers and users alike. But I'm curious if others feel that same way enough to justify the big break.

To ease the change I added a type alias to `Moya.Error` and marked it with an unavailable attribute that offers a fix-it to `MoyaError`. And if we do this, I'll volunteer to submit some PRs to Moya extensions to fix them. For what it's worth, I prefer `Moya.Error` to `MoyaError`. 

Having either `MoyaError` or `Moya.Error` be more idiomatic isn't an objective measure, it's just a marker of familiarity with.
Your comment about the confusion between `Swift.Error` and `Moya.Error` is real though, it does make `Error` ambiguous in some cases, and forces one to namespace the error. But, I feel as if that makes sense, you have your module, each with its own kind of error (`Swift.Error`, `Moya.Error`, or `MyApplication.Error`), and each of those define an error (that's what I have, at least).
Then in my `catchError`, I usually switch to pattern match between those three.

It wouldn't be the end of the world if we made this change, I'd be ok with it, but I think having `MyModule.Error` instead of `MyModuleError` is a paradigm shift and I'd like to encourage it for swift. A few years from now I think it would be awesome if the former is the default, idiomatic naming option for Errors in our language üòÑ I can understand that line of reasoning @AndrewSB. I think it would be a reasonable way to go if Swift and SourceKit had stronger support for namespaces. Unfortunately that's not the case yet.

The only objective thing I can say about what is idiomatic or not is that I just scanned through the 10 most starred Swift libraries and I couldn't find any other examples of publicly overloading `Swift.Error`. So I think it would be fair to say that most users familiar with these libraries wouldn't expect it. That's not to say that doing something unexpected in a software library is bad, but there should be some good reasons for it.

Also important to crafting a well written library is consistent reasoning. I think we all can agree it wouldn't be a great idea for us to overload `Swift.String` or `Swift.URL`. I can share some tearful stories of days lost dealing with a library that overloaded `Swift.String` (the punchline is that I wrote some declarations as `let a: String` when they unexpectedly needed to be `let a: Swift.String` üò≠). So if overloading the standard library type names is bad in general, then we need to ask why should `Swift.Error` be the special case? Again, it's not to say having a special case is bad, but it should come with some good reasoning.

Paradigm can be good. But I think they are only good when they make users lives better or easier.

I don't want to rock the boat too much here. I just think if we want to shift the paradigm to a special case that is unexpected, it should come with solid reasoning and make users' lives better. The reasoning for `Moya.Error` doesn't seem robust and I think it actually might makes users' lives a little more difficult--even in writing about this PR we have to explicitly namespace a swift standard library type .

I like your idea of every module exposing a `Module.Error`. It has a lot of appeal to it. If we could get everyone on board with that, having such a standard convention might be all the reason we need. But realistically I don't think it would work because not every library can cleanly fold all of their errors into a single `Module.Error`. For example, a library might be clearer and cleaner with a `JSONError`, `HTTPError`, and `CacheError`. So I'm not convinced that this would work as a widely-accepted standard either.

Sorry for the wall of text. I just think that Moya is so well respected that it helps craft standards, so we need to really think through how we make use of that. As we've seen with [Result](https://github.com/Moya/Moya/pull/885#issuecomment-269935129), I think it might not be a bad idea to go ahead with this and prevent namespacing issues, as well as making room for the use of more than one "Error type". Yeah, I like `Moya.Error` from an idealogical perspective but pragmatically I think `MoyaError` makes more sense. Another solution could be to put the `Moya.Error` type inside the `MoyaProvider` class, since that class is what generates the errors. I'm fine with whatever we decide though, thanks for bringing up the discussion üëç No problem! Thanks for entertaining the idea!

I think embedding it into `MoyaProvider` is an interesting solution, yet I see a number of drawbacks:

* At ~50 lines (without much documentation), folding Error.swift into `MoyaProvider` will be a significant expansion.
* There are other types than `MoyaProvider` that need access to `Moya.Error` (e.g. `PluginType` and `Response`). So embedding it will cause those structures to need more namespacing and is probably a code smell that it shouldn't be embedded.
* It might not be straightforward for people to find `Error` when browsing the source. Cool, let's rename it `MoyaError` then. Like I said, it's not ideologically as awesome but we've got to live/code in the real world üòÑ   As discussed in #861, this PR removes the default implementation for `TargetType`'s `parameterEncoding` to be consistent with current approach for `TargetType`. The default will be reintroduced as part of #861. Oops wait, need to edit the CHANGELOG to mark `parameterEncoding` as a breaking change. Should be good to go now. Oh, didn't notice those were missing too. Just saw the GitHub one and fixed it within GitHub. üôà

Teamwork. üôå  This is meant to address an issue that I have come across in using `sampleData` to return responses of moderate complexity: `TargetType`s quickly get bloated and harder to read. This works against one of the main use cases for Moya: better organization of client API code. This has also popped up in a number of issues/PRs (e.g. #866, #603, #600, etc.).

The solution provided here is to write a helper function in `TargetType` (`stubbedResponse`) to load stubbed responses from a file. The intended usage is:

```swift
var sampleData: Data {
  switch self {
  case .users:
    return stubbedResponse("Users")
  case .profile:
    return stubbedResponse("Profile")
  }
}
```

This is accomplished by assuming that the file exists in the main bundle and that it has a "json" extension, but both of those default values can be overridden at the call site. If the data cannot be successfully loaded, the function will trap in debug mode (via `assert`) or just return an empty data in release config.

I'd love to get feedback in general, but here are some specific things:

* What do you think about the function name? I also considered `bundledResponse` to allow room for it to be differentiated from other ways of finding the stubbed response (e.g. via file URL so that one can avoid bundling test data with a production app).
* What do you think about the `assert()` behavior? I like this because devs will know right away in testing that the stubbed response can't be loaded as opposed to needing to debug a failing test because of a typo or the file being in a different bundle. However, even though it should be fine I am nervous letting an `assert` get into a production app because of high consequence if for some reason it doesn't work correctly. I'm also not sure if this will just hang a CI build or crash the test and cause it to fail. It is also untestable to my knowledge. The alternative I considered was just printing a warning message and returning an empty `Data` always. This is lower risk but possibly harder to debug. It's probably the way to go.

Another thing to consider is if we go further to encourage that test data be stored in files, we bring up some of the concerns in #425. We might want to consider alternatives to encouraging testing that don't require users to bundle production apps with test data/code. I'm a big believer of keeping testing and dev code/data out of production apps. I think it is less clean and the risk of unintended consequences is too high. It would, however, require a change in philosophy from Moya forcing testing to supporting testing. This was also talked about quite a bit in #861.

*Note: I'll add docs and CHANGELOG after incorporating feedback* I went ahead an renamed the function to `stubbedResponse(forFileNamed:)`. What do you guys think? Oops. Messed up a rebase it looks like. Let me retry. Looks good now. FWIW, I can't really think of a *better* function name. About the `assert()`: I think this is the best option here. > I'm also not sure if this will just hang a CI build or crash the test and cause it to fail.

... but we should definitely test this before doing so. I'm pretty sure it will behave the same way as a `fatalError()` but I will open up a test branch here and throw an `assert` in to see what happens. According to [this failed build](https://circleci.com/gh/Moya/Moya/1159?utm_campaign=vcs-integration-link&utm_medium=referral&utm_source=github-build-link) it looks like it behaves the way we want it to. Hmm, does `sampleResponse(forFileNamed:)` make sense for the function name? Maybe it's just me, but does this really belong in Moya? It seems like it's just sugar that could be implemented on a per-client basis. As OP said, this is only really relevant for testing, and this is stuff that should be coming from your network layer, rather than Moya itself. @justinmakaila I agree that point should be discussed. We should consider whether or not Moya needs a rethink on how it handles testing. I think it might.

However, if the current approach holds, then we advocate that test data should be provided by `TargetType`s in production code. Since it's not ideal to provide most real world test data from code, we should provide the tools necessary to load it from files. Sure, it might be pretty trivial stuff, but at least we could update our documentation and/or demos to show how it's likely to look in the real world instead of counting on users to come to this same conclusion. @BasThomas, I'm pretty indifferent to the two names. I still slightly prefer omitting the first argument label, but that's just my personal style. I don't think it's on us to provide tools for loading the sample data in an opinionated format.

For instance, in my most recent networking library, I have this ((pardon the space formatting...):
```swift
var sampleData: Data {
  switch self {
    // ...
      case .verify:
          return try! JSON([
              "isValid": true
          ]).rawData()
      case .graphOperation:
          return try! JSON([
              "data": [:],
              "errors": []
          ]).rawData()
      case .checkProgramCode:
          return try! JSON([
              "isValid": true
          ]).rawData()
  }
}
``` 
I think we're headed down a slippery slope if we're just adding sugar.

The end user of Moya is the one implementing `TargetType`, and should be deciding where and how to load their data for their stubbed responses. If they're not building with tests in mind, they're going to put `return Data()`, and if they are, they probably have some custom way that they're going to serve their responses anyway.

 I don't disagree with you. However, I just think our viewpoint might be in disagreement with the stated goal of Moya:

> Treats test stubs as first-class citizens so unit testing is super-easy.

By forcing `TargetType`s to provide a `sampleData`, it seems we are already on the slippery slope of recommending testing patterns. This PR goes not much further really, as it's just providing an optional tool and there is nothing to say you can't still do it the old way. 

On the flip side, judging by the issues that I referenced above, some users do run into the problem of our documented pattern not going far enough to support testing with real world responses from moderate complexity APIs. The goal of this PR was to prevent all those users from having to write this method themselves, not represent my personal feeling on how testing should be done.

Personally, I think tests data should be in the test target and supplied by the test objects, not bundled with the main app. But that approach has it's own drawbacks, so I respect that Moya is trying to do it differently. But isn't providing `sampleData` and built in mocks/stubbing enough to make it a first class citizen?

API resource models are literally providing their `Data` representation.

I'm just afraid that we'll start adding something like this while everyone has divergent ideas will put us in the same place we were when people started writing JSON extensions and saying "oh well 90% of services deliver data in this form, why don't we build in JSON handling with this provider?". That is fair. To me this is less divergent and more a natural extension of the tools we provide for testing, but I totally understand the pushback for going even a bit further in this direction as it's further promoting a specific testing pattern that doesn't sit well with everyone... including sometimes myself.

This is code that I personally use to reduce the pain of managing complex responses for sample data, but it's not a one-size-fits-all approach. Issues led me to believe others were having the same problems, so I offered my help. We don't have to include it though.

If you had some other ideas on how we could make testing more open and flexible to all approaches (including keeping test data in test bundles) while still keeping it first class, I would love to see that PR come through. üëç  I think the least we can do here (especially since I think @justinmakaila makes a fair point), is to include this snippet in the docs. Just as we did with some of the String extensions. This then is also a reference point for future issues. :) The consensus here looks like this isn't a good idea, so I will go ahead and close this.      This fixed the issue mentioned in #842. Going to close this unless it can be reproduced.  Also renaming the associated files with extensions on MoyaProvider. If we do this, we should probably also rename Moya+RxSwift and Moya+ReactiveSwift. I will do that in a further PR if this gets merged.    Hi there, I took a look and the `requestClosure` looks like it is escaping (see [here](https://github.com/Moya/Moya/blob/1e9a9d16eb61b90910357b770e5e11e080950d97/Source/Moya.swift#L38)). What version of Moya are you using?  @GTMYang: We have some documentation here: https://github.com/Moya/Moya/blob/master/docs/Providers.md#requestclosure

If you have further questions on how to use it after reading that, and the Endpoints documentation, we'd be happy to help! @GTMYang were you able to resolve you issue or do you need any additional assistance? Closing this due to inactivity, please re-open if you're still having issues üòÑ   While trying to figure out some of the codecov problems from #871, I realized that we were incorrectly getting a lot of coverage credit for the testing code itself. I added everything in the Demo and Carthage directories to be ignored.

Unfortunately this means a hit to the coverage metric. üò¢ I am also including a fix to the issue seen in #871 where coverage was reduced due to a file name collision with Alamofire. Looks like the fix worked, so this somewhat mitigates the loss in coverage from not including testing code in the coverage metrics.  After reviewing #869, I realized that MultiTarget wasn't passing it's embedded target's `parameterEncoding`. I fixed this as well as created a `MultiTargetSpec` to get full unit test coverage for `MultiTarget` and cleaned up a little related test code.  Closes #819

Added a test to ensure RxMoyaProvider does indeed emit a `complete`. Did some light house cleaning while I was in there. Hmm, how does this close #819 exactly? I don't think I understand; although bear in mind I'm not that familiar with Rx. I read the issue to mean that the OP didn't think `RxMoyaProvider` emitted a `complete` after a request. So I added a test to ensure it did. I guess I thought that closed the issue from the perspective that the test shows it isn't an issue. But we can leave it open if you think that's a good idea or that the new test doesn't go far enough. Hmm, right. Not entirely sure what OP's issue was then; let us just close it, and we can reopen if needed.   There are a few things in TargetType.swift that I think there might be better locations for. Here are the changes:

* Move the `Method` typealias to the Moya+Alamofire.swift file with the other Alamofire type aliases.
* Extract MultipartFormData to it's own file.
* Move `StubBehavior` to Moya.swift since it has more to do with `MoyaProvider` than `TargetType`.
* Move the extension on `Method` to Moya+Internal.swift where it is used. This could possible also go in Moya+Alamofire.swift.

Let me know what you guys think about this. Hmm... that's odd. Not quite sure why this would reduce test coverage by such a significant amount. I don't really think a changelog entry is needed for a refactor. :) Haha. Yeah, I didn't think so either. But I was a bit unsure because of Danger calling the build failed. I know I could add a #trivial tag to the PR, but this didn't really feel trivial either. Think I should go that route? Hmm, added #trivial in this case just to make Danger happy. Oh well. @scottrhoyt: thank you for doing this üòÑ  No problem! Anyone have any ideas on the test coverage? Ok, so I think I understand a little more about the drop in test coverage. For some reason, [CodeCov is registering](https://codecov.io/gh/Moya/Moya/src/sh_targettype_refactor/Source/MultipartFormData.swift) 285 missed lines for MultipartData.swift even though the file only has 32 lines with 5 lines of executable code. I wonder if it's possible that there is some confusion between Moya's `MultipartFormData` and Alamofire's `MultipartFormData`. These type name collisions are üò©.  Somehow this file got orphaned.  Can you post the code for your `TargetType`? It is an issue with your braces. You put most of the properties inside of the `sampleData` computed property. @dannymout I noticed you deleted that code block. Did that settle the issue for you and can we close this or do you have another question about `TargetType` implementation?  As discussed in #861   I agree it can get ungainly fast. I would recommend loading the data from files instead of including it directly in your `TargetType`. I'm going to work on including some helper functions in `TargetType` for this. Another option you have right now is to put the `sampleData` into a separate file.

For instance, create a GitHub+SampleData.swift that contains just this:

```swift
extension GitHub {
  var sampleData: Data {
    // put your sample data here
  }
}
```

That file would still be pretty ugly, but it would clean up the main API code. Agreed, it can get pretty wild. I store sample response data (JSON mostly) in files and return the contents of those files instead of hard-coding things. Here's an example: https://github.com/artsy/eidolon/blob/bbaa513cc50e6bdfe0aad317ffca1372ecbc8323/Kiosk/App/Networking/ArtsyAPI.swift#L182-L238 Let us know how it goes üëç Closing this now then, let us know if you encounter any issues!    #859 already adds `parameterEncoding` defaulting to `JSONEncoding`. Which version of Moya are you using? Thanks for the suggestion @EvilNOP. That is exactly what was done in #859 with `URLEncoding` being the default. A new release hasn't been cut yet so it is only available on `master` at the moment. Ah right, @scottrhoyt's change has not had a new release yet. Do you think that solves your problem or would your number 3 still be something you'd really like to see? @BasThomas, I think that number 3 is also being done in #859. It looks to just be the change needed to encorporate `TargetType`'s `parameterEncoding` instead of the hard-coded `URLEncoding.default`. Alright, I am going to close this issue then. @EvilNOP, if you feel like something else should still be addressed, feel free to reopen!  The quotes in the JSON aren‚Äôt escaped so the compiler is not interpreting this the way that you want. For `sampleData` this complex, instead of going through and escaping all the necessary characters, I would recommend that you load this data from another file.

> On Dec 25, 2016, at 10:34 AM, Danny M <notifications@github.com> wrote:
> 
> I have a question. I want to make sure I understand the purpose of sampleData. So, is this where examples of the JSON data you'd receive from the API go? If this is the case, I'm having an issue. The documentation for the API I'm using provides examples. I'm trying to use these examples, so I copied and pasted them and put the quotes around the text, but something with the quotes somewhere is messing up making Swift think it's a comment, I need to be able to put this into a string. Here is what's happening:
> 
>  <https://camo.githubusercontent.com/be0f50333832858332202c9880fe94f619d463c8/687474703a2f2f692e696d6775722e636f6d2f315038634939572e706e67>
> Some of it is being picked up as a string, and some of it as a comment. All I did was put quotes around it.
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub <https://github.com/Moya/Moya/issues/863>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AED9sk_YmhLnaITX_28vWkowci38gMM1ks5rLrczgaJpZM4LVc2W>.
> 

  Not 100% sure this is a great idea, but hopefully this PR can facilitate a discussion. I'll add a CHANGELOG entry and update the docs if we agree on this direction.

## Default `TargetType` Property Implementations And `SingleURLTarget`

### Problem

Currently, if a Moya user wants to make a simple GET request to a new URL (not represented by an existing `TargetType`) they have a couple of options: 

They can create a new `TargetType` which will allow them to keep a consistent networking layer as well as have access to `RxMoyaProvider`, `ReactiveMoyaProvider`, easy response mapping, and 3rd party extensions. However, there is a good amount of boilerplate needed for a simple request and a new type needs to be created even for one-off requests.

Alternatively, they could utilize `Alamofire` or `URLSession` directly, but this would introduce inconsistency into their networking layer and they wouldn't have access to easy reactive extensions and response mapping.

### Solution

Provide default implementations of all `TargetType` properties to represent the most commonly used combination of request settings: a GET request with no parameters.

Additionally, provide a trivial `TargetType` implementation (`SingleURLTarget`) so that users can easily create a `TargetType` that represents a GET request to a single URL with no parameters.

### Usage

```swift
let url = URL(string: "http://api.com")!

// Example 1
MoyaProvider().request(SingleURLTarget(url: url)) {
    result in
    // process result
}

// Example 2
let target = SingleURLTarget(url: url)
MoyaProvider().request(target) {
    result in
    // process result
}

// Example 3
let provider = MoyaProvider<SingleURLTarget>()
provider.request(target) {
    result in
    // process result
}
```

### Tradeoffs

* A reduction in conformance errors that are generated in compilation. These errors are often a source of documentation of available behavior.
* Explicit implementation of all behavior is self documenting and may be easier for developers to reason about.

These tradeoffs can be mitigated by improving the documentation for `TargetType`.

### Alternatives Considered

Provide `SingleURLTarget` without providing default implementations for other `TargetType`s. This would be a good compromise between servicing the specific use case of a simple target without reducing the self-documenting nature of implementing `TargetType`. However, there are other common use cases where other properties like `parameters`, `method`, `task`, or `sampleData` can result in unnecessary boilerplate. I was thinking... should we default everything for `TargetType` as well, or just for your suggested `SingleURLTarget`? I think the latter might be better.

Also, a separate PR for the documentation for `TargetType` would also definitely welcome! Yeah, there are pros and cons to both approaches.

On one hand, you can see even from the sample `TargetType`s in TestHelpers.swift, defaulting for all `TargetType`s helps clean up a decent amount of boilerplate. I like how this makes simple API implementations even more readable.

On the other hand, the lack of default implementation is a powerful means for discovering functionality and ensuring intended behavior. Hmmm

@scottrhoyt I feel as if you're totally right when you say

> lack of default implementation is a powerful means for discovering functionality and ensuring intended behavior

I thought the problem you've noticed is better serviced by something like `NSURLSession` or `Alamofire`. but then I looked around a bit at Moya's documentation, and realized that Moya is supposed to be a completely unified networking layer. If youre using Moya, there should be no need to use Alamofire.
![diagram](https://github.com/Moya/Moya/blob/master/web/diagram.png?raw=true)

So now I'm not totally sure whether or not Moya should integrate your solution. Can you share the code you were working with that led to you seeing the need of a default implementation? So I can see where you're coming from?
The way I've been using Moya is to model all of my API calls. So I look at my API's swagger, and then I convert each operation into a Moya enum case. Moya, for me, has become a way to document how I'm using the provided API. In that paradigm, being able to create a one-off API call has no value, I'd rather have the API call documented in my provider's enum I don't have any personal code to share, unfortunately. What got me thinking about this is when I was thinking through a good strategy for #836. In that case I thought writing all the typical `TargetType` boilerplate to utilize Moya in a simple request was a bit unnecessary, yet using Alamofire felt like going against the idea of Moya in the first place.

That made me realize you'd be likely to run into similar scenarios when utilizing 3rd party APIs in a light way along side your own API client written with Moya. Some examples of this might be adding weather information to an app, using an image API like Flickr, or accessing a Google location API. In these cases you are unlikely to need to fully specify `TargetType`s properties. You may need nothing more than `baseURL`, `path`, and possibly `parameters`.

Also, I find myself breaking up my API client code into multiple `TargetType`s to keep them from becoming monolithic (anything more than a handful of cases with several associated values each and a `TargetType` starts to get less readable IMO). In these cases, I often wind up with `TargetType`s that don't need `method`, `task`, or even `parameters` to be configurable. So I do wind up repeating a decent amount of boilerplate.

Finally, with the introduction of `validate` and now `parameterEncoding` with default values, the case for not providing defaults for the other properties felt a little more diluted to me.

But like said, I definitely see the other side here so I was hoping this proposal would bring out some other opinions. If you do a [search](https://github.com/search?utf8=‚úì&q=language%3Aswift+-filename%3ATarget.swift+TargetType+baseURL+path+method&type=Code&ref=searchresults) for how `TargetType` is used in public GitHub repos, you can see there is a high percentage of cases where the suggested defaults would reduce the amount of code needed. `method`, `task`, `parameters`, and `sampleData` are commonly `get`, `request`, `nil`, and `Data()` respectively. I would think there is some bias in this sample because more complicated API client code is probably more likely to be in a private repository, but it's still an interesting data point. @Moya/contributors Any more thoughts on this? @scottrhoyt what about a subclass of TargetType? `OpinionatedTargetType` or something that gives you nice defaults?
That way one can continue to take advantage of 
> lack of default implementation is a powerful means for discovering functionality and ensuring intended behavior

while removing the need to specify defaults in the simple cases Thanks for the suggestion @AndrewSB! Do you mean a new protocol conforming to `TargetType` and adding default implementations (a sub-protocol, if you will)? I see where you are coming from on that.

It's certainly an option, yet at first blush I'm not in favor. That is primarily because I think making the API surface area larger works counter to the goal of this PR--which is to make Moya easier to use for simple cases. An `OpinionatedTargetType` would require users to read more documentation to confidently use Moya, and that's really the same problem as is introduced by just doing the defaults on `TargetType` except you don't get all the benefits.

At it's heart, this is a philosophical decision for Moya about convention or configuration. I favor convention, and if you look at the defaults provided when you execute `Alamofire.request` or use `URLSession` to process a `URLRequest`, there are similar approaches. If the goal of Moya is to provide a unified networking layer, then I feel we should endeavor to make simple tasks as easy to accomplish with Moya as with the two technologies it replaces. By not doing so, we encourage just a new type of fragmentation of networking code. Even if this causes the self-documenting nature of `TargetType` to not be maximized, it will still be pretty clear to my eyes, and better and more organized than writing an ad-hoc networking layer on top of Alamofire or `URLSession`. Users will still have the option to fully specify the `TargetType` protocol for maximum clarity.

But I really think we need more than just the two of us to weigh in on this, since it is a decision central to Moya's philosophy.
 Yeah @scottrhoyt, I see what you're saying. There are pros and cons, and its definitely central.

Lets wait for some other people to chime in before we do anything here While we are talking about this: we might want to consider removing the [defaults already in place at this moment](https://github.com/Moya/Moya/blob/master/Source/Target.swift) and add the (much) needed (?) documentation for all the options, like was done in this PR, to the options. If we are going to advocate that simple API requests still be handled with Alamofire/`URLSession` then I think we should change the image at the top of the README to this:

![diagram](https://cloud.githubusercontent.com/assets/4259250/21548608/2b57e3b4-cda2-11e6-953c-ea8f53307917.png)

As for `sampleData`, even as an ardent unit tester, I think there is a difference between first-class support of unit testing and first-class forcing people to write testing code. We all know very few projects get started with full test suites in place. If tests do eventually get added, it is often done at a later date (i.e. not much TDD going on). The amount of Moya code that starts off with

```swift
var sampleData: Data {
  return Data()
}
```

considerably outnumbers the amount of code that is using `sampleData` in it's intended fashion. [This search](https://github.com/search?utf8=‚úì&q=language%3Aswift+-filename%3ATarget.swift+TargetType+baseURL+path+method&type=Code&ref=searchresults) backs that up at least for public repos. By adding even a little bit of friction to selecting Moya as your networking layer because of it's verbosity and forcing of unit testing code into your app, we just encourage people to go a different route that will be harder for them to add unit tests once they get to the point that they realize they need it. While it is admirable to say that we can change testing etiquette by forcing people to implement `sampleData`, the reality is that it's still just a--confusing for anyone that isn't familiar with Moya--`Data()` away from being ignored and that is what most people are doing. Changing testing behavior will require a bigger impetus than a single networking library, but every single networking library should still support it in some way. Frankly I think Moya should go further to support testing by providing an easy way for test data to be stored in fixtures because if you want to use real returns from even a moderate-complexity API, the `TargetType` code quickly gets bloated back to unreadable status.

I started off thinking that the verbosity of `TargetType` was a positive because of it's self documenting nature. But I think I have come around to see it differently. When I look at this:

```swift
enum SimpleApi: TargetType {
  case newsfeed, messages

  var baseURL: URL { return URL(string: "http://api.com")! }

  var path: String {
    switch self {
    case .newfeed:
      return "newsfeed"
    case .messages:
      return "inbox"
  }
}

MoyaProvider<SimpleApi>.request(.newsfeed) { //... }
```
  
It is pretty clear to me that what is being executed is a simple GET request with no parameters. That's the same as if I were to see this:

```swift
Alamofire.request("http://api.com/newsfeed") { // ... }
```

That is because pretty much every way that I interact with HTTP (Alamofire, `URLRequest`, curl, wget, Postman, my web browser) defaults to a GET request with no parameters. And the reality is that once your API becomes complicated enough to really worry about whether API specifications are clear in the Moya code, you will have overridden most of the defaults and gotten right back to where we are today, except you'll be glad that you used Moya for even the simple things because now you don't have to go back and figure out how to write unit tests for all the times you fell back to Alamofire. @BasThomas I think we definitely need that documentation if we are going to provide default values. If not, then the documentation is pretty trivial--but probably still a good idea to have the whole surface area of your public API documented. I'll open up a separate PR with some trivial documentation. Do any @Moya/contributors know why Danger might be failing here:

![screen shot 2016-12-29 at 9 16 45 pm](https://cloud.githubusercontent.com/assets/4259250/21560008/3d277f22-ce0c-11e6-8ec6-c3f957bad319.png)
 I *think* it's the ["Any changes to library code need a summary in the Changelog."](https://github.com/Moya/Moya/pull/861#issuecomment-269254867) maybe? No, I think that's a Danger bug. We should try updating to the latest to see if it's been fixed.  I'd love to pick a direction on this one way or another soon. Does anyone else have any opinions on whether or not this is a good fit for Moya?

If we decide to not go this direction, it's not a big deal to me. Other users and I can still add these defaults without much hassle. We can even add a suggestion in the docs. However, I do think it aligns with Moya's stated goal:

> So the basic idea of Moya is that we want some network abstraction layer that sufficiently encapsulates actually calling Alamofire directly. It should be simple enough that common things are easy, but comprehensive enough that complicated things are also easy.

If we decide against defaulting, we might want to revisit whether or not `parameterEncoding` (and possibly `validate`) should have a default before the 8.0.0 release. Hard to say, is defer to whatever is least surprising for users, but that's certainly up for debate in this case. It doesn't sound like there's a tonne of push for it, so it might make sense to hold off for now at least.  Alright. I'm going to leave this PR open for the moment so that others that might be gone for the holidays can consider it when they get back. It can still be done post 8.0.0 since it won't be a breaking change. 

I think we can make the case for providing a default for `validate` since it's suppressing Alamofire behavior and we try to not leak Alamofire where possible. However, I'll open a PR to remove the default for `parameterEncoding` and include that default in this PR. That way we are consistent on the current approach and can decide on providing defaults for `TargetType` as a whole. If no-one has any further thoughts on including this, I will go ahead and close this.  This is to clean up the warnings generated by SwiftLint. Could someone explain what this change does?
From my understanding, `Void` is just a `typealias` for `()`, what is swiftlint's complaint? Yeah, there is nothing functional here. It's purely stylistic. I prefer Void, but if others would like to stay with (), we can silence these warnings by disabling this rule in .swiftlint.yml.

> On Dec 24, 2016, at 4:36 PM, Andrew Breckenridge <notifications@github.com> wrote:
> 
> Could someone explain what this change does?
> From my understanding, Void is just a typealias for (), what is swiftlint's complaint?
> 
> ‚Äî
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 
 Which rule catches functions that return `()`? `void_return`  Closes #858 

This is a simple implementation of allowing the `TargetType` to specify its `ParameterEncoding`. The default implementation specifies `URLEncoding`. Yep! Sure, I went ahead and updated the documentation. Thanks! @scottrhoyt No, thank you. I'm so glad this got done! üíØ   For RxSwift, the favored approach to updating your UI would be to use `bind`. You can find some good tutorials for how to do so via a search. @rlam3 were you able to sort out using `bind` to accomplish what you want? If not I suggest working through [these excellent tutorials](http://www.thedroidsonroids.com/blog/ios/rxswift-by-examples-1-the-basics/) from our very own @sunshinejr. Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  I've updated the readme to link to [Moya-JASONMapper](https://github.com/AvdLee/Moya-JASONMapper) as this one is being update more often and tries to be in sync with Moya releases. I'm getting the error: 
```
For your GitHub repo, you need to expose: DANGER_GITHUB_API_TOKEN
You may also need: DANGER_GITHUB_HOST, DANGER_GITHUB_API_BASE_URL
```

I've got my token ready, but I'm unable to expose it using the `DANGER_GITHUB_API_TOKEN` key. Anyone available to provide me the needed information to do this? > Suppressing export of environment variables DANGER_GITHUB_API_TOKEN fork PR builds

Not sure why Circle decided to skip this step, but that's what is causing the issue Got it: I had to enable **Pass secrets to builds from forked pull requests** in the settings. We could do that. However, I think it's important that we reference the repo's who are up to date the most. When developing you want to reference up to date repo's as much as possible. I agree with @AvdLee. Maybe @sunshinejr knows about any intended work on the former? > We could do that. However, I think it's important that we reference the repo's who are up to date the most. When developing you want to reference up to date repo's as much as possible.

Agreed, but I don't think that [Moya-JASON](https://github.com/DroidsOnRoids/Moya-JASON) is truly outdated at this point. [It is using Moya version 8.0.0-beta-4](https://github.com/DroidsOnRoids/Moya-JASON/blob/master/Moya-JASON.podspec#L33).

It's true that [Moya-JASONMapper](https://github.com/AvdLee/Moya-JASONMapper) is using 8.0.0-beta-6, but I wouldn't consider this a huge difference.

My suggestion is to keep both listed and let whoever needs a JASON mapper decide which one fits their needs. Woah, that's harsh. Didn't have time to update all the things lately, dunno when will it happen so can't promise anything. I'm gonna leave the decision to you guys. Listing both makes the most sense to me too. Moya has been moving very quickly and making a lot of breaking changes, it makes sense that the community is struggling to keep up. Hopefully things settle down a bit after our 8.0 release.  This is probably a result of the underlying `Alamofire.URLEncoding`. If your API can take parameters encoded as JSON in the HTTP body, I would suggest  switching to `JSONEncoding`. The easiest place to do this would be in the `endpointClosure` when initializing the `Endpoint`. You can now use `TargetType.parameterEncoding` to accomplish this.  Hey @liliah.

I can't say that I know specifically what is going wrong here, but if I had to guess, I would say that there could be a problem with how the authorization header is being encoded and/or how it is interpreted by your API. If you have the ability to change how authorization headers are used by the API, I think you might have fewer issues if you use the standard approach for access-token-based authentication. This is the standard format:

```
Authorization: Bearer <access_token>
```

If you have to use the current approach, I would note that the capitalization of `Authorization` also changed. That may be the source of the different behavior as well.

For debugging purposes, you can also utilize the `NetworkLoggerPlugin`. Turn on the curl output and then you can try the generated requests via CLI for another perspective on what might be going on. Were you able to get this sorted out @liliah? Glad to hear it is working for you! üëç  That is interesting @mihailstumkins. Would you mind opening up an issue to track that? `AccessTokenPlugin` and `AccessTokenAuthorizable` are new additions, so there is a possibility that they contain a bug that is not being tested for.  @shivayogic, in the code you posted, it doesn't look like there are any subscriptions to `rx_getAuthToken`, so the request won't be made. The `do` operator only specifies a side-effect to be performed. Try replacing the `do` operator with `subscribe`. Then uncomment the `expect.fulfill()` and see if this test passes.  Hey, I already updated dependencies in #842, which has yet to be merged. Might be better to update that (`rc.1` to `rc.2`) and update everything at once? :) Closing this, then. :)  You can take a look at #834 to get started, maybe? @rlam3 since you're using Rx, I'd recommend looking at this example in the RxSwift repo: https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples/GitHubSearchRepositories

It doesn't use Moya, but the GitHub service it uses is similar to a Moya `provider` I really can't say without seeing the rest of your code @rlam3. I'd recommend putting a `didSet` propertyObserver on your `feedItems` property, and either printing out the newValue, or setting a breakpoint so you can see what is mutating the property. It doesn't look like an RxSwift problem to me, I've been able to use standard collection view functions while using Rx üòÑ  @rlam3: I'm going to close this for now, but please do re-open this if you still have questions, it sounds like this is more of a Rx-y question than a Moya question.

RxSwift also has a really friendly slack where people are usually really willing to help out, especially with questions about best practice üòÑ   In this case your best bet is to modify the `httpBody` of the underlying `URLRequest`. You have two choices on where to do this: either in the providers `requestClosure` or by creating a plugin and using the `prepare` function. If you can represent all of your XML data in key/value format, another option would be to create a custom parameter encoder conforming to `ParameterEncoding` and utilize the `TargetType.parameters` property to pass the data. Then in the `endpointClosure` create the endpoint with your custom parameter encoder. You can now use `TargetType.parameterEncoding` to change the parameter encoding, but you would still need to create a custom XML-based `ParameterEncoding`. @k8mil No problem! If you wind up creating a custom XML `ParameterEncoding`, it would be awesome to submit that to Alamofire in a PR. That way we can offer it to all Moya consumers as well.  Alternatively if you want to have the subscription remain there's `.catchError|.catchErrorJustReturn` to handle the error before it disposes. For example:

```swift
provider.request(.token(_,_))
  .filterSuccessfulStatusCodes()
  .catchError() { error -> Observable<Response> in
    // do something to return a new Observable, retry etc.
    
    // ...or pass it along if it's not recoverable
    throw error
  }
  .mapObject(type: MyObjectMap.self)
  .subscribe(onNext:{ object in

    // do something with mapped object 

  })
``` @rlam3, @jonlambert 's suggestion looks like what you are looking for then. Does this resolve the issue for you? Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.   Can this be removed? ü§î We already have that nice Swift -> Moya versions table Agree, that's much better.  Ref #299  Also moved the file to the `.github` folder.  I have an endpoint that‚Äôs timing out when using Moya.
```swift
getApiProvider().request(.getOrder(id: 4))
  .subscribe { i in
    print(i)
  }
```

No errors, just the following in the console: 

```
2016-12-17 12:19:20.223132 TestApp[46055:1474324] [] nw_endpoint_flow_service_writes [3.1 176.34.225.3:80 ready socket-flow (satisfied)] Write request has 4294967295 frame count, 0 byte count
```

I don't see any logs showing this particular request on the server, and other requests from Moya are working fine.

- [Moya configuration code](https://gist.github.com/jonlambert/b6662045f21e849a00899f51deda5b01)  (tidied up to include only the endpoint in question for brevity)
- [getApiProvider() code](https://gist.github.com/jonlambert/b6662045f21e849a00899f51deda5b01#file-networkhelpers-swift)

When I perform an identical request with Alamofire... 

```swift
Alamofire.request(
  "http://localhost:3000/api/v1/assistants/order?order_id=4",
  method: HTTPMethod.get, 
  parameters: nil, 
  encoding: JSONEncoding.default, 
  headers: [ "Authorization" : "Bearer <token>" ]
)
.response(completionHandler: { response in
    print(JSON(data: response.data!))
})
```

...the request completes without issue. 

I'm sure it's likely something simple I'm overlooking - any ideas what may be causing this?
 Thanks for providing all the details. You could try adding the [NetworkLogger](https://github.com/Moya/Moya/blob/master/docs/Plugins.md) plugin to see if that reports anything.
Also, which version of Moya are you using? @BasThomas 
Thanks for your quick reply! `NetworkLogger` doesn't really add anything extra info - in fact at the moment it's not showing any request at all. 

I'm using `Moya/Swift ~> 8.0.0-beta.4` - should I give the latest version a go?

 Although I am not aware of anything that might fix this particular issue, please give it a go :) @BasThomas ah, now I remember why I'm tied to this version: I'm pairing Moya with `Moya-SwiftyJSONMapper` which specifies `beta.4` Hey @jonlambert, `Moya-SwiftyJSONMapper` has been updated for `beta.6`. Could you try with that version and see if that makes a difference? Thanks @BasThomas but I've just updated, no luck I'm afraid! Still getting the same issues. Is my `parameters` property specified correctly? Hmm, I see your API.swift file uses `POST` instead of `GET`, might that cause the issue? @BasThomas ah that was a mistake when I tidied it up! It's specified as `GET` in the actual file. I'll edit the file attached accordingly. Hmm, don't see anything that'd cause it, then. @Moya/contributors, any ideas? @jonlambert it looks to me like an Rx issue. Are you adding your subscription to a disposeBag? @AndrewSB Yep - problem occurs both with and without the subscription being added to a DisposeBag. @jonlambert Any chance you could create a public repo that reproduces the problem? I'd jump in and do some debugging. Also, one thing to note... while your `Alamofire.request` example specifies `JSONEncoding`, you are manually encoding the parameters in the URL. In the Moya instance, these will instead be encoded as JSON in the HTTP body. This might not make a difference depending on your API code. I've actually run into a similar issue, only it's much more spotty than what OP describes... it happens occasionally on my sign in request. I'm using `ReactiveSwift` and `ReactiveCocoa` with `ReactiveMoya`. My network request is wrapped in an `Action<(), String, AuthenticationError>`, and it seems to be invoked, because my button disables properly, but no network requests show up on the server, in the network logger, in my local proxy, or anywhere. I have to leave the app and come back, which for whatever reason, forces the `Action` to send an error.

Typically, this will fix itself with a few tries of leaving the app and coming back.

We've been trying to chase this bug down for MONTHS, but have such a hard time trying to reproduce it. @jonlambert: could it have anything to do with creating a new provider and then immediately using it? Could you try creating your Provider, and then dispatching your network request a second later, as an experiment, to see if it changes anything?

@justinmakaila: sounds like a headache üòï @justinmakaila I've had this issue sporadically too, just this time (luckily or unluckily?) it's consistently failing so I can examine it further.

@scottrhoyt I will certainly try and put together a repro tomorrow (I'm on UK time at the moment). I expect accurately reproducing the server's behaviour might be a bit difficult if it's a server quirk throwing Moya off - but I'll give it a go nonetheless. 
That's a great point about the JSONEncoding. I'll look into that now!

@AndrewSB I've tested that with a 5 second delay to no avail unfortunately. Still the same timeout. üòï @scottrhoyt Just tried your suggestion this morning - that fixed it! 

```swift
let endpoint = Endpoint<ToshiAPI>(
    url: url,
    sampleResponseClosure: {.networkResponse(200, target.sampleData)},
    method: target.method,
    parameters: target.parameters,
    parameterEncoding: target.method == .get ? URLEncoding.default : JSONEncoding.default
)
```

Looks like there's an issue with Alamofire timing out when sending `GET` requests using Alamofire with JSON in the body: https://github.com/Alamofire/Alamofire/issues/1530, https://github.com/Alamofire/Alamofire/issues/1819

If you guys think this use case is common enough then this conditional is fine; perhaps I could add a pointer in the documentation though. 

Otherwise I'd be happy to discuss other ways of handling this automatically when using JSONEncoding üëç (Although perhaps that's an issue for Alamofire itself)

Thank you so much everyone for your help!  Hmm... that doesn't fix it for me. If I get a re-creatable test case, I'll open a new issue. If you get a reproducible error @justinmakaila I'd be interested in following along. I have a feeling this isn't the same bug as the sporadical timeout.  @jonlambert, glad to hear that worked for you! With the introduction of #859, you can now set your `parameterEncoding` directly in your `TargetType`. This change is currently only available on `master`. Reopening issue - it worked in the instance above but I'm getting the same error using it elsewhere in the code. Looks like a similar scenario to @justinmakaila. Sorry to hear the issue is back. My recommendation would be to enable curl output on the `NetworkLoggerPlugin`, add it to your provider, and use the curl output to test the requests from your CLI to diagnose the problem. If you aren't seeing any output from the logging plugin, then something is probably going wrong on the Moya side and might be able to be reproduced in a sample repo for us to debug. @scottrhoyt There's no output from the logging plugin when I make the request - I'll attempt to reproduce the issue as soon as I can!  @scottrhoyt

I have attempted to reproduce the issue, the repository can be found here: https://github.com/jonlambert/MoyaIssue844 @jonlambert I set up a few breakpoints in your project and ran into this curious situation:

<img width="1512" alt="screen shot 2017-01-10 at 17 43 17" src="https://cloud.githubusercontent.com/assets/1638996/21828048/5ae7450c-d75c-11e6-87cc-832991f8c115.png">

it looks like the provider is nil at the point of creating the `Observable`

EDIT (addition?): That's probably due to the fact that the provider is out of scope at the end of `download()` on the view model. I'm going to try keeping the provider around... @jonlambert Updating your view model code to:
```swift
class WelcomeViewModel: NSObject {
    let provider: RxMoyaProvider<API>
    
    override init() {
        provider = RxMoyaProvider<API>(
            endpointClosure:  MoyaProvider.defaultEndpointMapping,
            requestClosure: MoyaProvider.defaultRequestMapping,
            stubClosure: MoyaProvider.neverStub,
            manager: RxMoyaProvider<API>.defaultAlamofireManager(),
            plugins: [NetworkLoggerPlugin(cURL: true)],
            trackInflights: true
        )
        
        super.init()
    }
    
    func download() -> Observable<Moya.Response> {
        return provider.request(.ping)
    }
}
```
Results in expected behavior:
```
2017-01-10 17:48:01.958: WelcomeViewController.swift:39 (viewDidLoad()) -> subscribed
["$ curl -i \\\n\t-H \"Accept-Language: en;q=1.0\" \\\n\t-H \"User-Agent: MoyaIssue844/1.0 (co.evada.MoyaIssue844; build:1; iOS 10.2.0) Alamofire/4.2.0\" \\\n\t-H \"Accept-Encoding: gzip;q=1.0, compress;q=0.5\" \\\n\t\"https://hookb.in/Z6mo35ag/?foo=bar\""]
[["Moya_Logger: [10/01/2017 17:48:16] Response: <NSHTTPURLResponse: 0x608000039320> { URL: https://hookb.in/Z6mo35ag/?foo=bar } { status code: 200, headers {\n    \"Access-Control-Allow-Origin\" = \"*\";\n    \"Cache-Control\" = \"private, no-cache, no-store, must-revalidate\";\n    \"Content-Length\" = 16;\n    \"Content-Type\" = \"application/json; charset=utf-8\";\n    Date = \"Tue, 10 Jan 2017 22:48:17 GMT\";\n    Expires = \"-1\";\n    Pragma = \"no-cache\";\n    Server = nginx;\n    \"Strict-Transport-Security\" = \"max-age=31536000; includeSubdomains; preload\";\n    \"access-control-allow-headers\" = \"Origin, X-Requested-With, Content-Type, Accept\";\n    \"access-control-allow-methods\" = \"GET, PUT, POST, DELETE\";\n    \"x-expires-at\" = \"Tue, 17 Jan 2017 16:25:02 GMT\";\n    \"x-ratelimit-limit\" = 1000;\n    \"x-ratelimit-remaining\" = 999;\n    \"x-ratelimit-reset\" = 3600;\n    \"x-ua-compatible\" = \"IE=Edge,chrome=1\";\n} }"]]
2017-01-10 17:48:18.035: WelcomeViewController.swift:39 (viewDidLoad()) -> Event next(Status Code: 200, Data Length: 16)
Status Code: 200, Data Length: 16
2017-01-10 17:48:18.035: WelcomeViewController.swift:39 (viewDidLoad()) -> Event completed
2017-01-10 17:48:18.035: WelcomeViewController.swift:39 (viewDidLoad()) -> isDisposed
``` Thanks for the investigation @justinmakaila! This is quite related to the issue brought up in #905. Side note: I don't think this is exactly related to the sporadic issue. In fact, while playing with this project, my team reported that they encountered the bug again. Requests began appearing in a proxy they had set up within 15-90 seconds of the initial "stumble". Still trying to dig in. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
     Yay Danger! :D After this was merged, when I run `pod install` in the Demo directory, I get this:

<img width="1618" alt="screen shot 2016-12-30 at 10 28 29 am" src="https://cloud.githubusercontent.com/assets/4259250/21570495/657af282-ce7b-11e6-829c-f50a488b31aa.png">

<img width="1740" alt="screen shot 2016-12-30 at 10 35 22 am" src="https://cloud.githubusercontent.com/assets/4259250/21570548/b3887c42-ce7b-11e6-9c25-6164c619180a.png">

I'm using the beta of the new cocoapods release because I was having issues with the current release. I think we just need a minor change to the Podfile to support this. Strange; I don't think I have run into any issues myself doing this. ü§î Yeah, I don't know what's going on here. After playing around a bit more, I think it is quite possible it was on my local machine. Running a `pod update ReactiveSwift` and not committing the changes seems to have solved it for me. This is likely some difference between cocoapods 1.1.1 and 1.2.0-beta3.   Hmm... (cc @pedrovereza)

```bash
Downloading CocoaPods master repo from cocoapods-specs S3 bucket...
Uncompressing CocoaPods master repo...
master/.git/objects/pack/pack-35326da53152e3c953d14b6383803365213400d7.pack: gzip decompression failed
tar: Error exit delayed from previous errors.
Download from S3 failed, cleaning up and falling back to standard checkout...

curl -sS https://cocoapods-specs.circleci.com/fetch-cocoapods-repo-from-s3.sh | bash returned exit code 1

Action failed: curl -sS https://cocoapods-specs.circleci.com/fetch-cocoapods-repo-from-s3.sh | bash
```

Let me rebuild. Hmm, interesting. I am not sure. Should we use `verbose` in the initializer, but leaving it `isVerbose` internally? Does that make sense? Then again, you can get the "verbosity status" as it is a pubic `Bool`. ü§î Why are these (read: `cURL` and `isVerbose`) public anyway? They are `let`s, and always configured in the init. Is there a reason they should be accessible? Having it as `isVerbose` internally seems fine. In fact, [Carthage does it](https://github.com/Carthage/Carthage/blob/2808725a6c0cb7ae714b0cad28aeaf97d89064db/Source/carthage/Update.swift#L19), but you set this mode by using `--verbose` not  `--isVerbose`. Agreed üëç. Changed the constructor back to use `verbose` instead of `isVerbose`. @Moya/contributors, any idea as to [this](https://github.com/Moya/Moya/pull/841#issuecomment-267766014)?

> Why are these (read: `cURL` and `isVerbose`) public anyway? They are `let`s, and always configured in the init. Is there a reason they should be accessible?

If that's cleared up this should be good to go. The properties are public because they're passed in as parameters to the initializer, and I [still adhere to API design principles](http://mattgemmell.com/api-design/) that specify all initializer parameters should be accessible after the fact. But that's just me ‚Äì it's totally open for discussion! Yep, great! There's not really a problem keeping them public, so let's keep it this way. üëç   Just saw that in the NetworkLoggerPlugin, there a non `is`-bool (verbose) that should be updated. Let's do that in a separate PR. -> #841   What do you mean exactly?  Circle CI finally rolled it out to everyone :tada:

Fixes #755  There are a couple of things to unpack here. First of all, currently Moya's support for executing simple requests against a single `URL` is pretty light. There are some new features suggested in #861 that would make this easier, but we are still deciding whether or not they agree with Moya's philosophy. If you want to include this in your own code, I'd suggest looking at how `SingleURLTarget` is implemented and possibly include that in your code.

Without a `SingleURLTarget`, I would recommend using Alamofire instead for the dynamic `URL` requests.

The second part is writing a `TargetType` that can accept multiple `baseURL`s and cycle between them. For this I'm inclined to suggest that you create a new `TargetType` that isn't an `enum` (possibly an extended version of `SingleURLTarget`). You can even embed a separate `enum` into this structure to retain some of the `switch` semantics that Moya promotes. You will also want to subclass `MoyaProvider` to contain the state you need (e.g. the index of the `baseURL` to try). You may also want to change the behavior of it's `request` method to emit an error (from `catchError`) when the `baseURL`s have been exhausted.

Beyond that, you should just be able to string the requests together with `RxSwift` similarly to your example. Let me know if that gets you going in the right direction or if you have any other questions! Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  @nahung89 can you also post your `Cartfile.resolved`? Seems like the same problem as #760, but that hasn't been identified yet. :/ Hmm...
The problem seems to be a bug in Carthage, for some reason Carthage is choosing a really old version of Moya (3.0.0), and you're failing to build because that version is written in an older version of Swift.

A temp fix would be to add a greater than version specifier to your Cartfile, but we should loop in the Carthage maintainers to take a look.

Update your Cartfile to `github "Moya/Moya" >= 8.0`, and let us know if that works  This all seems very strange - Carthage shouldn't be looking at the demo.xcodeproj

Can you also try clearing your derived data and Carthage cache? When I run it with an empty project, I get the following result:

```bash
bas$ carthage update
*** Cloning Moya
*** Cloning ReactiveCocoa
*** Fetching RxSwift
*** Fetching Alamofire
*** Fetching Result
*** Checking out Alamofire at "3.5.1"
*** Checking out Result at "2.1.3"
*** Checking out ReactiveCocoa at "v4.2.2"
*** Checking out RxSwift at "2.6.1"
*** Checking out Moya at "7.0.4"
*** xcodebuild output can be found in /var/folders/ys/z545gl_90v7918jxtvv_2dzm0000gn/T/carthage-xcodebuild.u1E6C9.log
*** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*** Building scheme "Result-Mac" in Result.xcodeproj
*** Building scheme "Result-watchOS" in Result.xcodeproj
*** Building scheme "Result-iOS" in Result.xcodeproj
*** Building scheme "Result-tvOS" in Result.xcodeproj
*** Building scheme "ReactiveCocoa-Mac" in ReactiveCocoa.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
*** Building scheme "ReactiveCocoa-tvOS" in ReactiveCocoa.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
*** Building scheme "ReactiveCocoa-watchOS" in ReactiveCocoa.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
*** Building scheme "ReactiveCocoa-iOS" in ReactiveCocoa.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
*** Building scheme "RxBlocking-OSX" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxBlocking-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxBlocking-watchOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-OSX" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-tvOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-watchOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxTests-OSX" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-watchOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxTests-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-tvOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxBlocking-tvOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-OSX" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxTests-tvOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxMoya watchOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya watchOS" in Moya.xcodeproj
*** Building scheme "Moya watchOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya iOS" in Moya.xcodeproj
*** Building scheme "Moya iOS" in Moya.xcodeproj
*** Building scheme "RxMoya tvOS" in Moya.xcodeproj
*** Building scheme "RxMoya iOS" in Moya.xcodeproj
*** Building scheme "RxMoya OSX" in Moya.xcodeproj
** BUILD FAILED **


The following build commands failed:
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Error.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Image.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/NetworkActivityPlugin.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Response.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Endpoint.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/CredentialsPlugin.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/NetworkLoggerPlugin.swift
	CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(9 failures)
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
/Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
A shell task (/usr/bin/xcrun xcodebuild -project /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Moya.xcodeproj -scheme "RxMoya OSX" -configuration Release ONLY_ACTIVE_ARCH=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:
** BUILD FAILED **


The following build commands failed:
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Error.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Image.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/NetworkActivityPlugin.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Response.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Endpoint.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/CredentialsPlugin.swift
	CompileSwift normal x86_64 /Users/bas/Documents/iOS/Test/Carthage/Checkouts/Moya/Source/Plugins/NetworkLoggerPlugin.swift
	CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(9 failures)
```

(Also, my gosh, that took forever)

Cartfile:

```
github "Moya/Moya"
```

Cartfile.resolved:

```
github "Alamofire/Alamofire" "3.5.1"
github "antitypical/Result" "2.1.3"
github "ReactiveX/RxSwift" "2.6.1"
github "ReactiveCocoa/ReactiveCocoa" "v4.2.2"
github "Moya/Moya" "7.0.4"
```

The failing here makes sense, as `Carthage` can't resolve beta tags, and it fetched a Swift 2 release.
Testing with `github "Moya/Moya" >= 8.0` now. With Cartfile

```
github "Moya/Moya" >= 8.0
```

and Cartfile.resolved:

```
github "Alamofire/Alamofire" "4.2.0"
github "antitypical/Result" "3.1.0"
github "ReactiveX/RxSwift" "3.0.1"
github "ReactiveCocoa/ReactiveSwift" "1.0.0-alpha.3"
github "Moya/Moya" "8.0.0-beta.5"
```

... it seems to just work. Not sure what's happening üòï

Output, for reference:

```bash
bas$ carthage update
*** Fetching Moya
*** Fetching RxSwift
*** Fetching Alamofire
*** Fetching Result
*** Checking out Alamofire at "4.2.0"
*** Checking out Result at "3.1.0"
*** Checking out ReactiveSwift at "1.0.0-alpha.3"
*** Downloading RxSwift.framework binary at "Graham"
*** Checking out Moya at "8.0.0-beta.5"
*** xcodebuild output can be found in /var/folders/ys/z545gl_90v7918jxtvv_2dzm0000gn/T/carthage-xcodebuild.5A09ae.log
*** Building scheme "Alamofire macOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Result-Mac" in Result.xcodeproj
*** Building scheme "Result-watchOS" in Result.xcodeproj
*** Building scheme "Result-tvOS" in Result.xcodeproj
*** Building scheme "Result-iOS" in Result.xcodeproj
*** Building scheme "ReactiveSwift-macOS" in ReactiveSwift.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
*** Building scheme "ReactiveSwift-tvOS" in ReactiveSwift.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
*** Building scheme "ReactiveSwift-watchOS" in ReactiveSwift.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
*** Building scheme "ReactiveSwift-iOS" in ReactiveSwift.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/bas/Documents/iOS/Test/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
*** Building scheme "ReactiveMoya iOS" in Moya.xcodeproj
*** Building scheme "RxMoya OSX" in Moya.xcodeproj
*** Building scheme "RxMoya iOS" in Moya.xcodeproj
*** Building scheme "RxMoya tvOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya watchOS" in Moya.xcodeproj
*** Building scheme "RxMoya watchOS" in Moya.xcodeproj
*** Building scheme "Moya tvOS" in Moya.xcodeproj
*** Building scheme "Moya watchOS" in Moya.xcodeproj
*** Building scheme "Moya OSX" in Moya.xcodeproj
*** Building scheme "Moya iOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya tvOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya OSX" in Moya.xcodeproj
``` Tried on the Demo project using `github "Moya/Moya" >= 8.0`, worked fine for me üëÄ 
*using Carthage 0.18.1* Hmm, Carthage is consistently checking out an older versions of Moya (initially `3.0.0`, and `7.0.4`) when one doesn't specify `>= 8.0`.

@BasThomas, @pedrovereza, and I all have it compiling when specifying `>= 8.0`, I'm not sure why you're running into this issue @nahung89. Are you in a Swift 3 project?
What's stranger still, is that your Carthage is trying to build `Moya/Demo/Pods/Pods.xcodeproj `, which shouldn't be seen by Carthage (and isn't seen by the three of us) when the project is being built by Carthage...

I'll go ahead and create an issue on Carthage to see if they know what's happening. Thanks for the additional information @nahung89, we're waiting on https://github.com/Carthage/Carthage/issues/1637 now. Sounds good @nahung89! Matt from Carthage said he thinks it was something wrong with your Carthage cache, if you see this problem again, can you report it?

Thanks!  I usually include the page number as an associated value on the enum, and use that value in the parameters. Does that work for your code?  Hmm, how should we do this? Alamofire has a great explanation on how to add their project as a `git submodule`, which are roughly the same steps needed for `Result` and `Moya`.

I don't think I've captured that the best I could; I'd love some feedback on how to make it better!

Fixes #780  @jaymutzafi: please check if this works for you, and let me know if you have any questions / improvements! `Do the same for Moya` is a little sparse, what if we tried to copy more of Alamofire's docs?

almost exactly all of this, tweaked to work for Moya
<img width="919" alt="screen shot 2016-12-08 at 2 23 18 pm" src="https://cloud.githubusercontent.com/assets/3814772/21030145/e4e13ec2-bd51-11e6-8bbc-2a33b12ae747.png">
 Was considering that. And then make it "compatible" with all three frameworks? (As Alamofire needs just Alamofire, and we need Alamofire, Result & Moya itself) @BasThomas that sounds good to me! Updated them. If someone could try this and provide feedback, that'd be awesome!  Also cleaned it up a bit.

(Yay, working with Moya for the first time üò¨üò¨üò¨) üíØ   As discussed in #824  @manas-chaudhari mentioned something interesting here: https://github.com/Moya/Moya/issues/823#issuecomment-265458718

Let's use this issue to discuss whether we can implement what he was trying to do üòÑ  closing this for now. @manas-chaudhari: please do re-open this if you're interested in getting this added to Moya Sounds interesting @manas-chaudhari, I'm having a little trouble understanding your example though, are you saying that if I wanted to request my user model, for example, I'd do `provider.request<UserModel>(.me, completion...)`? In my opinion, that doesn't add much to `provider.request(.me).map(UserModel.init)`.

Would you like to make a PR to implement your idea? I think starting out by amending the docs would be the easiest way for me to understand what you're suggesting, and for the contributors to talk about (see https://github.com/Moya/Moya/pull/762 for an example of a README-first PR). If we can get enough people saying they like your idea, we'd be more than happy to merge this in üòÑ  Sounds great @manas-chaudhari, looking forward to checking out the updated docs üòÑ  Closing this in favor of #910 üòÑ   Noticed in #827  Thanks!  These changes were already implemented and merged in PR #581.

Brought up in Issue #580, the changes were never added to a Swift 2.2 and 2.3 releases, meaning MultipartFormBody was broken for release 7.x
 Cool, I'd love to get another set of eyes on this, and we can release tomorrow. Thanks for taking this on! Ok, I'll get this released as soon as possible, I'll let you know üëç Okay, this should be up. @mattfxyz can you confirm this works on your end?  @ashfurrow Looks like cocoapods is aware of new version but there isn't a release for it. I can release it if you want.

But I pointed my podfile at the release-7.0.4 branch and everything is working as planned!  Right! I had to release manually instead of using the rake task, if you could create the GitHub release that would be :100: @ashfurrow Release created and our podfile update!  @ashfurrow Release created and our podfile update! I'll close the issue.    Weird, I wouldn't think Danger would complain about that on trivial PRs. Might be worth a change.   I seem to have missed this in #805. üò¨  This renames some functions to better comply with the Swift 3 guidelines, as well as unifying the RxSwift and ReactiveSwift functions Hmm, not sure about the renaming of `filterStatusCodes(:)` to `filterStatusCodes(in:)` quite sure myself, to be honest. I think `filterStatusCodes(0...9)` reads nicer than `filterStatusCodes(in: 0...9)`. Reading the first as "filter status codes zero through nine", which seems more readable. Thoughts? Esp. because this will probably not be called (much) like `filterStatusCodes(in: range)` where `range` is predefined. My understanding after reading the [API design guidelines](https://swift.org/documentation/api-design-guidelines/#argument-labels) is that we should go with `filterStatusCodes(in:0...9)`:

> [...] This guideline implies that if the first argument doesn‚Äôt form part of a grammatical phrase, it should have a label.
 FWIW I think "filter status codes zero through nine" is grammatically correct, and sounds better than "filter status codes in zero through nine" I always thought of `0...9` as an interval ([Apple also calls it closed range](https://developer.apple.com/reference/swift/closedrange)). To me the function, as is, reads "filter status code interval 0 to 9".

But that's not a strong opinion, I'm ok with what makes more sense to us :wink: Yeah, I think if we were to rename it to `filterStatusCodes(in:)`, I'd want to review the `filter` family of functions as a whole. For example, we also have `filterStatusCode(code: Int)`, why not `filter(statusCodes:)`, `filter(statusCode:)`, etc? I don't have an opinion either way, I think either works within the guidelines. +1 for `filter(statusCodes:)`, `filter(statusCode:)`  `willSendRequest` renamed to `willSend`.
`didReceiveResponse` renamed to `didReceive`.
`prepareRequest ` renamed to `prepare`.
`processResponse` renamed to `process`. Totally unrelated, by why is the testing class for the `NetworkLoggerPlugin` called `NetworkLogginPluginSpec`? Seems like a pretty strange typo üò¨. Or am I missing something there? It's common in Ruby to call them `Spec`, probably from there. Either way is fine, most of my projects have both üòÜ Was actually referring to the `Loggin` part. ;) Mmmm, yeah that's probably just a typo ¬Ø\\_(„ÉÑ)_/¬Ø Renaming the file makes sense üëç  

Can we make the change in another PR? Sure, will do! BTW, do we need anything else done in this PR? Or can it be merged? Should be good to go! Thanks @pedrovereza üôå üëä   This would be hard to put in the Moya framework because you'd have to come up with a way to inject a lot of application-domain-specific information into Moya without bloating the API. You'd also lock the consumer into a particular JSON deserialization library which they'd need to adopt in their models.

That being said here are two ways to accomplish this right now:

### Subclass/extend `MoyaProvider`

I override `RxMoyaProvider`s `request` method to handle my object deserialization as well. The signature looks something like this:
```swift
request<T: ModelProtocol>(_ token: TargetType, object: T.Type) -> Obeservable<T>
request<T: ModelProtocol>(_ token: TargetType, array: T.Type) -> Obeservable<[T]>
```

In this example `ModelProtocol` is a protocol that all my models conform to and extends the JSON deserialization protocol of your choice (e.g. `Unboxable` or `Mappable`). You could omit passing the type and instead overload just on the return type. `RxSwift` does plenty of this. Either way you'll have to supply the type info implicitly or explicitly at the call site, and I have a more pleasant experience with autocompletion the sooner and more explicitly I do that.

### Create a `Networking` layer

This is similar to the above but instead of putting that logic in `RxMoyaProvider` or `MoyaProvider`, you put it in a layer that wraps the provider. The nice thing here is that you can supply type information in the function signatures (e.g. `getUsers() -> Observable<[User]>`). But you are adding another layer of abstraction and at this point the primary benefit that Moya would provide is just organization of API information.

Both of these options are also nice because it gives you a spot to put domain specific error mapping and other information. For example, I'm currently using Moya to interact with an app that returns responses with the signature:

```json
{
  "code": "<success or error code>",
  "message": "<message>",
  "data": "<dictionary or array of data>"
}
```

So at this middle layer I can also map to domain specific errors and embed the information that I need to look at the `data` key to map my models.

Hope that all helps. Let me know if you have any other questions. Using `associatedType`s will allow you to inject model type information into the protocol. The problem is that then you can only return one model type for each conformance to `Api`. This forces you to organize your API client code by return type which might not be the ideal organization--particularly since `ModelProtocol` and `[ModelProtocol]` returns would need separate `Api`s.

While Moya was designed with `enum`s in mind for use as `TargetType`s, you can use any data structure to conform to `TargetType`. The nice thing then is that if this makes sense in your situation, you can use `struct`s to conform and add a protocol on top of `TargetType` with your associated types. Then you can subclass or extend `MoyaProvider` to add the deserialization behavior.

I can't speak for all @Moya/contributors, but IMO I don't see model deserialization as being added in the near future. Mainly because doing so would force consumers into a particular convention for their model code and there is no single best practice that has emerged for JSON deserialization--all the libraries have their pros and cons. However, [Moya Community Extensions](https://github.com/Moya/Moya#community-extensions) offer a good way to get this functionality while still being flexible on how you want to do JSON deserialization. @manas-chaudhari yeah, you would have to create a different provider instance for each kind of model that your API calls return. Maybe instead of having `associatedType`s on the protocol, you could pass the types in. Your `call` function would have to then be generic, and your parse function would take the type as an argument.

```swift
static func call<T>(request: Request) -> T? {
        let params = parameters(request: request)
        // Invoke api get result
        return parse(data: Data(), type: T.self)
}

internal static func parse<T>(data: Data, type: T) -> Result? {
        return T.init(data: data)
}
``` 

and you'd probably have to also create a protocol where you can specify that `T` can be initialized with some `Data`, and specify that conformance in your generic, `Mappable`, or `Unboxable`, as @scottrhoyt said.



FWIW It sounds like you want an extremely simple API layer, where a consumer doesn't have the opportunity to mess anything up by putting the wrong type in; somewhat similar to the API layer one might ship in an SDK.
If that is what your goal is, I'd recommend going with @scottrhoyt's `Networking` layer. The `Networking` layer would be the closest thing to what Facebook, or Stripe's SDK vend.
I recently built an SDK, and did the same thing. I had Moya included as a private implementation detail, and I wrote functions for each API call that looked something like 

```swift
static func login(email: String, password: String) -> Observable<User> {
    return Email.validate(email)
        .flatMap { email in networkingProvider.request(.login(email: email.value, password: password)) }
        .mapJSON()
        .do(onNext: saveAuthTokenToKeychain)
        .map(User.init)
}
``` @scottrhoyt https://github.com/Moya/Moya/issues/823#issuecomment-264653488 was **incredibly** detailed. Thank you üôè

Should we create a documentation page for this questions like this issue? Your comment is 90% of the content I think we'd need for that doc page Hmm, I see where you're coming from...

I dont think we'd add it to Moya right now, since it would definitely force us to include (or depend upon) a JSON parsing library, and force all consumers of Moya to use the same.

What about defining another protocol that conforms to `TargetType`?

```swift
protocol DecodableTargetType: Moya.TargetType {
    var modelType: SomeJSONDecodableProtocolConformance.Type { get }
}

// then you'd be able to take your model
struct User: SomeJSONDecodableProtocolConformance {}

// and then convert your `TargetType` enum conformance to `DecodableTargetType`, and add
enum MyAPI: DecodableTargetType {
    ...
    var modelType: SomeJSONDecodableProtocolConformance.Type {
        switch self {
             case .me: return User.self
        }
    }
    ...
```

by doing that, you could have all the functionality you're looking for from Retrofit in Moya.

Your API consumer can be oblivious to the fact that the response is in JSON by defining a `parse` function in your networking stack that `mapJSON`s, and then calls your JSON decode function with the `modelType` of the target; making it look like

```swift
provider.request(.me).decode() // returns Observable<User>
``` I hope it can be eliminated üòÑ But I'm not sure how to. I think we might need to something type-erasurey here. I'm not totally sure, but the goal is to be able to express

```swift
enum MyAPI: DecodableTargetType {
  ...
   var modelType: SomeJSONDecodableProtocolConformance {
     switch self {
       case .upload: return String.self
     }
    }

    func decoded(response: Response) -> Observable<Self.modelType> { // This line doesn't compile üò≠
      // parse things and return the correct modelType
    }

  ...
}
```

Right now, without any type magic, its possible to return `Observable< SomeJSONDecodableProtocolConformance >`. It makes sense that you should be able to return `Observable<String>` (or `Observable<any other modelType>`) because I know how to express that in logic, but I'm not sure how to express it in the Swift type system.
@Moya/contributors: Does anyone more experienced with such problems care to chime in?

I feel as if the answer would be to make each case in the `MyAPI` generic over type `T: SomeJSONDecodableProtocolConformance `, (or give each case an associatedValue of `SomeJSONDecodableProtocolConformance`). But I'm not sure to do that  I think the best bet is to provide a custom wrapper around your provider, similar to the Ello app.

My current implementation, which is built around a GraphQL server:
```swift
struct MyProvider {
    public static var sharedProvider: ReactiveCocoaMoyaProvider<MyAPI>  = WellthProvider.DefaultProvider()
    
    public static func request(_ target: MyAPI, queue: DispatchQueue? = nil, progress: @escaping Progress = { _ in  }) -> SignalProducer<JSON, Error> {
        return sharedProvider
            .requestWithProgress(token: target)
            .mapProgressResponse(progress)
            .mapSwiftyJSON()
    }
    
    public static func graphQL(_ operation: GraphQLType, variables: [String: Any] = [:]) -> SignalProducer<GraphQLResponse, Error> {
        return request(.graphOperation(operation: operation, variables: variables))
            .mapGraphQLResponse()
    }
}
```

At this point, all you have to do is wrap the `Moya` API, and provide the proper extensions to process the request.

Ultimately, I agree with @scottrhoyt that deserialization is beyond the scope of the library. It should be the consumer of the API that maps the response to specific results. 

You can achieve this with protocols and dependency injection:
```swift
protocol MySpecializedProvider {
   func request(target: MyAPITarget) -> SignalProducer<MyModel, RequestError>
}

class MyViewController {
  let networkProvider: MySpecializedProvider

  func refresh() {
    let endpoint = MyAPITarget.doSomething(parameter)
    networkProvider.request(endpoint).startWithResult { (result: Result<MyModel, RequestError>) in
      switch result {
        case .success: /// Handle successful request
        case let .failure(error): /// Handle error
      }
    }
  }
}
``` @manas-chaudhari: I think using an approach like Ello would be best for your use case under the current Moya.

Your point on 
> build[ing] a MoyaProvider variant which does not have a generic `<Target>` parameter

does sound interesting. If its possible for us to make Moya better by implementing that, we should look into it. I've created an issue for you to expand on that idea (https://github.com/Moya/Moya/issues/830).

If you think your initial question was answered, and you're satisfied with the Networking layer, go ahead and close this issue, and we can continue discussion on #830  Your `Podfile` contains `'Alamofire', '4.0'`, which doesn't support iOS 9. Alamofire `4.1.0` and `4.2.0` (which we use) do.  @Ernest-su is the problem that `.complete` is not called? You are getting all the `.next(progress)` events?

If that is the case, I think the way we should fix the bug is by creating a pull request that creates a (currently failing) test in https://github.com/Moya/Moya/blob/master/Demo/Tests/RxSwiftMoyaProviderTests.swift, and then write code to make the test pass.

If you want to take a shot at that @Ernest-su, that would be awesome (no pressure!), if you don't have time right now or aren't comfortable doing that, I'm sure a contributor will look into this soon!

Providing the clarification on the `.next` vs `.complete` would be very useful either way!  Hey all! I was reading https://blog.pusher.com/what-i-learned-building-the-pusherswift-framework/, and one of the first things the author goes into is how the framework they built uses only one target for all platforms. 

Currently Moya has 4 targets for each 3 of our frameworks (12 total), and then 3 for tests.
<img width="175" alt="screen shot 2016-12-01 at 2 39 57 pm" src="https://cloud.githubusercontent.com/assets/3814772/20815764/11cd4af8-b7d4-11e6-9d3c-7a1d801ddc48.png">

I'm not sure how the author was able to make a universal target, but maybe we could do something similar? @petester42 that looks really cool, it would be awesome to have Moya vend through one target as well.
I could take a shot in a PR, but since you've done this before it may be easier for you to do it? Let me know what you think. üíØ

A script that would do this automatically for any project? That... that'd be awesome üò± @aaroncrespo can you give a concrete example? 
I think the issue with bundle ID collisions disappears when you have one universal target, since there is only one target - it can't collide with something that no longer exist.

*sorry if I misunderstood your comment* üòÖ @petester42 I think we should go ahead with this, and we can fix watchOS issues if/when they come up. When you create a PR, can you close this issue?

Thanks üòÑ  @scottrhoyt @BasThomas @pedrovereza: Along the lines of simplifying the project structure in #885, I think it would be really awesome to have this implemented too.

Especially if we can have it in before the 8.0.0 release. Hmm, would this be a breaking change? I agree this would definitely be nice, but I am not so sure if we need it before releasing 8.0.0.  I don't think it would be a breaking change. Oh, you guys are right. It would have 0 effect on the API, it was just related to the new project structure we had Implemented in #967 üòÜ    What do you mean with "standard structure"? That the email and mobile number might not be returned in that order? What is not JSON? What do you get back from the request in your app? So, doing the same request, gives you the following JSON in Postman:

```json
{
  "message": "422 Unprocessable Entity",
  "errors": {
    "otp_code": [
      "The selected otp code is invalid."
    ]
}
```

and

```
{
    email =     (
        "The email has already been taken."
    );
    "mobile_number" =     (
        "The mobile number has already been taken."
    );
}
```

in Swift? Am I understanding this correctly? In that case, I really have no idea what is going on, but it seems related to the backend. Hmm, it doesn't seem like JSONSerialization is failing.

```swift
do {
    let jsonData = try JSONSerialization.data(withJSONObject: value, options: []) as? [AnyHashable : Any]
    print(jsonData) // this is nil
} catch {
}
```

If the jsonData here is `nil`, the casting fails, not the conversion from `value` to `data`. You are trying to cast `Data` to `[AnyHashable: Any]` here, which probably fails. The way your JSON is printed might be confusing, but seems to not be the issue here. The casting does fail, as `Data` can't be cast to `[AnyHashable: Any]`.

I've made a gist, does that clarify? https://gist.github.com/BasThomas/0f894d610f7f24732077fa961a6fc182 So, does that solve the issue for you? :) I am going to close this issue as it is not related to Moya.

The problem again is casting. You are trying to cast `Any` to `Data` here, which is not possible.
What you can do to solve this is the following:

1. Create `Data` from your `Any` response with the `JSONSerialization(withJSONObject:) function`.
2. Create a `JSONObject` / `[AnyHashable: Any]` by using `JSONSerialization(withData:)` on the data you just received.   Failed because of the missing changelog entry, but I'd argue that is not necessary in this case. Ah, I [see](https://github.com/Moya/Moya/blob/master/Dangerfile) we can use `#trivial` in the PR title to prevent this. Neat!    ## Purpose

While the endpoint and request closures are useful for modifying requests, they
provide an inconvenient solution for many use cases--notably authentication--for
a number of reasons:
  * Only one closure of each type can be provided, making it less ideal when
    multiple atomic modifications need to be made to a request.
  * Overriding these closures require duplicating the work that the default
    closures do and knowledge of more internal¬†Moya API.
  * It is sometimes ambiguous as to which closure you should choose for your
    task.

## Solution

Plugins can be extended with ability to modify requests and results. This would
bring the concept more in line with the concept of web framework middleware and
provide a convenient interface for Moya users and 3rd party plugin creators.
Ultimately, the ability to interact with requests and responses will make
Plugins much more useful.

To do this, we can add two functions to `PluginType`:
```swift
func prepareRequest(_ request: URLRequest, target: TargetType) -> URLRequest
func processResponse(_ result: Result<Response, Error>, target: TargetType) -> Result<Response, Error>
```

*Note: function names were chosen to be consistent with existing interface but
there is an opportunity to better conform to the Swift API Guidelines*

These functions are called before `willSendRequest` and after `didReceiveResponse`
respectively. Like the other protocol functions, empty implementations are
provided by default.

## Example

The following is an example of supplying an access token via a plugin and only
authorizing targets that need it.

```swift
protocol AuthorizedTargetType: TargetType {
  var needsAuth: Bool { get }
}

struct AuthPlugin: PluginType {
  let token: String

  func prepareRequest(_ request: URLRequest, target: TargetType) -> URLRequest {
    guard let target = target as? AuthorizedTargetType, target.needsAuth else {
      return request
    }

    var request = request
    request.addValue("Bearer " + token, forHTTPHeaderField: "Authorization")
    return request
  }
}

let provider = MoyaProvider<Target>(
  plugins: [
    AuthPlugin(token: "eyeAm.AJsoN.weBTOKen"),
    NetworkLoggerPlugin()
  ]
)
```

## Alternatives Considered

### *Add another closure for simpler request modification*

While this would solve the problem of request modification not being
straightforward, it still wouldn't be clean to chain modifications together.
Also, there wouldn't be a simple interface to encourage 3rd party plugin creation.

### *Make the existing plugin functions capable of modifying request/results*

This would not be easily possible due to the way the `willSendRequest` abstracts
Alamofire's `Request`. In addition, adding the extra lifecycle calls makes it
easier to create consistent behavior (e.g. always log requests after they have
been modified by plugins).
 This is great! Some questions:

- I don't think this is a breaking change right now, right?
- On the following:
> *Note: function names were chosen to be consistent with existing interface but
there is an opportunity to better conform to the Swift API Guidelines*

Do you have an idea on where we can improve? As we haven't yet released `8.0.0` final yet, we'd love to iron out these Swift 3-issues and names.

- Danger will complain about this in a minute probably, but could you add these changes to the Changelog and maybe add your awesome example to the documentation?

Thanks again for taking this on! No problem!

> *  I don't think this is a breaking change right now, right?

Nope, should be good to go. The behavior of the existing Plugins haven't been modified and default implementations are provided so that Moya-consumer plugins should conform by default.

> * On the following:
> > Note: function names were chosen to be consistent with existing interface but
> > there is an opportunity to better conform to the Swift API Guidelines

Nothing big here. Mostly `didReceiveResponse` and `processResponse` seemed awkwardly named when the first parameter is of type `Result<Response, Error>` and not `Response`. You could consider `didReceiveResult` and `processResult`. Alternatively, a scheme like this could work:

```swift 
prepare(request: URLRequest, target: TargetType) -> URLRequest
willSend(request: URLRequest, target: TargetType)
didReceieve(result: Result<Response, Error>, target: TargetType)
process(result: Result<Response, Error>, target: TargetType) -> Result<Response, Error>
```

I went ahead and made an entry into the Changelog and added the example. Thanks for the changes! @Moya/contributors, do we want to take a look at the function signatures for `8.0.0`? See the above comment by @scottrhoyt. :+1: on the changes and functions renaming.

@ashfurrow thoughts? The idea behind upgrading Plugins is great, and the implementation is üíØ, good job @scottrhoyt! 

However I'm not sure about `prepareRequest`, for some reason it feels like duplicating functionality (`requestClosure`). We might get a lot more questions about what is better for that use case and so on. 

Also, about dropping the `request`, `response` part of the plugin function names - great idea, I'm up for that, but maybe let's do it in another PR to avoid chaos.
 Would definitely do the renaming in another PR, yeah. @sunshinejr , the intention here is to replace the use of `requestClosure` for a large number of use cases. What I'm not a fan of about `requestClosure` is that if you make use of it, you are overriding default behavior and must offer a replacement for that behavior--even if it is trivial. It also isn't very composable with respect to chaining request modifications which discourages creating extensions for Moya to handle common use cases.

My hope is that this helps resolve a lot of the questions like "should this be a `requestClosure` or an `endpointClosure`" by saying that if the intention is to make a modification of a `URLRequest`, it should be a plugin--and maybe that plugin already exists! I think the question is whether or not those closures still would be necessary. Hmm, should we also create some tests around `pluginsWithCompletion`? Not really sure where to start on that myself. The trivial case is tested by default. Testing the non-trivial case should be pretty straightforward. Just add a header to the request/response and then check for it in `willSendRequest` and the `completion` closure respectively. You could go further and test that the order of plugins is preserved, but I don't know if that is necessary unless we are documenting that assurance. I would have written the test, but it doesn't look like the test suite is in this repo? The tests are located in the Demo app, located [here](https://github.com/Moya/Moya/tree/master/Demo/Tests). :-) I wrote some simple tests. Because I'm not that familiar with `Quick`, I put them where was the easiest for me which was where `MoyaProvider` with delayed stubs is being tested. It should probably go somewhere else since you don't need delayed stubs to test this and it's only increasing the test time unnecessarily, but there was already a `TestingPlugin` being used here. I'll leave the rest as an exercise for the reader. I think the biggest considerations here revolve around the API surface area that is being exposed. Once this is in place, it will be a source of future breaking changes that will need to be managed. Also, there is the question of whether or not `requestClosure` and `endpointClosure` should be deprecated or are still useful. I think there are more pros than cons with empowering plugins though. @scottrhoyt love the changes to docs, good job! üôå Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.  On the error: am I right you are expecting the error's response data to be in the `NSError`'s `userInfo`? I think that would make sense to do. Well, at least my reading of the docs lead me to believe that I could extract the original response data by casting the `Moya.Error` to an `NSError` and then retrieving its `userInfo["data"]` value. That didn't work for me. Retrieving the response is straightforward the way I mentioned above, it's just different than what the docs say. @scottrhoyt thank you for checking out the README. The issue you ran into with RxMoya not having `Response` defined stems from changes made in https://github.com/Moya/Moya/pull/563.

Previously both RxMoya and ReactiveMoya were *fat* (they also contained all of the `Moya` source code), but this change made them *slim* (they dont contain Moya, so are dependent on Moya being imported as well).

Not updating the README was an oversight, it should have been updated in tandem with #563. We should create a pull request to update that documentation.   Awesome, thanks! Could you update the community guidelines repo as well? Others use it as a reference: https://github.com/Moya/contributors/blob/master/Community.md Done. :)  Awesome :tada:

Thanks for sharing how you fixed it, this may be useful to other people üëç   Fixes #796.

Can we somehow check if this works as intended? I couldn't really find a way to do so.  Looking at the history of Changelog, this seems to be right changes.
Mentioned by @BasThomas in https://github.com/Moya/Moya/issues/792#issuecomment-263544652. üôå   Codecov, please  See #648  If anyone wants / has an idea on how to take [this](https://github.com/Moya/Moya/issues/648#issuecomment-263372164), please do!

> I was thinking we could include it as two subspecs, and deprecate the old one in favour of the new. To avoid repeating ourselves in the podspec, we can have the old deprecated subspec simply have a dependency on the new one. Does that make sense? Could we simply do this? Without needing the `ss.source_files`?

```
s.subspec "ReactiveCocoa" do |ss|
    ss.dependency "Moya/ReactiveSwift"
end
``` The current `podspec` seems to work. Did what [I thought](https://github.com/Moya/Moya/pull/805#issuecomment-263545349) would work. Can anyone confirm? `pod lib lint` runs fine (although it takes a really long time üòÆ) Yup, it takes a long time because it needs to run every permutation of every subspec. This is great, the only change I would add is the modify the Podfile used in the Demo project to reference the new subspec. Great work! Done. üëç  Thanks for catching this, @rlam3!  How does this increase the coverage? ü§î  Hey there @rlam3. You could look up Artsy's [eidolon](https://github.com/artsy/eidolon/tree/master/KioskTests), they are using Quick/Nimble with Moya.  @rlam3 are you interested in testing Moya specifically for authentication?  The solution is to use two different enum cases that return the same `path`. Maybe `fetchZen` and `createZen`. Does that make sense?   Hey @rlam3. We have updated our documentation around the new `ParameterEncoding` type from `Alamofire`, please check it [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint). Hope it helps! 

Also, whenever you feel like something isn't clear enough, please let us know so we can improve the docs. üëä The `URL` parameter should be `url`.  ^ I've updated the documentation to reflect that in #804. Sorry! @rlam3 it is, it was probably the `URL` renaming to `url` as @BasThomas mentioned. Can you try if it works? @rlam3 it looks like @BasThomas' change should have fixed what you were seeing, please do re-open this if it didn't!

Closing for now üòÑ   Fixes #795  üôå  What is your question exactly? What doesn't work? If using CocoaPods, please post your `Podfile`. :) We support iOS 8 in `beta.4` and `beta.5` :)   @BasThomas this looks good to me (thank you for making it üôÉ), can you run a `carthage update --no-build` to update rxswift in the resolved file, and to make sure everything works? Because we use `4.1.0` via CocoaPods as well. We might be able to up this to `4.2.0`, but let's bump it to `4.1.0` for now to keep them in sync. Hmm, do we want to update both CocoaPods and Carthage to `Alamofire 4.2.0`? Now I've locked Carthage to `4.1.0`, but not really for a reason. This might be confusing in the future? Let me create a new PR for that. Closing in favor of #799 #799 looks good to me üòÑ   Yep, true! @AndrewSB, have you had time to take a look at this?
Otherwise, @ufosky, a PR to update the dependencies would be really appreciated! @BasThomas I haven't really been on my computer this weekend, I can make a PR towards the middle of the week, but Im available to look over a PR today! I've created ~#797~ #799. :)  Ooooh @mrfarukturgut, that's a doozie of a synchronization problem. I, personally, like to model problems with reative programming. Abstracting multiple, potentially concurrent `Request`s that require a common resource (an auth token in this case) as streams allow me to stay sane, and reason about the state of program at any point in time.

I recently had a long conversation with @rlam3 in https://github.com/Moya/Moya/issues/748 where we talked about a similar problem, why don't you give that a read, and then let us know how we can help once you're aware of the Rx/Reactive Moya solution to your problem This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 sounds good @mrfarukturgut! Let me know if theres anything else we can help with üòÑ 

GCD is a perfectly fine alternative as well you could use a dispatch group to turn the callback into something that blocks the thread. I wouldn't recommend it, but it is doable  Hey @tspecht I'm not too familiar with ReactiveSwift, but this is on [our docs](https://github.com/Moya/Moya/blob/master/docs/ReactiveSwift.md):

> For ReactiveSwiftMoyaProvider, the network request is not started until the signal is subscribed to.

Also, from [ReactiveSwift docs](https://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Documentation/FrameworkOverview.md#signal-producers):
> [SignalProducer] Unlike a plain signal, no work is started (and thus no events are generated) until an observer is attached

Feels like this could explain the problem you're facing. 

But I think @ashfurrow may have a better answer üòâ  @tspecht You should just return the `SignalProducer` from your provider from your `login(_:)` method, and change the signature to `login(token: String) -> SignalProducer<Response, Moya.Error>`.

What you should have is this:
```swift
class APIProvider {
    static let provider = ReactiveCocoaMoyaProvider<MyService>()
    
    static func login(token: String) -> Signal<Response, Moya.Error> {
        return provider.request(token: .login(token: token))
            .filterSuccessfulStatusCodes()
    }
}
```
All that does is creates a `SignalProducer`, or "unit of work" when you call `APIProvider.login("someToken")`. That unit of work still needs a subscriber before it will be invoked. In your view controller, you're going to want to do something like:

```swift
APIProvider.login("someToken").startWithValues { response in
    /// Update the UI with the response.
}
```
If you want the response to be transformed into some new value, you'll have to write extensions on the `SignalProducerProtocol`, i.e.:
```swift
extension SignalProducerProtocol where Value == Moya.Response, Error == Moya.Error {
  func mapLoginResponse() -> SignalProducer<NewValue, Error> {
    return producer
      .map { response -> NewValue in
        /// Transform response to `NewValue` and return the transformed value
      }
  }
}
```
Which will slightly modify your login producer to look like...
```swift
static func login(token: String) -> Signal<NewValue, Moya.Error> {
    return provider.request(token: .login(token: token))
        .filterSuccessfulStatusCodes()
        .mapLoginResponse()
}
``` @tspecht, have you been able to solve your issue with the answers given? Let us know if you have any more questions! @BasThomas I'm just going to go ahead and close this.

@tspecht, Please re-open if your issue persists.  Github updated the markdown parser and we're getting some weird messages from our fellow @MoyaBot.

![image](https://cloud.githubusercontent.com/assets/1916041/20544340/bd2ab4d4-b0f0-11e6-890f-c184a0d80929.png)

A fix was shipped with [Danger 4.0.1](https://github.com/danger/danger/releases/tag/v4.0.1).

The breaking changes on [Danger 4.0.0](https://github.com/danger/danger/releases/tag/v4.0.0) seem ok in my opinion: I personally prefer our messages to not be sticky, but it's totally open for discussion.  The documentation on this has been updated: https://github.com/Moya/Moya/blob/master/docs/Targets.md. Does that answer you question? Hey @rlam3, was the documentation helpful? Do you still have questions regarding the use of `Task`?  Yep, most endpoints probably use `.request`.  Fixes #782  Oh, should we add a note in the changelog as well? Will do, good catch! Another question... it seems like we can drop the deployment target on macOS to 10.10 as well (now 10.11). Do we want to do that as well? That would be lovely! Hmm, I think we need to update the Cartfile and Cartfile.resolved as well? This still points to Alamofire 4.0 / 4.0.1, which does not support iOS 8. @AndrewSB, maybe you can take a look? And is this something we can test to prevent this in the future? @BasThomas taking a look now

For testing in the future, we can create a (or many) test cases that run in parallel with our CI? Maybe using Travis just to check if carthage is still working?

For the test cases, they would just be single view applications that import Moya & Alamofire, each with a different deployment target (test one can be iOS 8, test two can be iOS 10), and the only the thing travis will test is to see if the targets compile.
We could also test cocoapods in the same fashion, same goes for the Reactive & Rx targets

Not sure if this is going overboard though- let me know what you think? > For the test cases, they would just be single view applications that import Moya & Alamofire, each with a different deployment target (test one can be iOS 8, test two can be iOS 10), and the only the thing travis will test is to see if the targets compile.
We could also test cocoapods in the same fashion.

We use cocoapods to install pods in the Demo app before executing tests. Is it fair to say this covers  cocoapods?

I'm not familiar with carthage, but #630 added a step in the build called `rake:test carthage`, which runs `carthage bootstrap --platform 'iOS'`. Doesn't it cover carthage support? 

*Apologies if I miss understood your suggestions* üòÖ  Hmm, strange how CI didn't fail with Carthage then. Because carthage indeed seems te be tested during CI. ü§î You didn't misunderstand them at all @pedrovereza :smile:

The issue is that `carthage bootstrap --platform 'iOS'` would succeed, since Carthage just pulls down the dependencies and builds them, it doesn't test to see if they'd all compile under the same swift or iOS version (like how cocoapods does in it's podspec).

To test `carthage` for iOS 8, we'd need to create an target that targets iOS 8, build dependencies with carthage, `import Moya` & `import Alamofire`, and then try to compile the project.
Do you guys think we should create that project & test for this case? Or is it too much work to maintain for this edge case? @AndrewSB Oh, now I get it, thanks! üëç  What might be a simpler fix is to add a `Danger` rule to check if the `cartfile` / `cartfile.resolved` or ~`podfile` or `podfile.lock` have~`Moya.podspec` has been updated, to then warn to update / check all of these files? Does that make sense? @BasThomas Yea, sounds like a good first step. @BasThomas that sounds like a good first step to me too üôÉ
On Wed, Nov 23, 2016 at 2:58 PM Pedro Vereza <notifications@github.com>
wrote:

> @BasThomas <https://github.com/BasThomas> Yea, sounds like a good first
> step.
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/787#issuecomment-262628284>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dE5gRMStstw_OZlFX8lcOeNLbhGxks5rBKjTgaJpZM4K5qgZ>
> .
>
  Yeah, I will close this one as this is a duplicate of #782, let's track the process there. üëä  So you want to fetch multiple "pages" at once? Most of the time, paging in an API is added to prevent sending too much information at once. I think what you would be trying to do is something that might not be the ideal solution.

That being said, I think "chaining" the requests like you are doing here should be a solution that works just fine.  Heya guys! üëã

So a few months back we introduced the `StructsAPI`(#427), but we didn't really document that nor made a demo. Maybe it was for the better? Because we can use structs really without introducing this API at all. What we couldn't do was to avoid creating multiple providers for multiple targets. 

So I thought about this and came up with an idea. I've renamed our `StructTarget` to `MultipleTarget`, because you can use this with any type you want, that conforms to `TargetType`. Additionally, I've made a new target in `Demo` project, called `DemoMultiTarget`, that shows how you can use any of the network API that we have (`Giphy`, `GitHub` etc.) with just one provider and the `MultipleTarget`. I've made a new target because it would be hard to see through everything that is now in the `Demo` target & VC. That way (with usage of new Shared directory), we can reuse most of the code and make two clear examples of different usages. 

The last thing I did was to make an example file & link it in the Readme.

I think this could help large projects in splitting logic (or at least I'm pretty sure I will use it in my bigger projects) & make it easier to maintain. 

I think that's it! Please comment anything you find strange/bad/superbad in the PR üòà

Cheers! üéâ Thanks Ash! üôá
 Any idea why Danger didn't run here? Only saw the linter issues here: https://github.com/Moya/Moya/pull/787#issuecomment-262306591. (Fixed those in 7d8489f, FWIW)  Does that solve your issue, @ohohco?  Take a look at #639. As Alamofire seems to have lowered their target to 8.0, we can take another look if the other dependencies did so as well, but that was our reason to drop iOS 8 support. 
 Cool! What do you think, @ashfurrow? Seems like we can lower it again.
 Let's do it, I never really liked removing iOS 8 support anyway but we had to because of Alamofire. If they're lowering it, let's do it üëç
 Let's keep this open to make sure we won't forget. :)
  Does that solve your question, @Ernest-su? @BasThomas is that an issue? I'm not that familiar with `DefaultDownloadDestination` Unfortunately, I don't know either. :/ @bchrobot? Anyone else from @Moya/contributors? Thanks, @lulee007! Also, PR #1053 by @pedrovereza should fix this problem as well (released in Moya 8.0.4). Thus I'm gonna close it, but please feel free to reopen whenever.  Due to the dependencies not being included in this repository, I am not sure if this is possible at this moment. Do we want to support this, @ashfurrow? It's never really come up. It'd be pretty tricky to do, since we have a lot of source code hacks to support either CocoaPods _or_ Carthage. I'm not opposed to adding this, but I think linking to a blog post describing (in general) how to install CocoaPods or Carthage libraries without using those tools would probably be the best solution. Thoughts?  @jaymutzafi it is unfortunate that the current package manager landscape on iOS is that unapproachable to new developers üòï.

@ashfurrow I think we've removed most of our hacks to support Cocoapods & Carthage, so it shouldn't be *too* hard to integrate manually (famous last words üòõ)
@ashfurrow is right though, a blog post describing how to do this in general would be better, and more sustainable in the long run, but I can't find one as of now. So I'll just try to help you out here üòÑ 

For a manual integration, all you (should) need to do is drag the source files inside https://github.com/Moya/Moya/tree/master/Source into your xcodeproj. You might want to not drag in the `RxSwift` and `ReactiveSwift` directories, unless you're using those packages in conjunction with Moya.

I haven't tested this, so I may be wrong. Let us know if you have any issues, we'll try our best to get you working with Moya üòÑ  I think you're missing out on all Alamofire code in that case, which would mean that doesn't work? I think you'd have to manually copy Alamofire's code as well.  Oh yup, you're right @BasThomas. Thanks for catching that üíØ

@jaymutzafi you'd also need to include Alamofire in your project, they have manual integration instructions here: https://github.com/Alamofire/Alamofire#manually Hmm, and it seems like we need to add `Result` as well.

... and then it still doesn't work. Removed all `import Result`s, then Xcode started complaining about all `Moya.`-files, which makes sense. Seems like we're going to have a little more work to make this possible.

<img width="1512" alt="screen shot 2016-12-08 at 22 31 46" src="https://cloud.githubusercontent.com/assets/4190298/21028633/5d78c2da-bd96-11e6-9d54-490fb5feb826.png"> It seems like Alamofire's approach (git submodule) might work (?). Yay, got it working using `git submodules`. Let me add a how-to to the readme. :) Thanks for rolling with this @BasThomas!   @BasThomas is this also ready to merge?  Hey there @bchrobot! Thank you so much for the PR üéâ I've only got one comment but other than that it looks üíØ
 Thanks @bchrobot! üôå @ashfurrow Where is @bchrobot invitation to join us?? üòÑ  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions. Weird, the webhook delivery failed. Re-delivering the webhook payload seemed to work, thanks for the bump üëç Looks like GitHub was having some trouble yesterday:

![screen shot 2016-11-22 at 11 14 47 am](https://cloud.githubusercontent.com/assets/498212/20531489/eebbe14a-b0a4-11e6-97c6-a0392579cf6c.png)

Looking in my inbox, I got a notification of the error on Heroku, so if it happens again I'll know üëç   Closing this, see https://github.com/Moya/Moya/pull/774#issuecomment-261369545
   Closing this, see https://github.com/Moya/Moya/pull/774#issuecomment-261369545
   Closing this, see https://github.com/Moya/Moya/pull/774#issuecomment-261369545
   Yeah, I saw that. Let me take a look.
 Ah, it seems like in this few changes, I did not yet change `Cancellable`'s `cancelled` to `isCancelled` yet.
 Added the bool renaming to the `CHANGELOG` in d77c261.
 Let me try to combine this PR with #775 #776 and #777 :wink:
 @BasThomas Ok, branch `cleanups` should have all changes. Can you open a new PR out of that branch? I'll close this and the other PRs to avoid confusion üòÑ 
 Done, thanks a lot! üôå
   Oh no, seems like all of these have been commited incrementally... ( #773, #774, #775, #776, #777 )
Any idea how I can fix this?
 No worries, can we just merge them in that order?
 I'll merge this since it's the first one (and the most simple), then we see if the others need to be fixed üòâ 
    üíØ Thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  @Fredehagelund92 this sounds like an issue at the [Alamofire](https://github.com/Alamofire/Alamofire) level. Moya doesn't actually handle making the request, all of that work is delegated to Alamofire. You may be better suited to asking the folks over there?

*Apologies if I misunderstood your problem, and the issue is actually something related to Moya incorrectly embedding your headers* üòÖ As this seems to be an Alamofire issue, I'll close this for now. Please reopen if not!  @Moya/contributors, can anybody reproduce this bug? Might be good to take a look at this for `8.0.0`. This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Can someone review this? I am not sure if the `UserInfo` and `Router` types are purely  made for the example here, or if these are in any way connected to `RxSwift`? I think they're specific to this example, not related to RxSwift for sure. Thanks for updating this üëç
  We could include an example in the example app maybe? Also, we've been considering an [`Advanced.md`](https://github.com/Moya/Moya/issues/718#issuecomment-254076697) file, maybe it would fit there?
 Yes, that'd be awesome!
 I'm not going to worry about our code coverage going down by 0.08%, this looks great, merging üëç
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 Thanks @jeryRazakarison! üòÄ
  Did you mean to make a separate issue for this? (#700)
 Cool, makes sense!
 Fixed by #767.
  It's not straightforward, but definitely possible. Check out the [Endpoint documentation](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#request-mapping)'s request mapping section, as well as the [overview of how Moya works](https://github.com/Moya/Moya/tree/master/docs#documentation) for more detail, and let us know how it goes üëç
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hey, great question. Thanks for taking the time to open an issue. The instructions in the readme are outdated, please try Moya 8.0.0-beta.4 and you should be fine. Please let us know üëç
 Wonderful, glad to hear it! Would you be able to open a pull request updating the CocoaPods readme instructions? No worries if not!
 Well well, thank you!
 This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue should be actually closed already by `probot`, so I'm gonna close it for them.  This is based of the conversation on #423, If anyone else wants to take a shot at this, they are more than welcome to! I'll implement it sometime soon, if not üòÑ 

I added some documentation on threading to the Readme, not sure if it should go there or in it's own file in `docs/`

TODO:
- [x] Update the docs
- [x] Do a final check Queue parameters are almost implemented in #1055 so I'm gonna close this one. @sunshinejr: the plan was to merge #1055 into this branch, and then discuss what kind of queue primitive we wanted to use for ReactiveMoya & RxMoya (based on https://github.com/Moya/Moya/pull/1055#issuecomment-294671464) Damn, sorry, my bad. Somehow I've missed branch & this comment. Nevermind, carry on üòÑ haha not an issue üòã Two tasks to go:

- [x] Rename everywhere we mention `queue` to `callbackQueue`
- [ ] Add docs

let's tackle this in another PR! Anyone is free to start it üòÑ 

I'll resolve merge conflicts here rn @pedrovereza did a PR with rename, so the only thing we need right now is a doc update + last check if everything is correct? And a SwiftLint sweep, apparently. üòÅ I think most of the SwiftLint issues on test files were fixed in #1103, they should go away once we rebase our branches against master (`optional-response-thread-param` and `9.0.0-dev`).

The warnings on `ViewController` seem legit, but I'd rather clean them up after we merge this PR against `9.0.0-dev` üòÑ  Yup, completely agree with @pedrovereza. Ah, missed that @pedrovereza. Nice work @sunshinejr :) About the docs: do we want to include this in `Advanced.md` or in `Providers.md`? Not sure where it fits best. I would go with `Threading.md` - this is big enough topic that it should have its own space, in my opinion. Oh! That's perfect, I didn't know we had a threading readme
On Tue, Jun 13, 2017 at 7:34 AM ≈Åukasz Mr√≥z <notifications@github.com>
wrote:

> I would go with Threading.md.
>
> ‚Äî
> You are receiving this because you modified the open/close state.
>
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/762#issuecomment-308136080>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dECoOTZMEfWrXIMKwM_TtLe6vPaNks5sDp2zgaJpZM4KuD7b>
> .
>
 Haha, we don't - but we should :D üòÇüòÇ
Agreed
On Tue, Jun 13, 2017 at 7:44 AM ≈Åukasz Mr√≥z <notifications@github.com>
wrote:

> Haha, we don't - but we should :D
>
> ‚Äî
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/pull/762#issuecomment-308139564>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dJiDMa1CdK-L-a93uM0yGm9p2xgtks5sDqAwgaJpZM4KuD7b>
> .
>
 Also, what do you guys think about removing `stubScheduler` from `ReactiveSwiftProvider`? Now that we have unified `queues`, I think we might consider this change. It would also help in transition from multiple providers to `rx.request` & `reactive.request` mentioned in #963. for the uninitiated, what does `stubScheduler` do? Does adding queues already fix it, or do we need to add more functionality? ~~@AndrewSB it is scheduling stubbed data onto scheduler, so queues should resolve this problem. We may need to revisit tests and add few that ensures the data comes on a given queue.~~ Seems like this is a special scheduler, `DateScheduler`, and it is used instead of GCD when dispatching the stubbed data. Any idea why it was used instead of GCD in RAC extensions [here](https://github.com/Moya/Moya/blob/master/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift#L43-L64)? From what I've seen it was implemented by @swizzlr, but maybe someone else remembers the reason? @ashfurrow maybe?

**Edit:** nvm, we can take care of it after the release. If needed, we'll still have `ReactiveSwiftMoyaProvider`. Ok. Final stage of this one I think. Only docs left - make a `Threading.md` with what @AndrewSB wrote + check other docs if there is something we need to change. Anyone up for this one? Let's merge it already üòÑ  Okay, docs are in, @AndrewSB. We just need to check if we have everything we need here. If you could take a look (and other @Moya/contributors to double-check) it would be awesome! alright, I'm happy with this. Let's wait for CI

Can someone who knows what the conflict for this to be merged try to resolve? Was a quick one, refactor by @SD10 from #1149. Fixed it (hopefully üòÑ)! Gonna do another review of the whole PR in a few. üî• once you do that review, if you're happy, go ahead and merge.
Let's land this pull request 8 months in the making

![SHIP](https://media.giphy.com/media/ta83CqOoRwfwQ/giphy.gif) Great job everyone, especially @AndrewSB! This is a huge one! 

Now might be even bigger one: making sure we got everything between 9.0.0-dev and master in the new release üòÖ

Gonna hit this satisfying merge button after CI!

**Edit:** Damn, didn't update tests for stubs. Gonna repair that one.
**Edit2:** Pushed the fix, gonna still wait for the CI, though üòÖ üéâüéâ  This is the readme image, the first point at which people interact with Moya, so it's gotta be awesome. This PR centres the text, aligns the coloured boxes, and gives some whitespace around the images. Nice! üíÖ 
  Can you show us the entire Cartfile that results in that 3.0.0 being resolved? It's possible that there's another dependency you've included that depends on Moya@3.0.0
 @Pr-Chen Any update on this? Would love to figure out the issue.
 Closing this for now @Pr-Chen. Please come back if you're still running into this üòÑ  FYI, this has been resolved in #835 :)  I'll approve after that update üòÑ 
I think you're right about adding other types of tasks making `Basic.md` too complicated
 Not sure if this needs a comment explaining what this is needed for?
 @BasThomas is that because `Task` feels less cut and dry than something like `Method` or `Path`?

I feel as if a user can just deep link into the `Task` type and see the documentation for the type there - if you still think docs in the basic usage make sense, go ahead and add that comment üëå.

I can review and then merge it in after you've made that edit üôÉ
 I think you're right - the documentation on the type should be enough.
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Does it only come up when building RxCocoa through Moya? Not if you just have a Cartfile with `github "ReactiveX/RxSwift" ~> 3.0`?

If the issue is in fact with RxSwift, then it should be tracked on their library, on the issue @fruitcoder  mentioned https://github.com/ReactiveX/RxSwift/issues/970.
 Can you delete your derived data and try again? 
 Hmm, so it's working on me when I check specify `github "Moya/Moya" "master"`. Testing now with the `8.0.0-beta.2` release.

`master` output:

```
‚ûú  how-carthage-works carthage update --platform iOS
*** Fetching Moya
*** Fetching RxSwift
*** Fetching Alamofire
*** Fetching Result
*** Checking out Alamofire at "4.0.1"
*** Downloading Result.framework binary at "3.0.0"
*** Checking out ReactiveSwift at "1.0.0-alpha.3"
*** Checking out RxSwift at "3.0.1"
*** Checking out Moya at "1b1edcf782bdf9eea0fa0c55c18275904d35d1e6"
*** xcodebuild output can be found in /var/folders/6y/2zb68tcs4nn6v899_jz0nmfr0000gn/T/carthage-xcodebuild.nCphgo.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "ReactiveSwift-iOS" in ReactiveSwift.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
*** Building scheme "RxBlocking-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxTests-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/asb/how-carthage-works/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "ReactiveMoya iOS" in Moya.xcodeproj
*** Building scheme "RxMoya iOS" in Moya.xcodeproj
*** Building scheme "Moya iOS" in Moya.xcodeproj
```
 Hmm, I'm definitely seeing the issue on the latest release, but not on `master`. It seems to come and go.

@mobilestar0223 after it fails, can you open the `Rx.xcodeproj` inside `Carthage/Checkouts/RxSwift` and see if you can build the RxCocoa target from Xcode? If not, can you paste your error?
Trying to get a handle on what the issue is.

We may just want to do a new release soon -- not sure if that will fix the problem though, let's investigate it
 I think I've got a handle on the issue - I'm only seeing the `Ld` error from `RxCocoa` if I'm trying to build version `3.0.0-beta.1`, if I checkout `RxSwift` at `3.0.1` instead, I don't get the build failure

So we should release master as a new version ASAP, since our latest release (https://github.com/Moya/Moya/releases/tag/8.0.0-beta.3) points to RxSwift `3.0.0-beta.1`.

@ashfurrow can we do a new release? The `Cartfile` on `master` points to a non-breaking install of RxSwift üòÑ 
 Aye, I'll do a release asap. Thanks for looking into this! 
 All done üëç Released as 8.0.0-beta.4, let us know if this works. I've opened https://github.com/Moya/Moya/issues/759 to decide if we want to release that as a 8.0.0 final.
 Thanks @ashfurrow!

Fix for this issue: target Moya `8.0.0-beta.4`.

If anyone is having issues, please reopen this. Im happy to help!
  Sounds like a custom parameter encoding is what you're looking for. [Here's an example](https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md) of how you might approach that, please let us know if that approach works üëç
 @loryhuz Any luck with this? 
  As discussed in #752 

Tried to make it in a way that it should only affect Circle CI üòâ   You can use a [custom endpoint mapping](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint) to return something other than `.sampleData`, one of [these three cases](https://github.com/Moya/Moya/blob/33d1c7ed5e1baaf927bfff412c9cc52d584d0b3a/Source/Endpoint.swift#L5-L15). That should let you return any data, any status code, and possible even a "network not connected" error. Let me know if that answers your question, and also let us know if we can improve our documentation around this. Thanks!
 Could you create a PR with the improvements you proposed? No pressure, I could look into doing that as well. üëç
 Not a problem, thanks for the thoughtful question! 
  Related to #736
  You definitely do need to add your request to a `disposeBag`, start with that. 

On issue 2: I'm going to open source my networking stack so you can see how I inlined my token request into the provider. You don't need to create a second provider for that 
 @rlam3 I changed my mind on the open-sourcing of the networking stack, decided not to make a repo for 2 files of networking code.

Basically, I have a class that wraps my provider called `Networking`, it looks like

``` swift
struct Networking: NetworkingType {
    typealias T = ProxyAPI
    let provider: OnlineProvider<ProxyAPI>
}
```

and `Networking`'s `request` function looks like

``` swift
    func request(_ token: ProxyAPI) -> Observable<Response> {
        let actualRequest = self.provider
            .request(token)
            .filterSuccessfulStatusCodes()
            .catchError(parseMoyaError)

        if token.requiresAuth {
            // makes sure the oauthtoken is fresh
            return OAuthTokenRequest().flatMap { _ in actualRequest }
        } else {
            return actualRequest
        }
    }
```

everything uses this request function. except the OAuthTokenRequest(), which is a function that goes through the provider's request function

``` swift
func OAuthTokenRequest() -> Observable<AuthToken> {
        guard let authToken = AuthToken.local() else {
            return .error(Error(Strings.Error.NotLoggedIn.title,
                                description: Strings.Error.NotLoggedIn.description))
        }

        if authToken.isValid {
            return .just(authToken)
        }

        return request(.refreshAuth(refreshToken: authToken.refreshToken))
            .mapJSON().map(AuthToken.decodeValue)
            .do(onNext: { $0.save() })
    }
```
 Let me know if you have any other questions üòÑ 

Moya really affords itself to solving this problem
 You're welcome üòÑ 

> I understand you wrap your provider in a Networking class/struct. What is NetworkingType though? I'm not understanding what you're subclassing here...

`NetworkingType` is

```swift
protocol NetworkingType {
    associatedtype T: TargetType, ProxyAPIType
    var provider: OnlineProvider<T> { get }
}
```

its a wrapper for the provider (I'm using a custom provider that takes into account the online status, `OnlineProvider` is just a subclass of `RxMoyaProvider`), that has the custom `request` function I was talking about.

> Where would my requestClosure and endpointClosure be? Also in the provider? I need to do be able to modify my request based on its HTTP methods.

The `requestClosure` and `endpointClosure` stay inside the provider.

> Where does Networking's request function exist? Is it in the Networking class/struct?
> If it exists within the same Networking struct/class... what is the _ in front of token? 

Yup üòÑ `Networking`'s `request` function is inside the `Networking` struct.
The `_` in `request(_ token: ProxyAPI)`? That just makes it so you can call `request(.getMyTweets)` instead of `request(token: .getMyTweets)`. It's a swift language feature, just syntactic sugar üòâ

> What exactly are you trying to do here:
> You're calling back on the same provider class and passing a token into the request? Or is it the API enum?

You're right again, `actualRequest` calls the `request` function on the provider, it passes in the OAuthToken in the `flatMap` right after the definition.

> Does OAuthTokenRequest also exist inside of Networking class/structure, or in it's own seperate class?

`OAuthTokenRequest` is a global free function.

> what are the trade offs of using an Observable rather than Endpoints?

Not sure what you mean üòû If you rephrase that, I'm happy to help you understand it further üòÑ 

> If you can't provide the opensource version of it. Could you please provide me with a few gist? Thanks!

[NetworkingType.swift](https://gist.github.com/AndrewSB/4f1f1256a0a35e82ac44cf7d3dba56f0) [OAuthTokenRequest.swift](https://gist.github.com/AndrewSB/f41d5834afc32b284957535192221f38)
 I am indeed wrapping my provider inside this `Networking` struct. I later create an instance of my networking client by 

``` swift
static func newDefaultNetworking() -> Networking {
  return Networking(provider: OnlineProvider(endpointClosure: endpointsClosure))
}
```

`TargetType` comes down from Moya, `ProxyAPIType` (Proxy is the name of the iOS app from which I'm showing you code) is a protocol that defines some additional params that each of my endpoints must provide:

``` swift
protocol ProxyAPIType {
    var parameterEncoding: ParameterEncoding { get }
    var accept: String { get }
    var contentType: String { get }
    var contentLength: Int? { get }
    var requiresAuth: Bool { get }
}
```

So for me, having this `Networking` wrapper accomplishes 2 main things
1. It lets me use the `OnlineProvider` to only send networking requests when Reachability says I have internet connection (watch out for #722, I haven't solved the problem there yet)
2. It allows me to have a custom `request` function ([gist](https://gist.github.com/AndrewSB/4f1f1256a0a35e82ac44cf7d3dba56f0#file-networkingtype-swift-L14)) that reactively injects an OAuthToken to all endpoints that `requiresAuth` from `ProxyAPIType`

Let me know if you have any other questions, I'm here to help üòÑ 
 Associated types work, I'm using this in swift 3, I can show you how I'm doing my OAuthToken expiry, I'll post a gist soon

EDIT: [OAuthTokenRequest gist](https://gist.github.com/AndrewSB/973d81843a834c68c8cfb916830cd92d)
So in my `Networking` struct's `request` function, if the target required authentication, I `flatMap` this `OAuthTokenRequest` into the target, to make sure it's valid and fresh, then I grab it from my persistent storage 
 Closing this for now. Let us know if you still have any questions, @rlam3 :) My AuthToken.swift just holds a model struct, nothing interesting there.
Let me try to illustrate the sequence in which my requests chain through an example

1. I call `Networking.request` for my `.me` endpoint
2. `Networking.request` goes ahead and adds some decoration to the response, i.e. filtering out successful status codes, and parsing the error if there was one (https://gist.github.com/AndrewSB/4f1f1256a0a35e82ac44cf7d3dba56f0#file-networkingtype-swift-L15)
3. `Networking.request` also signs the request with an AuthToken if required https://gist.github.com/AndrewSB/4f1f1256a0a35e82ac44cf7d3dba56f0#file-networkingtype-swift-L20. Since this is a flatMap, it passes control to the OAuthTokenRequest, and only sends the `.me` request after `OAuthTokenRequest()` `.next`s.
4. Looking at `OAuthTokenRequest` (https://gist.github.com/AndrewSB/973d81843a834c68c8cfb916830cd92d), you can see that it either returns a local valid token (in which case the request is signed and it goes out to Alamofire), or does a `Networking.request` to the `.refreshAuth` endpoint, which would repeat steps 1-2, and skip over 3 & 4, since the `.refreshAuth` doesn't `requireAuth`. Once we hear back from the network with a new AuthToken, our `OAuthTokenRequest()` returns the `AuthToken`, we sign the `.me` request, and it goes out to Alamofire

Let me know if I was unclear anywhere, or if you have further questions!

Re the `.error`: which error are you referring to? [This](https://gist.github.com/AndrewSB/4f1f1256a0a35e82ac44cf7d3dba56f0#file-networkingtype-swift-L18) one? can you make your example more concrete? Are you saying your implementation requires two tokens to sign each request? OAuth and something else? I'd add a `requiresCSRF` and a `requiresOAuth` to each your `TargetType` enum, and then do some sort of pattern matching, maybe:

```swift
switch (target.requiresCSRF, target.requiresOAuth) {
    case (false, false): return actualRequest
    case (true, false): return CSRFTokenRequest().flatMap { _ in actualRequest }
    case (false, true): return OAuthTokenRequest().flatMap { _ in actualRequest }
    case (true, true): return Observable.zip([CSRFTokenRequest(), OAuthTokenRequest()]) { _ in actualRequest }
}
```

So yup, you were on the right track! Sorry about that @rlam3! I forgot that `Observable.zip(Array<T>)` expected the array to be an array of one element. Try this instead

```swift
Observable.zip(CSRFTokenRequest(), OAuthTokenRequest()) { _, _ in actualRequest }
``` Hey @rlam3! Sorry about not responding, this must have slipped past me on my notifications!

If your `OAuthTokenRequest` depends on your `CSRFTokenRequest` then you don't want to zip, Zip is good when you have two operations that don't depend on each other you'd like to have completed, (diagram for reference) http://rxmarbles.com/#zip

If your OAuthTokenRequest is dependent on CSRFTokenRequest, you should 

```swift
CSRFTokenRequest()
  .flatMap { csrfToken in OAuthTokenRequest(csrfToken) }
  .flatMap { _ in actualRequest }
``` @rlam3 I renamed this issue to reflect what the discussion turned into, I hope that's alright with you, please let me know if I should change it back or change it to something else üôÉ I'd say (after thinking for about 5 seconds) make your authtoken observable
share replays, that way you'll only have one AuthToken request actually
issued.

You'll also have to handle invalidation of the token somewhere internally,
as soon as the token expires the replay-able event should be dropped so the
next subscription to the observable triggers an actual auth token refresh

While working on this myself, I used http://github.com/Expirable and
thinking of my AuthTokens in that way really helped me

Here if you need clarification!
On Tue, May 23, 2017 at 12:22 AM (Alfred) <notifications@github.com> wrote:

> @AndrewSB <https://github.com/andrewsb> I face a problem when the access
> token expires and multiple requests happen, that all request a new access
> token via the refresh token, at the same time.
>
> I noticed that Ello-iOS is handling multiple unauthorized requests by
> call request/refresh token at a time and waiting for a new token on other
> requests.
>
> I don‚Äôt see the similar feature on Artsy Eidolon. Does your code support
> this?
>
> Does trackInFlights will help. I didn‚Äôt see much information or document
> about it, just read in some related issues/commits?
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/748#issuecomment-303312259>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADo1dFHJvTTo97u-Jt-W6a9DvlzVhNJvks5r8okGgaJpZM4KjFdG>
> .
>
 @AndrewSB think you meant https://github.com/AndrewSB/Expirable :wink: I did, thanks for catching that @pedrovereza!

Also, this thread is becoming awfully long, I'm going to lock it so it doesn't become much longer. @dangthaison91 if you want to follow up on handling multiple unauthorized requests at once, can you create a new issue and mention your earlier comment in it?  @wongzigii: #737 updates the `Cartfile`, not the `Cartfile.resolved`. How does having an outdated `Cartfile.resolved` affect your builds? Are you running `carthage bootstrap`, not `update`?
 Hmm #737 has my carthage install functioning properly, what command are you using to build your dependencies?
 Hmm, when I `carthage update` for `github "Moya/Moya" "master"`, it's checking out and building the latest compatible versions of the dependencies, it doesn't look as if it's pinned to the versions in the `Cartfile.resolved`

```
> carthage update --platform iOS
*** Fetching Moya
*** Fetching RxSwift
*** Fetching Alamofire
*** Fetching Result
*** Checking out Alamofire at "4.0.1"
*** Downloading Result.framework binary at "3.0.0"
*** Checking out ReactiveSwift at "1.0.0-alpha.3"
*** Checking out RxSwift at "3.0.1"
*** Checking out Moya at "1b1edcf782bdf9eea0fa0c55c18275904d35d1e6"
```

Are you seeing anything different?
 It can be updated, but updating it has no effect on usage of the library - it's a build artifact, right?

Are you interested in updating it just for the sake of updating it? Or to solve an issue you've noticed with using Moya?
 Ahh, I understand - I thought you were running into a build problem and I wanted to make sure that wasn't the case üòÑ 
  We piggyback on Alamofire for networking requests, which you can [configure with a custom manager](https://github.com/Moya/Moya/blob/master/docs/Providers.md#manager), so it _should_ work. Let us know üëç
 Awesome, thanks! Do you think we should add any documentation about this? Maybe something to the readme? 
  We've been facing a lot of time-out issues when running `bundle exec pod install` in Circle CI.
This is an attempt to fix it (or at least make it happen less often).

Suggested in https://discuss.circleci.com/t/cocoapods-timing-out/7494
 Thanks for taking care of this!
  Plugins probably aren't the best way to approach this, I'd suggest subclassing either the RxMoyaProvider or ReactiveMoyaProvider and use RxSwift or ReactiveCocoa to `retry` on failures. There is no straightforward approach, I'm afraid. Even if you don't use RxSwift or ReactiveCocoa, I would still recommend subclassing and putting the necessary logic in the `request` function.
 _Edited your comment to enable code highlighting_ :wink:
 This is great, thanks @raphaelcruzeiro! Except for basic HTTP auth, Moya has remained largely agnostic about authentication. Do we think this should go in the library itself or in the documentation?
 Cool do you think this could go into our existing [Examples section](https://github.com/Moya/Moya/tree/master/docs/Examples)? Or do you think it should be separate?
  Does @haydarKarkin's answer solve your problem, @zeew? Let us know it doesn't :)
 Closing this for now @zeew, please re-open this if @haydarKarkin's solution doesn't solve your problem! @mrdaios can you elaborate? You want to have a variable timeout based on the target? For example: you want `.zen` to timeout in 60 seconds, but `.requestSomeThings` to timeout after 45 seconds? Hmm, yeah. That's an interesting question. I don't know if we have a per-target timeout setup yet.

The easiest thing right now, would be to add `var timeoutInterval: TimeInterval { get }` to your enum, and cancel override the `provider.request` function to cancel the request after the `target. timeoutInterval `.

To get a better solution for per target timeouts, creating a new issue is probably the best idea, to get other people's opinions üòÑ    Hmm, I've always been using the `~>` syntax with pods, as per [the guides](https://guides.cocoapods.org/using/using-cocoapods.html). Anybody knows the difference? Should we update the README? @Moya/contributors 
 The `~>` syntax assumes that all versions adhere to semantic versioning, which our betas have not done. So until we release 8.0 I'd recommend to keep the existing readme instructions. 
  Does @WildDylan's answer solve your problem, @wenzhaot? Let us know it doesn't :)
 This should be fixed by #767. I'm going to close, feel free to re-open if the problem persists üëç
  Not sure, it looks like the `\` in the original string are getting escaped ‚Äì sometimes this happens with `print`. I've never used Postman, how are you getting the value returned from `mapString()`? 
 And you're just using `print(about)`? I'm just wondering if it's actually working but `print` is doing something weird. 
 I don't, I'm sure there are solutions to this. [`mapString`](https://github.com/Moya/Moya/blob/bc434f64bf39dc67c1fd73b4968f002dfb92e605/Source/Response.swift#L74-L79)'s source code is pretty straightforward, this could be something with Alamofire. To be honest I'm not sure which direction you should go in, I would look up issues on Alamofire's repository and google how to prevent double-escaping. Sorry for not having a more satisfactory answer, please let us know how it goes üëç
 Glad you got it sorted out, and thanks for following-up with the solution üëç I'm sure it'll be of help to others. 
  Does @fjcaetano's answer solve your problem, @ohohco? Let us know it doesn't :)
 Closing this for now, feel free to reopen when you are still running into this issue!  Updates dependencies to their latest versions, including a final release of RxSwift. See #720 for more info.
 CI errd out for some strange reason, attempting a rebuild
 Attempting another rebuild now that #745 seems to have saved `cocoapods/repo/master`
 And it got past `pod install`. I'm so happy :tada:
  Anyone from @Moya/contributors available to take a look at this PR?
 Is this worth a note in the Changelog?
 Yeah, can't hurt! Thanks! 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Merges #674.
  #721 hadn't updated unit tests to refer to new function names, this PR updates the tests. I also restart tests on CI in case they fail the first time (see #725).
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  The closure is called with a `Result`, which is one type. You are now referring to two (`endpoint` and `done`)
  We don't need to use the RC now that it's out officially.
  Really cool project from @devxoul. 
  Great question, we should improve our documentation about this because you're not the first to ask this. 

It's deceptively simple, actually: you need to provide an array of the parameter values. Something like

``` swift
return [
    "status": [ "draft", "live" ]
]
```

Let me know if that works üëç
 The `[]` is standard HTTP way to send an array of parameters, I'm surprised it's not working. I took a look through the documentation and couldn't find the endpoint you're using. Can you point to that documentation?

It's possible to do exactly as you ask, with duplicate status parameter fields, but you'll need a custom parameter encoder. You can see an example of how to use custom param encodings here: https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md
 I see, very interesting! A custom parameter encoding looks like your only option. Using one will be very similar to Alamofire custom parameter encoding. I looked at their issues and found a very similar question here: https://github.com/Alamofire/Alamofire/issues/965 I hope that helps, I'm sure you can do it üëç Once you've figured it out, I'd love to see more documentation in Moya around this, so please consider either posting your solution here or sending a pull request to add it to our docs.
 Hey @tuyendv2, have you ever found a solution for this? Would love to add it to our documentation. :) @tuyendv2 closing this for now, but we'd love to hear back from you! Please re-open this if you found a solution we can add to our docs üòÑ   Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  You should be able to use rc 1 of RxSwift, we just haven't had a chance to update the readme yet. Let me know if it works üëç
 Yikes! I'm not too familiar with how we work with Carthage. Updating our Cartfile might fix the issue, can you send a PR? 
 Should be fixed by #727. But now we need ti move to their final release (I'll do that now).
  The intermittent CI failure fix from https://github.com/Moya/Moya/pull/723 didn't work, so I need to find out why. Also, according to [this comment](https://github.com/Moya/Moya/pull/723#issuecomment-254607549) we should be filing radars about it with details. Moya's in the distinct position of being fully open source, and we should use that to our advantage and provide lots of details for the Apple developers to fix the underlying issue.
 Same failure occurred in #731, it seems. 
 This should be fixed by #734.
  Hey there @kanishkatn. There was an update for `ParameterEncoding` type in `Alamofire`, so we had to adapt as well. Everything should be clean when you read it [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint). Basically there is no `enum` anymore, just a protocol that you have to implement. There are also 3 predefined types that you can use:`URLEncoding`, `JSONEncoding`, `PropertyListEncoding`. These you can use by `.default` property, like: `JSONEncoding.default` in your case.

Hope it helps! üëä 
 Closing this for now, please reopen if you run into any issues with @sunshinejr's explanation.   Every time `xcodebuild` is run on CI, there's a chance the simulator won't start ([example build](https://circleci.com/gh/Moya/Moya/709)). Here's the error message:

```
2016-10-17 11:36:18.717 xcodebuild[8123:27968] Connection peer refused channel request for "dtxproxy:XCTestManager_IDEInterface:XCTestManager_DaemonConnectionInterface"; channel canceled <DTXChannel: 0x7fabb343a9e0>
2016-10-17 11:36:18.721 xcodebuild[8123:26958] Error Domain=IDETestOperationsObserverErrorDomain Code=3 "The operation couldn‚Äôt be completed. (DTXProxyChannel error 1.) If you believe this error represents a bug, please attach the log file at /Users/distiller/Library/Developer/Xcode/DerivedData/Demo-eajasjdonmwjombqexluhpxvsaae/Logs/Test/AC08A4B2-3E7C-4F34-9902-1D51939369F7/Session-MoyaTests-iOS-2016-10-17_113457-EHKzKv.log" UserInfo={NSLocalizedDescription=The operation couldn‚Äôt be completed. (DTXProxyChannel error 1.) If you believe this error represents a bug, please attach the log file at /Users/distiller/Library/Developer/Xcode/DerivedData/Demo-eajasjdonmwjombqexluhpxvsaae/Logs/Test/AC08A4B2-3E7C-4F34-9902-1D51939369F7/Session-MoyaTests-iOS-2016-10-17_113457-EHKzKv.log}
** TEST FAILED **
```

We run this kind of command several times on CI, compounding the likelihood that someone has to restart it. So let's automate it :tada:

This PR changes the CI script to look for code 65 and retries a build up to three times.
 On eigen we did - https://github.com/artsy/eigen/blob/master/circle.yml#L36-L39 - which I think has basically negated the problem for us. 

However, I'm totally chill with this too - key to all of it is being extra aware of xcode faffing. 
 Turns out we do have a 15s wait:

```
def open_simulator_and_sleep(uuid)
  return if uuid.nil? # Don't need a sleep on macOS because it runs first.
  sh "xcrun instruments -w '#{uuid}' || sleep 15"
end
```

if it's still being flakey - this is a good call IMO.
 Hmm, doesn't appear to be working:

<img width="649" alt="screen shot 2016-10-18 at 9 03 02 am" src="https://cloud.githubusercontent.com/assets/498212/19478758/c7ba4c70-9511-11e6-8512-9bbcf3160ea2.png">
 Cool, will do @russbishop :+1: I've opened #725 to make sure I don't forget, will likely get to it this weekend. 
  Hmm, not sure where that milestone came from actually. I agree it's time to consider releasing Moya 8.

We're still ironing out regular bugs and other breaking changes for Swift 3, personally I'm fine with keeping it in beta for now. Especially since if we go final with beta versions of RxSwift/RAC, and then there's another RxSwift/RAC beta with breaking changes, then we need to have a new major version to avoid breaking semantic versioning.
 I also think that we should stay in beta as long as our dependencies are. No need to rush and ReactiveSwift isn't even out of alpha. Also, I've removed the milestone to avoid confusion. 
 It's a fair point, thanks for bringing it up. I think a new beta makes at least makes sense, I'll try to get it done today.
 Cool, beta 3 is up and pushed for Carthage and CocoaPods üëç
 RxSwift's updated to 3.0 final, so we're just waiting on Reactiveswift now. ~~I'll open an issue asking for a timeline~~Looks like they only have one issue left and there's [already a PR](https://github.com/ReactiveCocoa/ReactiveSwift/pull/48) so it shouldn't be too long.
 Closing in favor of #759
  Related to #668.
  What a great question! Usually for example URLs that aren't meant to ship, I use example.com ‚Äì this sounds like a good alternative? 
 It would be a can of worms, unfortunately. The trouble is that somewhere ‚Äì either inside Moya or outside ‚Äì someone needs to deal with the fact that a call to `NSURL(string: )` might return `nil`. We've decided it's better to give the user of the library the flexibility to fail as they like, instead of having Moya fail or work unexpectedly.

It's a balance, there are arguments for both approaches. Do you think adding documentation of this rationale might help explain it to other Moya users? Where should we put that documentation? 
 Agreed, Basic Usage is already a large document. 

We could create a new `Advanced.md` file and discuss it there. Could you send a pull request adding it? 
 This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Closes #715

As detailed in #715, the callbacks of the download requests were never being called because the `DownloadRequest` does not inherit from the `DataRequest`.

What was changed was that there is now an different cast for download requests. This is based on the [code that is found in the Alamofire example](https://github.com/Alamofire/Alamofire/blob/master/Example/Source/DetailViewController.swift#L104-L112). The second casts fixes the completion block never getting called issue but the progress is still wrong.

I noticed when trying to write tests for this that the progress object will never have its completed property be true since it requires a response to be present. In all the code for progress tracking a response is never set so what I did is that on request completion update the progress object to have a response. Doing so has the desired effect of having the progress object returning completed.

This also contributes to increasing the code coverage from #668.
 Great PR, thanks! The only feedback I have is in the comment above. If you like, we can address it now, or we can open an issue to address it later. 
 @Ernest-su, what do you mean? Is this a possible bug? If you can create an issue for that, that'd be greatly appreciated!  Not sure, but shouldn't the `.Custom` be `.custom`?
 @shivayogic if you are using Swift 3 version of Moya, there is no `enum` for `ParameterEncoding`. If you want custom one, you need to implement `ParameterEncoding` protocol. More on the topic in our documentation [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint). Hope it helps! üëä
 @shivayogic usually you don't need to specify custom `httpBody`, parameters do it for you. If you want to add parameters that you want in every request, then `endpointClosure` might be the best way. However if your case is a specific one, you might try to replace the httpBody of a request in `requestClosure`.
  Hey there, great question! 

First, to return empty data you can `return Data()`, which makes things a little easier. 

The data you return should be a response representative of what your API actually returns. For example, if you request a `user` object from a REST API, you should get back some JSON that represents a user (encoded in `Data`). In my apps, I'll store this JSON as files and read them from disk when asked to (note: `sampleData` is not called except when stubbing, so it's not accessed in production).

The reason it's not optional is to force developers to specify something so it's easier to unit test the code that uses Moya. Network call stubs are first-class citizens in Moya, and are as foundational to the library. I understand that not every developer agrees, so `return Data()` is always going to be an option for developers to opt out of this behaviour. But since all network responses _do_ return some data (even if it's empty) then it doesn't make to make the property optional. 

I hope this clarifies things to your satisfaction. We're always looking for ways to improve our documentation, do you have any suggestions where we could add this explanation to help future developers? 
 Ah, you're looking to stub requests locally, to return previous requests? Interesting. I'll have to think about that. 

Having a plugin to record network calls might be cool, too, especially for testing. 
 I agree with @DeepMissea. This should be it's own library, caching is really hard

Plug for a talk my friend gave: https://www.youtube.com/watch?v=8uqXuEZLyUU
He talks about a caching library called Carlos, I haven't tried it, but he makes a good case for using it https://github.com/WeltN24/Carlos

Caching would be a level above Moya though 
You'd probably want to use Carlos from your application level, and Moya (i.e. the network) would be one of the *caches* you could fetch from. @WildDylan can you elaborate? 
Are you saying that you'd like Moya to implement a cache that follows the cache policy you outline? @WildDylan I'm going to close this for now, please do re-open if you'd like to further explore adding a cache!  Hey @zhigang1992! I know the feeling so don't worry about it üëä 

You can extend `TargetType` protocol with `ParameterEncoding` parameter, then in the `endpointClosure` use the `parameterEncoding` from target. [Here](https://github.com/sunshinejr/FlexibleMoya/blob/c33f9b9bbeddab2776de33f08d802660dab3ea4b/FlexibleMoya/Networking/Utils/MoyaUtils.swift#L14) you have example how I did it with `authToken` type, just instead of `authToken` use `parameterEncoding` in the `Endpoint` init. 

More on the `endpointClosure` you can also find [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint).

Hope it helps! If you have more questions or something is unclear, shoot üôÇ
  What do you mean? I am not sure I understand your question.
 If you look closely at @MoyaBot's message, you can see it is generated by [Danger](http://danger.systems/). :)
  Hey all! üéâ  Due to #681 and new `ParameterEncoding` type, we also have to update our documentation around it. Let me know if there is something to improve! 
  I think a way this can be accomplished now is to create a custom `ParameterEncoding` that searches for the `"key"` parameter makes sure to encode that first. Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Hey @lolgear! I believe you're talking about some changes that I made last month.

https://github.com/Moya/Moya/pull/563 is the pull request that suggested those changes, and the comments there go into the rationale behind the choices I made, and how it solves the dependency management mystery üé© 

I'm around if you have any follow up questions, or if you want me to talk about the _tricks_ I'm using in more detail üëä
 Yup, @petester42 is completely right.
By including the line `github "Moya/Moya"` in a Cartfile, it builds all three of the shared targets (Moya, RxMoya, and ReactiveMoya), as well as all of the dependencies, and then you choose which frameworks you want to drag into your linked frameworks
 üëç 
  The backend I'm dealing with is sending custom error code and message in response data in certain situations.
Although it's not the perfectly designed backend, there is no way to change it right now. 

The goal is to transform this response data to a Moya.Error.underlyingError(NSError). This NSError should have a custom domain and the values sent from the server as its userInfo. 
Main reason for that, I'm working on a framework which will be used in an Objective-C project and this Moya integrated framework should return values similar to old Objective-C implementation that the project is using. 
I didn't want to do filtering after each call to request(:) of my providers, so I want to do this in a common place. 

Example response:

```
Http status code: 401
Response data:
{errorCode: 3, errorMessage: "Authorization required"}
```

Current solution: 

``` swift
extension ReactiveCocoaMoyaProvider {

    func customRequest(token: TargetType) -> SignalProducer<Response, Moya.Error> {
        return self.request(token: token).flatMap(.latest) { (response: Response) -> SignalProducer<Response, Moya.Error> in

            let json = JSON(data: response.data)

            // Convert response.data to APIError instance
            guard let apiError = APIError(jsonData: json) else {
                return SignalProducer<Response, Moya.Error>(value: response)
            }

            let userInfo = [NSLocalizedDescriptionKey: apiError.message, "httpStatus": response.statusCode, "areaStatus": apiError.errorCode, "url": response.request?.url?.absoluteString] as [String : Any]
            let mappedError: NSError = NSError(domain: "custom error domain", code: response.statusCode, userInfo: userInfo)

            return SignalProducer<Response, Moya.Error>(error: .underlying(mappedError))
        }
    }
}
```

Then, user of my framework needs to call `customRequest(:)` for each provider call, which is not really nice. Another problem is I can't write a stub for the extension method to test it. 

Nicer solution would be subclassing `ReactiveCocoaProvider` and overriding `request(:) method, but`request(:)`is not defined as open (not like in`MoyaProvider`).

So is it possible to define `ReactiveCocoaProvider.request(:)` as `open`?

In fact, both of these solutions don't seem much convenient. Is there a better solution?

My suggestion would be letting Plugins alter the result by returning the altered result from `didReceiveResponse()` protocol method.
However, there can be multiple protocols which could make this solution complicated. Maybe a single instance plugin with different kind can be used, something like `"ResultTransformerPlugin"`. 
 This issue has been marked as stale because it has not had recent activity. It will be closed if no further activity occurs. 
 This issue has been auto-closed because there hasn't been any activity for 59 days. However, we really appreciate your contribution, so thank you for that! üôè Also, feel free to [open a new issue](https://github.com/Moya/Moya/issues/new) if you still experience this problem üëç.
  What is your `Podfile` like?
 Hey there, can you double-check the installation instructions for CocoaPods [in the readme](https://github.com/Moya/Moya#cocoapods)? Then run `pod update Alamofire Moya` and that should do the trick üëç
  Hmm, what an interesting idea! I think if we were to include `NSURLResponse`, we would want to remove the `Int` status code. Another solution would be to add another `case` to the enum. I think that would make a lot of sense, actually. Want to send a pull request? 
 Adding documentation for this change is definitely appreciated! üòÉ 
  This seems like a great addition! Would you be able to submit a PR implementing this, @jeryRazakarison?
 Closed by #767, thanks @jeryRazakarison! 
  Related to #696 

Currently there's no watchOS test target. Was that an oversight? Should I create one?
 Oh wow üòÇüòÇ
I wonder when Apple will decide that watch apps deserve tests üòõ
 This works with a carthage install, but is completely broken when you're using Cocoapods, and since CI uses Cocoapods as well, CI is reporting ‚úñÔ∏è.

Are there any cocoapods users from @Moya/contributors that have some time to un-break the tests when installing through `pod`?
 Might take a look at this soon. :) Sounds awesome @BasThomas!

I tried rebasing, but I'm not sure what a lot of the changes on `master` have been.
Wasn't sure how to handle this conflict while rebasing

<img width="859" alt="screen shot 2016-12-01 at 12 29 58 pm" src="https://cloud.githubusercontent.com/assets/3814772/20811277/ea6fd65e-b7c1-11e6-9c58-2610f7f77cb8.png">

So I didn't finish the updating this branch. Do you know why those files were changed on master? 
I'm around to fix the conflicts, or you can take a shot if you'd like Hmm, just started "fresh" on this, but Xcode is complaining when moving the `Tests` directory into the root.

<img width="1650" alt="screen shot 2016-12-09 at 19 44 35" src="https://cloud.githubusercontent.com/assets/4190298/21060518/0cd1656e-be48-11e6-97b0-6c95fbbbd6ab.png">
<img width="1650" alt="screen shot 2016-12-09 at 19 44 40" src="https://cloud.githubusercontent.com/assets/4190298/21060520/10558df0-be48-11e6-9e3c-1d56d7bb0bdc.png">
<img width="1650" alt="screen shot 2016-12-09 at 19 44 47" src="https://cloud.githubusercontent.com/assets/4190298/21060531/1b2069ee-be48-11e6-8028-c750376f73cd.png">
<img width="1650" alt="screen shot 2016-12-09 at 19 47 27" src="https://cloud.githubusercontent.com/assets/4190298/21060567/57ec0734-be48-11e6-9b19-d536b57797a8.png">


Not sure how to proceed :/ fresh as in pulling from `master` and manually redoing the work? If that's what you're thinking of doing, I can take the lead instead. I got it working before, so I can probably figure it out again.

Xcode looks as if it's expecting some source files and they're no longer there. Maybe you moved them in the filesystem without updating the xcodeproj? @BasThomas I think I'm just going to redo this PR, that seems easier than managing all the rebase merge conflicts we're going to hit.
I'll do it later today üëç Created #885 to continue this  Hey! Thanks for the PR! Although at the first glance I don't get the error here, so I've made a comment about the line that is confusing me the most. 
 Well, I didn't know about this caveat, not sure if this is intended behaviour of Swift, but glad you discovered it and shared with us! Only one more comment from me and we are ready to merge. Thanks again!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 Thanks @Viniciuscarvalho!
  Merges #685 and adds a test for a nil urlRequest.
  Can someone take a look at `From Target to Endpoint` here? Alamofire's encoding has changed, but I am not entirely sure how myself.

https://github.com/Moya/Moya/blob/master/docs/Endpoints.md

This also might mention some incorrect code(?)

https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md
 @nanoxd, any idea?
 Right, closing this in favor of #681.
  As discussed in #684

``` swift
public enum Method: String {

    case options = "OPTIONS"
    case get     = "GET"
    case head    = "HEAD"
    case post    = "POST"
    case put     = "PUT"
    case patch   = "PATCH"
    case delete  = "DELETE"
    case trace   = "TRACE"
    case connect = "CONNECT"
```
 Was just busy doing this, thank god I had a GitHub window open üôà
 @BasThomas Oh, my bad! Totally forgot to mention I was working on it üòÖ 
 No worries!
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  This is a great idea and a swell PR. We (I?) added the IUO because it was easy, but this is definitely the better approach. Thanks!

I've restarted CI, it failed due to a version mismatch in the Podfile.lock. Do the tests pass locally?
 CI is running on https://circleci.com/gh/Moya/Moya/608 , I just had to rerun without the cache. 
 We should add tests to be sure there aren't any regressions as well as document the change and a migration plan for existing users (if any). 
 Agreed, a changelog entry should be sufficient though ‚Äì this isn't any more intrusive than the other breaking changes we've got on master. The tests have been updated, too, so I think it's just the changelog entry that's missing. 
 I should read more closely at filenames üòÖ. 
 This is great, I'll take care of the test and merge :+1:
 In this case, I did the following to resolve the conflicts:

``` sh
git remote add KelvinJin https://github.com/KelvinJin/Moya.git
git fetch KelvinJin
git checkout KelvinJin/master
git checkout -b merge-685
git pull origin/master
```

git resolved the changelog conflicts, I just had to resolve a conflict with a unit test from #688. I did need to run `bundle exec pod update ReactiveSwift`, since CocoaPods was giving an error. Then I `git add . ; git commit` and used the default merge message. 

Let me know if anyone has any questions about this workflow, it might be worth writing up in a blog post sometime. 
 No problem, two different objects can have the same hash value without any major consequences (as long as two equal objects don't have different hash values, it should be fine). 
    Thanks for noticing! I've fixed it now :)
  It looks like Alamofire removed [ParameterEncoding enum](https://github.com/Alamofire/Alamofire/blob/d59ed4f611a447c98881be24764b130e3f7d24bd/Documentation/Alamofire%204.0%20Migration%20Guide.md#parameter-encoding-protocol) for a Protocol of the same name. 

We [typealias locally](https://github.com/Moya/Moya/blob/master/Source/Moya%2BAlamofire.swift#L13) here and use it in [Endpoint](https://github.com/Moya/Moya/blob/master/Source/Endpoint.swift#L23). 

The [docs](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint) should be updated to remove the enum values. 

Will the change cause issues with Moya's usage of ParameterEncoding?
 Great question, thanks for linking to relevant code :bow: We definitely need to do something here, at least in docs. I'll take a look later today and see what we can do. 
 Cool, that sounds like a good fix @RamwiseMatt. I think we just need to update our docs then, right? Anyone available for a pull request? 
 Hey @bryanbartow, only typo I found in your code is the `.GET` instead of `.get` enum case, otherwise it should be good to go. I've tested it in the Moya demo and was building correctly. If there are still some errors and cleaning doesn't help, let us know! 

Also I've made a PR with the `ParameterEncoding` changes so I'm gonna close this one in favor of #709. If you guys could chime in there, it would be awesome! üëä
 Oh, I will keep this opened till we resolve the issue then :)
 Closing this now, then. :)
  Missed a codeblock with `URLByAppendingPathComponent` to `appendingPathComponent`
 üôå
  Removes AnyObject casts in TargetType parameter examples
  Currently a WIP to gauge interest. Updates docs to reflect the new Swift 3 interface as well as Moya's interface.
- [x] Update enum usage
- [x] Match Swift 3 interface changes (e.g. NSURLSession -> URLSession)
- [x] Change usage of `AnyObject` to `Any`
- [x] Reflect interface changes in Moya
 YES! Thanks for this :)
 I believe that should be it but I'm sure I missed something üòÖ. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  hello lovlies‚Äì‚ÄìI'm trying to update a community library I maintain to support Swift 3 and all, however the `Moya+Alamofire.swift` file is ERROR'ing the lint :( 

here's the output of the `pod lib lint`:

```
‚ûú  Moya-Gloss git:(master) ‚úó pod lib lint

 -> Moya-Gloss (2.0.0-beta.2)
    - WARN  | [Moya-Gloss/Core, Moya-Gloss/RxSwift, Moya-Gloss/ReactiveCocoa, and more...] xcodebuild:  Moya/Source/Moya+Internal.swift:206:16: warning: value 'progress' was defined but never used; consider replacing with boolean test
    - ERROR | [Moya-Gloss/Core, Moya-Gloss/RxSwift, Moya-Gloss/ReactiveCocoa, and more...] xcodebuild: Returned an unsuccessful exit code. You can use `--verbose` for more information.
    - ERROR | [Moya-Gloss/Core, Moya-Gloss/RxSwift, Moya-Gloss/ReactiveCocoa, and more...] xcodebuild:  Moya/Source/Moya+Alamofire.swift:9:46: error: no type named 'StreamRequest' in module 'Alamofire'
    - WARN  | [Moya-Gloss/RxSwift] xcodebuild:  Moya/Source/RxSwift/Moya+RxSwift.swift:31:20: warning: 'init' is deprecated: renamed to 'Disposables.create'
    - NOTE  | [Moya-Gloss/RxSwift] xcodebuild:  Moya/Source/RxSwift/Moya+RxSwift.swift:31:20: note: use 'Disposables.create' instead
    - WARN  | [Moya-Gloss/RxSwift] xcodebuild:  Moya/Source/RxSwift/Moya+RxSwift.swift:57:20: warning: 'init' is deprecated: renamed to 'Disposables.create'
    - NOTE  | [Moya-Gloss/RxSwift] xcodebuild:  Moya/Source/RxSwift/Moya+RxSwift.swift:57:20: note: use 'Disposables.create' instead
    - WARN  | [Moya-Gloss/RxSwift] xcodebuild:  RxCocoa/RxCocoa/Common/TextInput.swift:74:28: warning: 'RxTextInput' is deprecated: renamed to 'TextInput'
    - NOTE  | [Moya-Gloss/RxSwift] xcodebuild:  RxCocoa/RxCocoa/Common/TextInput.swift:74:28: note: use 'TextInput' instead
    - WARN  | [Moya-Gloss/RxSwift] xcodebuild:  RxCocoa/RxCocoa/Common/TextInput.swift:67:29: warning: 'RxTextInput' is deprecated: renamed to 'TextInput'
    - NOTE  | [Moya-Gloss/RxSwift] xcodebuild:  RxCocoa/RxCocoa/Common/TextInput.swift:67:29: note: use 'TextInput' instead
    - WARN  | [Moya-Gloss/ReactiveCocoa] xcodebuild:  Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:5:45: warning: 'where' clause next to generic parameters is deprecated and will be removed in the future version of Swift

[!] Moya-Gloss did not pass validation, due to 2 errors and 6 warnings.
You can use the `--no-clean` option to inspect any issue.
```

relevant podspec is [here](https://github.com/spxrogers/Moya-Gloss/blob/master/Moya-Gloss.podspec). i ran with the `--verbose` tag and found the **watchOS 2.0 platform** with the **ReactiveCocoa** subspec that failed and building and removing the watchOS deployment target succeeds the lint. 

:/ hoping maybe some other contributors would have some insight, maybe @ashfurrow?
 Are you using a swift-version file? https://github.com/CocoaPods/CocoaPods/blob/master/CHANGELOG.md#110rc2-2016-09-13
 yep! @orta 
 Would recommend using `--no-clean` to take a look a the resulting folder with lint, double check all the versions of alamofire/moya are what you expect them to be - as a [StreamRequest does exist](https://github.com/Alamofire/Alamofire/blob/a946285f1b1efcb7129d546f00c90ae213678185/Source/Alamofire.swift#L438) inside head Alamofire

You can also clean your pod cache for this listing stuff with `pod cache clean`
 right, i found it too which why i thought it quite funky. 

i'll inspect the `--no-clean` output as well as clean the pod cache. 
 @petester42 yep, i am.

so: https://github.com/Alamofire/Alamofire/blob/master/Source/Request.swift#L577-L600 
... line 577 in AF only compiles `StreamRequest` if the os is not watch, explaining why the lint fails when compiling the watchOS platform :| 

i guess this begs the question on how Moya isn't encountering this as well since [it similarly supports watchOS](https://github.com/Moya/Moya/blob/master/Moya.podspec#L18)
 Interesting, watchOS isn't being tested on CI, maybe our watch support has been broken for a while and we've just not noticed until now?

We're not even using the `StreamRequest` anywhere, we should be able to delete [this line of code](https://github.com/Moya/Moya/blob/25b8072a2cffa3baff3aea90ed94afed2c03b076/Source/Moya%2BAlamofire.swift#L9) without any problems. 
 @ashfurrow funny. AF didn't introduce this type until version 4 and i had no issues updating to support Moya 7, so likely not broken for so long :) 

i'll get a PR working and make sure nothing breaks, hopefully not!
 Cool, thanks!
  Hmm, getting a legitimate failure this time, but I don't understand. Your PR is exactly what I would've done, not sure why it's failing. Keep it open and I'll investigate, thanks again!
 That's a good question! @justinmakaila can you chime in on this? 
 For what it's worth, I think @wongzigii has the right idea. We should probably be using the semantic version of a library instead of (basically) a commit hash (in this case `master`).

@wongzigii if you update the tag ReactiveSwift's release to `alpha 2`; confirm that it doesn't break anything in `ReactiveMoya`'s target, and no one from @Moya/contributors has an issue with it, I think it would make sense to merge this in.
 @wongzigii That timeout happens sometimes, I've restarted the build üëç
 Just realized we forgot to merge this, I'll deal with conflicts and merge today, thanks again üëç
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  And Demo file, since they have a release we can reference now: https://github.com/ReactiveCocoa/ReactiveSwift/issues/20
 The readme, needs to use the same Podfile format as the Demo project. A PR would be awesome!
 Cool, thanks!
  This looks good, did you want to re-open it? 
 Sometimes the unit tests fail like that and someone has to restart the build. I've restarted it, if you want to re-open :+1: Thanks!
  I suppose that changelog entry is not needed here. üòâ 
  This has been fixed in #661. @ashfurrow, could a second beta be released for this?
 8.0.0-beta.2 has been pushed, @Tynox can you verify it works? 
  What is you question exactly?
 Does that answer your question, @12207480?
 @wangguangfeng unfortunately, the Swift 3 branch has dropped support for iOS 8. For the reasoning behind this, see #639
  Our code coverage is okay, at a solid 80%. We've held this for a while, but we could do a bit better. Our [current coverage](https://codecov.io/gh/Moya/Moya/tree/master/Source) has some places we could improve:

<img width="1154" alt="screen shot 2016-09-21 at 9 37 47 pm" src="https://cloud.githubusercontent.com/assets/498212/18734570/d21c2478-8043-11e6-8c54-86b7d0d3c683.png">

I'll take a look sometime, this is probably a longer-term task though. 
 Both actually, the graph above is just an outline, you can see individual files' coverage in the link. 
 Hmm. Sounds like it could be a configuration issue, do you have experience with CodeCov? Could be worth a look. 
 Looks like CodeCov can't access file names with + in them, like https://codecov.io/gh/Moya/Moya/src/master/Source/Moya%2BInternal.swift . I've contacted their support team to clear it up. 
 We're in the high 80's, CodeCov seems to be working. Gonna close this, thanks everyone üëç
  Glad you got it figured out! Thanks for posting your answer, I'm sure it'll be of help to someone. 
  Looks great! The CI failure looks unrelated, I'll open another issue to fix. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  A PR to add this would be welcome!
  Hey @marcusficner! This is a really good question, I'm not really sure _why_ we don't use it in the `mapJSON()` function, but I would be up for introducing it there! 
 Closing in favor of #664 then!
  ReactiveCocoa -> ReactiveSwift `sendNext(_)`->`send(value:)` and `sen‚Ä¶dFailed(_)`->`send(error:)`
  Hey, check #604
  Fixes Homebrew on CI, updates installation docs, and updates Demo podfile.
 Hmm, seeing the failure locally too. 
 Looks like tests for inflight tracking were actually making network calls instead of stubbing, fixing now. 
 Weird, still getting `fatal: Not a valid branch point` on Danger. 
 Looks like Danger is already tracking this issue: https://github.com/danger/danger/issues/160
  Cool! I'll add corresponding changes for CocoaPods tomorrow (it's going to be a bit tricky).
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
   Okay, so still not working. Getting this error:

```
The bundle ‚ÄúMoyaTests-Mac‚Äù couldn‚Äôt be loaded. Try reinstalling the bundle.
(dlopen(/Users/distiller/Library/Developer/Xcode/DerivedData/Demo-eajasjdonmwjombqexluhpxvsaae/Build/Intermediates/CodeCoverage/Products/Debug/MoyaTests-Mac.xctest/Contents/MacOS/MoyaTests-Mac, 265): Symbol not found: _OBJC_CLASS_$_OS_dispatch_queue
  Referenced from: /Users/distiller/Library/Developer/Xcode/DerivedData/Demo-eajasjdonmwjombqexluhpxvsaae/Build/Intermediates/CodeCoverage/Products/Debug/MoyaTests-Mac.xctest/Contents/MacOS/MoyaTests-Mac (which was built for Mac OS X 10.12)
  Expected in: /usr/lib/libSystem.B.dylib
 in /Users/distiller/Library/Developer/Xcode/DerivedData/Demo-eajasjdonmwjombqexluhpxvsaae/Build/Intermediates/CodeCoverage/Products/Debug/MoyaTests-Mac.xctest/Contents/MacOS/MoyaTests-Mac)
Error Domain=IDETestOperationsObserverErrorDomain Code=5 "Early unexpected exit, operation never finished bootstrapping - no restart will be attempted" UserInfo={NSLocalizedDescription=Early unexpected exit, operation never finished bootstrapping - no restart will be attempted}
```

Has anyone seen this? I'll take a deeper look for it tomorrow. 
 Well this is frustrating. 
 Investigating one last ideal, but I think our best course of action may be to remove the macOS test target. We've done this before with tvOS when those builds were working locally but not on CI. Coincidentally, tvOS builds are now working on CI.
 Tests were passing! But Danger failed because Circle was providing the wrong commit hash. Editing the base of the PR seemed to work, fingers crossed. 
 Only danger is failing, and only because of a Circle issue, gonna merge. 
  The references to podspecs in the Demo app's Podfile are very specific, until ReactiveCocoa and ReactiveSwift have been released, even in alpha form. I'll keep my ear to the ground.
 Huh, with this new ReactiveCocoa split, we only really depend on ReactiveSwift, we can remove ReactiveCocoa as a dependency. Maybe we should rename the subspecs, too. 
 We can change the name in another PR, going to focus on getting this to üìó

Opened https://github.com/Moya/Moya/issues/648 to discuss the rename.
 These are passing locally, can be merged into the swift-3.0 branch even though the PR is üî¥
  @Moya/contributors was thinking of this. Should we add templates for issues / PRs? For example, I noticed some issues with no / incomplete Podfiles / Carthage files, which makes it harder for us to help the person with the question.

I am not sure what exactly should be in them - but they should be able to both help people with questions, as well as the people helping.

Let me know what you think; feedback is definitely welcome!
 I think this is a good idea, what are the most common miscommunications we need to address in issues? 
 Some examples:
- https://github.com/CocoaPods/CocoaPods/blob/master/.github/ISSUE_TEMPLATE.md
- https://github.com/danger/danger/tree/master/.github
 It would also be useful to make users aware of syntax highlighting for code in these templates.
 Closed after #704
 A PR template still has to / can be done maybe?
 @BasThomas you're right, my bad üòÖ 
 I don't see the need to add a PR template right now. If someone does, please reopen or submit a PR :)
  What is your deployment target? It should be iOS 9 or higher. (See #639)
 I'm not entirely sure, but you should only need the following in your Podfile:

``` ruby
pod "Moya/RxSwift", :git => "https://github.com/Moya/Moya", :branch => "swift-3.0"
```

Does that work?
  Does @aamctustwo's answer solve your problem, @Henawey? Let us know it doesn't :)
  Things we're still waiting for:

- [x] Ability to explicitly import Foundation (**pushing this off** for a future PR/release)
- [x] Ability to import libraries through dynamic/static libraries (currently spm doesn't build dependencies, it just embeds the source files in the Moya xcodeproj (**pushing this off** for a future spm release, spm doesn't support this as of now)
- [x] Merging https://github.com/Moya/Moya/pull/698, so Moya has a swift package manager compatible layout
- [x] Alamofire fixing their swift package manager installation (https://github.com/Alamofire/Alamofire/issues/1815) Both ReactiveSwift & RxSwift vend through spm now, trying to see if I can get Alamofire to work, running into some issues related to https://github.com/Alamofire/Alamofire/issues/1544

After that we should be ready to go üéâ

We still can't import `Foundation`, but I think we can go ahead without that for now, until @apple figures out how they want to handle that
 @VivienGiraud still waiting on the folks at Alamofire. 

I opened https://github.com/Alamofire/Alamofire/issues/1815, since they previously closed https://github.com/Alamofire/Alamofire/issues/1544 I'd love to get this working as well. However, short of some fragile hackery, I don't see it as a possibility while SPM doesn't support setting the deployment target and [doesn't support non Mac/Linux platforms or depending on Apple Frameworks](https://github.com/apple/swift-package-manager/blob/master/Documentation/Reference.md#depending-on-apple-modules).

The best long term solution would be hassle the SPM folks to add this in time for the next Swift version.

If SPM support is high priority, the other option is to depend instead on an Alamofire fork with the offending functionality removed (if possible) until the underlying issue in SPM is resolved. This could even be the beginning of replacing Alamofire with a Moya-specific `URLSession` wrapper. That would obviously come with it's own list of pros and cons. @scottrhoyt: I was able to use spm to deploy an iOS app (I only had one private dependency), but it was very similar to using a submodule. `swift package update` pulled down the files and built a binary (that I ignored), and then I dragged the source files into my iOS xcodeproj

not ideal, but it worked Thanks @AndrewSB. That is good to know. Like you said, you were using it very similarly to a submodule. I suspect you could get Moya to build just fine using a similar method. Even though `swift build` might fail, you can drag the resolved dependencies' source files into an Xcode project and build from there. To get `swift build` to work is another matter.

The core of the issue holding up Alamofire seems to be a dependency on a newer version of `Foundation` than the version SPM defaults to. The solution proposed by the Alamofire maintainers is to basically use Xcode configurations to override this behavior. A pure SPM solution would involve being able to depend upon specific Apple frameworks within `Package.swift`--this is what currently doesn't exist.

If the goal of getting SPM working for Moya is to add Linux support (as opposed to another macOS-based dependency manager), then the `Foundation` dependencies within Alamofire will likely only cause even more headaches. This is because of the how `Foundation` is deployed on Linux (bundled with Swift and not available via SPM) and how it is out of sync with `Foundation` on Apple platforms in terms of both API naming conventions and missing functionality. This makes smaller projects a hassle to port to Linux and maintain that support. I can imagine Alamofire would be a much larger undertaking. Hey @AndrewSB, I took a look at this and realized it just needed one small change to build correctly via SPM. Might be a good idea to add an SPM build job to CI to catch these kind of things in the future (could be a separate PR), but this is looking good! üëç  I'm going to retarget this PR to come off #885.
Hopefully we'll have Alamofire cooperating soon so we can merge this in üëå Try a `swift build` with that commit that I pushed. I think it builds fine now. I'll check it out Woah, that was awesome. Cool, I'll cherry pick two commits onto Moya's `master` and we should be ready to go here  Is this issue still present in the latest release, @aphorisme?
 @AndrewSB, any idea if this is still an issue?
 We haven't heard from other users that this is persisting, going to close for now but we can revisit if it comes up again. 
  Take a look at #627. Does that help? :)

You should be able to use the following:

``` ruby
pod "Moya", :git => "https://github.com/Moya/Moya", :branch => "swift-3.0"
```
 Ah, of course. Sorry!
 Great question @juliengdt. The solution is to specify the branch in your Podfile; if you're writing a library that depends on Moya, I'm afraid the best solution is to document that they will need to do that in their own Podfiles. 

I'm reluctant to tag a release because we're just not ready with Swift 3 support yet, especially around our ReactiveCocoa extensions. Does that answer your question?
 Basically yeah, you're basically telling CocoaPods that you want to override that version of B. It's worked for me in the past, if it's a problem we can always tag maybe like an alpha?
 Should be resolved by our new use of a 8.0.0 beta tag, can you verify? 
 Fab, thanks!
  There's been a lot of activity on master while we've been focused on Swift 3.0. Gotta merge 'em in! After making sure I didn't make any mistakes resolving the merge conflicts. 
 Tests are passing locally from the command line, too: 

<img width="1102" alt="screen shot 2016-09-15 at 9 52 02 pm" src="https://cloud.githubusercontent.com/assets/498212/18573116/a9fa0910-7b8e-11e6-9850-4a21e8244da6.png">

Going to try Carthage while I'm at it. CI is üî¥ because of an issue with Circle, I'm waiting on a response in their community forum.
 ![Giphy](http://media0.giphy.com/media/D0WOL0ogZIoG4/giphy.gif)
 <img width="1006" alt="screen shot 2016-09-15 at 23 12 36" src="https://cloud.githubusercontent.com/assets/49038/18574314/eef6a5a4-7b99-11e6-9961-74c80ab623bb.png">

ran it from scratch on a fresh computer - all üëç üçè 
 When I run on my local machine all tests pass too -- I'm currently trying on travis and tests fail however 
  https://github.com/Moya/Moya/pull/608#issuecomment-247292895
 Thanks for the kind words! I dug around the Alamofire repository and found this discussion which includes rationale for their decision: https://github.com/Alamofire/Alamofire/issues/1367 I personally find this regrettable, but there are comments in that issue of using forks of Alamofire that continue to support iOS 8. If you find one that works, I'd be happy to help you use Moya with them.
  This was causing a compiler error on ReactiveMoya for me. Similar to #629 
 Standby, performing the conversion for all 8 Rx & Reactive targets
 that should have done it üòÑ 
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Ace, thanks! So after merging, we can release like a 7.0.3 that adds Carthage support for Swift 2.3, correct? 
 Yeah, CI wasn't working for me, either. I didn't update it to use Xcode 8, which is probably why. I'll merge + release.
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 @tpesce Can you check that everything works for you with the 7.0.3 release? 
  :100:
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  I think you are still using Swift 2.2, correct? `7.0.2` is a Swift 2.3 release (in which `URLByAppendingPathComponent` _is_ optional. :)
 Use `7.0.0` on Swift 2.2 instead, upgrading to `7.0.2` once you switch to Swift 2.3 :)
 I think you did a pod update before? I don't think `pod install` automatically downgrades to the specific pod version. You should be able to update to `7.0.0` again now, I think?
 @Denis1992 please use specific Moya version, like:

```
pod 'Moya', '7.0.0'
```
 Fixed now? ^^
 üôå
 You are right @v-ken, it should be fixed now. Thanks for mentioning! üôá 
  Hi everyone :wave:,

Great thanks to all the contributors for this awesome project ‚ù§Ô∏è  !

Just found some typos and fixed it üòâ 

What this pull request does:
- Fixes some typos
  - In [`docs/Examples/CustomPlugin.md`: `dont` ‚Üí `don‚Äòt`](https://github.com/Moya/Moya/pull/633/files#diff-97cf7e1f68627a9088db3cbba8828c10R4)
  - In [`docs/Providers.md`: `activitiy` ‚Üí `activity`](https://github.com/Moya/Moya/pull/633/files#diff-f4a748831e283823bcd510bcae06b299R172)
- Uses American spellings (since most of the spellings in this project are in American style)
  - `behaviour` ‚Üí `behavior`
  - `initialisation` ‚Üí `initialization`
  - `customisation` ‚Üí `customization`
- Removes trailing whitespaces
- Fixes invalid links to other `.md` files
  - In [`docs/Examples/RxSwift.md`: `Providers.md` ‚Üí `../Providers.md`](https://github.com/Moya/Moya/pull/633/files#diff-7811fd9d8877f8a5856897e2ba3271f4R5)
  - In [`docs/Examples/ReactiveCocoa.md`: `Providers.md` ‚Üí `../Providers.md`](https://github.com/Moya/Moya/pull/633/files#diff-cafbaa4f5c12f0b68546c28bb2edf88dR5)

Would love to hear you feedback/suggestions, thanks!
 Good job! üëä
 Looking good!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  See https://github.com/Moya/Moya/issues/541 for a conversation about how to test, specifically around stubbing. We should document the outcomes of that discussions somewhere in the repo. 
 Specifically [this comment](https://github.com/Moya/Moya/issues/541#issuecomment-232428790) makes for a great start for the documentation.  7.0.1 is the last version that is compatible with Xcode 7 / Swift 2.2. Moya 7.0.2 is compatible with Xcode 8 running Swift 2.3. Swift 3 support is still a work-in-progress: #608.
 Does that answer your question, @rlam3? :)
  We should get the CI to keep track of our Carthage support, I debated putting this in danger but it takes a very long time to run, and when I ran it locally Xcode crashed :-/

![screen shot 2016-09-14 at 6 11 16 pm](https://cloud.githubusercontent.com/assets/49038/18531892/acab1520-7aa6-11e6-824f-0a63b47c55a2.png)
 Maybe it'll be better on CI
 Great idea! 
 Dang, an extra 35m to run on each CI run. Wonder if it's worth adding Jenkins _just_ for doing this instead of putting it on the real CI.

Anyway, we _know_ master is broken, this just validates it. Happy to either rebase with master isn't broken.
 I'm not surprised master isn't working, the 7.0.x stuff branched off from the 7.0.0 tag, and all the Swift 3 stuff is in its own branch, so master has been languishing for a bit. 

We could consider only testing one platform with Carthage, instead of iOS, macOS, watchOS, and tvOS. It might be worth the time tradeoff, not sure. What do you think?
 I'd be OK with just doing iOS, if we can - once some of the other PRs are in, I'll look at the docs to see if I can do that
 Great work! I think keeping Carthage support working is an acceptable tradeoff for a slower CI, thanks Orta.
  Sorry you're running into this error, it's possible I made a mistake when releasing 7.0.2 for Swift 2.3. Could someone from @Moya/contributors who is familiar with Carthage take a look and see if 7.0.2, the latest release, works with Xcode 8/Swift 2.3? 
 Ah, interesting! Would you be able to submit a PR against the release-7.0.1-take-two branch? Don't worry about it, though, I can take a crack tomorrow. 
 Wonderful, thanks! 
  Hey @lixingshi! We are currently working hard on releasing Moya for Swift 3.0 in #608. For now you can use Moya with CocoaPods specifying the branch "swift-3.0", like:

``` ruby
pod "Moya", :git => "https://github.com/Moya/Moya", :branch => "swift-3.0"
```

And switch to Moya 8.0 when the release happens.

Hope it helps! 
 This should work:

``` rb
pod "Moya/RxSwift", :git => "https://github.com/Moya/Moya", :branch => "swift-3.0"
```

Let us know how it goes :+1:
 Is there a problem with `Moya` here, or the `RxSwift` branch? @gordoneliel 
 But does that not work? It should point to the / a Swift 3 branch of Rx of course.
 Any idea @sunshinejr?
 Hmm, what is your Podfile @zhaoyunyi? Can you download our Demo and check if it works for you? Because I've downloaded it, and `RxMoyaProvider` works just fine in the Demo. Another idea could be that you maybe forgot importing `RxSwift` at the top of your file along with `Moya`?
  Hey, `7.0.1` is tagged at the same commit as `7.0.0`, but that's was a conscious decision
Details here: https://github.com/Moya/Moya/pull/594#issuecomment-246513882
 Yup, it was caused by a mistake on my part, working to fix it and release Moya with Swift 2.3 compatibility today. 
 This should be fixed now, could you try updating to Moya 7.0.2 and letting us know if it works? 
 Are you using Cocoapods or Carthage? Is the version number `7.0.2`?
 7.0.2 is what you want for Swift 2.3. Try `pod update Moya`, without specifying a version in your Podfile. That should install the latest version, which is 7.0.2. Maybe try deleting the `Pods` directory, if you can, and re-run `pod install`. 
 @dangthaison91 You need to explicitly specify that you want Moya 7.0.0. You can do this like:

```
pod 'Moya/RxSwift', '7.0.0'
```

(you also don't need both `Moya` and `Moya/RxSwift`, because `Moya/RxSwift` has `Moya` in it)

You can check [here](https://guides.cocoapods.org/using/the-podfile.html#specifying-pod-versions) what `~>` means and more in a Podfile. Hope it helps! 
  Hey all! This is the task from the #608 PR. Here I've updated the syntax of tests and it seems that it is building correctly. üéâ Most important notes:
- ~~Only two tests aren't passing. It has something to do with inflight tracking, I'm no expert in that field so could use some help.~~ **All tests are passing as of now!**
- I've commented out ReactiveCocoa tests for now, because we didn't update the code from the extensions yet. 
- The `parameterEncoding` has changed in Alamofire and it was tricky to test (at least for me). What I ended up with was checking if encoded request using encoding from old and new endpoint is the same. Second idea was to switch on type of the `parameterEncoding` and then used specific type to check, but because I didn't see any Equatable operator for any of the types, it was also tricky to differentiate all the types. The first one seemed more "generic", but if anyone has a better idea, I'm happy to hear it!
  You need to create only one Service that manages all endpoints. To better understand how to use Moya see the documentation at:https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md

If you have further question write here!
  Hey @hewigovens, this is being worked on in #594 :wink:
  Well done! üëç 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  I have removed the API key, just to avoid tempering with it.
Next time, you can just leave your issue open after editing its content / title :)
 Also, I am not sure if this is an error. The response is empty, but maybe this is intended? What is the status code returned for the request?
 What is unclear to you? We'd love to help! Please provide more code like how you make the request and more info about the request(address, header, method and so on). Because we can't make sure the issue is cause by your app-side or server-side. This is another question. I reply it in https://github.com/Moya/Moya/issues/1021.  What exactly is your question?
 Ref #620 
  This PR fixes the progress handlers to use Progress instead of the [now deprecated by Alamofire]-style (Int64,Int64,Int64) variant.
 Thanks! 
  Hey there! I'll do my best to help you distinguish them üòâ

`EndpointClosure` defines how to map `TargetType` to `Endpoint`. `RequestClosure` on the other hand, resolves `Endpoint` into `NSURLRequest` (or `Error` if the request shouldn't be performed). You can use them both on the same provider and  `RequestClosure` follows after `EndpointClosure`.

In the `EndpointClosure` you can customize endpoint's `parameterEncoding`, `headers` or additional `parameters` and more if you want. There you can setup things your API needs in the headers or parameters, that should go globally. You can also stub the `statusCode` so it returns errors instead of 200 for testing purposes.

Then, when you have the `Endpoint` created, there is that `RequestClosure`. You are moments before the request. Here you can change things that you want in `NSURLRequest`, but also you can perform asynchronous token fetch, and if it fails you can stop the request as well (and this is the place for it). 

There is also great documentation about the topic [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md). If you find something hard to understand, you are more than welcome to make an issue or pull request if you know how to fix it.

Hope it helps! If you have more questions, let us know! üêº 
 Great answer, @sunshinejr. @rlam3 let us know what else we can clarify, we're always looking for ways to improve our documentation!
 Hi @rlam3, thanks for opening the issue. We actually have some auth-specific documentation [here](https://github.com/Moya/Moya/blob/master/docs/Authentication.md) I wanted to make sure you were aware of; the request closure has been specifically designed with OAuth and other forms of asynchronous authentication in mind. If you have any suggestions on ways to improve our documentation, please send a pull request and we can take it from there. 
 You found the code that does the refreshing, further down that file you'll see the code that calls the fetching code: https://github.com/artsy/eidolon/blob/a7bb061c89cd4bed44d956b1376909ca0e72060b/Kiosk/App/Networking/Networking.swift#L87-L94

Basically, the `XAppTokenRequest` function's Observable always returns a valid token (whether it was a cached valid token, or a newly fetched token). Then we use `flatMap` to turn that Observable into one that represents the _actual_ network call we want to make. Does that make sense? 
 Yup, don't need to worry about synchronizing NSUserDefaults manually, it does it for you. And worst case, it looses the token and just fetches a new one. We clear them out just for consistency's sake. NSUserDefaults is just a convenient place to put them. We inject the token here: https://github.com/artsy/eidolon/blob/a7bb061c89cd4bed44d956b1376909ca0e72060b/Kiosk/App/Networking/Networking.swift#L132
 We don't use a JWT in that app, but the principle is the same. That's where you would add any tokens as HTTP headers, or sign the request using Heimdall or whatever for OAuth. 
 Good question; the response object [contains the URLResponse](https://github.com/Moya/Moya/blob/606fd46080ed3e4eabdfa1d50cdbe6b103466c62/Source/Response.swift#L7) which has the headers you can access. 
 Cool! Sounds like your issue was resolved, so I'm going to close this. Please feel free to re-open if that's not the case, thanks again!
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Thanks! Good job! 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Alamofire updated their podspec to 4.0.0 on master which causes errors if we still reference 4.0.0-beta.2
 Tried it out and it seems fine! Thanks! 
  So due to [Alamofire#1455](https://github.com/Alamofire/Alamofire/pull/1455) change, we have to update our progress blocks as well. For now I've just updated the new Alamofire's Progress API to our existing Progress API. If we should update to two blocks instead of one (`downloadProgress`, `uploadProgress`) is eligible for discussion. 

More info #608.

Cheers! üêº 
 this looks great!
 Oh no - alamofire deprecated the Int64 variants for the progress handlers
 sounds like this is definitely a major version bump then üëç 
 I'm working on a PR for this right now. 
 even though 7.0.0 was released recently - does it make sense to move to 8.0.0 as @orta suggests?
 I too think that makes the most sense, yeah.
 I'm testing #618 #613 #608 on my own fork and everything seems to be working smoothly üëç 
 Okay, I think that it can be merged to the main Swift-3.0 repo, and make sure that Moya builds, and if there are any issues about this PR we can make a new one with fixes.
  Two downsides to the approach I went with:
1. Its a breaking change, but that's understandable, given this is a source change
2. In the print output, the items may be printed as an array, instead of a variadic list. Not sure how to get around that, I looked at function currying and partially applying the print function, but it didn't lead anywhere
 Wow, fast! Thanks! Looks fine to me! About that problem with printing array, would it work that instead of using array, make the items parameter the last one in tuple, so it can accept variadic parameter?
 Oh that might! Let me try it
 Yeah, that worked @sunshinejr. Awesome insight!
If this looks good to you, then I think it's ready to merge üòÑ 
 üíØ
  carrying out #609 for the xcodeproj
 Ace.
  since alamofire 4 requires ios 9++ I believe we need to increase the deployment target of Moya to 9.0 as well 
 Makes sense! 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hey guys! üéâ  I tried to update Moya to the latest Swift 3.0 shipped with Xcode GM Seed. As there is work that still needs to be done, I would use some help with:
- [x] `sendAlamofireRequest` method in [Moya+Internal](https://github.com/Moya/Moya/blob/swift-3.0/Source/Moya%2BInternal.swift#L187-L221). (@sunshinejr, PR: #613)
- [x] [NetworkLoggerPlugin](https://github.com/Moya/Moya/blob/swift-3.0/Source/Plugins/NetworkLoggerPlugin.swift). (@AndrewSB, PR: https://github.com/Moya/Moya/pull/612)
- [x] [ReactiveCocoa extensions with Tests](https://github.com/Moya/Moya/tree/swift-3.0/Source/ReactiveCocoa). (@ashfurrow, PR: #647)
- [x] [Tests](https://github.com/Moya/Moya/tree/swift-3.0/Demo/Tests). (@sunshinejr, PR: #625)
- [x] Continuous Integration.
- [x] Any other things you may find.

I think together we can make it better üëäCheers! 
 Will take a look soon!
 Not really sure how to proceed - the build (Demo) fails because of Alamofire, Rx, Nimble, Quick, and does not give me any type information (with alt+click). Am I missing something @sunshinejr?
 Did a little - but couldn't really test. :/
 Looks good! Want to add a changelog entry?
 Done!
 Thanks @sunshinejr @BasThomas, I'm testing pulling this in through Carthage right now üòÑ 
 Hmmm. I got a failure on building `RxMoya iOS`, based off some shell task exiting with error code 65?

<img width="1277" alt="screen shot 2016-09-08 at 12 26 15 pm" src="https://cloud.githubusercontent.com/assets/3814772/18363573/869375e4-75bf-11e6-89af-8b30745e334d.png">

I'm going to try nuking my derived data and trying again
 Ahh, the problem is that the `Cartfile` hasn't been updated to point to swift 3 versions, just the Podfile. I'll make a commit that brings the Cartfile upto speed
 Fantastic work here, everyone! This kind of collaboration is what makes me proud to be a member of this open source community.
 @ashfurrow üòÑ 

Testing this again with the new cartfile
 Created #610, can someone sanity check the PR if it makes sense merge it in?
 Hey again guys! Thanks for helping out so quickly! üéâ  I've added fix to `Podfile` that should fix most of the problems with building. Let's now agree that every new changes to this PR should go in another PR, just to not make any more chaos than needed and not duplicate the code in advance. Thanks again! üôá 
 it seems like there are still a couple of build errors in Moya+Internal and NetworkLoggerPlugin
 @sunshinejr looks great!

Here's what I've uncovered with with `output` in the `NetworkLoggerPlugin`.
Swift 3 removed parameter labels for tuples, making it impossible to create a tuple with a variadic parameter

I think we're going to have to make a breaking change with the `NetworkLoggerPlugin`, and switch from `output: (_ items: Any..., _ separator: String, _ terminator: String) -> Void` to something else. I see two possibilities:
1. remove the variadic parameter of `_ items: Any...`, into`_ items: [Any]`, or `_ items: Any`
2. switch from this tuple to some sort of delegate

I think it makes sense to do the first, I'm going to get started with it in a PR. Open to any other suggestions though! 
 @edwardvalentini yeah, these are the tasks I've listed as a TODO ones in the first post, I've just removed the errors with building Frameworks, which didn't have Swift 3.0 set in settings. 

@AndrewSB yeah, one of the reasons I'd rather see this change in `NetworkLoggerPlugin` in a PR, to agree on the solution.

Also, I'm gonna take a stab at new progress APIs for Alamofire.
 üôå 
no experience with alamofire,  so I'm happy you offered üòÖ

Just submitted https://github.com/Moya/Moya/pull/612
 @charlag Yeah, we need to also update README, docs, examples, prepare for next major release and I thought that it would be good to have migration guide of some sort. I'm not sure if everything should be in this PR tho. Thoughts? 
 I think a separate PR for docs and README is a great idea.
 As of now, Moya core, Moya/RxSwift and Demo should build correctly üéâ
 Awesome! I think the last thing we need to do before releasing Moya 8, with support for Swift 3, is to get CI working. Does that sound right? 

Thanks again for all the work everyone!
 Yeah, I'm working on the tests right now, we also need help with ReactiveCocoa if possible, and we have to wait for Circle CI because as of right now they don't support Xcode 8 GM Seed (more info [here](https://discuss.circleci.com/t/what-is-timeline-for-xcode-8-gm-support/6153/2)). But we are really close :)
 Travis supports Xcode 8.  I've been using it on another project.   We can switch to Travis, maybe ?
 Aye, we've bounced back and forth between Travis and Circle. I can't remember what made us leave Travis last time, but it's definitely a possibility worth revisiting. 
 @charlag Thanks! Because both [Alamofire](https://github.com/Alamofire/Alamofire) and [RxSwift](https://github.com/ReactiveX/RxSwift) have iOS 9.0 as a minimum deployment target.
 Circle now supports Xcode 8 GM: https://discuss.circleci.com/t/what-is-timeline-for-xcode-8-gm-support/6153/5 I'm taking a look at things now, the last failure was due to an old cached version of Alamofire, which exhibited this bug: https://github.com/Alamofire/Alamofire/issues/1507 So it might be as easy as rebuilding without the cache. 
 Still being the beta 6 Xcode build number on Circle: 8S201h could be a slow rollout of the Xcode GM build.
 @Moya/contributors is there a way to use current master branch of [ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa) via CocoaPods? It seems like they have their Podspec [here](https://github.com/mhuusko5/Podspecs.git), instead of the main repo.
 @sunshinejr That's not possible, unfortunately. The workaround is to define the ReactiveCocoa branch in your Podfile. Documenting this requirement in the readme should be sufficient, I'll try to work on getting those ReactiveCocoa tests to pass.
 Okay, I dug into this. It is possible to get ReactiveCocoa downloading with CocoaPods, but it's a bit roundabout since they [don't yet have a podspec](https://github.com/ReactiveCocoa/ReactiveCocoa/issues/3000) in their repo. I've modified a community-supported podspec to point to their `master` branch, which has Swift 3 support.

``` swift
pod 'ReactiveCocoa', :podspec => 'https://raw.githubusercontent.com/ashfurrow/Podspecs/852d47f4d1ff836402fa2903c544a09ec665a72b/ReactiveCocoa.podspec'
```

However, ReactiveCocoa depends on a new library called ReactiveSwift, which does not have a podspec yet. I've [opened an issue](https://github.com/ReactiveCocoa/ReactiveSwift/issues/13) seeking advice. The team seems amenable to it, so the next steps for me are to:
1. Create a podspec for ReactiveSwift, send a PR to their repo.
2. Uncomment the tests, modify them as required.
3. Add instructions to the readme to specify both the ReactiveCocoa and ReactiveSwift pods manually in one's Podfile.
 @ashfurrow great! Can't wait for this piece to be done as well üéâ
 I've submitted a PR to ReactiveSwift: https://github.com/ReactiveCocoa/ReactiveSwift/pull/14 Once it's merged + pushed to CocoaPods trunk, we'll need to submit a PR to ReactiveCocoa to add a podspec there, too (updated to depend on ReactiveSwift). 
 BTW, CI is working with the Xcode 8 GM now. I'm building to see if it works, but macOS tests were failing on Circle earlier. 
 Same exact issue i had with travis CI last night when I tested Moya there ‚Ä¶  iOS tests passed but macOS tests were failing‚Ä¶ locally it was all working though
 Very strange! Still, we're one step closer. Is anyone else able to take a look at the failing macOS builds? I've got my hands full with the ReactiveCocoa stuff already. 
 @hiteshsondhi88 Agreed, do you have time to submit a pull request with those changes? 
 Okay, so we just need to update the Readme/Podfile to the new tagged versions of RxSwift and Alamofire. I'm thinking at that point, we consider releasing a beta? Or should we just release?
 @ashfurrow Hmm, how about staying in beta as long as our dependencies are? 
 Homebrew broke overnight, see https://github.com/Homebrew/brew/issues/991 . Going to fix in a PR. 
 Okay, once #657 is üçè and merged, I think it's a good idea to release `8.0.0-beta.1`. Let me know if there's anything else holding this back :+1:
 Okay, it's all green. Merging!
 Released as 8.0.0-beta.1, see the Readme for installation instructions. It's a bit touchy since ReactiveSwift isn't yet on CocoaPods trunk, open an issue if you run into trouble. 
  This is great, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Moya relies on Alamofire to do its parameter encoding, I'm a bit surprised that it behaves this way. There is a workaround though.

Sounds like you might need to use a custom parameter encoding, similar to [what's described here](https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md). You can do this on a per-target basis, so just `SearchUPC` if that makes sense for your code.
 Care to share how you solved it? :)
  You can use the [built-in network logging plugin](https://github.com/Moya/Moya/blob/master/docs/Plugins.md) which can be used to log all requests. 
  Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  @tomj How do you think we could improve our documentation around this? Any suggestions? 
 Looks great!
  I have added a snippet of code to clarify the use of a Plugin and done some textual modification to better understand what a plugin is.
 Woo, nice!
  Maybe @leoneparise can help with this. And the Multipart still has to be documented (see #586)
 I'm documenting this feature but for next version (8.0), which changed a lot from version 7.0. You can use my comment on this issue https://github.com/Moya/Moya/issues/572 to guide you implementation. 
 `.File` can be used only with `NSURL` and `.Data` with `NSData`. You need to convert your `UIImage` to `NSData` to build the Multipart.

Try this:

``` swift
var multipartBody: [MultipartFormData]? {
        switch self {
        case .ChangeProfileImage(_, let profileImage, _):
            guard let data = UIImageJPEGRepresentation(profileImage, 1.0) else { return nil }
            return [MultipartFormData(provider: .Data(data), name: "files", mimeType:"image/jpeg", fileName: "photo.jpg")] 
        default:
            return nil
        }
    }
}
```
 What version of Moya are you using?
 Yeah, that installs the latest version.
 Yeah, the syntax for that is the following:

``` ruby
pod 'Moya', '~> 7.0.0'
```
 `multipartBody` param is an array of `NSData`. You can return the array pointing to the same `name` form parameter. That will be parsed by the server as an image array.
 @riksof-zzlalani Hey there! What your code is lacking is subscription. This is not _really_ a Moya problem, but problem with Reactive Extensions. So, a quick fix would be a following:

``` swift
return testApiProvider
    .request(.PostTest(obj: _file))
    .debug()
    .mapJSON()
    .map({ JSON -> EKResponse? in
        return Mapper<EKResponse>().map(JSON)
    })
    .subscribeNext { _ in }
```

I hope it helps! Please next time use another issue for questions if they are touching quite different topic, so others can easily search for it üêº
 @riksof-zzlalani no problem! I think that the original problem @swabzz had should be resolved as of now, so I'm gonna close for now.
  Great question ‚Äì we actually had developers with a similar problem a while ago, check out their issue: https://github.com/Moya/Moya/issues/431 I think you'll find the solution here. Let us know how it goes. 
 I think I may have misunderstood your initial question, but I think you should be able to use the default `.URL` parameter encoding.

When returning `parameters` from the target, does the following work?

``` swift
return ["param1": "[\"15\", \"19\"]"]
```

Normally when URL-encoding an array, the format is something like `parameter[]=15&parameter[]=19`, I think. If that's not what you want, then you'll need to create the final string you're looking for manually, which is a bit messy I admit. Just using the `parameters` property of `Target` should be enough.
  I think you can omit the `?` when casting (so, `as` instead of `as?`).
 I have been taking a look, and it seems the `error` is not an optional. The unwrapping therefore makes no sense. Also, I found converting the `error` from `Error` to `Moya.Error` has no effect either, so that can be committed as well. That means you can the following in your closure:

``` swift
let provider = MoyaProvider<MyService>()
provider.request(.CreateUser(firstName: "James", lastName: "Potter")) { result in
  switch result {
  case let .Success(response):
    ()
  case let .Failure(error):
    switch error {
    case .Data(let response):
      print(response)
    case .ImageMapping(let response):
      print(response)
    case .JSONMapping(let response):
      print(response)
    case .StatusCode(let response):
      print(response)
    case .StringMapping(let response):
      print(response)
    case .Underlying(let nsError):
      // now can access NSError error.code or whatever
      // e.g. NSURLErrorTimedOut or NSURLErrorNotConnectedToInternet
      print(nsError.code)
      print(nsError.domain)
    }
  }
}
```

which will 'just work'.
  Great question! I wouldn't mind implementing something for our existing Swift 2.x code, but moving to `ErrorType` on `UnderlyingErrorType` and `RequestResultClosure` removes the ability for developers to switch to a specific `Moya.Error`. 

I'm not sure of the best approach here. @Moya/contributors any ideas? 
 Thanks for the follow up!
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  @charlag because this is a PR to add support for Swift 2.3. We are currently using Swift 2.2, which also means using Xcode 7.3.1. We may need to change the CircleCI file though? (cc @ashfurrow @gustavogervasio)
 Xcode 8 supports both Swift 2.3 and Swift 3.0, right? May we do need Xcode 8 then? 
 Sorry if I wasn't clear - that's what I was trying to say. 

Swift 2.2 == Xcode 7
Swift 2.3 == Xcode 8
Swift 3.0 == Xcode 8
 @charlag I've opened PR #608 with help wanted on the Swift 3.0 migration for Xcode GM Seed, if you want to help üòâ 
 I can merge+release this for Swift 2.3 before releasing a separate version for 3.0, _or_ we can just do it for 3.0. What does everyone think? 
 Okay, will reply from @gustavogervasio's branch and push a tag. Wish me luck!
 Rather after #621, I think master is updated for 2.3. 
 I've cherry-picked the commits from #621 into the 7.0.1 tag and everything looks good. This means we can release _just_ Swift 2.3 support and not also the breaking changes currently on master. I'm downloading the Xcode 8 GM to test locally before releasing. Thanks everyone!
 Cool, will do :+1: What's the trick to get Xcode 8 to use Swift 2.3?
 Wow, that was a lot of work. I've got 7.0.1 released on Carthage and CocoaPods, would someone be able to verify it's working for them as expected?

I'm going to close this PR.
 üò¢ @marcelofabri can you check for other breaking changes? If that's the only one, we can replace the `7.0.1` tag and hopefully no one will be the wiser. 
 I've pushed the release up to a `release-7.0.1` branch. 
 Okay, well let's stop the bleeding. Hold on.
 I've pushed a 7.0.1 tag with an identical commit to 7.0.0 so no one's projects will break. I'll take another look tomorrow, thanks for pointing out the issue!
 Cherry-picking commits turned out to be too complicated, so instead I branched off of the 7.0.0 tag and redid the changes for Swift 2.3: https://github.com/Moya/Moya/compare/7.0.1...release-7.0.1-take-two . I'm going to lint the podspec locally before releasing, I'll let you know. 
 7.0.2 has been released, could someone take a look and verify it's all good? 
 Great, thanks!
  Makes sense to me! Good to merge when üçè
  @rlam3 I think that the discussion for difference between `endpointClosure` and `requestClosure` is moved to #617 so I will take on the next questions:
1. `YourAPI` is in this example is the `Target` you use for requests. Let's say you have one `Target` in your app and let's call it `TwitterAPI` here instead of `YourAPI`.
2. The `YourAwesomeOauthProvider` is just an example. Here you can use third party library to get your token, or you can just use Moya to get it - your choice. There are times you are working with existing SDK's for fetching tokens, but also there might be time that you will need to handle it yourself and Moya can be a perfect fit for it as well. You can even have it in the one `TwitterAPI` if you want.
3. Yes, now every time you use your `provider`, it will first use the `requestClosure` to map `Endpoint` to `NSURLRequest`.
 Closing this for now. @rlam3, please reopen if you have any additional questions related to this.  I'm not sure what the plans on this are, but a PR to update the branch would be great!
 Also, there seems to be an [issue](https://github.com/Moya/Moya/issues/513) that's tracking the progres. I am not sure how up-to-date it is, though. But it might be helpful.
 The Podfile currently uses [10.9 as a target](https://github.com/Moya/Moya/blob/fd2cb69a3e9a6c5e4c978c38563c90941ecbccc5/Demo/Podfile#L37) but [RxSwift requires 10.10](https://github.com/ReactiveX/RxSwift/blob/3.0.0.alpha.1/RxSwift.podspec). Maybe upping that would work?
 @DenisLaboureyras is this issue still causing trouble? 
  A PR to update that would be great!
  Sure!  If you want.  We've started using it with FutureKit, and it works great.

Should Moya _require_ or _depend on_ one of these microframeworks?  Could, but I would not like that decision made for me.  So I hope we don't go in that direction.
 https://github.com/ello/ello-ios/blob/cg/add/hire-me-button/Sources/Networking/HireService.swift
 Nope, I didn't even look at PromiseKit at the time. Pick whichever seems right for you. 

> On Aug 25, 2016, at 9:44 PM, rlam3 notifications@github.com wrote:
> 
> @colinta Is there a reason for you guys to choose FutureKit over PromiseKit?
> 
> ‚Äï
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
 @rlam3 has this question been solved to your satisfaction? Happy to provide further clarification. 
  A lot was done to multipart upload last month. Now I see that this was a requested feature by a lot of users. I'm opening this issue to document our current implementation and provide some guidelines of how it works and how can be used. I think next version should be released with this new doc.

The documentation must include:
- [x] How to configure the Target for multipart
- [ ] How to use with Rx extensions
- [ ] Update the main page to tell all users that Moya supports upload

What do you think @colinta @ashfurrow?
 Makes sense. One note: we don't use the GitHub wiki, but rather the `/docs` folder. Sounds awesome, thanks for opening the issue :+1:
  Awesome, glad you got it figured out! Thanks a lot for posting your solution, I'm sure it'll be of help to others. Going to close the issue, feel free to open another if anything else comes up!
  - Fixed some typos
- Fixed a duplicated header doc
- Added `backticks` to more clearly show types 
 I guess that's not actually needed? Or should I add a `improved header documentation` in the Changelog?
 This is great, thanks for the PR! Yeah, a changelog entry like the one you suggested would've been great, don't worry about it. 
  Fantastic, looks great to me!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  a PR would be awesome @mattfxyz :) 
 @mattfxyz Is it fixed? I saw that PR #581 was merged.
 I have a fix in my fork. Can we create a new release branch?  Should be possible, can you create a PR? What branch? Should I just make a new 2.3 one on Moya/Moya?  I suppose so, and then release a `7.something` release for CP / Carthage. @ashfurrow, is this possible? Makes sense to me. You should be able to branch off from the tags of our releases.  I created a release-7.0.4 branch and opened a PR to merge the changes into it.   Thanks for the PR! I like it, not too sure about _recommending_ using a force cast, even though I just looked and it's exactly what my code does too üôà What do you think about a 

``` swift
guard let request = endpoint.urlRequest.mutableCopy() as? NSMutableURLRequest else { return }
```

Or something similar? I think if we keep the force cast, we should add a short comment explaining it will always succeed. Thoughts? 
 I prefer a `guard`. It wouldn't be optional if it could never fail.
 But a `guard` does not do any harm in that case, either.
 I have the same feeling as @vzsg on this: using `guard` implies that we don't know what's going on, and so we're protecting ourselves from something; i.e. `request.mutableCopy()` _might_ return _another type_ of object.

But that's not how that method works ‚Äì we all know that it is a reasonable guarantee that we will get back an `NSMutableURLRequest`.

OTOH if this code was written with `guard` I would probably say nothing; it doesn't _hurt_ to have a guard there.  But there _is_ benefit to showing intention with force-unwrapping.  It says "we know what we're going to get, we trust the system".  I'm OK with that. `</twocents>`
 Anecdotal support of this argument: Alamofire uses a force-unwrap to convert `NSURLRequest` to `NSMutableURLRequest` https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L72
 Adding a comment sounds like the best approach, thanks for all the discussion everyone! 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  This PR mainly fixes indentation errors for the code blocks in the documentation.
I have also added the Swift syntax to a code block where it was missing, as well as removed some unnecessary `break`s in a `switch` statement.
 This is wonderful, thanks! We've needed some tidying up for a while, thanks for taking the initiative. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Looks like this ran through Danger fine üëç 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Makes sense, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  ``` swift
let endpointClosure = { (target: MyTarget) -> Endpoint in
  let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
  let endpoint: Endpoint = Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
  return endpoint.endpointByAddingHTTPHeaderFields(["APP_NAME": "MY_AWESOME_APP"])
}

let provider = MoyaProvider(endpointClosure: endpointClosure)
```

then i got this error

``` swift
"errors" : [
"Unable to find endpoint"
]
```

my usage is not correct or something, i read the documents....,thank you
 Interesting! "Unable to find endpoint" suggests that the request is failing on the server side of things, like maybe the URL you're trying to hit isn't correct? Can you try using the [network activity plugin](https://github.com/Moya/Moya/blob/master/docs/Plugins.md#network-activity-indicator) to print out what exact URLs Moya is using, and then double-check that they're correct? 
  `"name": "images"` caught my eye, I expected that to have an extension, e.g. `"name": "image.jpg"`.  Also, you are returning the `dictObj` (aka `objDict` - you might want to check your naming on that one) from `var parameters: [:]?`, and so the `imagesDataArr` is going to be included there (maybe base64 encoded - I have no idea what Alamofire does with `NSData` in that case).
 Oh shoot, you're totally right on the `"name"` thing!  My mistake.
 Can you provide a sample using `Alamofire` and `Moya` so we can know what's happening?

I saw that you return the same `[NSData]` array on `parameters` and you shouldn't do that. Here is an example of how to make a form with multipart-data:

``` swift
enum SomeAPI {
  case CreatePost(message:String, coordinate:CLLocationCoordinate2D,
        contentType:Post.ContentType, contentFile:NSURL)
}
```

``` swift
extension SomeAPI: TargetType {

  var path:String {
    switch self {
    case .CreatePost: return "/posts"
    }
  }

  var method: Moya.Method {
    switch self {
    case .CreatePost: return .POST
    }
  }

  var parameters: [String: AnyObject]? {
    switch self {
    case .CreatePost(let message, let coordinate, let contentType, _):
      return [
        "message": message,
        "lat": coodrintate.latitude,
        "lon": coodrintate.longitude,
        "type": contentType.rawValue       
      ]
    }
  }

  var multipartBody: [MultipartFormData]? {
    switch self {
    case .CreatePost(_, _, let contentType, let contentFile):
      switch contentType {
      case .Image:
          return [MultipartFormData(provider: .File(contentFile), name: "files", mimeType:"image/jpeg", fileName: "photo.jpg")]
      case .Video:
          return [MultipartFormData(provider: .File(contentFile), name: "files", mimeType:"video/mp4", fileName: "video.mp4")]
      }
    }
  }
}
```

This sample will post a form with `lat`, `lon`, `message`, `type` and `files` properties. I'm using a `File` multipart but you can use `NSData` directly. 

All your text inputs should be on `parameters` property as string and data on `multipartBody` (Moya will take care of the rest).

BTW, I started the multipart upload implementation inside Moya. Today the code is much better than the first version, thanks to our great community :)

The lack of documentation is my fault too, I didn't have time to document this new feature and now I'm waiting for version 8.0 to document it properly (because it breaks our current API). For now, use this example to make your implementation and post here any question.
 @rcholic Yes! only `NSData` should be on `multipartBody` everything else should be on `parameters`.
 @rcholic Tell me if it's working now so I can close the Issue. :)
  You forgot to implement this protocol required property:

``` swift
var multipartBody: [MultipartFormData]? {
        return nil
}
```

I also encountered the documentation wasn't up to date for this. Changed that now: 
https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md
 Have you been able to solve this issue, @kanishkatn?
  So, do you want to catch and ignore the error?
 Tricky problem! It might be possible for us to handle this, but it would be a departure from `URLSessionTask`'s behaviour. I'm not sure if Moya should be circumventing the behaviour of CocoaTouch libraries. 

A workaround could be to (manually?) dispose of the `Observable` before cancelling, which should prevent errors from being sent on the observable. Let us know how it's going :+1:  
 Hey @mingyeow, did you find a way to make it work as you wanted? Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  üíØ
  @spxrogers This is great, thanks! Can you add a note to the changelog about the new parameter? 
 @orta there was a Danger failure [on the build](https://circleci.com/gh/Moya/Moya/358) that looked like:

```
$ bundle exec danger
sh: -c: line 0: unexpected EOF while looking for matching `"'
sh: -c: line 1: syntax error: unexpected end of file

Danger has failed this build. 
Found 1 error.

bundle exec danger returned exit code 1
```

I've not seen that before, anything I can do to troubleshoot/reproduce? 
 Thanks a lot! No pressure to rush! 
 Cool, looks good to merge! @spxrogers I think you'll need to merge from master first, feel free to merge after that üëç 
  That is a üíØ idea. 
  Cool! This is for Carthage support? Could you summarize the changes+motivation behind them in the PR? (For those of us not in the Carthage know-how.)
 omg you're my hero. this has been on my docket for too long. Excited to check this out when you're done @AndrewSB!
 Awesome! Sounds exciting, and like it's an involved process. Definitely worth a blog post, I'm sure we're not the only library to have this problem. 
 Just got around to finish implementing this, what I've done is importing the `Moya` framework into each of the Reactive & Rx source files, and remove all Moya source files from the Reactive and Rx targets.

Currently I'm importing Moya into the Reactive & Rx files like so:

```
#if !COCOAPOD
import Moya
#endif
```

where I'm expecting Cocoapods to define a debug flag named `COCOAPOD`, kind of like how it's explained in [this SO post](http://stackoverflow.com/questions/24111854/in-absence-of-preprocessor-macros-is-there-a-way-to-define-practical-scheme-spe/24112024#24112024).

I'm relatively sure Cocoapods doesn't define that flag, so some other workaround must be found. I've just created https://github.com/CocoaPods/CocoaPods/issues/5889 asking if there's anything I can do.

Also currently testing this to make sure it works through a carthage install
 Ok, I think this is now at a point where it's usable through Carthage, testing currently.
 This works for me through Carthage!

Heres an excerpt from the diff upgrading to this branch in my app üéâ

``` diff
diff --git a/Proxy/Internal/Network/Networking.swift b/Proxy/Internal/Network/Networking.swift
index d9bcd86..bafb067 100644
--- a/Proxy/Internal/Network/Networking.swift
+++ b/Proxy/Internal/Network/Networking.swift
@@ -9,7 +9,7 @@ import RxMoya

 private let reachabilityManager = ReachabilityManager()

-class OnlineProvider<Target>: RxMoyaProvider<Target> where Target: RxMoya.TargetType {
+class OnlineProvider<Target>: RxMoyaProvider<Target> where Target: TargetType {

     fileprivate let online: Observable<Bool>

@@ -17,7 +17,7 @@ class OnlineProvider<Target>: RxMoyaProvider<Target> where Target: RxMoya.Target
          requestClosure: @escaping RxMoyaProvider<Target>.RequestClosure = RxMoyaProvider.DefaultRequestMapping,
          stubClosure: @escaping RxMoyaProvider<Target>.StubClosure = RxMoyaProvider.NeverStub,
          manager: Manager = RxMoyaProvider<Target>.DefaultAlamofireManager(),
-         plugins: [RxMoya.PluginType] = [NetworkLoggerPlugin(verbose: true)],
+         plugins: [PluginType] = [NetworkLoggerPlugin(verbose: true)],
          online: Observable<Bool> = reachabilityManager.reach) {

         self.online = online
@@ -28,7 +28,7 @@ class OnlineProvider<Target>: RxMoyaProvider<Target> where Target: RxMoya.Target
                    plugins: plugins)
     }

-    override func request(_ token: Target) -> Observable<RxMoya.Response> {
+    override func request(_ token: Target) -> Observable<Response> {
         let actualRequest = super.request(token)

         return online
@@ -43,7 +43,7 @@ class OnlineProvider<Target>: RxMoyaProvider<Target> where Target: RxMoya.Target
 }

 protocol NetworkingType {
-    associatedtype T: RxMoya.TargetType, ProxyAPIType
+    associatedtype T: TargetType, ProxyAPIType
     var provider: OnlineProvider<T> { get }
 }

@@ -55,7 +55,7 @@ struct Networking: NetworkingType {
 extension Networking {

     // public interface
-    func request(_ token: ProxyAPI) -> Observable<RxMoya.Response> {
+    func request(_ token: ProxyAPI) -> Observable<Response> {
         let actualRequest = self.provider
             .request(token)
             .filterSuccessfulStatusCodes()
@@ -99,15 +99,15 @@ extension Networking {

 private extension Networking {

-    static func endpointsClosure<T>(_ target: T) -> RxMoya.Endpoint<ProxyAPI> where T: RxMoya.TargetType, T: ProxyAPIType {
+    static func endpointsClosure<T>(_ target: T) -> Endpoint<ProxyAPI> where T: TargetType, T: ProxyAPIType {
         let url = "\(target.baseURL.absoluteString)\(target.path)"
-        let sampleResponse: RxMoya.Endpoint.SampleResponseClosure = { .networkResponse(200, target.sampleData) }
+        let sampleResponse: Endpoint.SampleResponseClosure = { .networkResponse(200, target.sampleData) }

-        let endpoint = RxMoya.Endpoint<ProxyAPI>(URL: url,
-                                                 sampleResponseClosure: sampleResponse,
-                                                 method: target.method,
-                                                 parameters: target.parameters,
-                                                 parameterEncoding: target.parameterEncoding)
+        let endpoint = Endpoint<ProxyAPI>(URL: url,
+                                          sampleResponseClosure: sampleResponse,
+                                          method: target.method,
+                                          parameters: target.parameters,
+                                          parameterEncoding: target.parameterEncoding)

         let baseHeaderFields = [
             "Accept-Version": "2016-07-05",
@@ -120,7 +120,7 @@ private extension Networking {
         // networking is the epitome of side effects + shared global state üò∞
         let authenticationHeaderFields: [String: String]? = target.requiresAuth ? ["Authorization": "Bearer \(AuthToken.local()!.accessToken)"] : nil // swiftlint:disable:this line_length

-        return endpoint.endpointByAddingHTTPHeaderFields(baseHeaderFields + authenticationHeaderFields)
+        return endpoint.adding(newParameters: baseHeaderFields + authenticationHeaderFields)
     }

 }
```
 @petester42 @ashfurrow @justinmakaila: I'm sorry this took so long, but I think it's finally done!

Things left before this is ready to merge:
- [ ] check to make sure cocoapods install works
- [ ] fix danger on tests? currently `bundle exec danger` is crashing on CI
- [x] code review from you guys üòÑ, and a vote of confidence that this change is still a good idea to anyone but me üòã

Really excited to have this working now!
 Awesome! Thanks for the review @petester42 üëç I'm using this branch in prod with one of my apps, so I feel pretty comfortable with it too.

I do want to make sure that this doesn't break the cocoapods install though. Can any @Moya/contributors who use Moya through Cocoapods try pointing their install to this branch to confirm that everything still works?
 @AndrewSB I use Carthage as my dependency manager, and I believe @orta and @ashfurrow are the resident CocoaPods experts
 @justinmakaila alright, I'll wait for someone familiar with cocoapods to test it, I don't want to merge this into master and have it break for everyone depending on this library through Cocoapods üò¨
 I don't see any CocoaPods breaking changes, I think we're good to merge. 
 awesome, I'll merge üòÑ
 oh, @ashfurrow: you mentioned that it would be cool to write a blog post about this change. If you think it still merits one, I'd love to write/help write it. You can email me (asbreckenridge@me.com) to talk about it üëç 
 Circle is complaining, is this a problem? @AndrewSB 
 Nah, CI fails like that intermittently. Can you trigger a rebuild on master? 
 Rebuilding from their web interface immediately fails the build again, it seems. üòï 
  I noticed this when our CI tries to upload unit test code coverage reports:

```
error: Failed to load coverage
```

([Example build](https://circleci.com/gh/Moya/Moya/343).)

It happens for quite a few files, which may explain why as of a few weeks ago, our coverage dropped for %90 to %60. 

I have no experience with the tool, this might be an easy fix. If anyone nom @Moya/contributors who has experience could take a look, I would be very grateful :bow: 
 @swizzlr Do you still use CodeCov? Is this anything you've seen before? 
  Maybe we should remove it from continuous integration until it's working again? 
 Huh! When I get a chance, I'll take a look at Xcode's code coverage and see what it thinks. We might need to close this and open an "increase code coverage" issue üòâ 
 Have you been able to have a look at this, @ashfurrow?
 I have not, would anyone be able to take a look? 
 Xcode itself reports 0% (as it checks the demo itself, not the library)... or am I overlooking something?

<img width="1512" alt="screen shot 2016-08-26 at 14 31 42" src="https://cloud.githubusercontent.com/assets/4190298/18005381/e6aacd90-6b99-11e6-8581-766d1fdbfa3a.png">
 Ah great, thanks. The overall coverage reported by Xcode is 80% (see attached)

<img width="1680" alt="coverage1" src="https://cloud.githubusercontent.com/assets/4190298/18006575/74644958-6ba0-11e6-8426-0610ab22a571.png">
<img width="1680" alt="coverage2" src="https://cloud.githubusercontent.com/assets/4190298/18006576/75c4e8fc-6ba0-11e6-81d2-d0e86270dccf.png">
 Thanks for looking into that! 80% is a far cry from the 66% CodeCov is reporting, looks like there may be a config issue. Anyone familiar with this? 
 Not familiar with CodeCov, but the algorithms to get a percentage might be different, explaining the difference. But the gap would still be pretty big...
 Coverage reported by CodeCov is back to 79%. Closing this for now.
  Goodness, lots in here. SwiftLint us run with Danger on ever pull request we get. This is good, but there are a few problems:
- SwiftLint yielded lots of problems, which are now fixed.
- SwiftLint is run multiple times (see [this issue](https://github.com/ashfurrow/danger-swiftlint/issues/16)). So I updated the plugin to just run once, but on all files. This is fine as long as we don't merge warnings.
- SwiftLint was complaining about `Moya.swift` being over 400 lines of code long. Yikes. I split it out into multiple files.
- Updated Carthage's `Moya.xcodeproj` to reflect new files.
- Added a Danger failure for added/deleted library files without a change to the Carthage Xcode project. Fixes #270.
- Changelog for all this, and fixed formatting for a previous entry.
 Going to rebuild so Danger runs. 
 Cool, pushed the update to the Dangerfile, and no warnings! So that's nice. 
 üçè 
 üö¢ 
  Loosely related to #559.

WIP because GitHub is choosing not to render the `svg` tag.
 @orta suggestions for the best way to display these colours? This is what I'm going for:

<img width="296" alt="screen shot 2016-07-23 at 1 56 36 pm" src="https://cloud.githubusercontent.com/assets/498212/17080254/4e980ae4-50dd-11e6-869f-22f44506a6ed.png">
 My only known hack here doesn't work http://www.tizag.com/htmlT/bgcolor.php - https://gist.github.com/orta/62febeb573df8e52965a5af7ddf5ba17
 Images are the best way to go
 though the purple is massive, and the rest are the right sized, would recommend throwng in image optim too 
 Okay, I think this is ready for review üëç 
 Better fix all them swiftlintsssssssssssssssssssss
 Yup, working on it now. It's also running more than once. 
 but nah, everything looks good from me.

One option for improvement though. You could do all the images at 2x size, then set the width/height to be half that. Then you have retina images. This is how I do it in most of my web projects.

![screen shot 2016-07-23 at 9 29 03 pm](https://cloud.githubusercontent.com/assets/49038/17081196/806b3bd8-511c-11e6-93ae-7aed9f55160d.png)

with 

![screen shot 2016-07-23 at 9 28 23 pm](https://cloud.githubusercontent.com/assets/49038/17081193/7403bd66-511c-11e6-8a75-a926eec73061.png)

instead of this at full size:

![screen shot 2016-07-23 at 9 29 28 pm](https://cloud.githubusercontent.com/assets/49038/17081198/8baf4106-511c-11e6-8b24-24333da25541.png)

which is massive, but scaled inline here
 okaaaaay
 It's a free TIL ;)
 Yep - that should do it
 I've opened https://github.com/Moya/Moya/pull/561 to address the SwiftLint problems. 
  Moya's gotten pretty big, I reckon it's time we get some stickers üéâ There are a few aspects to this issue:
- [x] Pick a sticker medium (probably through [stickermule](https://www.stickermule.com)). Thinking a single-colour [transfer sticker](https://www.stickermule.com/products/transfer-stickers) would be the coolest
- [x] Make a sticker design based on the chosen medium ‚òùÔ∏è.
- [x] Figure out how to collect addresses for contributors to mail them stickers
- [x] Order the stickers.
- [x] Mail them out.

This is a long-term ticket, I'm thinking we'll try to get it wrapped up sometime before the end of 2016.
 I totally understand going with single-colour but oh boy; i'm going to miss the colors üòâ 
 Yeah, I'm leaning more and more towards the colours too üòÑ 
 IMO, think the colours too - can work with https://www.stickermule.com/products/clear-stickers 
Moya logo has too thin lines to pull off the ones CP/Artsy use 
 Agreed, I think either the clear ones or maybe the [square ones](https://www.stickermule.com/products/square-stickers) could work. I think the square ones would go well if we used the GitHub avatar rather than the entire logo:

![](https://raw.githubusercontent.com/Moya/Moya/master/web/logo_square.png)

I'm not sure which one, either that or the actual logo would be more recognizable:

![](https://raw.githubusercontent.com/Moya/Moya/master/web/logo_github.png)
 Agree re:square

Re: full logo might want type e.g.

![screen shot 2016-07-23 at 11 48 54 pm](https://cloud.githubusercontent.com/assets/49038/17081683/0ab56b34-5130-11e6-8215-b5aefe19bd75.png)

specifically done bad on purpose to not think of design 

---

I'm voting square if clear
 It's like "lorem ipsum" but for visual design üòÜ 

Cool. Okay, maybe a straw poll? Vote by reacting to this comment on if you think a square logo or a full logo would be more recognizable in sticker format.

| Square Logo | Full Logo |
| --- | --- |
| üéâ | ‚ù§Ô∏è |
 Cool, calling it: square logo. Which means the design is finished :tada:

I'll take care of ordering them, the tricky bit is figuring out how to collect addresses. @orta you have experience with this. Google Forms? 
 I used a shared google spreadsheet, but forms can work too üëç ( sheets made it easier to me to ask for edits etc )
 Stickers arrived: 

![ashfurrow_2016-aug-10](https://cloud.githubusercontent.com/assets/498212/17555701/87c18796-5ede-11e6-93c7-285678ed2d4a.jpg)

(Pen included for size comparison, they're 3.5cm squared.)
 The US-bound stickers are already in the mail, the international post should be going out this week. Thanks for your patience! 
 Mine arrived today!

> On Oct 12, 2016, at 3:04 PM, Ash Furrow notifications@github.com wrote:
> 
> The US-bound stickers are already in the mail, the international post should be going out this week. Thanks for your patience!
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub https://github.com/Moya/Moya/issues/559#issuecomment-253338744, or mute the thread https://github.com/notifications/unsubscribe-auth/AABrsnzlYVI99otwRW3t2kTRoPiWHp8tks5qzUtdgaJpZM4JTZGx.
 Hi @ashfurrow do you reckon I still have time to update my address?

The current address is `SoundCloud` but attention to ¬´Pedro Pi√±era¬ª because I didn't know if I was going to be in üá©üá™ by the time the stickers would arrive.

If its too much hassle I won't update, was just wondering
 @esttorhe Aye, I've addressed it to Berlin, but if you're not there anymore I can change it. 

If anyone else has address updates, please send the updated address to ash@ashfurrow.com . Thanks!
 Thanks @ashfurrow.
I'm in Berlin now actually. I just didn't want to bother Pedro now that I can actually get it myself üòä

But like I said. No biggie

‚Äì
Esteban Torres
CraftKollective (http://craftkollective.com) Co-Founder

Phone: (+506)8813-0934 (tel:(+506)8813-0934)
Skype: esteban.a.torres.hernandez
Twitter: @esttorhe (https://twitter.com/esttorhe)

On 12 Oct 2016, 23:20 +0200, Ash Furrow notifications@github.com, wrote:

> @esttorhe (https://github.com/esttorhe) Aye, I've addressed it to Berlin, but if you're not there anymore I can change it.
> 
> If anyone else has address updates, please send the updated address to ash@ashfurrow.com (mailto:ash@ashfurrow.com) . Thanks!
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub (https://github.com/Moya/Moya/issues/559#issuecomment-253342931), or mute the thread (https://github.com/notifications/unsubscribe-auth/AChTonfydJwuZiujIkPUgC3n9kdDmSz_ks5qzU8pgaJpZM4JTZGx).
 Alright, I've sent these all out, let me know if you don't get them. Thanks again for everyone's work in making Moya such a successful community project, I'm incredibly proud of what we've built together.
 Thank _you_, Ash!
 Exactly, thank _you_ Ash & @orta for starting this amazing journey üëè
  What's your setup like, CocoaPods or Carthage? What Xcode and Moya version are you using?
 Hmm, I haven't been installing Moya with CocoaPods 0.39 for a while. Can you post the relevant parts of your Podfile? I can take a look at it later tonight if someone hasn't chimed in by then. 
 @jcampbell05 I'm going to close the issue, if this is causing problems, feel free to reopen üëç
  Thanks! üôå
  Hmm, this is an interesting question. There's no reason we can't/shouldn't do this, it's just never been a priority before, so it's definitely worth considering. I'm thinking we abstract the functions we call from Alamofire into protocols, and extend Alamofire types to conform to those protocols. Then we just need a way to specify a different set of types that also conform.

There's a bit of hassle where we're currently using `typealias` to create Moya-specific types from Alamofire ones (for things like request methods, GET, POST, etc) that would need a little bit more code, but nothing too dramatic. 

I've got a flight tomorrow, might take a stab at this on the plane. In the meantime, you could explore subclassing Moya's `Provider` class to give you similar behaviour. Please let us know if you have ideas for implementation, too. 
 I forgot about that, thanks!
 I took an initial stab at this, it's quite an overwhelming change. We actually lean on Alamofire a lot, include use of `typealias` to create Moya types that are really just Alamofire types. If we do this, I would want someone to be able to theoretically use Moya without having any reference to Alamofire code at all.

@jasl how up-to-date is your fork? Moya has added multipart form uploading and a few other large structural changes recently, would it work with those changes? 
 Okay, thanks for the quick response!

I tried to tackle this from top-down, like replacing our references to `Alamofire.Manager` with a new protocol defined in Moya, but _everything_ broke immediately, and I was no where near finished an hour later. I think a better approach would be to remove the `typealias`s in `Moya+Alamofire.swift` first, then replace use of `Manager` with a new protocol. I'll see what I can do later. 
 I tried abstracting Alamofire and found Moya to be too tightly coupled to it to reasonably separate. This is probably because we've always built Moya on top of Alamofire, the de facto standard networking library on iOS. This is a reasonable hard dependency from my perspective, but as always, it's open for discussion. If anyone would like to send a pull request with this specific feature, I'd be happy to look it over :+1: In the mean time, we can keep this issue open in case others have ideas or suggestions.
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks. Thanks for the kind words, @SD10, and good luck with Nora. :)  The code is repeated because the app target is specific against iOS, but the three testing targets are specific to iOS, tvOS, and macOS. They all use the same files, but can't link against the app target because it's only iOS. Does that make sense? 
 It's a good question, thanks for opening an issue üëç
  This has been in a few builds, but support for unscoped vars is going away soon.
  Awesome thanks! Ignore the SwiftLint errors, we're having problems with it on CI. I can review the code shortly üëç
 Cool, I feel like this is good to merge. @leonereveel @colinta you two wrote the original multipart upload code, how does this look to you? Shame we'll have two major versions in quick succession, but I think it's worth it. 
 Yeah, same here üòÑ Okay, gonna wait for others to have input, otherwise I think we're good to merge!
 Fab, gonna merge!
  Yeah, seems likely. We've run into problems in the past on our Demo app (`import`ing more than one version of Moya). You're using Carthage, eh?
 Well, CocoaPods will include all the specified subspecs in one module, named `Moya`. So if you have `pod 'Moya/RxSwift`, that will pull all the RxSwift Moya files _and_ the regular Moya files into one module. Carthage doesn't have an equivalent of subspecs (they're stance is that you should use multiple frameworks instead ‚Äì which we considered but decided against).

_Maybe_ you could do something like

``` swift
typealias TargetType = RxMoya.TargetType
```

And then you wouldn't see `RxMoya.`?
 That's odd. Hmm. @Moya/contributors Anyone else seeing build errors with Carthage?
 Yup! I did delete the pre & post build scripts in that PR üëç
On Wed, Oct 19, 2016 at 8:07 PM Pierre-Marc Airoldi <
notifications@github.com> wrote:

> I think this has been addressed by #563
> https://github.com/Moya/Moya/pull/563
> 
> ‚Äî
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/Moya/Moya/issues/551#issuecomment-254997633, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ADo1dE0LBtCwBJZ6lpO2x2Cxj99HFd7Zks5q1trQgaJpZM4JNqy5
> .
  Looks good! Much nicer. The SwiftLint warnings above are strange, since you didn't modify _any_ of the files it's complaining about. I'll fix that separately, gonna merge!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  When you get this error, the next step is usually to specify the return type explicitly. Looking at the Moya source code, you can change your line to the following:

``` swift
let requestClosure = { (endpoint: Moya.Endpoint<ICanHazProvider>, done: Result<NSURLRequest, Moya.Error> -> Void) -> Void in
```

Let us know how it goes!
 Yup, taking a look now. I've not seen this before, things are working for me with the latest `master` branch with Xcode 7.3.1. Have you run `pod install` in the Demo directory? What version of CocoaPods are you using?
 @bryanbartow I think the second example might be getting confused with the `nil`s used as parameters (they're non-optional, just remove them and they'll fallback to the defaults). But that doesn't explain the first error. 

I'm really at a loss on that one. Would it be possible to share a small Xcode project demonstrating the problem? It would help figure out what the problem is. 
 Awesome! So that works? Where do you think we should document this? 
 @bryanbartow your problem might be returning the `Result` type in the closure that takes `Void` as a return type. Below code works under Xcode 7.3.1 & Moya 7.0.0:

``` swift
let requestClosure = { (endpoint: Moya.Endpoint<ICanHazProvider>, done: MoyaProvider.RequestResultClosure) in
    let request = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest

    done(.Success(request))
}
```

@kamil-tomaszewski: @ashfurrow is right, when you specify `nil` in the rest of the parameters, Xcode throws not-so-specific error. When you remove the parameters with `nil` it should be good with the code below:

``` swift
let endpointClosure = { (target: GitHub) -> Endpoint<GitHub> in
    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
    let endpoint: Endpoint<GitHub> = Endpoint<GitHub>(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
    return endpoint.endpointByAddingHTTPHeaderFields(["APP_NAME": "MY_AWESOME_APP"])
}
```

About @dccarmo issue I'm kinda lost as well ¬Ø_(„ÉÑ)_/¬Ø Might try omitting the `Result` type in `done` callback, like `done(.Success(result))` and try if it works? Otherwise could you provide us an example project where the issue exists? Would be really helpful.
 @bryanbartow Yeah, we've had issues before when using multiple `Result` identifiers. You can use modules names to namespace the specific `Result` type, like `Result.Result` or `MyLibrary.Result`, it can get tricky. Let us know how it goes :+1: 
 @kamil-tomaszewski It could be that in the original code, you had `let endpointClosure: MoyaProvider.EndpointClosure` without specifying the generic type of `MoyaProvider` and it confused the type system? Try `let endpointClosure: MoyaProvider<GitHub>.EndpointClosure` and see what happens. (It works if you don't specify anything because the compiler can infer from the closure signature what `MoyaProvider`'s generic type is.)
 It seems the issue here has been solved, so I guess this issue can be closed, right?
  We forgot to add a changelog entry for #483, this change now fails a build if library source code has changed without a changelog entry. This means that refactors that don't change user functionality will need to be included, too. I'm okay with that, refactors might introduce bugs and changelog entries could really help someone. 

@colinta Any thoughts on this?

Fixes #546.
 An expanded message is a good idea üëç 
 Empty Moya message is a known issue: https://github.com/ashfurrow/danger-swiftlint/issues/10

@colinta does that message look good? 
 Yep
  Hmm, I see. This is when building with Carthage or CocoaPods. In CocoaPods, I can see Moya maybe having 10.9 as a minimum deployment target, with the RxSwift subspec having 10.10. Not sure if we can selectively allow 10.9 with Carthage.
 Can't we just set the RxMoya targets to 10.10?
 Not sure what's best here, @justinmakaila I'll defer to you on this one.
 Cool, #553 has breaking changes anyway, so we can merge this without worrying about semver. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 @ashfurrow @sendyhalim Sorry guys, I got hung up with work. I tried my proposed solution above and it didn't seem like it worked; glad this got merged in and is good to go for all our `RxMoya` users... now we gotta figure out how to make it so you don't have to download unnecessary dependencies ;)
  Hmm, looks like an oversight. Want to send a pull request with the added entry? 
 It might be worth adding Danger's CHANGELOG as a fail back, even in this case it was missed, but the fail was legit:

<img width="788" alt="screen shot 2016-07-14 at 12 31 38" src="https://cloud.githubusercontent.com/assets/49038/16847420/0029f360-49bf-11e6-8d77-00d9f238e5ba.png">
 I think we would have noticed the danger message if it had run, but something went wrong on that build:

<img width="659" alt="screen shot 2016-07-14 at 12 36 13 pm" src="https://cloud.githubusercontent.com/assets/498212/16847560/a5d62ee6-49bf-11e6-9814-47a41b74ff62.png">

Which is on me, I should have re-run the build or fixed Danger. I think that pull request had just taken so long to get tot hat point, I was too impatient to merge. 
 I took that image from the PR: https://github.com/Moya/Moya/pull/483#issuecomment-230908591 - it must have got fixed on a rebase or something
 Yeah, what I mean is that if Danger had had a chance to run and fail due to a missing changelog, the human merging (me) should have asked for one. But because I ignored the Danger failure (because it wasn't working), I also ignored the previous comment Danger had made about this missing changelog. I guess I assumed it had been added at some point. 

I agree we should probably re-think how we treat missing changelog entries. What sort of heuristic do you reckon should we use? 
- Any swift files changed?
- A certain number of .swift lines added/removed/changed?
 Ah, yeah, on Danger we [check for any](https://github.com/danger/danger/blob/master/Dangerfile#L4-L5) lib files:

``` ruby
has_app_changes = !git.modified_files.grep(/lib/).empty?
has_test_changes = !git.modified_files.grep(/spec/).empty?
```

You could do the same for `Source` and `Demo/Tests`:

``` ruby
has_app_changes = !git.modified_files.grep(/Source/).empty?
has_test_changes = !git.modified_files.grep(/Demo\/Tests/).empty?
```

_\* disclaimer, I'm not great with regexes_
 Sounds good. I'll send a PR, thanks for bringing this up again Orta. 
  What you've got is actually how things are done, except broken into several lines. [Here's an example](https://github.com/artsy/eidolon/blob/70b59b1cfd0c68730b6a2860fabeb8cbaca2acca/Kiosk/App/Networking/ArtsyAPI.swift#L112) of using it. 
 Cool! Please consider submitting a PR to the readme to add it :+1:
  Weird, I'll check if danger has had any issues like that reported. @orta seen this?
 Looks like it's already been reported: https://github.com/danger/danger/issues/316 Issue involves how Danger determines which commit the PR is made from. Going to merge.
  This looks great, going to merge. @colinta thanks for your really rapid response time and quality code!

Just realized that now that #537 is merged, we'll continue to get code coverage reports on builds without changelog entires üëç 
  Moya only supports progress notifications while uploading a file, not for regular requests (thought Alamofire _does_ support this, so it shouldn't be too difficult to add this to Moya. I'm a little surprised that Moya doesn't already support this, to be honest, it's something we should consider adding. Could you tell us more about how you'd expect this to work?
 @colinta aye, could be worth factoring a bit out. If we can be backwards compatible, that's great, but we're about to have a major release with other breaking changes, so we could roll this feature into that release. 
 @alexdoloz yup, that makes sense! The trailing closure syntax is preserved that code.
 @alexdoloz now that #543 is merged, this should work if you use the latest version of Moya, on the master branch. If you're using CocoaPods, you can change the Podfile to include `pod 'Moya', git: 'https://github.com/Moya/Moya.git'` and do a `pod update` and it should work. Let us know!
 Ah, okay! No rush. 
 I think this was closed by #543, re-open if not. 
 Can you open another issue about the -1 bytes expected? Link back here for context üëç 

I think the bytes expected comes from Alamofire, and ultimately the server. It may be that -1 is what ALamofire provides when there is no expected number of bytes available, which might could from the server. Not sure, though.
 @alexdoloz I'm glad you got it figured out!
  This is a great question I looked through my own code, because this is something I've had to test to. The [code](https://github.com/artsy/eidolon/blob/fdd5981005b1c631d284f89f9a2d7bb808437e0d/KioskTests/ListingsViewModelTests.swift#L163) I found is a little old and doesn't apply directly to this question. 

So the way I would approach this fresh is that you don't necessarily need the state to be internal to the testing provider. When you create a provider in your tests, you can pass in an `endpointClosure` that accesses an `isFirstResponse` variable defined outside the closure, within the test. Set it to `true` before the test begins and the first time the `enpointClosure` is called, set it to `false`. Not sure what testing framework you're using ‚Äì if you provide the code that you've tried so far, I can give you an idea of how I would approach it.

Moya's architecture places a large emphasis on testing, but most of our documentation discusses only how to use Moya in production code. I think it's worth adding documentation demonstrating best practices and common techniques when using Moya with testing. @fruitcoder if you have any ideas on what could be included, let us know üëç 
 Sounds like you might be talking about this issue: https://github.com/Moya/Moya/issues/56 That's actually our _oldest_ open issue, something we've wanted for a while üòÑ 

So I think testing examples/demos should include things like the following:
- How to create a provider that always stubs (a "Hello, World" for testing with Moya).
- How to verify that a specific request was actually performed.
- How to verify that two different requests were actually made.
- How to return a different status code than 200.
- How to return different response data depending on parameters of the request.
- How to handle errors returned from a `requestClosure` (like an OAuth error).
- How to return different response data depending on how many times it's already been invoked (an example of polling for a specific response).

It could be really cool to include both a short code snippet showing the technique and also a link to an open source project that actually uses that technique. I can find Artsy examples once we have a list of everything we want to demonstrate. @fruitcoder any techniques you think we should add to this list?
 Cool üëç New issue sounds like a good idea, link back to this one, maybe copy over the list too. I think the new docs around testing should go in a new markdown file called Testing.md, if you're keen to to help out a pull request would be welcome!
 I've opened https://github.com/Moya/Moya/issues/632 to address improves to the documentation, going to close this, feel free to re-open. 
  What's the `carthage` command you're running that's producing the error? 
 We've seen [other issues](https://github.com/Moya/Moya/issues/445) with Carthage that were solved by running `carthage update --platform iOS --no-use-binaries` instead. Can you try that and see if it works? If that's the fix, we should add it to our readme. 
 I'm not sure then, I don't use Carthage so I'm not the best to help out with troubleshooting. 
  PR authors should be reminded of changelog entries, but missing entries shouldn't fail the CI build.
 Sure, seems fine with me üëç 
  Related to #534. Tested in local repo and got through `carthage update` no problem.
 Looks like it was checked in here, in October 2015: https://github.com/Moya/Moya/commit/9ee73026ba8e2bf4394de7d795ba42b778b3fea7#diff-8903239df476d7401cf9e76af0252622 so the problem this PR solves has been around since about [version 4.1.0](https://github.com/Moya/Moya/blob/master/Changelog.md#410) of Moya. @justinmakaila Do you think this is something worth including in the changelog? Like, would it be useful for Carthage users to have a note in there about it? 
 @ashfurrow I don't think so, everything looks fine for downloading the build with carthage with and without submodules. I think it made it in as a mistake and became a problem somewhere between then and now as `Carthage` progressed.

**EDIT**:
With the `Carthage/Checkouts` directory present, `Carthage` was able to pull the repos from that directory, which would come down with the `git clone` operation. When we pulled it in between now and the last tag, the `.gitmodules` file pointing to nothing in particular started causing problems while `Carthage` was trying to establish dependencies.
 Okay cool. The only CI failure is a missing changelog, so I'm going to merge (and then submit a PR changing that "no changelog" error to a warning...)
 > Okay cool. The only CI failure is a missing changelog, so I'm going to merge (and then submit a PR changing that "no changelog" error to a warning...)

Might want to check for App-level changes before failing instead
 Hmm, good idea. I added the error originally to help us be more diligent about our changelog entries. I still worry that if we keep the error, we might intimidate new contributors with a failed CI build instead of a warning. And longtime contributors are [even getting called out](https://github.com/Moya/Moya/pull/530#issuecomment-231434087). Going to move discussion over to https://github.com/Moya/Moya/pull/537
  I think this is a good idea, I don't see any other issues tagged "breaking changes", but we need to cleanup those issue tags anyway üòÅ 

I'll give some time for other @Moya/contributors to chime in, and if no one objects, we'll release Moya 7.0.0 üéâ
 We _might_ have a non-backwards-compatible feature request worth squeezing in: https://github.com/Moya/Moya/issues/542 I believe @colinta is taking a look, I can help too.
 Cool, I think we're good?
 Okay! That's tagged and pushed to CocoaPods, Carthage folk have their GitHub release, too: https://github.com/Moya/Moya/releases/tag/7.0.0

Thanks for the help all our contributors have put in to getting us to Moya's _seventh_ major release in two years!
  Thanks for the PR! Don't mind the SwiftLint warnings. 

CI is failing due to a problem finding the `isCancelled` property ‚Äì you said it's working for you locally? I can try and take a look here too. 
 I agree, sound good üëç 
 Mergin'!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Reported in https://github.com/Moya/Moya/pull/530#issuecomment-231418477 , we should consistently calling the failure block when cancel. 
  Looks üíØ Sorry for radio silence on the other PR, on vacation this week. This looks good to merge when you're ready, I'll review the comments on the other tomorrow. 
 Agreed, that's surprising behaviour. I'll open a separate issue to fix that, this looks great to merge. 
  Yup, we have them there for Circle. Is the Demo project used by Carthage for building? (We really do need better documentation around it, every time someone has a question related to Carthage, I'm a bit at a loss). 

Can any Carthage-savvy devs on @Moya/contributors help take a look? 
 Glad it's working!
  A request with duplicated parameter keys? I've never seen a server require those before, since query string parameters are usually referenced as a dictionary, and can't handle duplicate keys. I have seen arrays specified as `?filter[]=a&filter[]=b`, is that what you're looking for?

It's possible to get around this by doing your own custom parameter encoding (since we rely on Alamofire's, which has this limitation of treating params as a dictionary). Here's [an example of using custom parameter encoding](https://github.com/Moya/Moya/blob/38b0bda890b7b4598552a353b3f8db4248c37d6e/docs/Examples/ArrayAsRootContainer.md) that you should be able to modify for your server requirements. Let us know how it goes.
 I'm glad ‚Äì I think if you just pass the array as a a parameter, it should "just work." Alamofire detects arrays and uses that query string format. 
  @AndrewSB would you mind adding an entry to the `Changelog` ? üòÑ 
 Looks good and test are passing ‚úÖ 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 I'll need some time to get used to the ü§ñAsh from posting as soon as I hit the merge button üòõ 
 It worked! https://github.com/Moya/Aeryn
  It's possible; how are you building the project that's not working? Any details around Xcode version etc would be awesome too. 
 I wonder if the Xcodeproj needs updating?
 No problem, thanks! First, if this is blocking your project, you should be able to use our most recent release. But as far as fixing master, hmm. The `Moya-iOS` Xcode project was added by @JRHeaton for Carthage compatibility. I can't remember the mechanism for updating it ‚Äì it doesn't look like it's from the release task, but I'm not sure if it's generated by CocoaPods either. I'll take a peak and see. @AndrewSB have you seen this before on other Carthage projects? Any tips for troubleshooting? 
 Looking at #505 it does look like `NetworkCurlLoggerPlugin.swift` was added to the project file, but not to the repo, probably by accident. Removing those lines [added to the project](https://github.com/Moya/Moya/pull/505/files#diff-a24d686152f5e86f361b118f3c399d22) should fix it. @AndrewSB are you able to test + send a pull request?
  To encourage better testing strategies üëç 
 @AsimNet Worst case:

```
var sampleData: NSData {
  return NSData()
}
```

...But as @orta said, mostly for testing. You don't realize how great it is until you start writing your tests.
  I released [the gem](https://github.com/ashfurrow/danger-swiftlint) so we don't need to refer to it by repo URL anymore. This does the same for Danger.
  Hey @tdouglas1313. There is a conversation in #513 about Swift 2.3 and 3.0 support. However, there is no PR with updates for any of versions _yet_. 
 Good suggestion! I've changed the title, thanks! I think in this case I can close this one in favor of #513.
   ![11401351_10205530165906879_6807594257863400673_n](https://cloud.githubusercontent.com/assets/49038/16508623/b3c41936-3f02-11e6-8b19-35e84b63fd59.jpg)
 Hmm, getting this again:

> Not a Pull Request - skipping `danger` run

I'll take a poke. 
 Looks like https://github.com/danger/danger/issues/226
 Appears to be a problem with Circle where they don't specify a `CI_PULL_REQUEST` environment variable even though this _is_ a PR build. As per [their discussion on this](https://discuss.circleci.com/t/ci-pull-request-no-longer-when-building-a-pr/4191/8), I've contacted support to get this figured out.
 Weird, printing the [four required variables](https://github.com/danger/danger/blob/f895ac3be3c1fc2c30062d2ca71598f076a3e0b9/lib/danger/ci_source/circle.rb#L9-L12) after setting one explicitly works:

``` rb
puts ENV["CIRCLE_BUILD_NUM"]
puts ENV["CI_PULL_REQUEST"]
puts ENV["CIRCLE_PROJECT_USERNAME"]
puts ENV["CIRCLE_PROJECT_REPONAME"]
```

```
249
https://api.github.com/repos/Moya/Moya/pulls/521
Moya
Moya
```

Not really sure where to go next. It might require more digging around in Danger to figure out why this isn't working. 
 @at-daonv thanks for the tip! I"ve added something similar to the Rakefile.
 Ooohhhhh boy would you look at that?!
 You probably want this too,

```
# Make a note about contributors not in the organization
octo_client = env.request_source.client
unless octo_client.organization_member?('moya', pr_author)
  message "@#{pr_author} is not a contributor yet, would you like to join the Moya org?"

  if modified_files.include?("*.podspec")
    warn "External contributor has edited the Podspec"
  end
end

```
 This looks **AMAZING**
 @orta good idea, I was actually going to play around with [squad_goals](https://github.com/benbalter/squad_goals), maybe make a Danger plugin. For now I think we can merge without it, and add it in if squad_goals takes too long. 
  Most importantly, this fixes the broken CI we've had for a while. It also updates the version of CocoaPods that we're using to 1.0 and adds a Rake task to make doing a `pod install` locally easier (makes it easier to develop Moya!).

So what about those tests? Why were they broken? 

Good question. This is a timing issue related to testing request cancellation in the _integration_ tests, which are only meant to test that the provider actually hits the network. I moved the test into the regular provider tests and specified an explicit timeout to avoid timing problems. Fingers crossed for this PR.

Fixes #498.
 Yikes, [all Travis OS X builds are currently delayed](https://www.traviscistatus.com/incidents/rqb906yypnk0), might take a while to see this üçè 
 ```
[!] Unable to satisfy the following requirements:
- `ReactiveCocoa (= 4.2.1)` required by `Podfile.lock`
- `ReactiveCocoa (~> 4)` required by `Moya/ReactiveCocoa (6.5.0)`
```

Been seeing this only on Travis. `bundle exec pod install` doesn't change any files locally. Might be the misuse of `~>`. Gonna poke around.
  Super, thanks! Don't worry about the üî¥ Travis result, it's being fixed in #520.
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  You should be able to just have `"somethingBool": data4` as an element in the returned dictionary, right? 
 Thanks for the follow-up. How are you detecting the value, on the server side or client side? Could you try using the [network activity plugin](https://github.com/Moya/Moya/blob/master/docs/Plugins.md#network-activity-indicator) to log the request before it's sent? 
 @lucasp90 That's certainly puzzling! Especially since Moya gets Alamofire to do the parameter encoding, and I would have thought they would support Bool.
 @jasl Good thinking linking to that. It seems to [fallback to String interpretation](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L198) of plain objects, so `Bool` should work, right? 
 I dunno, I think that if Alamofire is parsing `Bool` as "true" or "false" it must be a good approach. These [Wordpress docs](https://codex.wordpress.org/How_to_Pass_Tag_Parameters#Bool) explicitly say that either is acceptable for them.
 @lucasp90 has this been clarified to your satisfaction? 
 No problem! I think adding examples would be a great idea, where do you think they should go? https://github.com/Moya/Moya/blob/master/docs/Targets.md maybe? 
 Cool! Could I ask you to send a pull request? Don't worry if you can't, we'll get it :+1: 
 Closing this as it looks like it's been resolved üòÑ thanks for contributing the README again, @lucasp90!
  @matteogazzato It's going to depend on your backend. Some can just take raw image blobs, some need it encoded a certain way, blah blah blah.

If you just want to put the raw data in the dictionary, you can do so using `UIImageJPEGRepresentation(_:)` or `UIImagePNGRepresentation(_:)`, as per [the docs](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKitFunctionReference/index.html#//apple_ref/c/func/UIImagePNGRepresentation).

If you want to use multipart, check out the open PRs, specifically #441 and #483.

Let me know if you have any questions!
 Glad you got it working ‚Äì are we okay to close this @matteogazzato?
  Yikes, I hadn't heard that. Can't remember why we used spin locks, we can probably move to `NSLock` without too much fuss. Anyone up for a pull request? 
  Awesome! Looks good to me, want to add links to the new files from the readmes in the docs/ and docs/Examples directories? Good to merge after that üëç 
 @wattson12 I added some links and syntax to your markdown: https://github.com/wattson12/Moya/pull/1
 Fab!
  This is great work and a nice comprehensive write-up, thanks @aaroncrespo!
 Sorry about the accidental closure. Misunderstood what 'Close' meant in a third-party GitHub client. Was just trying to close the issue view. üò≥ 
 No problem, it happens!
 I've changed the title due to #522 discussion.
 Aye, think it's worth shipping a 2.3 dupe of current Moya, one the Rx deps have them, then moving to 3.0
 That makes sense ‚Äì should we make 2.3 version off of `master` or the most recent commit? (master has breaking changes.)
 Maybe the last stable release?
 We will have to wait before updating to the GM Seed version:
- [x] [RxSwift#869](https://github.com/ReactiveX/RxSwift/pull/869)
- [x] [Result](https://github.com/antitypical/Result) update

**Edit:** I've opened #608 for Swift 3.0 support.
 @sunshinejr It seems Result already is Swift 3. :)
 This looks like it's been solved with the 8.0.0 beta releases, I'm going to close it out. Please feel free to open this if there are any loose ends!
  Related to https://github.com/Moya/contributors/pull/7

Remaining items:
- [ ] We should probably refer to this document from the readme. 
 Feels good, will try and look at the README thing on the plane
 OK, v2 is ready
  @dropski I would humbly encourage you to close the issue, because I've seen lots of open-source projects where there are tons of issues still open, only because the maintainers can't tell if the person who opened the issue is "happy" with the results.  It's a good way to keep things tidy!
  Just one, for sure!  Here's how we do it in the Ello app:

###### ElloProvider.swift

``` swift
    public static func endpointClosure(target: ElloAPI) -> Endpoint<ElloAPI> {
        let sampleResponseClosure = { return EndpointSampleResponse.NetworkResponse(200, target.sampleData) }

        let method = target.method
        let parameters = target.parameters
        let endpoint = Endpoint<ElloAPI>(URL: url(target), sampleResponseClosure: sampleResponseClosure, method: method, parameters: parameters, parameterEncoding: target.encoding)
        return endpoint.endpointByAddingHTTPHeaderFields(target.headers())
    }
```

###### ElloAPI.swift

``` swift
    public func headers() -> [String: String] {
        var assigned: [String: String] = ["Accept": "application/json", "Accept-Language": "", "Content-Type": "application/json"]

        if self.requiresAnyToken {
            assigned += [
                "Authorization": AuthToken().tokenWithBearer ?? "",
            ]
        }
```
 [ElloProvider L32](https://github.com/ello/ello-ios/blob/master/Sources/Networking/ElloProvider.swift#L32)

[ElloApi L455](https://github.com/ello/ello-ios/blob/master/Sources/Networking/ElloAPI.swift#L455)
 I'm going to close this issue. @mrfarukturgut, feel free to open it again if you still have questions!
  Neat, thanks! üéâ Build failure is not connected with the PR so I'm gonna merge it. üêº 
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hey @Miasma87! What I think @petester42 meant, was to extend your `TargetType` to have 2 cases:
- First one for getting one genre from API:

``` swift
case Genre(String)
```
- Second one for getting more than one (or to be precise, 0 or more) genres using array of strings:

``` swift
case Genres([String])
```

But it depends if your API has an endpoint for getting more than one genre at a time. If not, I'm afraid Moya does not have built-in solution for that. Actually, it would be really tricky, because what happens if one request succeeds and one does not? We would need an array of result responses/errors or any other solution to handle this.

But what comes to my mind is that you could create an asynchronous queue and handle this by yourself. Or use reactive extensions for Moya, which would make that task significantly cleaner.

Hope it helps! üêº 
 Have you been able to fix this, @Miasma87?
 Do you have an update on this, @VivienGiraud? :) No worries, thanks for the update nonetheless! Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Looks awesome!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Nice, thanks!
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hmm, not easily, though you could use the `StructTarget` to use a `struct` instead of an `enum` for your `MoyaTarget`. I'm not aware of anyone doing this, if you find anything online that helps, please let us know üôá 
 You may want to consider generating the Moya source code from your API similar to this: https://github.com/lkuczborski/SwiftMoyaCodeGenerator - you can't really get the advantages of Moya without their being defined types in code 
 @wonc003 did you manage a solution for this issue? Would love to have it added to our documentation üëç
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Can't tell without more information, like what it looks like when you request the API call. Also, not sure of the `func sendRequest` and `public func request`, are those from Moya or a subclass you've created? Thanks!
 Going to close this @kyleYang. Feel free to open a new issue if you still have a question. @robertofrontado can you post your code where you're getting this issue? Also, what version of Moya are you using?  Hey @iDiyor, thanks for opening an issue! :tada: 

Moya uses Alamofire's [parameter encoding](https://github.com/Alamofire/Alamofire#parameter-encoding) which has URLEncodedInURL case, which I believe you can use in your case. üòé

Hope it helps! 
  Not to belabor the point, but there is a lot wrong with parsing the body of a GET request. Here's a great explanation: http://stackoverflow.com/a/983458

> On Jun 13, 2016, at 7:53 PM, Sebastian Bean notifications@github.com wrote:
> 
> GET is meant as simply a request to a URL. Thus URL encoding is the only real thing that makese sense.
> 
> I'd try switching over to POST.
> 
> ‚Äï
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub, or mute the thread.
 I think we can close this one, but if you will have any more questions @awclives about this topic, let us know! üêº 
  Good catch! Can you also make the same update to `ReactiveCocoa.md`?
 Awesome, thanks!
  Hey @iSame7, thanks so much for the idea! üéâ  Seems really fun! 

Although _I'm not sure_ if it would fit in current core of Moya, I would love to see it _**at least**_ as some sort of extension. What do you think about that? 

Also, anyone else from @Moya/contributors could take a look? üêº 
 I'd love to see a working example, I've been working on something similar, but unfortunately I can't get away from the singleton object for making requests, which results in a lot of `API.request(target: MoyaTarget)` calls around
 @iSame7 would it be possible to look at your code? I'm not sure if this is the right abstraction layer to institute this, but even if it doesn't belong in Moya, I'd love to add documentation around it. Please let us know :+1: 
 Closing this for now. @iSame7, please reopen a new issue if you think there is an opportunity to improve the documentation around abstracting Moya.  Very strange, thanks for reporting this. Could you provide some more details so we can reproduce this? Is it on a device or just the simulator? iOS 8, 9, or both? The networking code that demonstrates the problem would be helpful, if you can share it. Thanks again!
 Received the email, taking a look ASAP, probably won't be until the weekend. Will update. 
 Okay, I've tried taking a look but I don't have a device at the moment to test on. I'll try to take a look this weekend. In the mean time, I'd recommend trying to following trying to call the Alamofire request manually (if you can). I'd like to narrow down if this is a problem with Moya, Alamofire, or NSURLConnection. Can you provide any more details, like what device you're using, wifi status, any server logs you have? Thanks!
 @kevin5396 Interesting! Makes sense, since `NSJSONSerialization` would fail with empty data. I'm not sure what the best way to solve this is, maybe extend `mapJSON` to include a parameter for allowing empty data? 
 Makes sense! We should provide a default option, and this'll need to be added to both the RxSwift and ReactiveCocoa extensions too. Anyone available to submit a pull request? 
 So it looks like a PR to fix this issue would modify [the `mapJSON` function](https://github.com/Moya/Moya/blob/645398713e41a0f61a36c57e707d5135f2fa8477/Source/Response.swift#L60-L66).

``` swift
func mapJSON() throws -> AnyObject {
    do {
        return try NSJSONSerialization.JSONObjectWithData(data, options: .AllowFragments)
    } catch {
        throw Error.Underlying(error as NSError)
    }
}
```

We would need to add a new parameter like `failsOnEmptyResponse: Bool = true`. If it's `false` and `data == nil`, we need to return some other value. An empty `NSArray` or `NSDictionary` might work, or maybe `NSNull()`. Not sure, open for discussion. 

Oh, and we should test it, too üòâ 
 @nickolayl Pull Request üòâ 
 Okay, re-opening for discussion. Does Alamofire have any similar issues? 
 The issues list is at https://github.com/Alamofire/Alamofire/issues I'm unavailable to help right now, try searching for the symptoms and see what others have experienced. 
 Had a quick look, but can't seem to find anything similar in the Alamofire issues.
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  This topic was discussed in #298, but it was long time ago and was mostly for deprecation. And because we have many breaking changes and it is time for breaking, I think it is the best time to decide what to do with `RACSignal` extensions. We have many warnings in Moya about deprecation of methods that we should take care of:

> This will be removed when ReactiveCocoa 4 becomes final. Please visit https://github.com/Moya/Moya/issues/298 for more information.

Personally I think that the extension for `Moya.Error` with `.nsError` property could stay, because we have questions about the `.nsError` property once a few weeks. Other than that I want to know what other @Moya/contributors think! üêº 
 I'm üëç for getting rid of RAC 2 support, and I'm keen to remove the `nsError` property, since it just serves to erase the `MoyaError` type, and was only necessary for Objective-C interop.
 +100 for removing deprecated RAC support.
I'm also for removing `nsError`. We have good docs now and it is really duplicate of existing functionality.
 I'm okay with removing the `nsError` property as long as we document the error section, because this is really a common question here. 
 We already have updated docs: [ErrorTypes.md](https://github.com/Moya/Moya/blob/master/docs/Examples/ErrorTypes.md)
But I agree maybe it worth additional mention or link in Readme.
 I think we should remove the `nsError` property. After all, we're really coercing our already good errors into NSError for legacy support and dated patterns. I think keeping it just adds to the confusion and is what is leading people to ask about it.
 Okay, I think we came to the agreement that it should be thrown out from Moya. Is anyone from @Moya/contributors willing to PR these changes? It would include erasing deprecated methods only, if we decide to expand documentation on the `Error` matter, I think it should go into another PR anyways.
 Closing in favor of #508.
  Very strange, sorry to hear about this. Not sure what the issue could be. Usually, Xcode's error inspector will have a drop-down arrow beside the "does not conform to protocol" that says which function is missing, is it there? 
 Gotcha. Thanks for taking a look through ‚Äì I'm not experienced with Carthage either, so if you find anything, please let us know!
 Hmm, must be a consequence of our Carthage setup. Some background: Carthage doesn't support any sort of "subspec" style organization. Since we keep Moya and the RxSwift/ReactiveCocoa code in the same repo, Carthage downloads all three targets even if you don't use them. Because of the project organization, `TargetType` is re-defined in three different modules. The solution you have will work.

I'm surprised we haven't run into this before, I think we should add documentation around this. @mlvhub when you first ran into this problem, where did you look for an answer? We should add documentation there so others can find the answer easily.
 Yeah, last time we looked it involved splitting out into three repositories, which is a lot of work to keep in sync, etc. Let us know what you find, thanks!
 @mlvhub is this still causing problems for you, or is it safe to close the issue? 
  This should be possible, Moya's completion handler provides a `Response` object when a network call is successfully sent/returned (failure is for things like not being connected to the internet). The response object has a [`NSURLResponse?` property](https://github.com/Moya/Moya/blob/master/Source/Response.swift#L6) you can access to use a similar solution as in the StackOverflow answer. 
  Everything looks fine, hmm. Very strange. Can you try using the [network logging plugin](https://github.com/Moya/Moya/blob/38b0bda890b7b4598552a353b3f8db4248c37d6e/docs/Providers.md#plugins) to see what request is getting sent? 
 Gotcha, looks like your `baseURL` has the query string and everything included with it. Moya uses `NSURL` to add additional paths, and that must be confused by the `?sign=...`. I would recommend returning only `http://124.172.184.216:8080/open_api/api` from the baseURL and use the `endpointClosure` to add those additional parameters. [Here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-) are some examples.
 Yeah, that should work. Here's a project that does ObjectMapper and Moya work: https://github.com/ivanbruel/Moya-ObjectMapper
  Cool! Want to email me at ash@ashfurrow.com to schedule a time that works? 
 Cool, this looks awesome. I think we have the following TODOs to get this wrapped up:
- [ ] Add ReactiveCocoa extension for requesting.
- [ ] Add documentation for multipart requests.
- [ ] Add tests for new functionality.
- [ ] Changelog entry.

I'll try to take a look at this this weekend.
 Definitely good stuff in this PR - and I like @hirad's changes in his experimental branch, FWIW.
 I'm def happy to review this, I'm excited to (finally!) get uploads into Moya.  Please ping me (`@colinta`) when it's ready (and `@Moya/contributors`).
 ^ Looks like Swift-lint is running once per target, might want to have an option there
 @orta weird, we only run `bundle exec danger` in the post-test step, outside the Rakefile. 
 This is fantastic work and a great example of open source collaboration. Thanks everyone!

Wondering about the new property in the TargetType protocol: `var multipartBody: [MultipartFormData]? { get }`. Could we have a protocol extension that has a default implantation that returns nil? Or would that override the user's implementation?
 üíØ
 Tests pass, not sure why Danger failed but I'm gonna merge üíØ
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  I am a newbie to Moya, and I knew that the Moya is the most populate repo that integrate Alamofire and ReactiveCocoa.

I have two question.
## question 1

``` swift
public enum GitHub {
    case Zen
    case UserProfile(String)
    case UserRepositories(String)
}
```

sometimes, I need pass multiple parameters for specific API. For example the UserProfile, I need pass two parameters String, Int. How can I do this?
## question 2

In the demo, the parameters and paths are mixed together in the GitHub, and this will cause the GitHubProvider more and more complex. 

``` swift
extension GitHub: TargetType {
    public var baseURL: NSURL { return NSURL(string: "https://api.github.com")! }
    public var path: String {
        switch self {
        case .Zen:
            return "/zen"
        case .UserProfile(let name):
            return "/users/\(name.URLEscapedString)"
        case .UserRepositories(let name):
            return "/users/\(name.URLEscapedString)/repos"
        }
    }
    public var method: Moya.Method {
        return .GET
    }
    public var parameters: [String: AnyObject]? {
        switch self {
        case .UserRepositories(_):
            return ["sort": "pushed"]
        default:
            return nil
        }
    }

    public var sampleData: NSData {
        switch self {
        case .Zen:
            return "Half measures are as bad as nothing at all.".dataUsingEncoding(NSUTF8StringEncoding)!
        case .UserProfile(let name):
            return "{\"login\": \"\(name)\", \"id\": 100}".dataUsingEncoding(NSUTF8StringEncoding)!
        case .UserRepositories(_):
            return "[{\"name\": \"Repo Name\"}]".dataUsingEncoding(NSUTF8StringEncoding)!
        }
    }
}
```

And I want to know that can I split the parameters or paths for each model, like the octokit.objc?
 For question 2, there's also a struct-based solution we added [here](https://github.com/Moya/Moya/pull/427), but haven't had time to document yet. 
 @holysin is this issue resolved to your satisfaction?
  This looks awesome! The ReactiveCocoa provider needs a similar extension to add this functionality, we can do that in another PR. I think we do need to write some tests for this feature, though, and ideally add some documentation and a changelog entry. I'm happy to do a screenhero to pair on that sometime next week, probably. 

@leonereveel this is fantastic work, well done. 
  Awesome, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Super cool, this looks awesome! Could you add an entry to the top of the changelog? 
 Looks good! Weird that CI is failing, I'll take a look when I get a chance. 
 Restarted CI, it is green now.
PR looks good for me, great work!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  The `nsError` property was created for use with ReactiveCocoa. If you want to get at an underlying response, you can `switch` on the error in your completion closure, like:

``` swift
switch error {
  ...
  case .Underlying(let error as NSError):
  // now can access error.domain or whatever
}
```

It's a bit weird to have to case `error as NSError`, maybe the `.Underlying` case should use `NSError` instead of `ErrorType`. Any thoughts? 
 No problem! This seems like something we might want to document better, and maybe make the change to `.Underlying` I mentioned above. You wouldn't be interested in making a pull request, would you? 
 +1 for the change from `ErrorType` to `NSError`, also we could provide an example when we are at it.
 If we change `.Underlying` to have an `NSError` instead of `ErrorType`, then we won't need to cast, right? In any case, casting from ErrorType to NSError is guaranteed to always succeed, so it would be fine too.
 Ah, you're right. I misunderstood. 
  Thanks for PR!
Your fork is behind of upstream. How about rebasing it on top of latest `master`?
 Looks great! A few notes:
- Needs a changelog entry.
- Tests for the ReactiveCocoa provider are good, need corresponding tests for RxSwift, and ideally for just Moya itself. Maybe using the cancellation token?

I'm _really_ busy this week, hopefully others get the chance to review. Otherwise I'll try to look at it this weekend. Thanks!
 We've just merged #479, another breaking change (it's nice to group them all together). Now I'm thinking about other things we should break...
 Looks good! CI failure is intermittent and doesn't look related to the PR, merging!
 6.5.0 was released off a separate branch with a diverged history from master; it was necessary to rewind to before some breaking changes to get the `queue` specification included in a point release (instead of in our upcoming major release, which will include the changes in this PR). Does that make sense? 
 It ought to be ‚Äì is it not working as expected for you?
 Glad you figured it out üëç
 Just to make this clear, the tracking is implemented inside the `MoyaProvider`. The `RxMoyaProvider` and `ReactiveCocoaMoyaProvider` inherit from this base class and therefor inherit the inflight tracking functionality. 
  If you're able to use RxSwift or ReactiveCocoa, they have retry operators that make this easy. You can also see [an example](https://github.com/artsy/eidolon/blob/1c746f9a9c6420cda9f691468783fee67376e8b1/Kiosk/App/Networking/Networking.swift#L22-L31) of how to write try-when-network-is-available logic. 
  Hey @vishal91. üéâ Can you please provide the code where you described all of these? It will help us with helping you üòâ 
 At a first glance, it seems like your switches in `method` (and/or) `path` are not exhaustive, there are different number of cases. I'd try to add `default` to both of them and see what happens.
 First of all, add `default` case to each `switch` and let us know. This should solve your issue, no matter how many cases you actually have.

Then, you can add http headers in `endpointClosure`: https://github.com/Moya/Moya/blob/master/docs/Endpoints.md
 Usually this error comes with more details, hidden behind a "disclosure triangle" - there's no other detail related to this error?

> On Apr 28, 2016, at 6:39 AM, Vishal notifications@github.com wrote:
> 
> Added default to all the 'switch' . Same error.
> 
> ‚Äï
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
 Cool! Glad to help!
  Hmm, good question. Generally, parameter encoding doesn't work like that (as far as I know). You'd more typically see `ids` sent as an array, like `ids[]=41MnTivkwTO3UUJ8DrqEJJ&ids[]=6JWc4iAiJ9FjyK0B59ABb4&ids[]=6UXCm6bOO4gFlDQZV5yL37`, but I admit it's been a while. Let's see how we would do what you're looking for.

This is how I would accomplish this; add an associated value to the `Album` enum case that holds a `String` array of the ideas:

``` swift
case Albums(ids: [String])
```

Then, in the `parameters` implementation, do the following:

``` swift
var parameters: [String: AnyObject]? {
  switch self {
    ...
    case .Albums(let ids):
      return ["ids": (ids as NSArray).componentsJoinedByString(",")]
    ...
  }
}
```

And that should do it. Let us know how it goes!
 @Miasma87 This is an error with your swift code:

``` swift
case .getSeveralAlbums(let ids):  // remove ': [String]' from your code
```
 And it looks like you're in the wrong section - you should be modifying the `var parameters`, not the URL path.
 Sure you can - the list of ids is assigned to the enum as an associated value.

The `path` is not supposed to include the `?-` GET parameters.  They will be added to the URL _for_ you, when you return them from the `parameters` property.  Don't try to construct the entire URL yourself (like you might in JavaScript).

``` swift
enum API {
  case .Status
  case .Albums([String])
}

var parameters: [String: AnyObject]? {
  switch self {
  case .Status: return nil
  case .Albums(let ids):
    return ["ids": (ids as NSArray).componentsJoinedByString(",")]
  }
}
```
 @Miasma87 has this issue been addressed to your satisfaction? 
 @VivienGiraud glad you found out the issue! Also looking by code, if you are using Swift's Structs API for arrays (instead of `NSArray`), you don't have to cast it and you can just use `joinWithSeparator(_:)` (in Swift 2) or `joined(separator:)` (in Swift 3) method:

``` swift
["test", "test2"].joined(separator: ",")
```
  Yeah, basically you pass the plugins in init of your provider, the same as closures, manager etc. For example something like:

``` swift
MoyaProvider<GitHub>(plugins: [NetworkLoggerPlugin()])
```
 I've written a whitelist/blacklist logger plugin. It's not elegant (which is why it's not in Moya üòõ ) but it works: https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/NetworkLogger.swift
 I can think of a few ways to accomplish what you're after.
1. Hard: Fork Moya and add NSURLRequest to the completion.  Then you'd have to maintain a fork, which is no fun.
2. Reasonable: Fork Moya and add a plugin method to line 210 `plugins.forEach { $0.didReceiveRequest(request, result: result, target: target) }`.  Again a fork, but such a subtle difference that this would probably be easier to maintain.  And the debugging would be off on its own, in a plugin, which is nice.
3. Easy: Just re-create the request in your response handler!  There's nothing special about the NSURLRequest instance, and it's easy to create a copy.

``` swift
provider.request(.Zen) { result in
  let request = Api.Zen.urlRequest
  ...
```

Better yet would be to wrap this in a networking layer, and then you can send the request back in a custom completion block:

``` swift
class Network {
  static let provider = MoyaProvider<MyService>()

  static func request(endpoint: MyService, completion: (NSURLRequest, Result) -> Void) {
    provider.request(endpoint) { result in completion(endpoint.urlRequest, result) }
  }
}
```
 You can now get `curl` commands logged using the included [network activity plugin](https://github.com/Moya/Moya/blob/645398713e41a0f61a36c57e707d5135f2fa8477/Source/Plugins/NetworkLoggerPlugin.swift#L17). 
 @nikita-leonov what do you think, has this issue been addressed to your satisfaction? If not, what are the next steps? 
 I'd be happy to review a PR, I'm not sure what request/response correlation would look like so I can't say for sure if it'd be accepted. Could you explain your implementation idea? 
 PR is merged! Are there any next steps on this issue? 
 Closing this for now, as it seems this has been resolved by merging the PR. Please reopen if there's anything else that needs discussing! :)  Awesome, thanks! üéâ 
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hmm, hard to say. I've not used Charles much, are you stubbing the requests? Could you post the Moya code that's not working? 
 I've used Charles w/ Moya a ton - but when we added SSL pinning, that causes Charles to stop working.
 @samirGuerdah Hey there! Did you get this working? 
  Nice!  Thanks for adding this to the README.  I took a quick glance at your adapter, and it looks very straightforward.  I think this is good to merge (and will, if no one else objects or beats me to it).
 Yeah, looks good! Thanks! üéâ
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  @bitomule what method did you end up using? 
 Okay to close this issue? 
 Do we know how/if Alamofire handles this? Moya's goal is to abstract away the actual network layer, so handling these types of responses seems like it's something we should take responsibility for. 
 Glad you got it working! Is there anywhere in Moya's documentation where some info about empty responses would have been helpful to you? I'm sure you're not the only one to run into this. 
 No problem, always feel free to open issues or send improvements to documentation. 
  Try this:

``` swift
public enum MyService {
    case Users(limit: Int?)
}

extension MyService: TargetType {
//...
    public var parameters: [String: AnyObject]? {
            switch self {
            case .Users(let limit):
                var params: [String : AnyObject] = [:]
                params["limit"] = limit
                return params
            default:
                return nil
            }
        }
//...
}
```

In this case `params["limit"] = nil` will be equal of removing object for key `limit`.
 Doesn't matter, method type is defined in separate property

``` swift
extension MyService: TargetType {
//...
    public var method: Moya.Method {
        switch self {
        case .EmailAuth:
            return .POST
        default:
            return .GET
        }
    }
//...
}
```
 What is your problem exactly? Check the samples above or check the [docs](https://github.com/Moya/Moya/blob/master/docs/Examples/OptionalParameters.md).
  @jimmy0251 the `parameters` `var` is the dictionary containing **ALL** parameters and their values.

In this case if you want to send an array as parameter; e.g. `[String]` or something along those lines you would need to pass it like this:

``` swift
var parameters: [String: AnyObject]? {
  switch self {
    case .ArrayParameter: return [ "parameterName": arrayObject ]
  }
}
```

That means that the parameter called `parameterName` will contain the `arrayObject`.

Let me know if that helps and if not we can dig it up until you got it up and running
 @esttorhe that sends a JSON dictionary of `{ "parameterName": ... }`, but what if you wanted to send a JSON _array_ instead? `[ ... ]` for example. I don't think that's currently possible in Moya without using a `.Custom` parameter encoding.
 @ashfurrow yeah I was working under the assumption that perhaps Jimmy wanted to send an array as a parameter.

If what he wants is send a JSON array then yeah I guess `.Custom` would be needed.

Maybe let's wait until he can clarify if he meant the array parameter or the parameters as an array üòÑ 
 Yeah, good thinking. JSON-arrays-as-data is a personal pet peeve ‚Äì I really wish API developers would stop doing it :disappointed: 
 Same here but maybe there's a really good and valid scenario for something like that (although I haven't found one just yet).
 Great solution @jimmy0251! Thanks a lot for sharing, I'm sure this will help others :bow: Do you consider the issue closed at this point, or do you think we should add your solution to our documentation, etc? Maybe something for #466.
 I got you covered, added this example to PR, commit authorship set to @jimmy0251:)
 In fact, it's how you should approach this, @vytis üêº More about it [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-).
 @tdouglas1313 Hmm, it should be possible to do it the same way, using `endpointClosure`. Did you encounter any problems with that? If so, please open another issue targeting Swift 3.0 version :)
 Yeah, you can pass it as `JSONEncoding.default`, `URLEncoding.default` etc., instead of an enum case.
 No probs! Happy to help! üëä
  Hmm, this is a really good question ‚Äì this isn't a scenario we thought about when making the request closure asynchronous. I think it would make sense for Moya to provide a way for the request closure to produce an error ‚Äì this would be a new addition to Moya, and likely a breaking change. @Moya/contributors anyone have thoughts/feels about this?
 I think that's a smart move. Maybe make the parameter for `done()` be a `Result<NSURLRequest, ErrorType>`? It would be a breaking change, but we already have several of those merged in master, so now is an idea time to make this kind of change. Is anyone interested in sending a PR? 
 Sure! I can take a stab at that.
 Closing in favor of #488.
  Hey!
I don't see any errors in your code. Actually, I even copy-pasted and compiled it.
Can you give more details?
  For additional token fields you could use Endpoint settings, explained [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-) (with auth token as well).
  Looks fine to me! Thanks for the contribution. 

I'm concerned that, as-is, this is a breaking change (if someone was subclassing the provider and overriding this method, the changing method signature would break thei override). Do you think, for now, we could introduce a second request function, instead of using the default value for a parameter?

A changelog entry and test would be awesome, but testing this might be tricky. We can merge without one and add it later. 
 I think using the same function is better, too, and I want to do that when we move to our next major release, but I don't want to break our [semantic versioning](http://semver.org) by breaking anyone's code.
 Good point @nuudles! üëè  What do you think about it @kokhong20? Is it okay with you? Also it would be probably the last point before we can merge this one I think.
 Looks cool, I'm fine with releasing this as a non-breaking change. Complicating things slightly is the fact that `master` currently _has_ non-breaking changes already. I'll take care of releasing this this weekend. What I'll probably do is go back to the most recently released commit, merge this in, make a release, then merge _that_ commit into master (closing this PR). That way everybody wins :tada:
 This has been released as Moya 6.5.0 and should be accessible from CocoaPods and Carthage. I've also had to manually merge into master, a few mew conflicts but nothing too serious. The merge commit is  https://github.com/Moya/Moya/commit/350bff8edbdb35007bdb8fd909aceef7d9d83d6b

@kokhong20 thank you for your contribution! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hey Shai!

I'm afraid there is no direct solution other than mapping response to have the top object that should be the array with objects. üò¢
 Sure! Here I have a method that gets a user by repository name. Let's say I give name **Moya/Moya**, it does the request [here](https://api.github.com/repos/Moya/Moya), and retrieves the **owner** object to parse it:

``` swift

func getUser(byRepoName name: String) -> Observable<User> {
    return self.provider
        .request(GitHub.Repo(fullName: name))
        .debug()
        .map { response -> Response in
            guard let responseDict = try? response.mapJSON(),
                owner: AnyObject = responseDict["owner"],
                newData = try? NSJSONSerialization.dataWithJSONObject(owner, options: NSJSONWritingOptions.PrettyPrinted) else {
                return response
            }

            let newResponse = Response(statusCode: response.statusCode, data: newData, response: response.response)
            return newResponse
        }
        .mapObject(User.self)
}
```

**Edit:** You could also use our extension for Argo, which @aschuch pointed out. üí™
 Sure! You can make your own mapper extensions for it:

``` swift
extension ObservableType where E == Response {

    func marvelMapArrayOptional<T: Mappable>(type: T.Type) -> Observable<[T]?> {
        return map { response -> Response in
            // your map
        }
        .mapArrayOptional(type)
    }
}
```

Just copy your map code above and you should be fine. And then you could use `marvelMapArrayOptional` instead of `mapArrayOptional`. You could also do a more generic method if you would like to do it for more methods like `mapObject` and so on.

``` swift
extension ObservableType where E == Response {

    private func marvelMapResponse() -> Observable<E> {
        return map { response -> Response in
            // your map
        }
    }

    func marvelMapArrayOptional<T: Mappable>(type: T.Type) -> Observable<[T]?> {
        return marvelMapResponse()
            .mapArrayOptional(type)
    }
}
```

 Hope it helps! üéâ
 Unfortunately we don't have a slack channel, but you could try asking on the RxSwift channel if it is more connected to RxSwift, or [on this slack](https://ios-developers.io) for ios-devs, they are all very helpful. Of course you could still ask the questions on here, no problem with that as well üéâ
 That is actually a question for [Mapper](https://github.com/lyft/mapper) rather than Moya itself, so please make an issue there. Other than that it would be really helpful if you could make new issues as the questions go, it will be then useful for other people if they need the answer as well (rather than scrolling). 

I think that we have resolved current issue, so I'm closing it for now. Thanks!
  With new pod owners, I want to document the automated release process.

@colinta @petester42 @sunshinejr @esttorhe Any questions?

Fixes #454.
 Not from my end; seems pretty straight forward 
 > /Users/travis/build/Moya/Moya/Demo/Pods/Nimble/Nimble/Adapters/NimbleXCTestHandler.swift:9:64: cannot convert value of type 'String' to expected argument type 'StaticString'

Haven't checked the `.travis.yml` but are we building against/using `Swift 2.2`?
Or the `Podfile` points to `Nimble` with `Swift 2.2` ?
 The CI failure? Trying to fix that here: https://github.com/Moya/Moya/pull/452
 ahhh; thanks @ashfurrow 
sorry for maybe bringing old stuff up; have been kind of away from the project due to a massive amount of work and trying to catch up on stuff

:grimacing: 
 No worries! April is really busy for me, and I wanted to make sure Moya would be OK if I wasn't available. 
  Good catch!
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  This was [fixed in 6.5.0](https://github.com/Moya/Moya/blob/master/Changelog.md#650), feel free to re-open if we can be of further help.
  Thank you for the PR! üéâ
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Cool! And we just throw in our .netrc file creds? Super neat! 
  Currently, I'm the only one who deploys Moya releases. This sucks because I'm not always available to do it, and I don't want to be a bottleneck for anyone else. 

So, I'm looking for existing contributors who are willing and able to occasionally release a new Moya version. It's not a huge job at all, but I feel like it's a bigger responsibility than being a contributor, so there's absolutely no pressure to accept. @petester42 @colinta @esttorhe @aschuch anyone interested?

(I would need to add some documentation around _how_ to make a release as well.)
 I'm not at all opposed to helping out with this, would love to have someone else involved to "have my back" (look over the release, sanity check that it's good to go, etc).
 I could help as well if needed. 
 Awesome, I've added you three :tada: Thanks so much. I'll submit a doc about deploying this weekend. 
 It's basically just `rake release["X.Y.Z"]` and mostly everything else is automatic.
 interesting; github did not notify me of this

aaaaanyways; If you need more hands i'm down to help with this as well
  Fixes #451.
 @Moya/contributors does someone want to try continue work here? 
The last ~10 PRs were merged with a red CI status
 Should be good to merge now.
 Awesome work @ealeksandrov üëç 
  Cool! Looks good. CI is failing on master, so that's not your fault, and since you tested Carthage locally I trust it works :smile: I've opened #451 to fix CI separately.
 Just a note, I had previously sent an invitation to join the Moya organization ‚Äì no pressure at all! ‚Äì just wanted to make sure you had received it. 
 No worries, take care! And thanks again for the help on this :bow: 
  This looks similar to #445, could you try the solution from there? (Something about `carthage update --platform iOS --no-use-binaries` and deleting a folder.)
 Hmm, sounds like a different problem. Discussing here sounds fine. 

Afraid I'm not very knowledgeable about Carthage, looping in @Moya/contributors to get another set of eyes. I didn't see any related [issues](https://github.com/ReactiveX/RxSwift/issues) on RxSwift or [ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa/issues). What would help diagnose the problem would be the contents of your Cartfile. 
  Is there any recommended and simple way for **defining targets for RESTful APIs using Moya?** I think this is a common way of how APIs are laid out nowadays so I think it would be great if Moya was making this easily addable and maintainable.

Say for example I want to consume an API that defines RESTful APIs for articles and comments that support **create**, **show**, **update** and **destroy** methods (using Ruby on Rails naming conventions) then I would currently solve this by defining a Target in Moya similar to this:

``` Swift
enum MyService {
    case ArticleCreate(title: String, content: String, author_id: Int)
    case ArticleShow(id: Int)
    case ArticleUpdate(id: Int, title: String?, content: String?)
    case ArticleDestroy(id: Int)

    case CommentCreate(message: String, article_id: Int, author_id: Int)
    case CommentShow(id: Int)
    case CommentUpdate(id: Int, message: String)
    case CommentDestroy(id: Int)
}

extension MyService: TargetType {
    // ...
    var path: String {
        switch self {
        case .ArticleCreate:
            return "articles"
        case .ArticleShow(let id):
            return "articles/\(id)"
        case .ArticleUpdate(let id, _, _):
            return "articles/\(id)"
        case .ArticleDestroy(let id):
            return "articles/\(id)"
        case .CommentCreate:
            return "comments"
        case .CommentShow(let id):
            return "comments/\(id)"
        case .CommentUpdate(let id, _, _):
            return "comments/\(id)"
        case .CommentDestroy(let id):
            return "comments/\(id)"
        }
    }
    var method: Moya.Method {
        switch self {
        case .ArticleCreate, .CommentCreate:
            return .POST
        case .ArticleShow, .CommentShow:
            return .GET
        case .ArticleUpdate, .CommentUpdate:
            return .PATCH // or alternatively .PUT
        case .ArticleDestroy, .CommentDestroy:
            return .DELETE
        }
    }
    // ...    
}

```

I'm thinking of something where I **explicitly mark an API target to be RESTful** without changing the existing behavior (much). For example the above code could then look something like this:

``` Swift
enum MyService {
    case Article(ResourceType)
    case Comment(ResourceType)
}

extension MyService: TargetType {
    // ...
    var path: String {
        switch self {
        case .Article:
            return "articles"
        case .Comment:
            return "comments"
        }
    }
    var method: Moya.Method {
        switch self {
        case .Article(let resourceType):
            return resourceType.method
        case .Comment(let resourceType):
            return resourceType.method
        }
    }
    // ...    
}

```

where ResourceType could be defined somewhere within Moya similar to this:

``` Swift
enum ResourceType {
    case .Create(params: [String: AnyObject])
    case .Show(id: Int)
    case .Update(id: Int, params: [String: AnyObject])
    case .Delete(id: Int)

    var method: Moya.Method {
        switch self {
        case .Create:
            return .POST
        case .Show:
            return .GET
        case .Update:
            return .PATCH // or .PUT
        case .Destroy:
            return .DELETE
        }
    }
}
```

Usage would then be something like this:

``` Swift
let provider = MoyaProvider<MyService>()
provider.request(.Article(.Create(["title": "Example", "content": "Lorem ipsum", "author_id": 100])), completion: { result in
    // ...
})
```

Please take note that **the above solution example is for demoing purposes only** and should only serve as a starting point for further discussions. I have not put much thought into it and it has several flaws (for example the params can include anything which is not good).

But I hope the differences between the currently possible approach and the suggested approach express why this might be a great feature for a future Moya release. Given that most RESTful APIs have dozens of targets you can imagine how bloated the enum would look given the current approach.

What do you think? Do you have any ideas on how we could implement this? Are your requirements for RESTful APIs somewhat different? What would make writing RESTful APIs easier for you?
 @Dschee did you try MultiTarget maybe?  Super, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  This is a pretty serious issue, but I don't have sufficient Carthage experience to fix it. @Moya/contributors anyone have suggestions? 
  Thanks for the kind words! The fix for this would be to change the [DelayedStub](https://github.com/Moya/Moya/blob/84e02244b5d89971611f167bf25d629ce77b5a74/Source/Moya.swift#L192-L194) function to look like this:

``` swift
public final class func DelayedStub(seconds: NSTimeInterval) -> (Target -> Moya.StubBehavior) {
    return { _ in .Delayed(seconds: seconds) }
}
```

I'm strapped for time at the moment, if someone else has the time to make + test this change, that'd be :100: 
 I can do this right now.
 Moving conversation to #443 
  I also like this implementation!  Feels very "Moya-esque" :smile: 

The "Response-subclass w/ `progress` method is a good idea to me, too.

Thanks for tackling this one!
 @startupthekid I think it should be possible for us to utilize the `encodingCompletion` invocation to add `parameters` from the target. All I'm doing is taking the encoded request and immediately kicking it off.

Also, short-term, I've been encoding any of my parameters straight into my multipart request as different parts
 The only thing I don't like about mirroring the `Alamofire.ParameterEncoding` to a custom `Moya.ParameterEncoding` (rather than the typealias) is that we tie ourselves to `Alamofire` updates. As their `ParameterEncoding` changes, we have to update ours. I'd rather us be able to abstract it in `Moya` land, transforming it into `Alamofire` land.
 Closing in favor of #483 and f3f7570dcf875d2c95cae41397176c4577cfc555
  Hi @jasl ‚Äì thanks for the bug report. I'd like to ask you to rephrase your comment about carelessness, as it could be interpreted as an accusation; we aim to discuss bugs without calling anyone's abilities into question. Thanks for helping keep Moya a positive place :bow: 

Sounds like this is always reproducible? Like it's not intermittent? When you get a chance, could you post a code snippet or PR a failing unit test to demonstrate the bug? Thanks!
 No problem! Thanks for looking into this, I'm sure it'll help when someone else has this issue. If you have any suggestions for documentation improvements, please let us know :bow: 
 Cool! Could you open a new issue with suggestions or ‚Äì if you're comfortable ‚Äì a pull request with the changes? 
  Thanks Justin, let us know when this is ready for a final look over :+1: 
  This **improves the documentation** of the Examples.rd and Provider.rd files by adding **more details**, structuring by params (**clarity**) and being more explicit about Moyas **default behavior** and **minimum usage requirements**.

I did these changes after trying to use Moya for a project and got stuck with it after reading the documentation alone. Once I looked into the code all my questions got answered quickly ‚Äì but not everybody will do that. So I in this PR I try to be more explicit about the parts that confused me and try to provide **more detailed** and **practical examples**.

See also #432.
 This is fantastic, @Dschee, thank you for taking the time to improve our documentation! I've made a few inline suggestions above ‚Äì I'm happy to merge as-is and submit a PR with my feedback, none of these are blockers.

![](http://media.giphy.com/media/V2xbsCrxcLQSQ/giphy.gif)
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  The problem looks like Moya vends its own [Error type](https://github.com/Moya/Moya/blob/4a834fcc96ed239d1f8da621c0ca4d16162d0a9d/Source/Error.swift#L3). It's an `ErrorType` so every cast to `NSError` will succeed, but I suspect the Swift compiler is getting confused. Try this:

``` swift
case .Failure(let error):
    let nsError = error as NSError
```

Let me know :+1: 
 Hey @lkuczborski! Thanks for reporting the issue! üéâ 

Although Moya's `Error` inherits from `ErrorType` and `NSError` also inherits from `ErrorType`, the cast from one to another is done by some bridging, because they aren't really connected other than the `ErrorType` protocol. So when you cast from `Moya.Error` to `NSError`, you get some really basic info and the associated type is gone. I'm guessing that the compiler is just confused, and it could be a bug, but I can't tell for sure. For now you can use `Moya.Error` property `nsError`. It might be removed in a future so you could copy the code and make your own extension instead.
 Glad we could help! ‚úåÔ∏è
  Hey! Thank you for reporting an issue!. üéâ

With your problem could you please provide what was the case and how you have repaired it? It might be useful for other people in the future ‚úåÔ∏è

And about Heimdller, I didn't really play with that, but what I can tell you is that Moya relies on Alamofire in its core. If you want to use Heimdller instead of Alamofire, you would need to create your own version of Moya and replace the Alamofire code in requests etc. But you can try using `endpointClosure` to add additional parameters based on Heimdller. There is an example [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-), that adds auth token to your request. Hope it helps! üòâ
 I think we can close this one as well, if anything pops out, let us know @mrfarukturgut!
  Stubbed responses, for one (testing as a first-class consideration).

> On Mar 18, 2016, at 5:23 PM, G Edward Gonzalez notifications@github.com wrote:
> 
> Love the concept of Moya, just reading the docs and struggling to see the benefits of it compared to just using vanilla Alamofire with an enum that conforms to URLRequestConvertible: https://github.com/Alamofire/Alamofire#api-parameter-abstraction https://github.com/Alamofire/Alamofire#api-parameter-abstraction
> I like that Moya formalizes the pattern, as it does seem like a side thought in the Alamofire readme. But are there other intentions/benefits compared to it?
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub https://github.com/Moya/Moya/issues/435
 Yup, the main features of Moya are:
- Compile-time checking for correct API endpoint accesses.
- Lets you define a clear usage of different endpoints with associated enum values.
- Treats test stubs as first-class citizens so unit testing is super-easy.

But philosophically, Moya represents a framework that encourages developers to think about the network calls they want to make upfront, to encourage more thoughtful coding.

Let us know if we can clarify anything!
 ## I'd happily review a pull request üòâ

Ash Furrow
https://ashfurrow.com/ 
  If the `Endpoint` type isn't generic, users can build a non-generic provider that may be better-suited for their needs. 

Background:

Today, @jasl and I had a Skype call about #376 to discuss their fork of Moya that uses a far less generic-based approach: https://github.com/jasl/MoyaX There are some really cool ideas there, and I realized that by forcing `Endpoint` to be a generic restricts those ideas. There's no need for it to be generic, that I can think of.

Other ideas were a little more radical, and might not fit within Moya, but would make excellent library extensions. For example, the non-generic providers used in MoyaX help define more complex APIs involved in social network apps (other people have cited social network apps as a use case for using structs instead of enums, too).

Once we remove the generic `Endpoint` requirement, there are some other ideas we should consider borrowing from MoyaX:
- Make the backend (Alamofire) abstracted away so users can replace their own. This might be an interesting way to stub network calls instead, like having a "StubBackend" to stub requests. 
- I'm sure I missed some, @jasl please add the ones I missed.

This is a longer-term project, and Moya as it exists today is relatively stable. We need to be mindful about how we introduce changes like this to our existing users, and balance the trade-offs appropriately. 

Thanks again @jasl for your great ideas :cake:
 Going to close this and move discussion to #556. 
  ## Sounds reasonable to me ‚Äì it simply wasn't included because we didn't see a need for it. Clearly there is one :) Would you be able to submit a pull request? Adding a comment above the function and an entry into the changelog would be üíØ  

Ash Furrow
https://ashfurrow.com/ 
  We need more examples in our docs page. I'm thinking about making a Table of contents in our [Examples.md](https://github.com/Moya/Moya/blob/master/docs/Examples.md), where we could make few examples. One would be the easiest, the most basic setup with `.GET` request, then we could make another one with POST, another one with custom and specific examples of endpoints, stubs, and we could even add the setup with structs (vide #428). Also the **Examples** document feels like too much text at once, we could make something like description of _how_ you can setup Moya and _why_, and then the examples step by step. 

This is just an idea but we can brainstorm together ü§î

What are your thoughts? üéâ
 I like this idea, but I don't want the docs to get overwhelming. Maybe we should expand from a single `Examples.md` and do something more like "TargetExamples.md" etc? That way each document stays bite-sized.

Seems like a bit of a duplicate from https://github.com/Moya/Moya/issues/189 , what do you think? Might be worth having a milestone around documentation to gather all the ideas in one place. 

Probably related to #428 and #369 as well.
 First, milestone is a good choice, it would be much easier to read (also yeah, kinda a duplicate, sorry about that). About examples I agree that multiple files are a way to go, also we could have one file that will guide new user through examples, like in this file you can learn basic and the simplest usage, then here you have this and that because reasons. Or maybe do it in the main docs? Hmm ü§î
 I think this might be a good structure:

```
docs/
  Targets.md
  ... etc ...
  Examples/
    Readme.md
    TargetExamples.md
    ... etc ...
```

Then the readme in the new directory can be a guide to the other documents, like [what we have now](https://github.com/Moya/Moya/tree/master/docs).
 I _really_ like that one! üôå
 Thank you for your input, @Dschee ! üéâ 

Yeah, we know that our documentation has to be improved. We are working on it and every hint at what we could improve is a great help. While I understand the problem with the required implementation, I kinda don't think I understand the logging part. Could you explain what exactly do you have in mind?

Also if you have any other feedback about current docs, feel free to write it here. Thanks!‚úåÔ∏è
 What else is missing now that #438 is merged? 
 Close in favor of #466. 
  Hey there! This is fairly straightforward, but our docs aren't great. We need to improve them. In your [`TargetType`](https://github.com/Moya/Moya/blob/master/docs/Targets.md), use the `parameters` and `method` properties to return the JSON data and POST/PUT. Then, when setting up your provider, you can use a custom [`endpointsCosure`](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-) to specify `.JSON` encoding for appropriate endpoints. 

Let me know if that helps, and if you have any suggestions for improving our docs. Thanks for the great question!
 Sounds complicated but not impossible. I haven't heard of an API requiring both an HTTP body _and_ query string parameters, usually it's one or the other.

Sounds like you need a custom parameter encoding. In my answer above I suggest using `.JSON`, but you'll need to use `.Custom` instead. We piggy-back on Alamofire's custom parameter encoding, so you should be able to follow [their docs](https://github.com/Alamofire/Alamofire#parameter-encoding) to create a custom param encoding to use in the `endpointsClosure`. 

To be honest this is outside my experience ‚Äì I'll try to help with an questions you have, just me know üëç
 @m00sey Thanks for sharing your solution! :bow: 
 Hey @retsohuang! We've updated our examples and [here](https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md) you can see it step by step. Hope it helps! If you have any questions/feedback about our examples, please let us know üêº Also, I think that this issue is resolved for now, so I'm closing it.
  Based off of work done in #427, refined from [this comment](https://github.com/Moya/Moya/pull/376#issuecomment-197149515). 

This removes the generic parameter for `StructTarget` and instead lets users create one with _any_ struct that conforms to the `TargetType`, so one provider can be used with many different struct targets. 
 Seems fine to me, @ashfurrow! üéâ I don't know, but maybe we could add the info about structs to Changelog with this PR?
 Good thinking :+1: 
  This is an alternative implementation of #408 (in lieu of #424).

Basically, Moya provides an `enum` type called `StructTarget` that has a single case, `.Struct` with an associated, generic value. That value is the "real" `TargetType`, the `struct` that our users would use. So instead of

``` swift
MoyaProvider<MyStructAPI>
```

You'd use

``` swift
MoyaProvider<StructTarget<MyStructAPI>>
```

Pros:
- Simple implementation
- No breaking changes

Cons:
- More verbose for developers using structs

Curious to know what you think!
 This is more in line with what _I_ had pictured - simple, more verbose, but doesn't introduce or rely on any new features.

I must give props to @sunshinejr for the cool use of reflection, but I would actually steer clear of that in a library like Moya.  Keep it simple, keep it explicit, let individual developers choose to implement something more interesting & complex.

But that's just my opinion! :smiley:
 ![d8c017582e3](https://cloud.githubusercontent.com/assets/498212/13791647/845e2b92-eac4-11e5-973e-a588592ca5a0.gif)
 Cool! I'll create an issue to update docs and demo app.
  While preparing for Structs API that potentially could be coming to Moya, we decided that the PR #424 was too large and, what is more important, it had breaking change that is extracted to this PR. 

In this PR we extracted from `MoyaProvider`:
- Defaults: `DefaultAlamofireManager`, `DefaultRequestMapping`, `DefaultEndpointMapping`
- Stubbing: `NeverStub`, `ImmediatelyStub`, `DelayedStub`

and moved them to the new class `MoyaDefaults`.

For more information you can take a look at description of #424. Thanks! üéâ
 Makes sense! We should double-check if documentation needs updating. 

So if I understand correctly, we'll hold off on merging this and take these changes _out_ of #424? Then:
1. Merge #424.
2. Release a patch for structs in Moya.
3. Merge this.
4. (Possibly wait for other breaking changes.)
5. Release a major version for this.

Does that sound right?
 So we basically _can't_ (at least not with the changes I proposed) introduce #424 without introducing `MoyaDefaults`. Normally it would go the way you suggested, but this time we kinda have to do it the other way around, which is:
1. Merge this.
2. Make sure everything is running correctly.
3. Merge #424 which is the StructsAPI on its own (without `MoyaDefaults` introduction).
4. (Possibly wait for other breaking changes.)
5. Release a major version for this.

If something is still unclear I'm happy to answer! üòâ
 Well no, we could remove the changes that reference `MoyaDefaults` from #424.  That's what I had intended by my comment.

You could either rebase #424, and remove the `MoyaDefaults` code, or create a new commit, and this PR _should_ override that change.
 Yeah I could rebase the #424 and delete the last commit which is `MoyaDefaults`. What I meant was that merging #424 before this one will also include the changes from here (or I don't really understand the idea).
 Right, I _think_ what @colinta means is that we can rebase #424 to remove any reference to `MoyaDefaults` so that we have two, totally independent pull requests. Then we can have a release between #424 and this one, so that people can adopt structs without adopting this (possibly breaking) change. Does that make sense?  
 Yeah, makes sense! But, I don't know if it possible. #424 relies on `MoyaDefaults`, because there was problems with type inferring üòî
 Those do happen >.< Could I ask you to take a look and see what problems they are? Maybe we can find a less-than-ideal, non-breaking change and move to this (which is a good idea) as soon as possible. Does that sound ok?
 Sure, will take a look üëÄ
 So, the problem with generics is that we have 2 options:
- we have TargetType as a MoyaProvider's Target,
- we have ServiceType which has 0..infinity TargetTypes

What leaves us with the case that our base protocol is ServiceType. Swift's generics seems to have a problem when an actual TargetType is passed:

<img src="http://i.imgur.com/LXpZEtI.png)" />

And we can "repair" it by specifying the TargetType explicitly. From:

``` swift
MoyaProvider<GitHub>(endpointClosure: MoyaProvider.DefaultEndpointMapping)
```

To:

``` swift
MoyaProvider<GitHub>(endpointClosure: MoyaProvider<GitHub>.DefaultEndpointMapping)
```

But it is still a breaking change. üòî
 Interesting! I guess I was thinking of https://github.com/Moya/Moya/pull/424 as having only _one_ struct-based enum type that Moya gives for developers to put their structs in (noted in [this](https://github.com/Moya/Moya/pull/424#discussion_r56069092) comment, sorry if I was unclear). Would that solution fix this problem, since we wouldn't need a ServiceType and could continue with the existing implementation? 

Thanks again for all your work on this, it's really great and we all really appreciate it!
 That would be most likely possible, but I don't know if it suits really #424 tho? Maybe we could leave #424 with the current implementation and create new one, which will only add new Demo project or new class that shows struct setup that is currently possible. Also, we agreed on a new Demo project, right? DemoStructs seems all right? Do we need some extra changes in old Demo? You got the documentation part, right?

And thank you, I really appreciate that I can contribute to the project I use the most. ‚ò∫Ô∏è 
 Yup, I've got documentation covered but we need to finalize the implementation first :smile: I don't know if a new demo project is necessary (beyond #189) if we can just add a side-by-side demo of using structs in the existing project, your call.

If we _can_ use the single-case-enum I mentioned in #424, maybe it's worth trying out a PR with just that idea? I can whip something quick together this afternoon, I'd like to hear your thoughts on it. Let me know :cake: 
 Yeah, go for it üéâ Adding it to the existing Demo is perfectly fine with me üëå
 I'm closing this one. This doesn't need to be introduced since we went with another option of structs API. 
 Makes sense :+1: 
  This is a great question, thanks! It's not something I've personally had an issue with, but I can totally see the concerns. 

So, the rationale behind this decision is to make sure that people _have_ to define sample date to make testing easier / encourage testing. There's no way to define a requirement _only_ in a test target, so this was our solution. 

But it's not ideal for everyone. An empty `NSData()` would do the trick, but what if you wanted to use this for testing? Empty `NSData()` wouldn't work then. In that case, I'd take the JSON out of the Xcode target (so they're not shipped with the app) and instead of using `NSBundle` to load the JSON, use some other way to reference the Xcode. FBSnapshotTestCase does this using either environment variables:

``` objc
[NSProcessInfo processInfo].environment[@"ENV_VAR_NAME"]
```

or by using `NSBundle`'s `resourcePath`:

``` objc
[[NSBundle bundleForClass:self.class].resourcePath stringByAppendingPathComponent:@"FolderWithJSON"]
```

That way the code is loading the files directly for disk and not through `NSBundle`. This won't work if you're running tests on the simulator, though, so that's one potential downside.

Let me know what you think ‚Äì I'd like to know what you think an optimum solution would look like, and how we could improve our documentation around this. Thanks again for opening the issue!
 This is a really interesting idea, I like it. It takes away from the goal of encouraging testing at all costs, but that may be discouraging some users from trying Moya. And I'm pretty sure they'll just return `NSData()` anyway :wink: 

This is a pretty big breaking change that would pair well with #426 when that gets merged. I think we should be careful about it; I'd like to get feedback from @Moya/contributors on the following idea:

Move `sampleData` out of the `TargetType` and into a closure passed to the provider that returns sample data based on its parameter, a target. This would complicate how we [handle structs](https://github.com/Moya/Moya/pull/424), though... We can also consider moving this behaviour into the `stubClosure`, like:

``` diff
-typealias StubClosure = TargetType -> Moya.StubBehavior
+typealias StubClosure = TargetType -> (Moya.StubBehavior, Response)
```

And we could even make this parameter optional, and `nil` implies "never stub", which would simplify the provider a bit. Just an idea, trying not to get ahead of myself :wink: 
 I like the idea of expanding `StubClosure` rather than passing it with provider as it is already big I would say (even tho we might not get any problems of the structs now as we'd chosen the simpler way of handling it). It also _feels right_ in `TargetType` (at least for me üòÜ).  
 Any more discussion/action items on this? Or can we safely close?
  As per issue #408, I'm sharing with you the solution I've come up with to the topic, which is structs in Moya. The general idea was a perfect start by @Matthijn followed up by a really good direction by @colinta 
## Motivation

We would like to keep existing enum setup and additionally support structs based setup for bigger projects or for any other reason. Specifically, what should be possible with this PR is that we can still use old configuration of enums and it won't break, but additionally we can use Moya with structs configuration, for instance:

``` swift
GitHubStructProvider.request(.UserProfile(UserProfileResource(name: name))) { result in

}
```
## Implementation

My idea was to create protocol that will be a default protocol for enum when using it with wrapped structs, I called it `ServiceType`. Then make `TargetType` conform to it protocol so we can reuse code for both implementations.
## Issues

There were few issues that occurred during the implementation. Changes I've made created some problems with generic's type inferring so I had to move Defaults (`DefaultEndpointMapping`, `DefaultRequestMapping`, `DefaultAlamofireManager` and stubbing defaults) to another non-generic class and I called it `MoyaDefaults`, which is a **breaking change** in case someone used them via `MoyaProvider.DefaultAlamofireManager` for instance. Couldn't find a way for not-creating another struct without many changes in code so if you have an idea I would love to hear it. 
## Demo

I've also added an example of usage to the current demo. As per our conversation I also believe we could move it to second demo. In short we can now define our struct like the one below:

``` swift
public enum GitHubStruct: ServiceType {
    case Zen(ZenResource)
    case UserProfile(UserProfileResource)
}

public struct ZenResource: TargetType {
    public let path = "/zen"
    public let baseURL = NSURL(string: "https://api.github.com")!
    public let method: Moya.Method = .GET
    public let parameters: [String: AnyObject]? = nil
    public let sampleData = "Half measures are as bad as nothing at all.".dataUsingEncoding(NSUTF8StringEncoding)!
}
```
## Conclusion

This is really a first step and we could improve it I believe, so I'm curious to hear what you think about it.

Cheers üéâ
 Going to close this in lieu of #427.
  Hi there! I want to clarify what you're asking for ‚Äì are you suggesting a change to Moya's behaviour? What change are you looking for? 

As far as I know, `subscribeOn` isn't typically used, because its the observation that matters and its the observation that has the side-effects (not the subscription). Does that make sense?
 I guess I must be confused about the issue then ‚Äì I was thinking Moya returns an Observable and the user can do whatever they like with it. Alamofire sends callbacks on the main thread, and we simply send them through.

To clarify, is the distinction one between Moya allowing users to specify a scheduler to observe/subscribe on versus requiring users to call `observeOn`/`scheduleOn` themselves?

In any case, I think keeping the observe/subscribe schedulers as the main thread scheduler _by default_ is the safest move, since users will often update UI elements based on the callback. Actually, I'm kind of curious why you would want the callbacks on a separate thread for all requests ‚Äì is it a performance issue? 

Let me know what you think ‚Äì thanks for taking the time to clarify for me, I want to make sure I understand the problem fully before we make any breaking code changes :wink: 
 > I just want to Moya does not change the thread which I choose when using subscribeOn and ObserveOn.

Right, that makes sense. I guess what I'm confused by is, as far as I know, Moya doesn't do that does it? If it does, can you specify where in the code it does?
 But that's how Rx is supposed to work, no? The elements (network response) are made always on the main thread. If you want to observe them on a background thread, you should use observeOn, not subscribeOn (which I pointed out is rarely used).
 I'm basing my assumptions of how `subscribeOn:` works off of [the RxSwift-specific documentation](https://github.com/ReactiveX/RxSwift/blob/83bac6db0cd4f7dd3e706afc6747bd5797ea16ff/RxSwift/Observables/Observable%2BConcurrency.swift#L42-L56), which says:

> Wraps the source sequence in order to run its subscription and unsubscription logic on the specified  scheduler. 
> 
> This operation is not commonly used.
> 
> This only performs the side-effects of subscription and unsubscription on the specified scheduler.     
> 
> In order to invoke observer callbacks on a `scheduler`, use `observeOn`.

Which sounds like it differs from the general Rx feel. I've contacted the RxSwift maintainers to ask for a clarification.
 OK, let's back up a little here. This quote:

> In case observeOn isn't explicitly specified, work will be performed on which ever thread/scheduler elements are generated

Has nothing to do with which scheduler Moya is called from, it _only_ has to do with Alamofire. Unless you specify which [scheduler](http://reactivex.io/documentation/scheduler.html), the work (map, flatMap, subscribeNext, etc) will be performed on whichever scheduler the elements are _generated_ on. Alamofire always generates these on the main thread, and Moya just passes them through, so they go on the main thread scheduler.

I think you're asking for the following: if a network request is made on a background thread, then its response should be delivered on that same background thread, but that's not how RxSwift works. RxSwift observables generate elements from whatever scheduler/thread that they want, and it's up to you to observe them on a separate scheduler with `observeOn:`, otherwise RxSwift conventions specify it's up to Moya, and Alamofire, to decide whichever thread/scheduler they want since they are the ones generating the elements.

I hope that makes sense. If it doesn't, I'm happy to schedule a call with you and talk this out.
 >  I‚Äôm a user of Moya, and I expect that its tasks would be performed in whatever scheduler I would set calling onSubscriber

But Moya _does_ do this, like any Rx Observable. Just because it omits things on the main thread scheduler doesn't mean you can't shunt those to another scheduler. I'd encourage you to re-read the RxSwift `observeOn` function documentation ‚Äì it's the method that you should be calling to put observables onto other schedulers.
 This is typical behaviour in Rx; it sounds like you're looking for Moya to emit events on the scheduler you call `request()` from, but that's not how Rx works. You _do_ have control over the observables scheduling but only from the outside, which is again very typical. If you want the events to be observed on another scheduler, you have to call `observeOn`.
 OK, so I think we've discussed this thoroughly and have to come a conclusion that the behaviour Moya is exhibiting is idiomatic to RxSwift, though may be unexpected in a thread-based context (as Junior said, Rx is thread-agnostic). I'm going to close the issue, but if anyone has follow-up, feel free to comment, re-open, or open a new issue :cake: 
 I think I understand the two sides of this idea:
1. The ability to use RxMoya without Alamofire dispatching to a different thread
2. The fact that ^ is the expected behavior for a majority of apps using (Rx)Moya, to load a network resource and then show it in the UI

I was wondering how to get closer to the first scenario - strictly as a client of this library, not to change the implementation inside RxMoya.

Is it as simple as calling `.observeOn(ABackgroundThreadForMoreProcessing.instance)` after my `.flatMap { provider.request(.zenResource) }`?
So something like

``` swift
provider.request(.networkResource) // called on whatever the current thread is
    .observeOn(ABackgroundThreadForMoreProcessing.instance) 
    .flatMap(persistToLocalStorage) // called on the thread associated with ABackgroundThreadForMoreProcessing
    .flatMap(expensiveConversionToMakePresentableToUI) // called on the thread associated with ABackgroundThreadForMoreProcessing
    .observeOn(MainScheduler.instance)
    .subscribe { /* bind the result to UI here */ } // called on the main thread
```
 Also, maybe it would be cool to expose https://github.com/Alamofire/Alamofire#response-handler-queue through RxMoya? That way, as a Rx user, if I explicitly say `.observeOn` a specific scheduler, we can pass the queue related to that scheduler to Alamofire?

EDIT: it looks like somebody had a similar question about doing the same with Alamofire https://github.com/Alamofire/Alamofire/issues/1147  (another use case that involved Rx) - may be worth adding an optional parameter to the provider that specifies which queue to run the responseHandler on üëÄ
 Hmm, interesting. To answer your question:

> Is it as simple as calling ...

Yup, I've done this and it's awesome how simple it is. I'm up for including this as an optional parameter, should it go on the provider subclass initializer or on the request method? 
 That is so awesome ‚ù§Ô∏è

I'll also go ahead and open a PR to track progress on the optional param.

My thoughts on where to put the param is definitely impacted by what I'm currently working on though: I'm moving an SDK (almost) completely onto a background thread, so **all** my requests are going to be moved onto a background thread, and I'm going to call `.observeOn(MainScheduler.instance)` after I've parsed and cached the data and to pass it to a client

It makes more sense to me as in the provider subclass - so I have consistent behavior across all my requests, but I can be convinced otherwise. What do you think?
 Makes sense to put it in the subclass/initializer üëç
 Created #762 üôÉ
  Yikes! Hmm, I want to make sure I understand the issue: could you post a code snippet that demonstrates what you're doing with `concat`? We can take a look at it ‚Äì likely an issue from immediately stubbing means that the signal sends synchronously? Not sure, definitely need to take a look. Thanks for opening the issue!
 OK, that is a _seriously_ cool idea :100: 

To clarify, what's your test code look like? What are you expecting to happen, and what specifically is happening instead? 
 I think I understand your use case, not sure of the cause yet ‚Äì I'll need more time to think about it. I'll try to get back to you as soon as possible.

In the meantime, you've got a workaround at lest :sweat_smile: Thanks again for filing the issue!
 Still not sure what's going on here, will try to take a look. 
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Hey! 

First of all, thanks for the time spent on resolving the issue! Helps a lot üôå I've made some small comments, but other than that we are good to go! 
 @tbaranes Thanks again for the changes! You did great job in finding that one and fixing it! üíØ When the build will pass I will merge it. Cheers! üéâ
 @ashfurrow We will need an invite for @tbaranes :beers: 
 Done üéâ 

@tbaranes no pressure to accept the invitation ‚Äì if you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Yikes! Looking through [the changes](https://github.com/Moya/Moya/compare/6.1.3...6.2.0), I don't see anything that immediately jumps out that would cause a slowdown like this... 

Could you describe your setup in more detail? Are you using CocoaPods or Carthage? I looked through Alamofire's recent issues and didn't see anything that might cause this either. 
 Thanks for the details. I'm travelling right now but will try to reproduce locally. In the mean time, if anyone from @Moya/contributors could lend a hand, that'd be awesome. This is a pretty serious problem and we should make input top priority. 
 @tbaranes Could you please try to clone the repo, then use the pod from the cloned repo (using the path in Podfile, like in Demo project) and go from commit with version 6.1.3. to the latest one? We could get the commit that produced the error and work with it. Other than that I don't see a reason for the behavior on the spot. :cry: 
 @tbaranes Perfect! üéâ I was trying to reproduce the long request on 6.2.0 but got nothing so far. Might be some edge case that you have on your environment. I will try again anyways üòá
 Hmm interesting, yikes. If this is still an issue, let's re-open so this stays on our radar. 
 @tbaranes I'm not sure I quite follow the remaining issues, could you clarify? Is this a case of not calling `closure(request)`? 
 OK, this sounds like a serious problem. I'll take a look this afternoon. From your description, it sounds like I should just be able to load the Demo app (hitting GitHub's API) and see reeeaaally slow responses, aye?
 Ah, I think I see! So this:

> I reproduce these case by setting an endpoint / resolver, but without doing nothing in (like in my above example).

You mean something like this?

``` swift
{ (endpoint: Endpoint<StructTarget>, done: NSURLRequest -> Void) in
    requestedURL = endpoint.URL
    // specifically _not_ calling done(endpoint.urlRequest)
}
```

So the problem is not calling `done`? Or is it when you _just_ call it, as in your example?

``` swift
{ (endpoint: Endpoint<GitHub>, done: NSURLRequest -> Void) in
    let request: NSMutableURLRequest = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest
    done(request)
}
```

I've tried it the second way, and I'm not seeing the slow network calls.
  Looks great, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hey!

It is because you are assigning tuple of parameters to the activity constant. It is now a tuple and when you have your variables named then you can access it like you have shown `activity.id` etc. If you didn't have them named, access to it would be like `activity.0`, `activity.1` etc. If you want to assign your parameters not to a tuple, but to a variables, just specify them in the parenthesis, like:

```
case PATCHApiActivitiesIdJson(let id, let nextParam, let nextNextParam):
      return "/api/activities/\(id)/"
```

Hope it is now clear :beers: 
 @onemanstartup If you specify _only_ one parameter (when you need to assign more than one) in enum's case, it will convert it to a tuple of parameters, otherwise it won't. So in your case, if you have e.g. 3 associated types, when you specify one, all parameters are converted into a tuple (because you need to catch all the values), and then passed to the variable. If you specify all parameters, it doesn't convert it to the tuple, that's why `id` in my case isn't a tuple, because we have all parameters already. I encourage you to try tuples in playground, really fun stuff (e.g. you can pass tuple as one argument, when you have function with 3 parameters needed! - really similar situation). 

Also, don't worry, swift is evolving all the time, no-one knows everything about it, learning is a key. Keep it up  üéâ
  Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 Ahh, we probably need to publish a new release that includes the changes. Will do shortly. 
 Cool, this has been released under [6.2.0](https://github.com/Moya/Moya/blob/master/Changelog.md#620). Let me know if that works :+1: 
  cool, thanks!
  Simple answer: you pretty much just need two providers _per app_. One to send actual requests, and one for stubbing (during tests). 

Using a "shared provider" (a global) makes sense, so that you can set it to the "actual" or "stubbing" instance as needed. 

You might create additional providers to provide more stub providers (delayed, immediate, errors), but I can't think of a reason to have more than one "real" provider. Anyone else?

> On Feb 24, 2016, at 4:56 PM, r√©mi Ô£ø notifications@github.com wrote:
> 
> Hi, I have few questions  about the Provider.
> 
> Is it only 1 Provider per endpoint, and then per request ?
> If I have several request to do in my controller, do I need several Provider ?
> I need for each request add or not a special header in the request, so I use the Provider block construction, but It will recreate my Provider each time.
> ü§î
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 @colinta I use multiple providers because I have multiple endpoints I am calling (e.g. an auth service and a content service) so I like to have different named providers for readability (I also use different TargetType enums for each to stop them getting too complex)
 @remirobert you should be able to send as many requests on the same provider as you like. The bottleneck here (apart from the quality of the connection, type of request being made etc) is the underlying `NSURLSessionConfiguration`. It has a default value of 4 for `HTTPMaximumConnectionsPerHost` but you could initialise a provider with a custom configuration if you wanted to change that 
 Does that answer your questions @remirobert? üêº 
  Are you retaining the provider anywhere? I've seen 999 errors when whatever is making the request is deallocated
 @matteogazzato You just need to retain the provider. You can do it by e.g. setting the provider as a property for your controller. ‚úåÔ∏è
 @matteogazzato No problemo :beers: 
 That's right! If you don't have it in a property, it gets deallocated as soon as it leaves the scope.

## 

Ash Furrow
https://ashfurrow.com/  

On April 10, 2016 at 10:25:58 AM, philcai (notifications@github.com(mailto:notifications@github.com)) wrote:

> @remirobert(https://github.com/remirobert) What I don't understand is that Why should I keep a reference on it? If I don't, will the provider be released outside the scope(For example, I make the request in viewDidLoad, and don't keep a reference.)? I didn't inspect the implementation of Moya, it a little strange...
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub(https://github.com/Moya/Moya/issues/412#issuecomment-207993002)
 Agreed, hard to debug. Moya tries to make it hard to crash the app üòâ

## 

Ash Furrow
https://ashfurrow.com/  

On April 15, 2016 at 11:30:35 AM, nikos kanellopoulos (notifications@github.com(mailto:notifications@github.com)) wrote:

> @ashfurrow(https://github.com/ashfurrow) Shouldn't this crash however? It is very hard to trace these kind of bugs.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub(https://github.com/Moya/Moya/issues/412#issuecomment-210507282)
 @tomj it would be _awesome_ if you could make a PR with how would you like to be informed about retaining the provider. üôå 
 Thanks! Looks like we need to update `Basic Usage` with similar note: https://github.com/Moya/Moya/commit/000662a026faf04953163f615663db7b44be6afe
  Awesome, thanks!!
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Awesome, thanks! The CI failure on Travis was unrelated. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  > So this is only a proposition since I don't know if there is much against using `ParameterEncoding` as a `typealias` compared to our own enum.

In this PR I tried to remove explicitly typed enum for `ParameterEncoding` that only is a bridge between us and `Alamofire`. I think that `public typealias` sounds fine (at least for me :bomb:) and I've made few changes. 

From positives, we can forget about PRs like #404 and upgrading our code everytime `Alamofire` adds something. What was left, however, was the equality operator in our unit testing. BUT! Thanks to [this stackoverflow answer](http://stackoverflow.com/a/34769898/2340462) we can forget (at least for now) about it. If there are some negative aspects, please let me now.

I'm really eager to hear from your guys! Thanks üéâ
 Interesting! I had not thought of just using a `typealias`! My only concern would be making sure that Moya users don't have to be aware of Alamofire, but the unit tests don't `import Alamofire`, so it _should_ be fine. Cool!

Anyone else see any issues? Otherwise, I'd just want to make sure we document the change in the changelog. 
 @ashfurrow Exactly my thoughts, was worried that user would have to import Alamofire, but it seems fine. This was just a suggestion, because I thought that there was a specific reason we didn't try typealias yet ü§ï So if we end up doing this, I will definitely write up the changelog + in my opinion we could remove the `AlamofireMoyaMappingSpec` test since this should be now done by the Alamofire itself. ü§ìüëå
 Okay I've updated the PR to prepare for merge üòá
 Awesome, thanks so much!!
  Hey, this is pretty cool! Thanks for the kind words, too. 

I'll have more time this weekend to look closer at it. I agree there are limitations in centralizing things, especially as APIs grow. I've broken things into multiple enums in a project, and [we've been talking about structs](https://github.com/Moya/Moya/pull/376) for a little bit. The use of the reflection API is really clever.

I'm not sure if we can "turn the ship" at this point (the structure of the enums is... pretty engrained into Moya), but I'd love to borrow some of the ideas from this. We should then consider linking to it from our docs, if you're interested in maintaining it as a separate project.
 Hey! Sorry I didn't get to this over the weekend :grimacing: Work is very busy right now and I'm preparing for a few conferences. 

@Moya/contributors Would anyone be free to take a look, give feedback, and open issues to discuss ideas we should consider adopting?
 Instead of removing `DefaultEndpointMapping`, you could makeit  easier to port by having that method accept the `baseURL`, and then return a closure:

``` diff
-public final class func DefaultEndpointMapping(target: Target) -> Endpoint<Target> {
-    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
-    return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
-}
+public final class func DefaultEndpointMapping(baseURL: NSURL) -> (target: Target) -> Endpoint<Target> {
+    return { target in
+        let url = baseURL.URLByAppendingPathComponent(target.path).absoluteString
+        return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
+    }
+}
```

I like that your fork's changes are pretty small - but important question: does the current `enum`-based system still work?

I know you're critical of it, but... well, you're an army of ~2 at the moment.  As long as we stay compatible with using `enum`s to store the endpoints, I think this is great!  What I mean is: it's great to support _both_, but if we're just going to support one or the other, I vote that we stick with the `enum`.
 It looks neat! I also thought about structures, but I really like enums' type safety. I'll take a closer look today/tomorrow if we could use something from it @ashfurrow. Also, great job @Matthijn üí£
 I'm going to +1 this idea. I love Moya but while using it, one of my biggest frustrations was when working with/adding an endpoint... I would have to jump around these very large sections to get to the different parts of the enums. I think this is really great to have it all contained in a single place. 
 Interesting discussion. I'd prefer enums still for a couple of reasons:
- I like how enums give my endpoints structure (e.g. AuthTarget.SignIn and ContentTarget.LatestPosts)
- While the enum code has more boilerplate, it has less magic and so less of an understanding curve which is important to me in an open source library

That said I really like a couple of points in the structs (non generic providers especially) and would be interested in seeing how we could get some of them into Moya
 that's true, but it's more work for my use case which at the moment is a few different services with a few endpoints each (i.e. a micro services backend) 

i might be biased though, I do love swift enums :) 
 I agree this is really interesting, I just want to provide a word of caution about radically changing Moya, and a work of assurance to our existing users who might be worried about large breaking changes. 

I'm still unsure of the best approach to take here, but whatever we decide it will be done with careful consideration :+1: 
 Isn't it possible to just _wrap your struct_ in an enum value, and forward the `TargetType` calls to your struct?

``` swift
struct UserResource {
  let method: Moya.Method = .GET
  // ... and so on ...
}

enum API {
  case User(UserResource)

  var path: String {
    switch self {
      case let User(resource):  return res.path.resolve()
    }
  }
}
```

You could probably take this a step further:

``` swift
struct UserResource: Moya.TargetType {
 // ...
}

enum API {
  case Resource(Moya.TargetType)
}
```

This lets people who use enums (which is still _everyone_ at the moment) to continue without major refactors, but also lets you use your struct in the way you've proposed.
 @colinta that is _super_ cool. I think bringing that down deeper into Moya to have first-party support would be great, but at the very least that's a great solution _for now_ and we should probably document this idea :100: :100: :100: 

The first-party support could look something like a middleware between the Moya `Provider` type and `Target` type. Something that generates an `Endpoint` (which really _doesn't_ need to be a generic at all). I'm just spit-balling, but having a middle layer that lets users use either sounds like an ideal world. 

And I think it's worth noting that `enum`s _are_ a great solution ‚Äì that's why we used them in the first place. It just happens that they don't scale well. On the other hand, structs _do_ scale well, but spread domain knowledge of how an API works across several files (that's good for experts but can overwhelm beginners). Each approach has its advantages, so while an ideal world where either works is hard to imagine (and implement!) I think it may be worth striving for. 
 :+1: - last year [I mentioned](https://github.com/artsy/eigen/issues/324#issuecomment-87065971) that the current structure of Moya might not be able to handle our largest iOS project, with these ideas, it should be able to I think
 I think a face-to-face chat (over the internet) would be helpful here, to pin down: 
1. What we want.
2. How to implement it.
3. Who will implement it.
4. Migration requirements.

I've scheduled a poll here for Thursday, March 10th: http://doodle.com/poll/ef4kbz3h8zi3crmz Sorry it can't be earlier, but I'm travelling until then. The times there are in EST, so go ahead and let me know when we can help this public hangout.
 OK, going to have a hangout tomorrow at 2pm EST. I'll post a Google Hangout link here.
 I forgot to reply to the poll, but I'll be there! :-D
 OK, I've set up a hangout here: https://hangouts.google.com/hangouts/_/artsymail.com/moyahangout

Thought about recording it, but decided not to so people can speak freely. I'll summarize our discussion afterward and post here.
 Ok, here are the notes from the hangout:

We're going to continue using Moya's `enum`-first philosophy and @colinta's wrap-a-`struct`-in-an-`enum` solution. It has no breaking changes on the face value (more that shortly) and keeps with our existing philosophy (which I think would be unwise to change at this point).

@sunshinejr is going to send a PR with they're solution and we can discuss any technical problems and possible breaking changes there. @colinta has agreed to review the PR.

We also need documentation for what/why/how to do this, references _to_ that documentation added throughout our existing docs, and changes to Moya's documenting comments that reference the "Target enum." I can take care of the documentation, as well as adding a `struct` demo to our existing demo app.

How well or poorly an `enum` scales to handle an API is subjective; it varies from person to person, and even from endpoint to endpoint. It might make sense for a project to use both, for example. I like this technical approach because it maintains our current philosophy but provides flexibility for anyone who needs it.

@orta @colinta @sunshinejr Thanks again for taking the time to discuss this, and to @Matthijn and others who have brought up this idea. I must admit I was initially sceptical of this idea, but a working fork and this discussion have helped clarify the needs of Moya users. Thank you to everyone who participated :bow: 
 Thanks for continuing to encourage such a community-based project, @ashfurrow!  Looking forward to see where this goes.
 I think we've addressed this in #427, pending some documentation updates in #428 and #429. I'm going to close this issue, but if anyone has any further feedback, please feel free to comment where you think is appropriate; we can re-open this issue or open new ones, so don't be shy!
  So after seeing issue #403 and  [this](https://github.com/Moya/Moya/issues/403#issuecomment-182784469) piece of code, and especially:

``` swift
return endpoint.endpointByAddingParameterEncoding(.URL).endpointByAddingHTTPHeaderFields(["Content-Type":"application/x-www-form-urlencoded; charset=UTF-8"])
```

I decided to make a convenience method that we can call without chaining it. 
Please let me know if there is something I can improve. Thanks! üéâ
 Cool! I love this idea, and the implementation is :100: Good use of `nil` to represent a "missing value" :+1: 
  Hey! Thanks for the PR! üéâ

You are right, it returns `Optional` and we should change it, since it is compile-time error. Although in the Demo project [we actually use it a little bit differently](https://github.com/Moya/Moya/blob/master/Demo/Demo/GitHubAPI.swift#L21-L25). I think we should stick to one version and depending on which one we choose, make changes to Docs & Demo respectively.

**Edit:** Just choose one, update it accordingly and we gucci üôå
 Agreed, making it the same as the Demo project would probably be best I think (that's how I use it in production ¬Ø\_(„ÉÑ)_/¬Ø). Thanks @Legoless!
 Perfect! thanks again @Legoless  üéâ
  Hey! Thanks for the PR! üéâ
Although it seems fine to me, please add the test case for it. 
 Agreed, this is great, thank you :bow: Adding an entry to the changelog would be :100: and also a test (here's an [example](https://github.com/Moya/Moya/blob/7fb084e700b12e3f0fc577e3dd8853db78d7c623/Demo/Tests/AlamofireMoyaMappingSpec.swift#L21-L29) that you can build from). If you don't have time, don't worry! I can take care of it this weekend.
 Coo, thanks! There was a merge conflict from #406 so I merged manually.

Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Typically HTTP bodies come from parameters, looks like you have one that's specified in `JSON`. So to set the HTTP body to the json, you just need to tell Moya which parameter encoding to use. 

``` swift
var endpointClosure = { (target: MyCustomApi) -> Endpoint<MyCustomApi> in
    let endpoint: Endpoint<MyCustomApi> = Endpoint<MyCustomApi>(
        URL: url(target),
        sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
        method: target.method,
        parameters: target.parameters
    )
    switch target {
    case .Person(let json):
        return endpoint.endpointByAddingParameterEncoding(.JSON)
    default:
        return endpoint
    }
}
```

And that should work. You can check out the different options for parameter encoding [here](https://github.com/Moya/Moya/blob/aece4ebe3ad3cab946d8df93de4ee72c7024c8e7/Source/Moya%2BAlamofire.swift#L9).

Let me know if that helps :+1: 
 Also i'd like to add [this link](https://github.com/Moya/Moya/blob/23c4d506c5be9b94d9ecf16cb1f70893ad0b4f41/docs/Endpoints.md#request-mapping)
Hope it will be helpful 
 Yeah, good point! The request-mapping is later-stage stuff in the [pipeline](https://github.com/Moya/Moya/tree/master/docs#documentation), but it's there that I'll often play around with stuff I can't get working at higher levels. 
 That would URL encode it, which might be what you want, I'm not sure of your server setup. 

In general, yes, this is exactly how you customize attributes of requests, through the endpoints closure.
 I think we can close this one for now, if anything pops out, let us know! üêº
  This is useful when you just need the (possible) network response but don't care about the specific Error (see [this example](https://github.com/artsy/eidolon/pull/584/files#diff-ce82ff0f55f023dbcf5e8ab92d76c934R90) of usage).

It feels silly to have to write it, but it makes sense. May as well only write the silly code once :smile: 
 :+1: 
 Thanks!
  Caching would be handled by AlamoFire: https://github.com/Alamofire/Alamofire#caching (which in turn uses the system cache)

A cache is set at a system level by default but if you want to set specific sizes or handle it yourself, you can set your own cache:

``` swift
let URLCache = NSURLCache(memoryCapacity: 4 * 1024 * 1024, diskCapacity: 20 * 1024 * 1024, diskPath: nil)
NSURLCache.setSharedURLCache(URLCache)
```
 Moya itself has no concept of a cache so you don't need to apply the cache in Moya directly, you also don't need to set a cache for AlamoFire since it uses the system level cache. If you set the system level NSURLCache it will be used by both libraries (though it is already set by default)

There is a good description of NSURLCache here: http://nshipster.com/nsurlcache/

(you can also set a subclass of NSURLCache if you want more customisation)
 Great answer @wattson12 ‚Äì thanks for answering so quickly!
 I think that everything _should_ be clear now, so I'm gonna close it. üéâ If you have any more concerns, please let me now and I will reopen the issue!
  Hmm, tricky question ‚Äì you've got a lot going on here, and I want to make sure I understand your question first. 

Looks like you have a `Network` struct on top of Moya so that you can handle retrying? That's pretty cool, I've done a similar approach [here](https://github.com/artsy/eidolon/blob/24e36a69bbafb4ef6dbe4d98b575ceb4e1d8345f/Kiosk/App/Networking/Networking.swift#L22-L31). Then it looks like you're using ObjectMapper to parse the response data, right? Have you looked at [this library](https://github.com/ivanbruel/Moya-ObjectMapper), which has bindings for Moya and ObjectMapper? It should make it so you don't have to do this every time. 
 The problem with your layer is in this line:

``` swift
var a : T = try! response.mapObjectMapper()
```

Method used in the `Moya-ObjectMapper` bridge has kinda different declaration, without the `Mapper` suffix. I tested your code with change in the mapping part, specifically:

``` swift
var a: T = try! response.mapObject()
```

aaaand it works. So if this is your custom method, make sure you test it correctly or just use the method from bridge library. Hope that now you will resolve it!
 [This one](https://github.com/ivanbruel/Moya-ObjectMapper) that @ashfurrow was talking about. In README it has only `mapArray()` in examples, but [here](https://github.com/ivanbruel/Moya-ObjectMapper/blob/master/Source/Response%2BObjectMapper.swift) you can see that there are 2 methods, `mapObject()` and `mapArray()`.
  Was in need of ModelMapper bindings to Moya so why not include them here also.
 Fantastic, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Only problematic part i see now ‚Äî only 4.0.0 RC2 is available at Pods Spec repo 
 Also probably we should bump Moya version since RC4 update but i'm not sure yet, so decided to delay that change
 Cool. This is only failing because the RAC podspec wasn't pushed until like an hour ago. I'm going to re-run CI. 
 :+1: 
 Cool, this has been released as 6.1.3 on CocoaPods and as a GitHub release.
  Can you make us a pull request?
 #396 possibly does this ¬Ø_(„ÉÑ)_/¬Ø  
 Nah, that's just Carthage. We need to update our podspec.
 Moya updated to use release version of RC4.
  This is a _fantastic_ pull request :tada: Unit tests look solid, commented code, all :100: 

I'm going to merge, then add an entry to the changelog on `master`. Our plugins are getting more complex, what are your thoughts on adding some documentation? Could be worth opening an issue to discuss...
 awesome, thanks

yeah i'd agree it was a bit difficult knowing how to extend the network logger plugin (and it felt like the style of extension I made will get messy eventually)
  I've not used the ReactiveCocoa extensions with Moya. @justinmakaila would you take a look when you get a chance? 
  We currently have a barebones network request/response logging plugin: https://github.com/Moya/Moya/blob/bd4f36bd958eaadd01d5266db61b8705d5e02447/Source/Plugins/NetworkLoggerPlugin.swift But it just dumped out the data (converted to `NSString` to the console). It'd be cool to have something that tries to convert it to JSON instead, so it's more readable. Maybe a new plugin, maybe an option to the existing one. 

See conversation at https://github.com/Moya/Moya/issues/391 for details and motivation.
 A pull request would be awesome! I'm not sure I quite understand this:

> even formatted strings are printed without formatting when printing as part of the array

But I trust you'll come up with a good solution :+1: 
 Huh! I'd have thought it would deal with that :disappointed: Oh well, thanks again!
 That might be the core part of the issue, perhaps it has to escape the array in order to be printed?
 Fixed in https://github.com/Moya/Moya/pull/394 
  Hmm, I see the problem: the "terminator" is really in the `print` sense, something the logger terminates its output with. The `\n` you're seeing is due to the nature of the logging: we take a response, take its data, and turn it into a raw string. When we do this, and we that string is printed, the `\n` characters get printed. 

I _think_ that's what's going on. What you're looking for, I think, is a plugin to log the response data formatted as JSON, right? I think that's a reasonable request ‚Äì we should consider creating a new plugin, or even just adding an option to our current one to accommodate this. 
 Good idea, I think that'd be a great idea for a feature. I'm not sure I have availability to work on it right now, though. We'll take a loot (I've opened #392 to develop it). 

As for whitelist/blacklist, I've run into this issue before, too. Here's my solution: https://github.com/artsy/eidolon/blob/32442b5099f2cd9e937a2c79eb0c94079646bd39/Kiosk/App/Networking/NetworkLogger.swift It might make sense for you to write your own logger in the short term until we have these features built into Moya. Let me know if can clarify anything!
 Yeah, Moya is not designed to give that level of granularity for plugins, the Target is as low-level as we want to go. 

For the RAC issue, could you open a new issue? There are examples of using it in the Demo project's unit tests in the mean time. 
 _I think_ we can close this one for now, if anything pops out, let us know! üêº 
 Hey @beretis, we heard something similar before. Can you check https://github.com/Moya/Moya/issues/739#issuecomment-257120482 and see if it fixes for you?

If not, please open a new issue :wink:
  What does it look like in ember-data?
 If you're using RxSwift or RAC, you can use `flatMap`. I don't know if this approach is common, but [I do this](https://github.com/artsy/eidolon/blob/24e36a69bbafb4ef6dbe4d98b575ceb4e1d8345f/Kiosk/Bid%20Fulfillment/BidderNetworkModel.swift#L29-L37). 
 I'm gonna close this one, if you have more questions about it @joedaniels29, please let us know! üêº 
  This is great, thanks!
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hopefully this resolves #385. @yinanfang Does this clarify things?
 Cool, thanks! I think we need to apply this same fix in https://github.com/Moya/Moya/blob/master/docs/Providers.md and https://github.com/Moya/Moya/blob/master/docs/Examples.md too. 
 Ahh gotcha.  Will do.
 :bow: 
 @ashfurrow phew, went a little nuts on `Examples.md`: ab85328
 https://github.com/Moya/Moya/blob/ab853283d8463e53fe306ed2b52b623f9db88856/docs/Examples.md
 Looks amazing! üòª
  Fab, thanks!
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 Ah yes! I forgot to release, let me do that now. 
 Cooooool, this has been released as 6.1.2. Let me know if that works!
  Huh, good point. Would you mind submitting a pull request to fix it? 
 It should probably be cool to use `~> 2.0` - assuming @kzaher keeps to SemVer
 I think what @orta is saying is that by using `~> 2.0`, it'll take 2.anything which is what we want, right? You can continue to explicitly define versions (I think that's what "hard versioning" is?) and it'll work for you, and for everyone. Does that make sense?
 How so? I'd say that requiring 2.1.x is more aggressive than 2.x, isn't it? `~> 2.0` is the most flexible, right? Maybe I'm confused.
 In my opinion automatically receiving minor updates for dependencies is much better. 
I don't think RxSwift will break something during minor update. 
  Yikes! Yeah, our readme/documentation is out of date, sorry about that :disappointed: 

You can see a working example in the [Demo app](https://github.com/Moya/Moya/blob/a78b32e78c3db401c1038e3e819fca6105d9e830/Demo/Demo/ViewController.swift#L15). It's basically a Result type that's either success or failure. Let me know if I can clarify anything. 
 try/catch is much much more common in Swift ‚Äì it replaces Objectice-C's NSError model, actually. In this case, it's due to JSON parsing. 
 Attempting fix w/ PR #388.
 Thanks @colinta !
  Hmm, yeah. nothing pops into my head immediately. I agree that automating this somehow would be :100: 
 I think mapping responses to models is something that is quite far away from a networking abstraction library such as Moya. I do not see this kind of stuff directly within Moya.

That said, you could create an internal protocol `JSONMappable` that defines the `responseType` property and conforms to `TargetType`. Your API definition(s) may then conform to `JSONMappable`.

I've done something similar with [Argonaut](https://github.com/aschuch/Argonaut) but opted for an implementation where you can optionally parse the response to Argo model(s).
Something along the lines of

``` swift
Provider.request(.Profile)
    .filterSuccessfulStatusCodes()
    .mapJSON()
    .mapToType(User) // maps to a User model
```
 Ok, I guess you can do something like this.

``` swift
// Create your own protocol that extends `TargetType`
protocol JSONMappableTargetType: TargetType {
    var responseType: ALSwiftyJSONAble { get }
}

// Implement your Moya enum using `JSONMappableTargetType `
enum ExampleAPI:  JSONMappableTargetType {
    // Implement all TargetType properties

    var responseType: ALSwiftyJSONAble.Type {
        switch self {
        case .X:
            return GetResponse.self
        // etc.
    }
}


// Then add an additional request method
func requestType<T>(target: JSONMappableTargetType) -> SignalProducer<T, Error> {
    return request(target).mapObject(target.responseType)
}
```
 If this is wrapped up, I'm going to close it. Feel free to re-open if we can help further. 
  Great idea! Will wait for :green_apple: then merge and release. 
 Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 Fabo ‚Äì this has been released as 6.1.1, thanks! :tada: 
 I'm sure you will :bow: But no pressure to, we all have lives outside open source!
  Fab! Gonna merge without waiting for CI. 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  The built-in `DefaultAlamofireManager` as parameter's default value instead of the singleton `Alamofire.Manager.sharedinstance` is now used when instantiating `ReactiveCocoaMoyaProvider` and `RxMoyaProvider` as well. Fixes #373.
 Super, looks great!
 Cool, version 6.1.0 has been released with this fix. Thanks again! :tada: 
  I, for one, consider this behavior to be _correct_, because Moya is only responsible for sending and receiving, not interpreting, the requests and responses.

A "Failure" in this context is a total network failure: either couldn't send, or couldn't receive the request.

In the Ello app, we re-send failed requests.  When the response is a 4xx, we create an error object (based on JSON data that comes back) and pass _that_ to a failure closure, which displays the error to the user.
 The only response that we handle from inside our Provider is a `401 Unauthorized`, which triggers a request for a new token (and while that is in flight we queue up requests, then send them once the new token is in hand).  500s are plain-jane errors that we show to the user, in this case with a generic error message (if no JSON / error message is provided from the server, we have a fallback error message)
 @marchinram: Is it possible to use a plugin? That would be awesome!

Both @colinta and I are using static functions after we see errors, that parse the JSON in an presentable error model. @colinta's code is actually open source, his function is called `generateElloError` https://github.com/ello/ello-ios/search?utf8=‚úì&q=generateElloError
  Makes sense to me. If CI passes we can merge, then make a small release. Thanks!
 Looks like no one has released an RC 2 podspec yet. I think https://github.com/mhuusko5/Podspecs is the canonical location to update them, since the ReactiveCocoa folks decline to maintain the podspec themselves. 
 I've hit the "Rebuild" button on Travis now that the RC 2 podspec is on trunk. Thanks @aloco :100: 
 Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
 OK, should be good to go on 6.0.1 :+1: 
  While I really like a lot of what I see here, I see that not only does this refactor the Provider code (and adding the Backend looks like a good idea), it also reverts the StubClosure back to the StubBehavior.

In short, I think there are too many breaking changes to have this considered as just a refactor - merging this would require a huge usage change on top of the mindshift.

I would rather see this broken into 2 or 3 PRs: One to just introduce the `MoyaBackend`, another to discuss reverting `StubClosure` to `StubBehavior`, and a third to move `Moya.swift` code into `Provider.swift`.  Does any one else feel like this PR is just _too huge_ to get merged in?
 Aye, @colinta I encouraged @jasl in https://github.com/Moya/Moya/issues/358 to open a PR to discuss some of the changes. I'll have time hopefully to look it over tomorrow!
 Yup, to be clear, I really _like_ the parts related to making the provider non-generic.  My worry is that the other changes introduced here will make it hard to keep the discussion focused on just that one thing.  Thanks for being open, though, and I look forward to seeing where this goes!
 @jasl Yeah, sometimes we want to stub immediately and sometimes we want a delay. Always in unit tests, of course. 
 Could be a use-case for an `enum`:

``` swift
struct StubBehavior {
    case .NoStubbing
    case .ImmediateStubbing
    case .CustomStubbing(closure: T -> Int)
}
```

Or something like that. I don't feel like the overhead of the current usage is bad at all, not sure how much extra utility we'd get changing the stub parameters (again lol) given everyone would have to update their code.
 So yeah, lots of interesting ideas in here, some I like and some I don't. I'm not sure I'm the best arbiter of what should/shouldn't be considered though ‚Äì Moya is too close to me and I don't think I can be impartial.

@Moya/contributors If you have time, taking a look through this PR and grabbing ideas to consider would be :100: Thanks again @jasl ‚Äì I think from this PR we can break out into smaller issues to consider the pros and cons of each idea individually. Does that make sense?
 Actually, I take back my comment about always stubbing in unit tests :speak_no_evil: [Eidolon](https://github.com/artsy/eidolon) uses stubbed responses for an offline mode available to OSS developers who don't have access to our API, as well as Artsy developers when they're offline. It's often useful for development, though I agree in _production_ it does seem weird. 
 Taking another stab at analyzing this, but again it's tricky because there are _many_ ideas all getting thrown into one PR.  I would still love to see this broken out into 3 (or more!) PRs.  So far, I've identified these changes:
1. Refactor Endpoint so that it doesn't neet `<Target>`.
   - This was the original goal, wasn't it?  And it looks like this would be a straightforward change.
2. Adding MoyaBackend - this looks like a nice way to separate the "real vs stubbed" response behavior.
   - Adds `Source/Backend.swift`, and refactors `Source/Moya.swift`
   - btw, looks like `MoyaProviderStubBackend` doesn't use or need the `manager` instance
3. Revert `StubClosure` to `StubBehavior`.  The most important reason, I think, for the `StubClosure` is because the `stubbedData` needs to be called lazily.  If this can be accomplished with `StubBehavior`, I think I'd be fine with it.
 ###### Some more questions
- What does `MoyaCommonProvider` do? I don't see this class used anywhere, but it is defined in `Provider.swift`.
- `DefaultCommonEndpointMapping` and `DefaultEndpointMapping` do the same thing, can this be simplified to just having `DefaultEndpointMapping`?
- `toNSMutableURLRequest` is only used to calculate a hash value (`public var hashValue: Int { return self.toNSMutableURLRequest().hash`), why not use `self.urlRequest` there?
- I see that `CancellableToken` has been made public, but I think it can remain private if you change the return type to `Cancellable` in `MoyaProviderBackend`

###### Most importantly

I labeled this `enhancement`, but then that begged the question: _what_ is being enhanced here?  I see a lot of changes (too many in my opinion, to be very honest), but I can't point at any one thing that is greatly _improved_ by these changes. @jasl what is the most important feature that is being added?  @ashfurrow what do you see as the best ideas here?
 Hi again @jasl, we've created a first-party approach in #427 that I think might work. Does that satisfy your needs? 
 Ah, I see. So you're looking to use _any_ struct that conforms to the `TargetType`, not just a specific one. That makes sense. I've opened https://github.com/Moya/Moya/pull/430 to try and fix that. Would love your feedback :cake: 

We need to balance the needs of different users, and while I understand wrapping the struct in an enum like this may not be the best approach from everyone's perspective, we've had to make compromises. I've been working with other maintainers for weeks on this issue and I feel like this is the best approach. If you like, I'd be happy to have a Skype call and chat about it, and hear more about your ideas to make Moya even better. Thanks again for the PR :bow: 
 Don't worry about renaming at all, it's open source because we want people to experiment however they like! I'll add you on Skype and see when you're free.
 After chatting with @jasl today, I've moved their feedback into #434 to discuss point-by-point. We'll borrow the ideas we can and bring them into Moya one-at-a-time, so I'm going to close this PR. However, that doesn't mean we should stop discussing the ideas. There are some really neat ones here, and I've asked in #434 that we list specific ideas to bring over, so please continue the conversation there :bow:
  Hi! Just to be sure, do you have Run Script which fixes well-known issue with frameworks? 
It's on 4th step [here](https://github.com/Carthage/Carthage#if-youre-building-for-ios-tvos-or-watchos)
 So you have Moya & Result & Alamofire added to project and all of them specified in script? 
I remember i had issue after Moya update when i forgot to add Result.framework too

Probably if all is set up properly it would be good to share some sample proj which reproduces issue?
  Hey there! Thanks a lot for contributing to Moya! I've invited you to join the Moya GitHub organization ‚Äì no pressure to accept! If you'd like more information on what that means, check out our [contributor guidelines](https://github.com/Moya/contributors) and feel free to reach out with any questions.
  Hmm, hard to say what's happening without more code. The underlying error isn't too descriptive in this case. 

Have you made any recent changes? Upgraded the library? Can you double-check the base URL?
 Oh, forgot to say: sorry about this! We try to have descriptive errors. Thanks for opening the issue, we'll do our best to figure out what's going on :+1: \
 Well! Glad to hear it's working :smile: It must've been a network issue, since an error like that indicates that there is no response (otherwise, you'd get a status code and stuff). 
 Hey there! Sorry you're having a problem ‚Äì not sure which version of Moya you're using, but an error code of 5 suggests that you can access the underlying error. Check the source code out here: https://github.com/Moya/Moya/blob/master/Source/Error.swift
 That's strange, RxSwift should already be using the new error-handling. You can use the Swift `case` syntax to unwrap the enum and the underlying data: https://github.com/artsy/eidolon/blob/24e36a69bbafb4ef6dbe4d98b575ceb4e1d8345f/Kiosk/Bid%20Fulfillment/PlaceBidNetworkModel.swift#L49
 Just to chime in here, what I think @aleufms understood was that he could use the `nsError` property of the [Error](https://github.com/Moya/Moya/blob/master/Source/Error.swift). If it is true, yes this is deprecated as of now, but the discussion about it is still going on in #489. 

Additionally, in your case you could just get the `.Underlying(let error)` case from the response error, as @ashfurrow mentioned. Having in mind your response error has a name `responseError`, you can get it as following:

``` swift
if case .Underlying(let error) = responseError {
    // Now you can use error property as an object of NSError
}
```

Hope it helps! 
 With @sunshinejr's comment, I think this is closed. Please re-open if not.
  Hmm, good question. Based on the current architecture, the plugins are only notified about the response (they're more meant for dealing with requests, not responses). For ObjectMapper, have you taken a look at this library? https://github.com/ivanbruel/Moya-ObjectMapper
 Yeah, I understand that perspective. But I'm not sure that level of extensibility is right for Moya's level of abstraction. 

What you're describing sounds like it might go well with the reactive approach, which [I've used here](https://github.com/artsy/eidolon/blob/32442b5099f2cd9e937a2c79eb0c94079646bd39/Kiosk/Bid%20Fulfillment/BidCheckingNetworkModel.swift#L124-L128). Happy to clarify anything. 
 Cool cool ‚Äì let us know if you have any other questions or if we can clarify anything else :+1: 
  Hey there! Sorry you're having trouble. It looks like you're just customizing the endpoint mapping, right? If that's the case, you don't have to subclass the provider at all, you can just pass in the closure when you create the provider. Subclassing the provider is generally only needed when you have to change the behaviour of the `request` method. For example, [waiting until there is internet](https://github.com/artsy/eidolon/blob/04a0c8488525be4b918e212e92a29f143e0f5838/Kiosk/App/Networking/Networking.swift#L22-L31) before sending the request.
 Definitely ‚Äì we need more examples for sure, and are tracking ideas here: https://github.com/Moya/Moya/issues/189 Let me know if there's anything else I can clarify :smile_cat: 
 I think we can close this one, if you have any ideas for our new [Examples docs](doc/Examples), please let us know! üêº 
  I hit an issue (#367) when attempting to use Moya's `Response` type in my code. When used from outside the module, it's easy to end up in ambiguous states where the compiler can't tell if you want Alamofire's `Response` or ours.

Since Alamofire is a dependency, should we consider prefixing or renaming `Response` to avoid this potential confusion? The fix is admittedly simple once you realize what's going on (referring to the type as e.g. `Moya.Response`), but may not be obvious to people who haven't encountered it before.
 I'm not sure I have a strong opinion either way, just wanted to open the table for discussion.
 Definitely, thanks for opening the issue @tomburns. 

This question is bigger than just Moya and something the entire Swift OSS community will need to answer. I don't have strong opinions, either. Maybe this is the new norm and we just need time to get used to it. Of course, lots of people said the same thing when _The Phantom Menace_ was released and look how that turned out.

Does the compiler error present when only importing `Moya`'s module, or when you link with Alamofire at all?

In any event, documentation and sample code should be updated to reflect the fact that using Moya's `Response` type requires namespacing it with `Moya.Response`.

/cc @Moya/contributors 
 This has been discussed previously. I think what is currently implemented is the standard swift way. You can always alias if you want to use something else right?
 @gregpardo Certainly, and perhaps the real issue here is that the Xcode error when you encounter this sort of ambiguity doesn't volunteer the more specific types as a FIXME. As I said, I wasn't sure any action was necessary here, but figured it couldn't hurt to make sure we had consensus either way :)

Thanks for the discussion!
 I think we can close this one, but if there is something to add to the discussion, please let us know! üêº 
  Thanks @aamctustwo ‚Äì much appreciated :bow:
  Yikes! I'll take a closer look later, but when I encountered problems upgrading eidolon to Moya 6, most problems were solved by being more explicit about closure parameter/return types. You can check out our existing inplementation, too. 
 I'm having the same problem. I thought it was a derived data issue or something like that but nothing I could do was working. When I removed my plugins it would compile but none of the autocomplete was working and it was seeming to happen with other pods to. It was driving me a little crazy glad I'm not the only one. 
 Update for me. I was also getting a casting to objc bridge error on my plugins array. Which is odd because I wasn't doing any objc. 

``` swift
let plugins = [somePlugin]
```

Now works as

``` swift
let plugins:[PluginType] = [somePlugin]
```

Not sure if this is a related issue but was a similar obscure result. I'm guessing you have to be explicit in such a case because the compiler shouldn't assume you don't want to add other types of objects to the array later.
 Ah, sounds like trouble :) Is this issue good to be closed? 
 It may be more of a swift 2 lint/compile error than anything else. Just seems like sometimes the errors are really unrelated to what is actually going on.
 Hey, don't worry about it! Issues are the perfect spot for questions like this. I guarantee other Swift developers are getting similar errors, and if we debug problems like this in the open, then they won't have to fix it by themselves next time :wink: 
  Figured it'd be easier to merge and have another PR for such minor issues ¬Ø\_(„ÉÑ)_/¬Ø
 :+1: 
  Yeah, Moya 5.3.0 uses RxSwift 2, which changed `just` to be a static function on `Observable`. This means `just(whatever)` became `Observable.just(whatever)` (or `.just(whatever)`). Running `pod update Moya` should fix this :+1: 
  Looks awesome, thanks! üéâ
 I've invited you to the Moya contributors list ‚Äì no pressure to accept! If you're curious about what being a contributor means, [check out the docs](https://github.com/Moya/contributors).
  Thanks for the kind words! I'm not entirely sure what the identity is, but I've only used Moya for OAuth/XApp/Basic HTTP authentication methods. As you noted, [the request closure](https://github.com/Moya/Moya/blob/master/docs/Authentication.md#oauth) is where I would think this would go, but it's clearly a no-go if you need only _some_ endpoints to be authenticated.

A Plugin could work. We [have a basic auth one](https://github.com/Moya/Moya/blob/master/Source/Plugins/CredentialsPlugin.swift) but it [has some issues right now](https://github.com/Moya/Moya/issues/326). I've done something [here](https://github.com/artsy/eidolon/blob/cb31168fa29dcc7815fd4a2e30e7c000bd1820ce/Kiosk/App/Networking/XAppAuthentication.swift#L8) that might work, but that approach relies on RxSwift/RAC.

A sort of hacky way to do this (for now, until we have a better answer) is to use the `requestClosure` and check against the Endpoint's URL or something. It's not great, but it would work. 

This seems like a common-enough problem that we should a) fix #326 and add documentation on how to do general-purpose authentication plugins.
 Ah, I see. Good point. I'm not sure if the best way to approach this ‚Äì the existing examples focus on authentication outside of Moya _or_ authentication at the Target level in the endpoints closure. 

@Moya/contributors any suggestions here? 
 Any further discussion on this? 
 Going to close this issue, but I'll note that there's a demo of a re-authentication plugin in this issue that's worth checking out: https://github.com/Moya/Moya/issues/744 Thanks again for opening @Skornos!
  Hmm, good question! I think the filtering idea you have could work, but it's not ideal. Like, Moya should handle this somehow. Let me think about it, maybe someone else has a better idea. In the meantime, filtering is your best bet. 
 Ah, that makes sense! We should add that as an example to our documentation. Would you like to send a pull request? :wink:
 Cool, thanks! Take your time, no rush! :christmas_tree: 
 With a separated out TargetType for each endpoint I take this approach:

``` swift
var parameters: [String: AnyObject]? {
    let optionalParameters: [String: AnyObject?] = ["value": nonOptionalValue, "optionalValue": optionalValue]
    return optionalParameters.mapMaybe { $0 }
}
```

where mapMaybe is to take a [String: AnyObject?] to [String: AnyObject]

As from Swiftz:

``` swift
func mapMaybe<Value2>(f : Value -> Value2?) -> [Key : Value2]
```
 Interesting discussion! I hadn't considered making the provider non-optional, since the original Moya was heavily configuration-based (where now you can create a provider with sensible defaults by passing in no initializer parameters at all).

I can see both sides to this. On the one hand, having a shared provider for all networking (multiple target types) would be convenient. OTOH, custom behaviour around specific cases of the enum (or whatever) is really hard without generics ([see this example](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-)).

I'd be comfortable moving away from generics if there is a compelling reason and if we can keep the existing philosophy and customizability intact. That second part is a big question mark right now, and it may be outside the scope of optional parameters ‚Äì maybe it's time to make a new issue?

It's also worth noting that for a large number of endpoints, something like a generated-enum may work, which has [been an open issue for some time](https://github.com/Moya/Moya/issues/73).
 Yeah, that _compiles_ but as I tried to describe in my earlier comment, it betrays the philosophy of Moya. Conditionally casting a parameter to a specific enum (or one of several enums, to expand to many) is... icky. 

At a higher level, we're discussing the separation of the one-to-one relationship between the provider and the target type. That's a big change, I think we can all agree, and it's one that would need to be taken with care and thoughtfulness. 
 Sounds good! 
 I _think_ this is resolved, not 100% sure. @jasl sounded like you had an idea of what to do next here, is that right? 
  Did you get this figured out? Is it a duplicate of https://github.com/Moya/Moya/issues/356 ?
  This PR suppose to fix issue #350 by calling `request.resume()` manually.
 As discussed in #350 , I've updated PR with some more commits. Would you take a look?
  Great, thanks!
 The CI failure isn't your fault, btw :sweat_smile: 

I've invited you to the Moya contributors group ‚Äì no pressure to accept! You would have the ability to review+merge others' PRs. There's [more info here](https://github.com/Moya/contributors). 

Thanks again for the PR!
  Checkout `path` & `parameters` which mentioned in documentation [Target](https://github.com/Moya/Moya/blob/master/docs/Targets.md).

Hope this is helpful :)
  _Hopefully_, this will fix the intermittent false negative on CI. I also removed all the unnecessary async testing (we never really need to use `toEventually` in our case).

Additionally, I changed the release task to accommodate [this issue](https://github.com/CocoaPods/CocoaPods/issues/4326) and cleaned up some matchers.

Fixes #349.
Fixes #259.
 This is an interesting PR (humblebrag) specifically from a unit testing perspective; I'm happy to answer questions or clarify changes made to our use of matchers, etc.

@Moya/contributors this would also be a good "first PR review" if someone out there hasn't reviewed+merged one before.
 I wonder if the world would benefit from RAC factoring out the Scheduling library into its own framework.
 Open an issue ‚Äì they seem to be all about small libraries. 
 I _think_ I've addressed all the feedback; GitHub isn't collapsing it since it's on the commits instead of the PR ¬Ø\_(„ÉÑ)_/¬Ø

![](http://gifs.ashfurrow.com/party.gif)
  Before all, there is nothing to apology, and thank you for addressing this issue :100: 

The problem is probably from [here](https://github.com/Moya/Moya/blob/master/Source/Moya.swift#L220), inside `manager.request(urlRequest)`, it call `resume()` immediately.

In my opinion, this is a bug and should be fixed. I'll look forward and propose a PR to fix this.
 That's unusual! And also bad! That shouldn't happen! A PR to fix this would be most welcomed. Hopefully there's a way to retrieve the AF request object without side-effecting.
 I've opened an issue on Alamofire to get this sorted out. We'll see how it goes.

The problem appears to be how we structure the authentication plugins. Maybe we need to rethink the plugin architecture. Actually calling the network while stubbing seems like a serious issue and we should prioritize. 
 @cnoon has provided valuable feedback: https://github.com/Alamofire/Alamofire/issues/986 I believe we should follow their advice and use a custom manager instead of the shared one (while still allowing devs to pass in their own manager if they want). 

Thoughts? Feels? 
 Hmm, solution is surprisingly simpleüòÇ ... but it do solve our issue.  It's OK for me. I'll update PR #354 if there is no objection. 
 Sounds good, thanks! In the AF issue, they had some guidelines about how to create a manager with good defaults. 

We also need to update our documentation to make it clear that we don't use the shared manager anymore. Since this is a breaking change, the next Moya version will be 6.0.0.
 Yeah, in short terms, I think it would be suffice to modify ade1589 with default configuration:

``` swift
    public final class func DefaultAlamofireManager() -> Manager {
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders

        let manager = Alamofire.Manager(configuration: configuration)
        manager.startRequestsImmediately = false
        return manager
    }
```
 Yup! I would add a comment pointing to the issue, too, in case someone is curious. 
 Looks like this is fixed in the current master: https://github.com/Moya/Moya/blob/d2897a91ee3b92214fd6e8d7636cec96a019f2dd/Source/Moya.swift#L306-L314 Going to close, thanks again for opening and the discussion!
  I just wanted to start a discussion around patterns on the `TargetType`. The existing solution with Swift `enum` seems to enforce the implementing client code to have huge switch statements based on the endpoint. I don't think this scales well for many endpoints and doesn't really play well with request or response parsing. I have adopted a struct based solution where each target is a struct with parameters to each passed into the init.

This is related to #347.

Example:

``` swift
func moyaErrorToMyAPIError(moyaError: ReactiveMoya.Error) -> MyAPIError {
    return .MoyaError(moyaError)
}

protocol MyTargetMarker {}

struct MyTarget: TargetType, MyTargetMarker {
    let targetType: MyTargetType

    init(_ targetType: MyTargetType) {
        self.targetType = targetType
    }

    var baseURL: NSURL {
        return targetType.baseURL
    }

    var path: String {
        return targetType.path
    }

    var method: ReactiveMoya.Method {
        return targetType.method
    }

    var parameters: [String: AnyObject]? {
        return targetType.parameters
    }

    var sampleData: NSData {
        return targetType.sampleData
    }

    var parameterEncoding: ReactiveMoya.ParameterEncoding {
        return targetType.parameterEncoding
    }
}

protocol MyTargetType: TargetType {}

extension MyTargetType {
    var target: MyTarget {
        return MyTarget(self)
    }
}

enum MyAPIError {
    case Custom(ErrorType)
    case MoyaError(ReactiveMoya.Error)
}

protocol ProducerTargetType: MyTargetType {
    typealias ResponseType = Response

    func producer(provider: ReactiveCocoaMoyaProvider) -> SignalProducer<ResponseType, ErrorType>
}

class MyAPIProvider: ReactiveCocoaMoyaProvider<MyTarget> {
    func request<T: ProducerTargetType>(token: T) -> SignalProducer<T.ResponseType, MyAPIError> {
        return super.request(token.target).mapError(moyaErrorToMyAPIError).flatMap(.Latest) { response in
            return token.producer(self)
        }
    }
}


extension ReactiveCocoaMoyaProvider where Target: MyTargetMarker {
    func requestProducer(token: Target) -> SignalProducer<Response, MyAPIError> {
        let producer: SignalProducer<Response, MyAPIError > = request(token).mapError { MyAPIError.MoyaError($0) }
        return producer
    }
}

struct GetUserTarget: MyTargetType, ProducerTargetType {
    typealias ResponseType = MyUser

    var path: String {
        return "/user"
    }

    func producer(provider: MyAPIProvider) -> SignalProducer<ResponseType, MyAPIError> {
        return provider.requestProducer(target).flatMap(.Latest) { response -> SignalProducer<ResponseType, MyAPIError> in
            return response.mapJSONValueProducer().toDecodedProducer()
        }
    }
}

struct CustomGetSomethingTarget: MyTargetType, ProducerTargetType {
    typealias ResponseType = MyCustomType

    var path: String {
        return "/something"
    }

    func producer(provider: MyAPIProvider) -> SignalProducer<ResponseType, MyAPIError> {
        return provider.requestProducer(target).flatMap(.Latest) { response -> SignalProducer<ResponseType, MyAPIError> in
            // custom parsing and processing 
        }
    }
}
```

With a little boilerplate, this allows each `TargetType` to be defined as a separate object that can be passed to the API provider to initiate a request.

I would love/appreciate any feedback. 
 I've heard of people doing this ‚Äì @swizzlr I think ‚Äì but this is the first code I've seen. Looks really cool! I think this approach is definitely worth adding to the docs. Thanks @mpurland!
 At Network Locum, we're taking this struct based approach as it's a little more flexible. The enums with the vast proliferation of AVs is here, though since an AV is really just a tuple, I could typealias those away, or embed them in a struct, since they form a pack of relevant query parameters.

You can see I've taken something of a middleground over the usual enum approach, versus the innovative one above. @mpurland, it would be incredible if you could write this up somewhere and add a link to the Moya docs, or even better contribute back to them. I love the economy of the protocol extension, faking a base class without the cruft of inheritance with opt-in behavior!

``` swift
public struct LocumTarget {
  public enum Environment: String {
    case Dev = "com.networklocum.environment.dev"
    case Live = "com.networklocum.environment.live"
  }
  public enum Action {
    case FindJobs(postcode: String, radius: Int, fromDate: NSDate, weekdays: Set<Job.Weekday>, timePeriod: Set<Job.TimePeriod>, hourType: Set<Job.HourType>, includeUrgentCare: Bool, token: String)
    case FindJobDaysAtFollowedPractices(fromDate: NSDate, weekdays: Set<Job.Weekday>, timePeriod: Set<Job.TimePeriod>, token: String)
    case GetUserToken(saltedHashedPassword: String, email: String)
    case GetSaltForEmail(email: String)
    /// Nil status implies no filtering, so return every application
    case GetUpcomingApplications(token: String, filteredByStatus: Application.ApplicationStatus?)
    case GetUser(token: String)
    case ApplyForJob(jobID: String, userToken: String)
    case WithdrawApplication(applicationID: String, userToken: String)
    case GetApplicationByID(token: String, id: String)
    case PostViewedJobDayEvent(jobDayID: Int, token: String)
  }
  public let environment: Environment
  public let action: Action
  internal init(environment: Environment, action: Action) {
    self.environment = environment
    self.action = action
  }
}
```
 This has been implemented with `StructAPI`, and I've opened issue #552 to document its use properly. I _think_ this addresses everything, please re-open if there's more to do.
  I just wanted to start a discussion around response parsing for `TargetType`. I have an existing solution using ReactiveMoya with some protocol extensions. It would be nice to have it built into Moya though.

Example:

``` swift
protocol ProducerTargetType: MyTargetType {
    typealias ResponseType = Response

    func producer(provider: ReactiveCocoaMoyaProvider) -> SignalProducer<ResponseType, ErrorType>
}
```
 Sounds like this is resolved, feel free to re-open if not üëç 
  This should go along with https://github.com/mhuusko5/Podspecs/pull/3 or https://github.com/mhuusko5/Podspecs/pull/2

@mhuusko5 FYI
 Cool! I'm pushing to trunk now 
  Similar to way it's done via CocoaPods where podspec contains different types(Core/Rx/Reactive).

Right now when we pull Moya via Carthage ‚Äî all 3 versions are downloaded and compiled (as well as specific dependencies for each one). 
Obviously, that is much more time-consuming than pulling only 1 version.
Example: `carthage update --platform tvos  856.54s user 145.58s system 445% cpu 3:44.89 total`
And yup, i think this is not highest-priority thing because this is an issue mostly for first Carthage run with Moya at Cartfile.

I've checked Carthage and found zero answers about such possibility. 

From all stuff i wrote above i have 3 different assumptions: 
- I'm wrong (feel free to tell me) 
- This is an issue and Carthage actually has way to solve this 
- This is an issue and Carthage has no ways to solve this (probably i'll create an issue on it's repo than). 

I had a thought about dealing with that via 
- Tags 
- Separate branches (seems to be painful to support) 

But i just hope to get any advice before starting to dig into that without even knowing if it's reasonable to spend time on this. 

Thanks for attention :)  
 :disappointed: Thanks, hope it will get better soon. 
 Correct ‚Äì we tried multiple repos but it got out of hand, quickly. Moya was created as a CocoaPod, and the Carthage support we have today was added after the fact by volunteer contributors (we're very grateful). The Carthage team has been asked for a subspec-like feature to accommodate this, but they have decline (it's antithetical to how they believe libraries should be built). 
 Totally ‚Äì everyone has different needs :)
  As discussed in #338, this move to using the standard result type instead of creating our own. Due to Alamofire having its own result type I had to move some things around to remove the name clashing. I had to move things to other files since the antitypical result type cannot be prefixed since the name of the framework is `Result` and using `Result.Result` gives a compiler error.

This should work with cocoapods just fine but there seems to be issues with carthage. ReactiveCocoa versions give errors for tvOS and watchOS targets since the minimum deployment target is now 2.1 and 9.1 respectively instead of 2.0 and 9.0. The same thing happens with the RxSwift version for tvOS. Maybe there was a change in Xcode 7.2 that causes this problem or these frameworks don't have the proper setting for the minimum deployment target anymore. This needs investigation.
 Cool, thanks for looking into this. We could certainly just bump up out minimum deployment versions. Anyone else free to help on this? 
 I can try to bring proper solution 
 Did bumping to RC1 fix the issue?
 Looks good to me!
  This fixes a pretty egregious bug where underlying errors would be rarely, if ever, handled appropriately. In short, the presence of an NSURLResponse would cause Moya to discard the underlying error entirely, which is _not good_.
 Interesting, good catch :+1: It could _probably_ stand to be tested ‚Äì I'm ok merging as-is as long as we open an issue to add tests later. 
 Yes it could. Hold on.
 @ashfurrow ready to merge at your pleasure
 Cool cool, forgot to ask for a changelog ‚Äì feel free to merge once that's in. 
    **Hi! 
First of all ‚Äî thanks for an awesome tool which helps with making projects better** :+1: 

I've faced one situation while using Moya, but since that seems to be breaking change i'd like first to discuss (or sort for approval to make that change). 

What we have:
Let's imagine some api with parameter/based URLs (Flickr, for example).

and code:

```
    public var baseURL: NSURL { return NSURL(string: "https://api.flickr.com/services/rest")! }

    public var method: Moya.Method {
        return .GET
    }

    public var path: String {
        return ""
    }
```

So a thing here ‚Äî returning empty string as path looks a bit creepy.
Wouldn't it be better if we will make path optional? 
So Target type will look like: 

```
public protocol TargetType {
    var baseURL: NSURL { get }
    var path: String? { get }
    var method: Moya.Method { get }
    var parameters: [String: AnyObject]? { get }
    var sampleData: NSData { get }
}
```

Not sure if this still looks good. Maybe better option will be to provide different target types (üôÑ) or default implementation for protocol functions in extension? So if you don't want to return parameters ‚Äî no need to implement getter which will return nil. 

Thanks for attention :) 
 Thanks, your opinion on this seems to be much more reasonable. 
 I see now,  thanks fkr making this more clear. 
  Doesn't type inference tell Swift which to use? It's also possible to use Moya.Result. I'm not opposed to adding a dependency if we need it. 
 Sounds like the easiest solution is just to add a dependency to Result. I'm totally OK with that ‚Äì anyone have time to send a PR? 
 Fab idea. This would also be a great "first time" contribution, too!
 This was fixed in #344, I believe. If it's still an issue, we can re-open.
  Yay :tada:
 Aye let's merge. Can the people above in the conversation please open issues they feel need to be addressed? 
  Basically, GitHub has its own idea of git tags called "Releases", and Carthage uses _releases_ instead of _tags_ when you specify GitHub.

So the following two lines in a Cartfile are _not_ necessarily equivalent.

```
github "Moya/Moya"
git "https://github.com/Moya/Moya.git"
```

By added a GitHub Release, we avoid confusion with people installing older versions of Moya by accident. I've automated this to make sure I don't forget.

See https://github.com/Moya/Moya/issues/335 & https://github.com/Moya/Moya/issues/332
 @mpurland When you get a moment, could you review this PR? 
 :+1: 
 @ashfurrow Okay, sure, let me have a look

EDIT:

Looks good :+1: let it :boat: 
 :boat: 
  Oh, right. Carthage means different things between specifying "git" and "github" ‚Äì we've seen this before, sorry it's not fixed yet. 

I've created a [5.1.0 "Release"](https://github.com/Moya/Moya/releases/tag/5.1.0) in addition to our existing tag. Try again and let me know if that works. 
 Ah I see, right. Moya 5.1.0 has a different version of RxSwift as a dependency. I'll fix that tonight, or roll back to beta 2 for now. 

For anyone interested in the problems with releases vs. tags in Carthage, check out the end of this thread: https://github.com/Moya/Moya/pull/329
 #361 deprecates this
  @AvdLee I should think the correct way to do this would be to embed it within the Target and correctly generate the params using the `parameters` property of the `TargetType` so you have a single point of entry.
 Hmm, that's odd ‚Äì sorry this is being problematic. So Moya actually _used_ to let you do this, and we took it out to sort of "force" developers to put these types of parameters inside enum associated values. 

You're right that enums can't have stored properties, but an enum _case_ can. In [our login case](https://github.com/artsy/eidolon/blob/a93f9f67aca6b27996076b3042ea532b4fbb9fb5/Kiosk/App/Networking/ArtsyAPI.swift#L8), we attach username and password as associated values. Then later when we need to return our parameters, [we use those associated values](https://github.com/artsy/eidolon/blob/a93f9f67aca6b27996076b3042ea532b4fbb9fb5/Kiosk/App/Networking/ArtsyAPI.swift#L140-L147). This lets us store, and then retrieve the parameters. Your code to invoke the endpoint would change to look like the following:

``` swift
MyProvider.request(token: Target(offset: 0, limit: 15))
```

Does that make sense? 
 Ok cool, this looks like it got sorted out. Going to close, feel free to re-open üëç 
  ~~In this case, you can take advantage from "Pattern Matching" in Swift~~
 Ok...I also run my tests this time, it won't work. I removed my answer
 If you need to put the same `user` and `password` for any kind of `endpoint`, why not just add auth header directly without `switch` cases ?
 OK, so if the username and password apply to _every_ endpoint, you have a few options. The easiest is to store the username and password in a globally-accessible place. Then your closure would look like:

``` swift
var endpointClosure = { (target: TestApi) -> Endpoint<TestApi> in
    let credentialData = "\(globalUserName):\(globalPassword)".dataUsingEncoding(NSUTF8StringEncoding)!
    let base64Credentials = credentialData.base64EncodedStringWithOptions([])
    let endpoint = Endpoint<TestApi>(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
        .endpointByAddingHTTPHeaderFields(["Authorization": "Basic \(base64Credentials)"])

    switch target {
    // TODO: Customize any parameters on an as-needs basis.
    default:
      return endpoint
    }
}
```

There are other ways to do this, like using composition to encapsulate the username/password inside an object that also holds onto the Moya provider for you. We do something similar [here](https://github.com/artsy/eidolon/blob/a93f9f67aca6b27996076b3042ea532b4fbb9fb5/Kiosk/App/Networking/ArtsyAPI.swift#L349-L408), but for other purposes. You could also store the credentials in [another type](https://github.com/artsy/eidolon/blob/f95c0a5bf1e90358320529529d6bf431ada04c3f/Kiosk/App/Networking/XAppToken.swift#L10-L64). There are lots of different options to do this _well_, but I'd first focus on getting it to work, and then make it awesome after :tada:

Does that help? 
  Hello, sorry you're experiencing this error. Not sure what's going on, as I'm not as familiar with Carthage. Any ideas @justinmakaila ?
 This is because 4.0.2 is the Latest release. The others are just tags. 

@minhoryang To fix this right now you can use:
`github "Moya/Moya" "5.1.0"`
 You should be able to try again now and have it work ‚Äì see https://github.com/Moya/Moya/issues/335 for more details. 
  Hey there! Great question, I've had this kind of error happen before too. I think it's a bug in Swift surrounding error-handling and inferring closure return types. The way I've fixed it is to explicitly tell swift what the closure return type is. `.map { response -> [Model] in` or whatever. Let me know if that works! 
 Great! Glad that worked, thanks for posting the solution! Should we close this issue?
  https://swift.org/package-manager/
 +10000 :tada: :+1: 
 The "correct" way to do this would be to provide a core "Moya" framework and then "ReactiveMoya" and "RxMoya" ancillary frameworks. Yes, you may end up needing to do two imports. You have to deal.
 YUP. Subspecs are a bad method of organising code.
 Creating whole repos, and all the required infrastructure for 1-2 files, then 1-2 test files is a bad method of organising code.
 I'd like to point out that, unlike with Carthage, we may have the opportunity here to add support for subspecs to SPM. I honestly think they're a fantastic feature, and I know the SPM/CocoaPods people have been chatting. Maybe that's something we could do together.
 They've already got something like this [on their todo](https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#package-flavors) as Package Flavours.
 Neato :ok_hand: 
 Like all things in programming, It's a trade off, there's additional complexity in maintaining a lot of redundant resources in order to keep things going as they are now.

Ensuring that multiple projects are now green on deploys becomes harder, might need a meta-repo to allow for editing all of the files at once, changes to one might not propagate to the others via multiple PRs. This is a community project, so those tradeoffs don't have to be the ones that I think are valuable.  

Switching to separate repos for all of these strongly correlated projects comes with lots of downsides, but if one of the upsides is that it can work with the current build of SPM before the add flavours, then maybe it is worth the tradeoff for someone to build and ensure all of the infrastructure is in place to simplify the extra work for contributors.
 Aye. If anyone is interested in the specifics of what's involved, check out [this PR](https://github.com/Moya/Moya/pull/169) for our first attempt at a multi-repo setup, and then [this PR](https://github.com/Moya/Moya/pull/215) that finally did add Carthage support (it discusses the reasons for going with only one repo).
 But Orta, the projects are _not_ strongly correlated! The RAC extensions to Moya are simply extensions to provide helpful wrapping. The core value of Moya lies in its endpoint modelling types, and if the extension subspecs went away tomorrow, we would be no worse off. There will be very little requirement for lockstep updates as long as the extensions only use public API, just as they should. A strong adherence to semantic versioning would obviate many issues. I agree that lockstep repo updates suck, but that wouldn't be the case here.
 > The core value of Moya lies in its endpoint modelling types, and if the extension subspecs went away tomorrow, we would be no worse off

That's idealistic, not realistic, I bet almost everyone who maintains and contributes to this project uses RAC/Rx with Moya. I had to argue that it was worth building a non-RAC version at all at the start. Again, I'm not the one who would be doing the work maintaining and keeping this all running, so it's not my neck on the line here.
 > I had to argue that it was worth building a non-RAC version at all at the start

Ha, I forgot about that!
 RxSwift has done this without [much faffing](https://github.com/ReactiveX/RxSwift/blob/master/Package.swift)
 Closing this conversation in favor of https://github.com/Moya/Moya/pull/643.

I didn't see this conversation when I was working on https://github.com/Moya/Moya/pull/563, but I'm glad to see other people had noticed the same problem I had üòÑ 

Of course, please re-open this if there's anything lingering that should be discussed!   Fab, looks great! Want to add an entry to the changelog?
 Sure, will do after I look into this build issue.
 @ashfurrow Can you trunk push this updated podspec for the latest ReactiveCocoa alpha? It's needed in order to set the version in the Podfile for the Demo project in Moya. 

See https://github.com/mpurland/Specs/blob/rac-update/Specs/ReactiveCocoa/4.0.4-alpha-4/ReactiveCocoa.podspec.json
 For reference: https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2590
 Sure, can do. Where did you get the original to modify? We're using https://github.com/mhuusko5/Podspecs as a source for Ruby-based pod specs. /cc @mhuusko5

Also, I'm afraid to say that the ReactiveCocoa developers are unlikely to do anything but close your issue. They've declined repeated offers from myself and others to help maintain the podspec in their repo, and choose to be poor sports instead. 
 I used the podspec for 4.0.3-alpha-3 as a base since that's the last one you added. 4.0.4-alpha-1 is a much older version actually...
 Makes sense ‚Äì the Ruby ones are a bit easier to reason about. 

I'm not sure why they insist on declining, but it's been that way for as long as I can remember ‚Äì far before Carthage. 
 Not sure what the next step here is. The carthage build works, but the Demo project will not build because it depends on CocoaPods and the Moya podspec which can't reference a branch or commit.
 The next step is we need to push a podspec to trunk. Could you update the podspec on https://github.com/mhuusko5/Podspecs and send him a PR? Then we can push to trunk, then we can merge this :tada:
 Done https://github.com/mhuusko5/Podspecs/pull/1 
 Thanks @mhuusko5 

Re-pushed commit, now let's see if travis builds it...
 @ashfurrow This should be good now?
 Looks good to me, if someone else wants to review + merge after the changelog is updated, that'd be :100: 

Thanks again @mpurland ‚Äì great work!
 Ready to :boat: 
 Thanks!
 I've added you as a contributor to Moya, so you've got full push access :tada: You can read more about that here: https://github.com/Moya/contributors

I've also released 5.1.0 of Moya so you can use your new commits from Trunk! Thanks again!
 @ashfurrow Thanks. Glad to help out now and in the future.
 @ashfurrow Any reason why 4.0.2 is the Latest release and every release since is just a tag vs. a published release?

Also, any thoughts on submitting .framework.zip to releases for carthage compatibility so that Moya doesn't need to build (there are a lot of dependencies)?
 @mpurland of ReactiveCocoa? Not sure. 

I have no feelings towards Carthage support. If that's a thing we can do (easily) to help them, sure sounds good :+1: My only requirement is that it gets automated: https://github.com/Moya/Moya/blob/e069bc22e28b2d69cfcfbbae3cb15304d112fbd6/Rakefile#L27-L57
 I've run into that issue as well. I hope it will be addressed soon.
 @ashfurrow The above issue about tags and releases was encountered in #332.

It looks like the Rakefile will need to be adjusted to publish releases vs. just tags if you would still only want to cut releases that way.
 Oh I see, so specifying GitHub instead of Git in Carthage means very different things, one uses GitHub-specific thingies and the other just uses tags? I did not know that ‚Äì seems silly. Anyway to create a "release" from the command line? 
 There is a dependency for rakefiles that I've seen referenced that can be used.
 I think this is what I saw earlier: https://github.com/mpalmer/github-release
  Btw, I suppose if you can create the PR based on another branch instead of `master`, that would be great. :tada: 
 Ah... my bad.. I didn't see it. It should compile without any error then.

On the other hand.. it seems to that you can not just fake methods without implementing the details. It turns out this solution will likely break the implementation of `willSendRequest` in `CredentialsPlugin`

Why not just set `startRequestsImmediately` to false by default and call `resume()` manually.
 Really cool PR, thanks! I don't mind it coming from master at all, personally. Could you add an entry to the changelog when you get a chance?

Thanks again! üéâ
 @mrahmiao Great, thx
 You can update the changelog, commit, and push to this branch and github will add it to this pr ‚≠êÔ∏è
  Just a quick guess: you sure about `(request.request as? NSMutableURLRequest)?` will not give a `nil` cause `NSURLRequest` not same as `NSMutableURLRequest` ?
 Hmm.. you are right. It's not caused by `nil`

Apparently, it's because `willSendRequest` get called after `request.resume()`... (It probably should not !)

So the workaround for now is using the approach mentioned by @ashfurrow in issue https://github.com/Moya/Moya/issues/325#issuecomment-161039326, it will work.
 Sounds like something that the library should fix :smile: Could someone open an issue (or send a pull request :wink:)?
 I've finally got some time in weekend and could be back to this issue. Here is my rethought.
- All the manipulations of `NSURLRequest` should be done in either `endpoingClosure` or `requestClosure`, the latter is the original way to **resolve/alter** a request, and should probably be the answer of this issue. (I should've noticed it at the first place:disappointed: ).
- It is probably not a good idea to manipulate `request` in `plugin`. 
  Think about this case: assume we have `let plugins = [A, B, C, D]`, 
  - `C` could sometimes break `A`, because `C` could alter some value which already have been altered by `A` again accidentally, then we got a silent failure.
  - `D` will be functional based on `B`, which means `[A, B, C, D]` will work, but [A, D, C, B] will not work.
  - :bomb: 
  
  The `Plugin` mechanism is basically a "multicast delegation" pattern. If we do not keep every `plugin` entirely independent (such as alter the same instance one by one), we could easily entry into a mess.

**Conclusion:**
- This is not a bug. :wink: 
- We may need to rethink also the implementation of `CredentialsPlugin`. :thought_balloon: 
 I agree with @wangshengjia about the `Plugin` mechanism for manipulating requests can have problems. We could solve this with some type of requirements, ordering, priority, or another type of streaming/proxy solution (something along the lines of https://github.com/typelift/Aquifer comes to mind).
 Using `requestClosure`, is this issue is resolved?
  Hey, good question! Moya uses Swift's associated values on enums in order to pass in parameters. 

``` swift
enum TestApi {
     case Login(userString: String, passwordString: String)
}

let endpoint = TestApi.Login(userString: "Ash", passwordString: "password")
target.request(endpoint)
```

Does that make sense? 
 Ah! I see. You can `switch` on the `target` and return a different endpoint. 

``` swift
var endpointClosure = { (target: TestApi) -> Endpoint<TestApi> in
    let endpoint: Endpoint<TestApi> = Endpoint<TestApi>(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)


    switch target {
        case Login(let userString, let passwordString):    
         let credentialData = "\(userString):\(passwordString)".dataUsingEncoding(NSUTF8StringEncoding)!
         let base64Credentials = credentialData.base64EncodedStringWithOptions([])
         return endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Basic \(base64Credentials)"])
    }

    return endpoint
}
```
 Yup, that's right!
  This should close #265 with the omission of watchOS since it can't have test targets as of now.

Changes:
- Renames DemoTests folder to Tests
- Add test targets for OS X and tvOS
- Update Podfile to have the new targets
- Update Rakefile to run all the new test targets
- Add `ImageJPEGRepresentation` method for tests since there is no `UIImageJPEGRepresentation` equivalent for OS X
 When I've seen problems like this, it's typically "the nth test always fails", irrespective of which test that is. 
 Likely a combination ‚Äì I've seen it on other projects where Quick/Nimble only fail to work on slow hardware like Travis, and only sometimes. 

Want to restart that build to get the green check in our commit history? 
 Looks like the error we're seeing here is different from #265. Could this be a legitimate test failure? It's only happening on the pr tests ‚Äì @petester42 when you have a chance, could you merge in changes from master and see if the test continues to pass locally? That way we can verify if it's a true failure or a Travis problem. 
 Nope, just intermittent ¬Ø\_(„ÉÑ)_/¬Ø

I'm merging!
  Aye, sorry for the confusion @ivanruizscm. I've released the podspec, so the best thing you can do is go back to your original Podfile (the instructions in the project's Readme) and do a `pod update Moya`. Let us know if that works :+1: 
 Cool! Glad that's working. @ivanruizscm would you mind if we close this issue? 
  As discussed in #300 theses are some changes to the protocol names to match the naming convention is the swift standard library.

Changes:
- **Breaking Change** rename `MoyaTarget` protocol to `TargetType`
- **Breaking Change** rename `MoyaRequest` protocol to `RequestType`
- **Breaking Change** rename `Plugin` protocol to `PluginType`
 Looks fab ‚Äì could someone else take a look + merge? 
 Superb work, as usual :stars: It's been a few days for anyone to object, I'm going to merge. 
  This PR aimed issue #318 which update the documentations
 Fab, thanks! 
  Huh, cool. Let's wait for :green_apple: just in case. 
  This PR update some documentations which is not matching the API correctly.
 Looks great, thanks! 
  This aims to fix #313 I tried various things but this solution seems to be the one that affects everything the least. What I did is that for the reactive schemes I added a prebuild action that changes all references in the source files from `Moya.` to `ReactiveMoya.` or `RxSwift` and also added a post build action that changes it back to `Moya.`

It's sort of hacky but it works properly. I have a lot of thoughts on how we are supporting carthage currently which seems like a bigger headache than it should be or worth. I'll open an issue about changes we could make to make everyone's life easier. 

Here are some of the things I tired for those interested:
- Changing the module name to `Moya` which works but since the output name has to be `Moya.framework` there will only be 1 framework in the carthage folder since the other ones get overwritten
-  Changing the module name to `Moya` and renaming the framework after it has been built in a post build action. This also works in Xcode but carthage references the framework name when moving it to the carthage folder so it fails with `file not found` since the name it wants is `Moya.framework`
- Rename instances of `Moya.` in the source files for `ReactiveMoya` and `RxMoya` on the fly before compiling and rename them back after compiling
 The inherent issue is that Carthage just builds targets in an xcodeproj; based on the issue, I'd recommend option 1, which was to make extension frameworks that sugar the respective libraries for Moya. I'm pretty sure that's what Apple would recommend in this situation if we were back in submodules. Until such time as we have weak linking in Swift, I think that would be the best option.
 @petester42 I quite like your approach here. Seems pretty reasonable, given the constraints we're in. 

> supporting carthage currently which seems like a bigger headache than it should be or worth.

You took the words right out of my mouth... 
  Hey there! Great question. We cover a bit about parameter encoding [in the docs](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-), but the short-and-simple answer is that you need to pass a custom `endpointClosure` when you create the provider. It takes a target, which you `switch` on to customize individual endpoints. 

The parameter encoding you're describing is pretty custom ‚Äì query string in the URL and a JSON body ‚Äì so you should use the `.Custom` parameter encoding type. It takes a closure that modifies the `NSURLRequest` and returns it. You can see the source [here](https://github.com/Moya/Moya/blob/731db29d6a68d350ef97ad059e881f361dc35e3f/Moya/Moya.swift#L38-L57). 

Like I said, it's a pretty custom thing so I'm afraid to say we don't have many examples on it yet. We'll help you figure it out, though! And once we do, it would be :100: if you wanted to submit a pull request that adds some more examples to the docs based on what your experience :cake:
 Hey, just following up! Anything I can to do help? 
 Looks good to me! I must admit I've not tried this before, but it looks like it should work :+1: 
  Hi guys. Today I pulled master and tried building all targets on all platforms in the project, to make sure all was gooby. I noticed that ReactiveMoya and RxMoya targets have incurred some errors as a result of the prefix-less type name changes. 

![](https://cldup.com/XzupFOCUYn-1200x1200.png)

Errors like this are happening on uses of types like `Moya.Completion` because `Moya` is only actually the module name in the "base" Moya, and the base source is shared. The reason this can't work is because Swift doesn't currently provide a way to reference things by the "current module." A lot of the decls in the source don't actually require the prefix where we use it, but some do, due to ambiguity, etc.

From what I can see, here are a few ways to fix this:
- Convert the Rx/ReactiveCocoa additions be extension frameworks that themselves link against Moya
- Revert type names back to having the Moya prefix
- Change the reactive framework targets' module names to `Moya` (though this would be kinda weird, linking to `RxMoya.framework` but using `import Moya`)

I had previous said I saw no drawbacks to moving to this naming convention, so I apologize üôÅ but I'd like to hear thoughts on what the best option for resolution is.
 Hey, no problem! The third option sounds appealing; it's how CocoaPods works anyway. We can also use preprocessor directives cleverly somehow maybe. 
 I may have spoken too soon about that option. It seems that Xcode for whatever reason won't let you alter the module name setting (only errors if name is not equal to the framework bundle basename). ![](https://cldup.com/kesfU5dzwf-3000x3000.png)
 It appears this was already brought up in the description of #310. Definitely something we should fix before doing a release with all of these new changes lest we break Carthage support.
  Fab, good catch! :cake: 
  This addresses issue #293. It changes the `Completion` closure to return a `Return` type instead of multiple optional parameters.

There is an issue though. Since we are using `Moya.Something` in places now some frameworks don't currently build. Since the module name for `ReactiveMoya` does not match `Moya` those frameworks don't build. This is even an issue with the current version but I don't see how to fix it.

Anyone have an idea on how to fix this. I tried setting the module name to Moya for all the frameworks but then you get a warning:

```
warning: PRODUCT_MODULE_NAME may not be overridden for framework target 'ReactiveMoya iOS'
```
 This looks :100: great work!

For the module name problem, since that exists currently, we should probably open a separate issue about it? 

Thanks again, @petester42. We'll need to update our docs, but we can open an issue for that after we merge this. Can someone else from @Moya/contributors take a look and merge if they're happy? 
 Quite impressive! I looked it over and it looks like this will be a great direction going forward. I'm going to go ahead and merge it so I can get some participation here. 
  Disabling force pushes: probably good.
Requiring status checks: probably good, but there are instances where discretion is required.

Then again, that discretion can be exercised by temporarily disabling the protection setting.
 Thanks for the great idea @SRandazzo! I turned on protection for master when we made Moya an organization, and even clarify(ish) this in the [contributor guidelines](https://github.com/Moya/contributors#when-should-you-use-push-access). Great minds :)

As far as CI passing, that's a trickier one. Sometimes we'll merge in broken tests because getting a PR merged is more important than getting the submitter to fix the tests (they're a first-time contributor and it's easier for me or someone to fix it after it's been merged). Also, we have intermittently-failing CI (see #259).

I think @swizzlr's "discretion"-based model is :+1:, and I want to give all the contributors a chance to use their own discretion. 

That's just my ¬¢2, if the community wants this then of course we'll enable it. Thanks again for the great suggestion! 
 > If it weren't for those intermittent failures, I would propose an experiment to try it out

Agreed! Definitely worth a shot. Do you think it's worthwhile to keep this issue open for more discussion? Let me know if I can help answer questions about CI :boat: 
 We're still pretty consistently getting CI failures, which sucks. I heard a rumour Circle might have a feature soon to restart builds failed with the infamous "Error 65", we'll see. 

In any case, we now have Danger on the repo's pull requests, and sometimes we do need to override. I really liked the discussion here, but I think we've settled into a groove with the somewhat protected branches. Thanks again for sparking a good discussion!
  Dependes on #305
 @swizzlr is it possible to turn off the code coverage check for the patch? It's consistently failing, and I don't think it's super-necessary. 
 Also for some reason it's still trying to merge in commits that were already merged. Can you merge in from master when you get a chance?
 Code coverage check is a nice way to remind you of technical debt, IMO, and I've got a fix coming up now.
 +2%. NICE.
 Yeah totally, I'm just worried someone sending their first PR will be intimidated by a failing CI :(
 @swizzlr Anything I can do to help on this? 
 Sorry, week got mad. To do is to address your crashing concerns and string inference, add some code coverage to alamofire method conversion and the method logger plugin. After that i think my codecov duty will be done.
 Cool. One thing, @swizzlr: there is absolutely no apologize necessary ‚Äì we're grateful for your contributions and you should not feel like you've let anyone down. 
 Looks üëå to me! Would someone open an issue to update our docs around plugins? 
  Should prevent some merge conflicts in PRs. 
 LGTM, mind if I merge this before CI check finishes?
 Note that I don't think this'll apply to any PRs sent without this commit in their history.
  Depends on #304 
 Cool, looks good. This depends on #304? Want to update the PR description?

Also, a changelog entry would be :cake: 
 Am I correct in reading this as "that would be cake"
 That would be a correct literal interpretation, yes. 
 I thought we were going to keep the `Moya-` prefix on these types, what's the advantage of removing it? Advantages to keeping it:

Unambiguous origination. A `MoyaResponse` came from Moya. Where does `Response` come from? I wish Alamofire used a prefix on these generic names, too. 

No possibility of namespace collisions. `import Moya` will bring `Response` in as a top-level type, no need to prefix `Moya.` - so what does it mean when you create your own Response type in a file that imports Moya?

I think, and this is just a "dissenting opinion" that this change is an unnecessary breaking change. 
 @colinta those are some good points. It seems like Swift libraries are going one of two ways: either they're sticking with common Objective-C-style conventions like prefixes or they're going 100% prefix-less with no prefixes. Alamofire has gone the latter route. 

I agree with the downsides. In the case where there are two `Response` types, you can delineate between the two by using the `Moya.` prefix (we do this when using Alamofire [here](https://github.com/Moya/Moya/blob/e0b2b2a9108d3b9df8e6e671a91e49422a0ef20c/Source/Moya.swift#L14) for example).

Seems we're at a crossroads. I honestly don't have a strong opinion either way, but I recognize that this is a big shift and it deserves thoughtful consideration. Trying not to spam @Moya/contributors but I think this deservers further discussion. 

Edit: Not to sway the discussion, but it seems like the prefix-less approach is "where the puck is going" with Swift, though.
 It does seem that way, and it just occurred to me that this change doesn't _remove_ the `Moya.` prefix, it just makes it optional. With that in mind, I'm less opposed to it. 
 https://github.com/raywenderlich/swift-style-guide

According to this we should just use namespaces. I'm okay with that. If there is a collision you just have a little more to type.

So you may have to refactor the refactor again if we go with namespaces :P
 I don't see any real downsides to prefix-less type names in frameworks. As has been established, with references to the full type name including the module name prefix, there's always a way to disambiguate references to same-name types that exist in separate modules.

In the case where a user of Moya (or any other Swift module) with a "colliding" type name doesn't want to keep prefixing with the module name, they can always use a typealias.
 Cool, can someone hit the "merge" button?
 Wheeeeeee!
 Do we "Delete branch" afterwards?
 Sure!
 THE CI WAS FAILING
 NOOOOOOO WE

(:sly smile:)
   Cool, looks good to me. Could you add a changelog entry? 

If someone from @Moya/contributors could also take a look and merge if once it's :+1: to them, that'd be :100: 
 Gonna close this since #305 got merged. 
  As per discussion in #301. 
 How about just removing when Moya hits v6?
 I'm closing this one in favor of #489. üêº 
  (Net reduction in LoC!)

I got carried away closing #293.

Significant changes:
- Completion handler now returns `Response?, ErrorType?`
- `Plugin`s are now a protocol
- `ReactiveCore` is gone and now part of Moya in general
- `MoyaTarget` is now `TargetType`
- `MoyaResponse` is now `Response`
- `MoyaProvider` is now `NetworkResourceProvider` (discussion welcome on improving this)
- `sampleResponseClosure` parameter is now an escaping autoclosure, which makes the API a lot cleaner to use.
- Test classes are now `final`, as all classes should be.
- `Response` is now `final` (see above bullet), and will be changed to a `struct` once we drop RACSignal support.
- `Endpoint` is now a struct, and the `SampleResponseClosure` typealias has been removed for simplicity's sake
- `EndpointSampleResponse` now takes a non-optional ErrorType, or a `Response` object as opposed to a code and data.
 I believe these changes to be good because they make the library a bit more "Swift". Modules provide a namespace, so we don't need to prefix stuff, nor do we need to create our own namespace.

Plugins sorely needed to be a protocol, but were quite objc. I sometimes feel Moya is really wanting to have that magic dynamism that Swift rightly disallows. Turns out that if we get rid of the provider param, we can make plugins protocols. I can't see a good use for it either. Could be replaced with an `AnyObject` param.

We should either make the completion in-type a result, or a throwing func, just as suggested by @petester42, right now this is just weird.
 Okie doke, wow! You're right this is a _huge_ PR :sweat_smile: That's ok, thanks for the work! I'd like to discuss a ew top-level issues before we discuss nitty-gritty details. 

I'm good with all the renames except `MoyaProvider` ‚Äì I know it's not necessarily "Swift", but I really like having the library name somewhere in there. Maybe it's just me ¬Ø\_(„ÉÑ)_/¬Ø

The changes to `EndpointSampleResponse` look good, too. The `final` test classes, I've never seen that but fi that's what's suppose to be, that's fine. 

I think adding @petester42's suggestions about throwing closures becomes necessary with these new changes. We can wait until after this is merged before doing it though ‚Äì already a big enough PR :)

This'll need a merge from master and all of these points need to be described in the changelog, but yeah I agree with the general thrust. Thanks for the work! Smaller PRs next time! :cake:
 I would add that I have always appreciated the names `MoyaTarget` and `MoyaResponse`. Reminds where those objects originated. 

In my apps I have often defined Target and Response types - those names seem too generic to "claim" by a library. 
 Yeah good point, even if the compiler lookup can succeed most of the time using type inference, my brain's type inferrer is less powerful. 
 You ever change one thing, and then change something else, and then before you know it you're crying on the bathroom floor and the compiler is screaming in the kitchen?
 I agree with the points about target and provider. Let me know if you think I should do it for response too. Generally speaking, Swift is moving in a direction where namespaces are a thing (cf Alamofire.Request etc) but I can totally see how this could be irritating and make the APIs less usable.
 I'm going to factor this into individual PRs, so we do this right!
 Sounds good! Looking forward to the PRs! 
  As the title states, ReactiveCocoa 2 support has been deprecated.

Closes #298
 Probably worth mentioning in the README too
 Him, maybe clarifying that its 3 and above, rather than saying what isn't supported is a better approach 
 Agreed with Orta ‚Äì some clarification in the readme would be good, but that's not a blocker. I'll open an issue. 
  I've created a v5 milestone. We shouldn't let breaking changes fester in master too long before releasing a release candidate, but while we're at it let's sneak some more stuff in!

I've identified five issues that I think should be resolved for v5; take it up in those issues if you think they should be descoped.

With this issue I'm opening the floor to any other suggestions for issues to be added to the v5 milestone.

Let's draw a line under planning any more features to v5 by, say, **Wednesday 18th November** (that is to say, a freeze on deciding what will go into v5, not doing it obviously), if only to stop it from bloating too much.
 Yeah, I like the idea of a milestone but I'm not sure we need any specific date to plan on. We can evaluate issues for version 5 on a case-by-case basis, and if anyone feels we're waiting too long, we can talk about it. 

This is also a great issue to discuss anything that's missing (changelog entries, for example). Thanks T-Swizzle. 
 So I think we're in a good spot now to release _a_ build. I know we still have 5.0.0 issues open, but many of them are either longer-term or could be done without breaking changes. It's been a while since we made a release and I don't want us to get to _too_ far away from the existing release. Does anyone have anything they want to make sure gets in this release? /cc @Moya/contributors 
 _Yes_. These all sound amazing. 

`Endpoint` should never be subclasses, so making it `final` is :100: I'll try and get to these changes this weekend.
 OK, anything else? I'll cut a release tomorrow morning if that's all. 
 Cool cool, this is released in https://github.com/Moya/Moya/commit/117af026df08d006aaac317c92294ebb9d5dffd1 with the podspec at https://raw.githubusercontent.com/CocoaPods/Specs/e0bf8b03d24b0b23829d8667298591ef5a431dfd/Specs/Moya/5.0.0/Moya.podspec.json .

So I'll close the issue and migrate the 5.0.0 milestone to a the "longterm" one. 
  Guess no one has yet tried to submit ReactiveMoya with Carthage yet.

This commit removes the MOYA_VERSION env var as it was out of date and not used everywhere. I don't think it's needed.
 Can you merge in from master and push? 
 If i'm not mistaken that was an error from Ô£ø that should be fixed by now.
 I can personally confirm that the matching version thing was a bug and was def fixed for me. There's no good reason to declare the framework version, so I think 1 is a safe bet.

The issue this resolves was that some targets had no MOYA_VERSION defined, thus causing a nil short bundle ID, and thus failing ITC checks.
 No worries sport; was there a reason why you wanted MOYA_VERSION? I can put it back in if that makes the library easier to use for more people.
 Well, looks like we're good to go with this?
  Not insignificant time is being spent maintaining the RACSignal extensions, as well as the non-RAC3+ provider. We should consider officially marking these as deprecated for some time, before eventually removing them. 

Not sure if anyone else is using them or if its just me, and I won't be for much longer. Open for discussion!
 Sounds like a plan!
 +1. Out with the old in with the new.
 Next action would be to add `@available(*, deprecated, message="This will be removed in the next major version of Moya. Please visit https://github.com/Moya/Moya/issues/298 for more information.")` to all relevant methods (I should think `request` overload).
  Before starting with #293 I just wanted to make sure that everything that came with #289 was finalized. There were a couple NSErrors that still existed so I cleaned it up to remove all usages of NSError and replace them with MoyaError.

Changes:
- Forward underlying errors when cast to MoyaError does not work
- Fix MoyaResponse extensions that were still throwing an NSError instead of MoyaError
- Change MoyaError to conform to `Equatable` in tests for cleaner syntax
- Update reactive extension tests to use MoyaError instead of NSError
- Update ReactiveCocoaMoyaProviderSpec tests to use the `SignalProducer` variant when possible.
 Looks great! Thanks!
 I've opened a PR against this branch to try to resolve some of the code coverage issues: https://github.com/petester42/Moya/pull/1
 Just a thought, but does it make sense to implement `Equatable` for "case equality" vs "value equality" (and are those two different for this type)? This expression could be true: `.Underlying(x) == .Underlying(y)` (where `x != y`). Seems to be typical convention to implement equality checking for associated value enum cases to compare the associated values, provided they're equatable (example: https://github.com/ReactiveCocoa/ReactiveCocoa/blob/fd64bf6ea7a83dec13fe42244db470fd9641a9a1/ReactiveCocoa/Swift/Event.swift#L94-L111), which I think `MoyaResponse` could conform to to make this work for this error type.

As for specifically checking the case equality, that's still very much useful and necessary, in this case for the tests, but it felt more appropriate as a function on the enum IMO. May be confusing for users of Moya seeking or trying to implement true value equality checking on this type, which may have been the reason for @tomburns' [initial reservation about implementing it this way](https://github.com/Moya/Moya/pull/289#issuecomment-154882315).
 Sure, just trying to stay aligned with observed language conventions üòä
From Swift `Equatable` docs:

> Instances of conforming types can be compared for **value equality** using operators == and !=.

I think it's more responsible of us to not to use an unconventional `Equatable` implementation just to be able to use `==` in a test rather than a (more appropriately named) function on the type. We don't need value equality for this type at this point, but we may in the future, or users of Moya may want to extend to implement it themselves, and would be stuck as the type already conforms with behavior they don't expect. 
 `Merging #297 into master will increase coverage by +9.07% as of 20e82cf`

üò±
 Do however agree with -1 on default cases in switches, and not comparing underlying values, but while it's internal to the framework it matters not to consumers of the API.
 Well I didn't say anything needed changed with the switch statement or how it was implemented (I agree with you, exhaustive is nice ‚Äì let's let the compiler work for us), just that this (again, perfectly valid) **case** comparison should change in no way _other than_ taking it away from `Equatable` where it doesn't fit.

And it _is_ public, unless you mean unreleased. It publicly conforms to `Equatable`, using up that conformity in a non-standard way, which was my point. Out of curiosity to understand: why is it thought that two "same-operation" errors from two entirely different responses are "equal?" Or two completely different `NSError` objects in `.Underlying(err)`? `.Underlying(errorA) == .Underlying(errorB)` evaluating true in any scenario other than where `errorA == errorB` seems lacking in sanity to me. As someone (also a user of Moya) who would potentially want equality checking with the behavior I describe, and would be forced to implement it OUTSIDE of `Equatable`.

For what it's worth, I [briefly described this situation on Twitter](https://twitter.com/JohnRHeaton/status/665185150356070400) and [saw an agreeing response from Joe Groff on the Swift team](https://twitter.com/jckarter/status/665186722498506752).
 > changed it to be a matcher

Great idea! :100: 
 Looks damn good to me! We just need to resolve the merge conflicts.
 Looks good once conflicts are fixed üëç
  Todo:
- [x] Update changelog

Allow injection of a date scheduler which will, when stubbing, be used instead
of the default behavior for executing stub closures.

This commit required reworking the internals of MoyaProvider, mostly factoring
out some common code to be shared by the subclass into a separate few methods
that are final and internal, and documented.
 To do: add tests
 Cool, looks great so far :cake:
 SOMEBODY MERGE IT
 I think you meant to say "this is ready for final review" üòâ

I'm on my phone right now ‚Äì anyone is free to merge this if it looks üëç to them ‚òïÔ∏è
 Nice work. I have some confusion regarding the behavior of `createStubFunction`'s `canceled` parameter. I'm unfamiliar exactly with how `inout` parameters work in this type of context. When the closure returned from `createStubFunction` checks this bool, is it still checking the original variable in the caller's scope by reference? Or is it a copied value at this point, thus negating the intended cancellation behavior?

Either way, it may be worthwhile to write a test that verifies this cancellation behavior pre-merge if we don't have one already. If we do, carry on and this should be ready for merge üòá
 You know, I have no idea. I need to experiment and find out. I'll make a playground when I get to work (~1hr)
 I've ducked the issue by making the stub function take a cancellable token, and refactoring the token to be a reference type. While I was at it I gave it a canceled property and ensured writes to it were locked, let's see what this does to coverage.
 @JRHeaton care to take a look?
 Clever! I'd say that seems like a better implementation. The only odd thing to me here is having a non-optional action closure on the token, but the initializer takes an optional one, defaulting to an empty `{ }` closure if initialized with `nil`. Perhaps the token could have an optional action closure (since it itself now handles a cancellation state boolean), and it could be invoked with Swift's optional function call syntax: `cancelAction?()` Feelings on this? It's a small thing, but would allow us to remove the icky force unwrap in `init()` :)
 Can do! Could also do an if let ‚Äì it's really just because the nil-coalescing operator gave up the ghost. I'm trying to be conservative with API changes, but I keep forgetting this is an internal class.
 Yeah, I like even the idea of a non-optional closure with a default init value of an empty closure. 
 If we're getting into the nitty gritty I'm going to assume the non-optional version would take slightly more overhead in terms of space; or I could just be justifying the change I made and pushed before I saw your comment :)
 I mean, I _prefer_ things to be non-optional whenever possible just to limit the surface area of the API. It's why the `Cancellable` tokens didn't keep track of their cancelled state until now :stuck_out_tongue: If you don't feel strongly against the idea, I don't feel _that_ strongly about it. 

Though I would like to keep things consistent within Moya and adhere to Apple's general practice of using `() -> Void` instead of `() -> ()` if that's okay.
 @ashfurrow sorted. Cancellable tokens should keep track of canceled state because otherwise they're really just a glorified completion handler.
 > they're really just a glorified completion

Now you're getting it :wink:
 Don't furrow me bro
   :100: :ship: it
  Since we are going to merge a breaking change with #289 I'd like to propose that we change the completion block type.

From
`public typealias Completion = (data: NSData?, statusCode: Int?, response: NSURLResponse?, error: ErrorType?) -> ()`

To
`public typealias Completion = (response: MoyaResponse?, error: ErrorType?) -> ()`

This would allow people that do not use the reactive extensions to be able to use the helpful mapping functions and simplify the integrating with various json parsing libraries.

What do people think?
 Great idea! Thoughts @Moya/contributors ?
 On board with this. This is much simpler. I was kind of wondering why it was broken up into 3 values related to response. 
 :100: 
 I think this should definitely be included in version 5.
 Hmm, super-interesting! I like it. Anyone else have feelpinions? 
 Well, I'd rather have a result type, because otherwise everyone's just going to be writing `let e = error as! MoyaError`, but what do I know checked exception bleh etc

(looking at you, Lattner)
 I have a massive PR incoming btw that addresses this issue plus a bunch of other stuff; this approach is better than our strange disjoint union of optional types.
 > Well, I'd rather have a result type, because otherwise everyone's just going to be writing `let e = error as! MoyaError`

@swizzlr I agree with that, at least with Swift's current shortcomings when it comes to specifying throwable error types. Leaving our known error type declared as `ErrorType` in the completion block requires a cast back to `MoyaError` to work with. 

What about the original idea, but with the explicit error type:
`public typealias Completion = (response: MoyaResponse?, error: MoyaError?) -> ()`

That also aligns more closely with the RAC signal type for requests:
`public func request(token: Target) -> SignalProducer<MoyaResponse, MoyaError>`
 I'm not a fan of the double-optional parameters, just because there's this weird state where both are nil that no one is quite sure what to do about and mostly ignore it. A result type feels like a reasonable compromise. 
  That's odd ‚Äì can you upload a project that demonstrates the error somewhere?
 :+1: Glad it worked out. 
  There was a lot of repetitive code in the reactive extensions for the mapping to different types. Decided to move those to an extension on `MoyaResponse` to be reusable. I also noticed that the tests for RACSignal were not in the test target so I fixed those up as well.

Changlog:
- Fix RACSignal tests not being run
- Update RACSignal tests to make them compile
- Create mapping helpers for MoyaResponse as an extension
- Change reactive extensions to use MoyaResponse mapping helpers
- Remove unneeded force unwrap in reactive extension's `request` method
 Fantastic work, as usual! We could add **Breaking Change** to the changelog entry just to be super-clear. 

I've learned never to merge things before coffee; will do a final review later (unless someone beats me to it!).
 Ah, clever! 
  Hmm, this could be accomplished using the custom parameter encoding block, but I agree it's a bit awkward. Maybe we could look around ways to make it easier to use custom encoding (or including an implementation that works with GraphQL? Is Alamofire doing anything lime this?). Regardless, a good solution to this issue should include good documentation and maybe even an example project :cake: 
 Agreed about the black-box functionality. Would making the `GraphQLQueryType` an associated value on the enum help? Not too much. Hmm. 

It could be a lot cleaner if the custom parameter encoding closure had access to the `endpoint` (or the target, I suppose). We only use that closure signature because we pass directly into Alamofire. If expanding it would help, that seems like a cool idea. 

I've not thought the issue through as much as you have ‚Äì what sort of obstacles would that present?
 Hmm, yeah. I mean, I know GraphQL is getting more popular so I think we should consider first-party support at some point. But for now I'm fine leaving it up to the user. 

This is what I was thinking of, probably not a huge improvement.

``` swift
let parameterEncodingEnpoint = { (target: GitHub, request: URLRequestConvertible, parameters: [String: AnyObject]?) -> (NSMutableURLRequest, NSError?) in
    // Instead of accessing the parameters dictionary to construct body,
    // You can access associated values of the target directly.
}
```
 A protocol, "ParameterEncodable" might be a good plan. We could add conformance for dicts to keep previous behavior, and then allow further smarts by providing a "GraphQLNode" struct (or let the users define it as an optional third party extension to Moya, until such time as it's a huge demand).
 @thomasmarsh I think that using the custom parameter encoding solution would be the easiest workaround. Let us know how it goes!
 @justinmakaila I've since used a GraphQL API, want to pick up the conversation on this? How did the framework go? 
 I'm afraid that I haven't used GraphQL with Moya yet, if you find things non-obvious, I'd love to see a PR adding GraphQL to our documentation üéâ
 Dope, just realized that my email response never sent:

@ashfurrow I wrote a simple framework that provided typed interfaces for GraphQL structures. You could then use the `description` property to build the proper strings. I implemented this around Moya like so:

``` swift
enum APITarget: TargetType {
    case graphOperation(GraphQLType, [String: Any])

    public var path: String {
        switch self {
            case .graphOperation:
                return "graphql"
            // ...
        }
    }

    public var method: Moya.Method {
        switch self {
        case .graphOperation:
            return .post
        default:
            return .get
        }
    }

    public var parameters: [String : Any]? {
        switch self {
        case let .graphOperation(operation, variables):
            return [
                "query": operation.description,
                "variables": variables
            ]
        // ...
        default:
            return nil
        }
    }

    public var task: Moya.Task {
            return .request
    }

    public var sampleData: Data {
        case let .graphOperation(operation, variables):
            // Your sample response based on the operation here
        // ...
        default:
            return Data()
    }
}
```

Turns out my initial issue with sending a raw string wasn't necessarily an issue with Moya, per se.
 @ashfurrow the framework went wonderfully for my use case, it's OS on my
profile.

I ended up just using standard JSON encoding to send queries/variables.

Not so familiar with Apollo though.
On Mon, Oct 24, 2016 at 05:14 Alex H√ºllmandel notifications@github.com
wrote:

> Hey @ashfurrow https://github.com/ashfurrow! Do you use GraphQL in
> combination with Moya? Is there any update on how to make parameter
> encoding more generic? I'm very new to GraphQL and try to integrate Apollo
> iOS https://github.com/apollostack/apollo-ios with how I use Moya and
> Alamofire to make network requests.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/Moya/Moya/issues/290#issuecomment-255688417, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ABkCVG8d1rhUmoGcPFWAenJMFhCN7IACks5q3HbZgaJpZM4GeTZL
> .
 Seems like this has been resolved, please reopen if there's any other issues. :)  Travis is failing for Moya intermittently (see: https://github.com/Moya/Moya/issues/259 ). I've restarted the build to see what happens, and I'll take a look at the code now. 
 Yup, green now :smile: :green_apple: 

This looks great, fantastic work :100:

The `MoyaErrorCode` enum exists, but I feel like (given the direction Swift 2 has taken with error-handling) it may be time to retire it altogether and use just your new `MoyaError` enum. This would only change using Moya with ReactiveCocoa (maybe we could make corresponding changes for RxSwift). Any opinions on that? /cc @Moya/contributors 

There're a few tests I'd want to make sure we cover in `SignalProducer+MoyaSpec.swift` but we can sort those out later.

Updating the changeling is a good idea in the mean time ‚Äì right at the top under "Next". Make sure to mark them with **bold breaking changes** and give yourself credit. Thanks again for the awesome pull request ‚Äì we'll discuss it for a bit and get your changes into a release hopefully this week. Cheers! :coffee: 
 Agreed it's worth being thoughtful about their associated values. I'm not sure how I feel about the range specification. I _think_ I like it ‚Äì anyone else have feels?
 Very cool, I think this is a great way to handle errors üëç. 

A couple of thoughts:
1. Since Alamofire fails with `NSError`, I think it may make sense to type the associated value on `Underlying` to be `NSError` rather than `ErrorType`. This prevents confusion that there could be any other type given and thus need to do runtime identification of the type that we know at compile time. This would require re-typing `EndpointSampleResponse.NetworkError`'s associated error type as well, so that `Moya.Completion` could have it's error type be `NSError`.

In short, the Alamofire/"underlying" layer only fails with `NSError`, and since none of these status code filtration or data mapping functions exist in the non-reactive Moya core, it is the only error type to be dealt with, so we can benefit from some type specificity here.
2. With Swift's sweet pattern matching, I think you may able to trim some redundant code off of the `sameErrorType` function by switching on a tuple of the two values. Example:

``` swift
switch (self, otherError) {
case (.ImageMapping, .ImageMapping), (.JSONMapping, .JSONMapping) /*, etc... */:
    return true
default: 
    return false
}
```
 I am also on board with moving away from NSError pattern. Can we just put the NSError into the metadata in case it's needed as well StatusCodeErrorMetadata @tomburns suggested?
 Good point @tomburns, it's a bit of concision versus compile-time safety. I wish there was a prettier way to get the latter, but oh well. At this point it may be best to keep it your way, unless there's another, more concise way to get that safety that I'm not aware of.

Any thoughts on my first point above? Alamofire only uses `NSError`, so the `MoyaError` case that covers the domain of Alamofire errors should provide an associated `NSError`, not `ErrorType`.
 I personally like ErrorType ‚Äì it's convertible to NSError. 
 Just seems silly to declare things as ErrorType when we _know_ it's literally only _ever_ an NSError. Am I not understanding a benefit of doing it the other way? I'm not complaining, but I am truly not understanding, I guess. This is even the motivation behind parametric error types for ReactiveCocoa signals ‚Äì to not leave a signal that can throw deterministic error types to the open-ended `ErrorType` that could be anything, but to give a specific `ErrorType`-conforming type so that there is no nondeterminism about types at compile time. It _is_ convertible to NSError, but it also ALREADY is an NSError, hence my not understanding declaring it differently. And this only applies of course to the `Underlying` error case.

Think about the call point of the Alamofire request. The completion handler provided takes an NSError, which Moya gets back, and then (only ever) feeds as `Underlying`, which takes a more generic type than we know it to be. 
 Is there anything preventing Alamofire from converting to using `ErrorType` over `NSError`?  If they do that, Moya would have to push out a new version.  Not _at all_ a bad thing, and this is the kind of version bump that makes semantic versioning so relevant, but that _might_ be an argument in favor of the more generic `ErrorType`.

A way of justifying it philosophically might be: if we don't need / aren't consuming the features of `NSError`, then using the generic type indicates that we _aren't promising_ what type of error is coming down the wire.  If this error is coming from a dependency, then this lack of promise is honest - we know we'll get an error, but we can't promise what it will be.

I'm just catching up on this discussion, but these are my initial thoughts.  Gonna re-read now.
 The ability to write exhaustive catch blocks is actually a really good point. 

Let's try to remember that we're all after the same thing (writing great code) even if we disagree on how to get there. If it would help, I can schedule a Google Hangout to discuss some of the pros and cons. 
 Should an issue be opened on Alamofire? I do believe it would be an API breaking change but I think it's probably worth pursuing. The docs on swift errors suggest using the ErrorType pattern is the way to go. 
 We should look into the history of their error handling first. The changelog might reveal why they have it this way. 
 Coincidentally, their 'benefits to upgrading' to 3.0 is almost all about errors.

I think the part that may be of interest is the custom wrapping of any NSError to a type of our choosing. 

https://github.com/Alamofire/Alamofire/blob/0cb96d59ad47be1b6f5018188fcfd1d6b0ecbb0c/Documentation/Alamofire%203.0%20Migration%20Guide.md#benefits-of-upgrading
 Cool, not sure where we stand on this one ‚Äì anything stopping it from being merged? 

In the mean time, I'm going to merge https://github.com/Moya/Moya/pull/291 because it has no breaking changes, and it'd be cool to include its changes in a point release before this one (so people can have just those changes if they want). 
 Cooooool yeah sounds great! There've been changes on master since this PR was submitted, @tomburns could I ask you to merge from master?
 Cool, seems good to me. If someone else could give this a final one-over and merge, that'd be :100: Good work everyone :balloon: 
  Cool, that approach sounds reasonable. @justinmakaila @petester42 do either of you have opinions about it? Whatever is more idiomatic for RAC 4. 

To be honest, I'd be OK with deprecating [`request()`](https://github.com/Moya/Moya/blob/136e3260e03a2d2e01ea6d9604e354ff3f9ed55d/Source/ReactiveCocoa/Moya%2BReactiveCocoa.swift#L39-L41) and shifting the responsibility to call `toRACSignal()` to the user. Thoughts?
 I think they'll just get an error like they do now, it's just it'll be an `NSError` cast from this new type instead of an `NSError` we construct presently. I like that change, but we'll need to bump Moya up a major version to adhere to [semantic versioning](http://semver.org) :checkered_flag: 
 Gonna go ahead and close this since #289 is merged. Nice job on this again @tomburns 
  Hmm, this is a question that has not come up before. Generally, there's [no all-purpose solution](http://stackoverflow.com/questions/28131329/how-to-install-projects-without-cocoa-pods) to using a CocoaPods library without CocoaPods. If you must integrate normally, dragging in the Moya files in the `Source` directory should age good, but you'll need to remove RxSwift and ReactiveCocoa files if you aren't using them, also integrate Alamofire, and remove the `import Alamofire` statements from the Moya files. That _should_ do it ‚Äì let me know if you run into issues. 
 Instead of dragging in Xcode projects, try dragging in the individual swift files. 
 It might be worth doing what AFNetworking does and just not supporting manual installation, you need to have a lot of prerequisites set up for Moya, and the more useful interesting stuff can only really happen when you have a larger dependency graph, of which doing manually is just a waste of time.
 Agreed. 
  Neat! Might go well with https://github.com/Moya/Moya/issues/73 if anyone is interested. 

Agreed with your concerns ‚Äì getting this to be an optional part of Moya will be tricky. Suggestions welcome!
 Nice idea, @DanielTomlinson. I guess this could be part of the `path` within `MoyaTarget`? However, I can see this to be difficult to implement in a generic way.
 I've added this for consideration to the v5 milestone, since now's the opportunity to break APIs (though not too much).
 Is this something we might be able to take on for `8.0.0` still? Not sure how this would fit in the API as it stands right now. @Moya/contributors, anyone? At first look, this seems doable with the associated values approach that we use--though might not be the most elegant way to handle it. Should we close this? I think it'd be nice to see if we can improve here in the future.  Sounds good to me. Looked at this more and took a look at @kylef's [URITemplate](https://github.com/kylef/URITemplate.swift).

I'm not sure I see the advantages to incorporating it here. This is what our current approach would look like:

```swift
var path: String {
  switch self {
  case .repo(let user, let repo):
    return "/\(user)/\(repo)"
  }
}
```

Using the approach from `URITemplate`, we could get something like this:

```swift
var path: String {
  switch self {
  case .repo(let user, let repo):
    return uri(template: "/{user}/{repo}", values: ["user": user, "repo": repo])
  }
}
```

This would introduce more expensive and fragile Regexes into constructing paths, has fewer compiler checks, and doesn't really look more readable to my eyes (granted Swift's string interpolation looks kinda ugly in paths).

Using reflection, I could get something like this:

```swift
var path: String {
  switch self {
  case .repo:
    return uri(template: "/{user}/{repo}")
  }
}
```

That does look nicer than the previous example, but it adds the additional drawbacks of requiring that the tags of the URI template match the order and number of associated values in the enum case, so it would be harder to associate any values not in the URI with the enum case. Also, you wouldn't actually be matching the tags--you could use "/{dog}/{cat}" and get the same result.

So at least in my opinion, our approach is superior because no regex and compiler checks. Maybe I am missing something though? ü§î I agree, and think our approach is better, at least according to Moya's vision:

```
Some awesome features of Moya:

- Compile-time checking for correct API endpoint accesses.
```

Which I think the current approach seems to do. Closing this. If anyone disagrees or has an even better solution, please feel free to reopen. Thanks for weighing in, @kylef! I think it's a really great tool, just not for Moya. :)  This should close #241 when it is finalized. The carthage targets should work but I am seeing errors when I run `pod lib lint`. Not sure what to do about it. The error is as follows:

```
 -> Moya (4.3.1)
    - ERROR | [Moya/ReactiveCocoa] xcodebuild: Returned an unsuccessful exit code. You can use `--verbose` for more information.
    - NOTE  | [Moya/ReactiveCocoa] xcodebuild:  <module-includes>:2:9: note: in file included from <module-includes>:2:
    - ERROR | [Moya/ReactiveCocoa] xcodebuild:  /var/folders/z3/llmwqlln7pz907z5596pjct80000gp/T/CocoaPods/Lint/build/Release-watchsimulator/ReactiveCocoa.framework/Headers/ReactiveCocoa-Swift.h:94:9: error: 'ReactiveCocoa/ReactiveCocoa.h' file not found
    - NOTE  | [Moya/ReactiveCocoa] xcodebuild:  <unknown>:0: error: could not build Objective-C module 'ReactiveCocoa'
    - ERROR | [Moya/ReactiveCocoa] xcodebuild:  /var/folders/z3/llmwqlln7pz907z5596pjct80000gp/T/CocoaPods/Lint/build/Release-appletvsimulator/ReactiveCocoa.framework/Headers/ReactiveCocoa-Swift.h:94:9: error: 'ReactiveCocoa/ReactiveCocoa.h' file not found

[!] Moya did not pass validation, due to 3 errors.
You can use the `--no-clean` option to inspect any issue.
```

Besides that it should be ready to go. 
- Adds tvOS and watchOS support
- Fixes carthage OS X target not having source files
- Makes base OS X target 10.9 instead of 10.10
 Looks :100: I have an idea about the lint failures ‚Äì will let you know. 
 Hmm. No dice here. Looks like it's problems with RAC on the watch/tv platforms. I'll try to look into it shortly. 
 Getting the same errors. Makes me think it's a problem I made with the podspec. I'll take a look at it tomorrow with @orta and see if we can get this merged. 
 Sure thing, hit me up when you get in to the office
 Alright, so it looks like the watch isn't getting `ReactiveCocoa/ReactiveCocoa.h` - it's likely from [this](https://github.com/ashfurrow/ReactiveCocoa/blob/v4.0-alpha.3-podspec/ReactiveCocoa.podspec#L48) subspec not providing a watch/tvos reference to the source files.

I did something like this for [Artsy Authentication](https://github.com/artsy/Artsy-Authentication/blob/17ceee99c3b3170a49b5fca7f7650f94f40e1de9/Artsy%2BAuthentication.podspec#L26).
 I've pushed up an updated podpsec to trunk that should deal with the problems: https://raw.githubusercontent.com/CocoaPods/Specs/92a7990f1f521367d3c4a1274d3ca37564973054/Specs/ReactiveCocoa/4.0.3-alpha-3/ReactiveCocoa.podspec.json
 Validating now. 
 <img width="403" alt="screen shot 2015-11-06 at 10 15 58 am" src="https://cloud.githubusercontent.com/assets/498212/11000374/65b1df06-846f-11e5-8c53-5b17c7e3b98d.png">
 Pushing up an update now. 
 Alrighty! Moya now supports iOS, OS X, watchOS, and tvOS: https://raw.githubusercontent.com/CocoaPods/Specs/2589039691ec831ba080994a5f4387306260da22/Specs/Moya/4.4.0/Moya.podspec.json

Thanks for all the hard work @petester42!
  Fab :cake: Gonna merge manually ro run a `pod install`. 
  Super, this looks great! Did the podspec already get updated? 
 No problem, it passed CI :)
  Removes some redundant code similar to #278.

Also, I added the changelog to the Xcode project so it's easier to find, and did a `pod install`.

@petester42 would you mind reviewing this one and merging when you're comfortable with it?

Fixes #276.
 Cool! I like the matching, but the empty return type is probably unnecessary. We don't specify `-> ()` when creating the obervable, either. Wanna take those out? Otherwise looks :100:
 Cool, great work! 
  Howdy. Please forgive me if I am wrong here. I've been working with the Swift version (v4) of ReactiveCocoa for a week or so.

I was reading this code: https://github.com/Moya/Moya/blob/3cd402cfddf2b361b6251de6d24214758ae54511/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift#L20-L47

and it looks a lot like there's a redundancy. The outer producer, when started, starts the inner signal, and seemingly just pipes the events from inner -> outer, and links the inner disposable to dispose when the outer does. The outer producer seems superfluous.

As an experiment, I reduced it down to this:

``` swift
public func request(token: Target) -> SignalProducer<MoyaResponse, NSError> {

    // Creates a producer that starts a request each time it's started.
    return SignalProducer { [weak self] observer, requestDisposable in

        let cancellableToken = self?.request(token) { data, statusCode, response, error in
            if let error = error {
                observer.sendFailed(error as NSError)
            } else {
                if let data = data {
                    observer.sendNext(MoyaResponse(statusCode: statusCode!, data: data, response: response))
                }
                observer.sendCompleted()
            }
        }

        requestDisposable.addDisposable {
            // Cancel the request
            cancellableToken?.cancel()
        }
    }
}
```

And it still works as-expected, and unit tests pass. So am I missing a specific reason or behavior of producers that requires it to be the first way in some specific scenario? If there is, please explain if you're willing, I'd love to understand and improve my RAC-fu üëäü§ì. Otherwise, I will PR this.
 Interesting ‚Äì I think it's likely a relic of when we were keeping track of inflight requests, and deduplicating new ones. I think @justinmakaila would be able to give a concrete answer about it. 
 Coooool, @JRHeaton did you want to open a PR? 
 Yes, will do. Thanks for verifying! :+1: 
 Going to reopen this, as @petester42 pointed out the issue is in the RxSwift provider, too. 
  Hi there. I really like Moya, yet it's currently not set up ideally for people wanting to install via Carthage, or even manually integrate with target dependencies. I've updated the project in a few ways to make things better for those people, and not affect the situation with CocoaPods. My motivation for doing so is that it's currently impossible to install [Mantle](https://github.com/Mantle/Mantle) and the latest ReactiveCocoa at the same time via CocoaPods. I'm attempting to build a framework that depends on Mantle, RAC, and [Reactive]Moya.
### Carthage Changes
- An Xcode project has been made with 3 shared iOS framework targets: `Moya`, `ReactiveMoya`, and `RxMoya`. 
- Each of the 3 targets has been set up to link against built `RAC`/`RxSwift`/`Alamofire` products in `Carthage/Build/iOS`, which will happen magically when installing Moya to another project, and can also be done locally for development using `carthage update --use-submodules --platform iOS` to install and build them.
- A proper `Cartfile` for installing deps either locally for development or through another project's `Cartfile`. This now includes all of the dependencies that are needed to build each of the 3 Moya framework targets.
- Now that a Carthage install of Moya doesn't need `Pods.xcodeproj` to work anymore (the symlink `_Carthage.xcodeproj` has been removed), there is no need for the pods-installed RAC to build to build Moya. This removes that redundancy and _saves time_.
### CocoaPods changes

For the most part, none. The `Demo` project remains in-tact and the same, still hosting the unit tests for this library and being set up ahead of time with `pod install` for CI and such.
- Updated RAC dependency to the latest version released.
- It made sense to move the shared source code of Moya to `Source/` instead of `Moya/`.
### What does this mean for maintenance?
- Source file references need kept up-to-date in the Xcode project with the framework targets.
- Align the dependency versions of `RAC`/`RxSwift`/`Alamofire` in the `.podspec` the `Cartfile`.
### In simple terms
- CocoaPods users of Moya will see no changes, other than a newer RAC version. 
- Carthage users of Moya now have the lovely advantage of Carthage itself resolving the deps of Moya.
- It's not much extra work for authors :)
### Tests

Unit tests are currently still in the Demo project as a separate target as before.

Also, I'm unsure about it for this project, but `Cartfile.resolved` may be unnecessary to track. 
 Hey there! Gotcha ‚Äì a few things. You'll need to pull in changes from master (tests there [are currently :green_apple:](https://travis-ci.org/Moya/Moya)). If Carthage no longer relies on the Demo Xcode project at all, then we can stop checking in `Demo/Pods` altogether, and also stop duplicating changes in our pod specs for RxMoya and ReactiveMoya. 

At first glance, this change looks good to me :+1: We've been keen to avoid splitting in two, because we had previously tried splitting up the Moya _repo_, which didn't work. Keeping it all here would be fine imo. Let's see if anyone has any comments. 
 Cool, I've made the changes you mentioned, fixed a couple of things, and set the iOS deployment target to iOS 8.0 to match the podspec.

 I've been giving some other things a bit of thought...
- ~~What purpose do/did the separate Rx/RAC Moya podspecs have?~~
- What would be the correct rDNS company identifier to use for these targets' bundle identifiers?
- Should I add a step to the CI script to run `carthage checkout --use-submodules; carthage build --platform -iOS --no-skip-current` (verify that things resolve & build via Carthage)?
 Oh, hmm. Current ones are `com.ashfurrow.Demo` ‚Äì not really appropriate anymore. Are the important in Carthage? If we just need one, `com.example` is fine.

The podspecs provide Carthage-compatible build targets in the Xcode project, but also complicate unit tests. I don't believe their needed after this PR ‚Äì getting rid of them would be :100:
 Heh, oops, I updated that comment right as you replied. The identifier will be set as the bundle identifier of the built product, so it probably would seem a little weird to see a shipping app embedding a `com.example.ReactiveMoya` bundle, for example. I'll go ahead and remove the podspecs from this branch though :smile: 
 Well, there _really_ isn't much more work to do. Making sure the targets reference the right files is a matter of seconds of work, and only on the occasion that you actually add or remove a file. How often is that, and is the extra 15 seconds to open the project and drag in the file truly "a lot of work?" Definitely not any "duplicate" work that I can think of. The podspec in most cases should automatically work with file changes if the patterns still match said files. 
 I've just tried, works pretty well. Good work, @JRHeaton!
 Yea I like this. Maybe could use some documentation? Time for a Contributing.md file? 
 Also I think that adding a CI step to verify carthage is a good idea. Does anyone know if its possible to run 2 CI steps, one for unit tests one for CP/Carthage install testing?
 It‚Äôs possible to override Travis‚Äô script command and do both.¬†

--¬†
Ash Furrow
Sent with Airmail

On October 27, 2015 at 12:39:36 PM, Alexander Schuch (notifications@github.com) wrote:

Also I think that adding a CI step to verify carthage is a good idea. Does anyone know if its possible to run 2 CI steps, one for unit tests one for CP/Carthage install testing?

‚Äî
Reply to this email directly or view it on GitHub.
 So as it turns out, the two extra podspecs may be required after all. With Rx and RAC variants only available now as subspecs of Moya, there isn't a way to install Moya/RxMoya/ReactiveMoya as separate modules into the Demo app. Trying to install both subspecs will build both RxMoya and ReactiveMoya sources under the 'Moya' pods project target, which will have conflicts (for example, the public `Image` typealias that exists in both source bases).  So is the best solution just to keep them?
 This is why they were originally added ‚Äì Carthage does not have any concept of a subspec, and the maintainers refuse to accept one to encourage smaller libraries. To get rid of them, we would need multiple Xcode projects for Carthage? If we need to keep them, what's the concrete difference with and without this PR to someone using Carthage?

This is, like, my least favourite part of software development. I'm sure others feel the same. Thanks for the hard work everyone ‚Äì don't forget that this is volunteering, not your job. Don't burn out! If you need to step back or take a break, do it. 
 Heh, except I'm trying to use Moya at my job. ;)
Definitely not the highlight of software development, but we're all smart people and we're getting closer :+1: And indeed thanks to everyone who has commented and helped out so far.

So to clarify a bit, this isn't an issue with Carthage, it's an issue with the Demo project and its test target needing to test all 3 modules. Carthage doesn't require a concept of a subspec because it just builds any shared framework target, from a regular old Xcode project. You can configure any number of framework targets in any way you want, with any sources you want. This is why we have 3 targets in one project, Moya/RxMoya/ReactiveMoya.

So the issue is that _Without_ separate podspecs for the `Demo` project, there's no way to install 2 different subspecs as separate targets. For example:

``` ruby
pod 'Moya', :path => "../"
pod 'Moya/ReactiveCocoa', :path => "../"
pod 'Moya/RxSwift', :path => "../"
```

Now the sources of all three of those are trying to be built into one framework target by pods, which doesn't work. I think that these may have originally been made to, as you've outlined, build proper framework targets for Carthage to use, but what I think was not realized is this fact, that the tests in the Demo project _also_ depends on there being all 3 frameworks.

There are a lot of refinements for Carthage on this PR, the most important one is that now dependencies of Moya are resolved _through Carthage_, and it isn't relying on an underlying pod install to be set up properly. Before, even with the dependencies listed in the Cartfile on master, that means those projects are having to be built twice. Once in the pods project, once in Carthage. This not only takes time, but lately it's been a 100% dead stop for my team trying to use Moya since the RAC podspec was broken for a while, and now Mantle's is as well, hence our usage of Carthage. I guess you could say this PR enables one to unhook from needing any work done from pods when you're using Carthage.

Regarding CI, I have been trying to think of a reasonable way to test Carthage stuff on Travis. Since iOS framework targets require code signing though, and some of our dependencies, like Alamofire, leave the default identity value as "iPhone Developer", Carthage skips building their targets, which is obviously an issue, as _our_ targets depend on them. Some of them do properly build for the "iphonesimulator" sdk, and I'm not sure how they set up their projects to do that, but I will investigate it and apply it to the framework targets in this project. The remaining issue though is that we'd need those dependencies to also update their code sign settings in the same way, which is hard to count on.
 Reading the rest of your comment, though the following with CocoaPods:

``` rb
pod 'Moya', :path => "../"
pod 'Moya/ReactiveCocoa', :path => "../"
pod 'Moya/RxSwift', :path => "../"
```

Works fine. 

EDIT: I see you clarified after ‚Äì was reading the email >.<
 Not clear on the need to use Carthage, but that's fine. I realize Mantle complicates things. 

Yeah, we know that the tests are using different frameworks. In an ideal, CocoaPods world, we would build _one_ Moya framework with all the subspecs. But we need to accommodate Carthage, so we instead have these extra podspecs for them. It leads to duplicated code in the tests because there are several different `MoyaTarget` protocols depending on which framework you've imported. 

This conversation is getting pretty lengthy ‚Äì I'm not even really sure what we're trying to accomplish anymore :confounded: Would hopping on a Google Hangout help? 
 > In an ideal, CocoaPods world, we would build one Moya framework with all the subspecs.

What i'm saying is that this is not possible currently, because code from RxMoya conflicts with code from ReactiveMoya. 
For a concrete example, the definition of `Image` in both of these files:
- https://github.com/Moya/Moya/blob/master/Moya/RxSwift/Observable%2BMoya.swift#L5
- https://github.com/Moya/Moya/blob/master/Moya/ReactiveCocoa/SignalProducer%2BMoya.swift#L5

Basically, compiling all of the Moya source code in one build target will not work without some source modifications, so I put the separate podspecs back. That work, including reducing down unnecessary tests, can be done on a separate PR.

The goal is still the same for this PR: restructure things a bit so that the project "natively" supports Pods _and_ Carthage.  That part is done. Can we come up with a concrete list of things left to do that are required to consider this PR ready? I'm more than happy to do the work and finish it up, I just need to know what's actually required. Otherwise, if you feel there's more to discuss, and perhaps too much for here, I'm not opposed to a call.
 OK, cool. I think this PR is ready for final review.

One side-note:

> compiling all of the Moya source code in one build target will not work without some source modifications

This `typealias` is currently the only duplicated symbol ‚Äì it should be moved into the ReactiveCore group and defined _once_. Other than that, you could use all subspecs in the same CocoaPods project. 
 Looked through the [raw diff](https://patch-diff.githubusercontent.com/raw/Moya/Moya/pull/267.diff) ‚Äì all looks :+1: 
 OK, so we need contributing docs, deduplicated `Image` typeliases, and see if we need the extra podspes.
- https://github.com/Moya/Moya/issues/270
- https://github.com/Moya/Moya/issues/269
- https://github.com/Moya/Moya/issues/271

Anything I'm missing @JRHeaton ?
 Looks correct to me :+1:. Thanks for going ahead and making issues for those.
  :bow:
  I am getting 

```
A shell task failed with exit code 66:
xcodebuild: error: Scheme Moya is not currently configured for the build action.
```

when running `carthage update --no-use-binaries --platform iOS`
 Cool, so we just need CI + merge from master + changelog update. 
 Looks like ReactiveCocoa was updated in https://github.com/Moya/Moya/commit/535d7a1b03673f9097f89686b2845cc7685cbba8#diff-51d740005a289b6c12f9ba0fe81dc8db ‚Äì does that sound right? 
 Cool, thanks for checking!
  Cool! I can handle updating the tests. What's the lint error?
 Awesome! I'll take a look at tests when I get home. Thanks again! 
 Going to merge this as-is; I've opened https://github.com/Moya/Moya/issues/265 to address the CI. Thanks!
 Hey, so that's a great question. Normally, tags are created with the [automated release task](https://github.com/Moya/Moya/blob/3f657edb6dcb2346754d65828b898e2b58cf95a4/Rakefile#L28). I just forgot to run the task after merging this >.<
 New version is up: https://raw.githubusercontent.com/CocoaPods/Specs/87704665c95c9c49e1324991ee94142c3504ded6/Specs/Moya/4.1.0/Moya.podspec.json
  :+1: This looks good
  You just need a new tag for Carthage, right? Can do :)
 Cool, I've created https://github.com/Moya/Moya/releases/tag/4.0.2-carthage ‚Äì let me know if that works!
 As long as the new release didn't re-re-introduce the problem :sweat_smile: What did the fix turn out to be, so we can integrate it into our deploy script?
 OK, cool. This commit ( https://github.com/Moya/Moya/commit/d0d30b1ce98972ce30d4a5b7b2be0aa3d7b43fe3 ) got released as 4.0.3 tag. My guess is an older version of CocoaPods was used to deploy the problematic release. Let me know if it works. 
  Not sure what caused it. Looks like a problem with Xcode (go figure).

```
The following build commands failed:
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(1 failure)
2015-10-22 00:38:04.847 xcodebuild[769:3065] [MT] IDETestOperationsObserverDebug: (357FE833-30CF-44F9-9DD3-7F464EB8F250) Beginning test session with Xcode 7A220 on target <DVTiPhoneSimulator: 0x7f99c2cdecf0> {
        SimDevice: SimDevice : iPhone 6 (CEBBD79A-B6C1-4A02-BD33-56BBCBDED03E) : state={ Shutdown } deviceType={ SimDeviceType : com.apple.CoreSimulator.SimDeviceType.iPhone-6 } runtime={ SimRuntime : 9.0 (13A340) - com.apple.CoreSimulator.SimRuntime.iOS-9-0 }
} (9.0 (13A340))
2015-10-22 00:38:33.992 xcodebuild[769:4353] Connection peer refused channel request for "dtxproxy:XCTestManager_IDEInterface:XCTestManager_DaemonConnectionInterface"; channel canceled <DTXChannel: 0x7f99c33d1c20>
Testing failed:
    Command /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc failed with exit code 1
** TEST FAILED **
```
 Misery loves company :)
 Hmm, we're actually not seeing this problem anymore. Going to close the issue. 
 Looks like I spoke too soon. 
 Can't hurt!
 Cool, so this is hopefully fixed in #317, but let's keep this issue open for a while to make sure.
  How are you installing Moya? CocoaPods? What does your podfile look like? Xcode 7, right? Did a clean build produce a different error? 

## 

Ash Furrow
iOS Developer, Author
http://ashfurrow.com

> On Oct 21, 2015, at 9:01 AM, istvanelekes notifications@github.com wrote:
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Interesting! Could you send a pull request? 
 Since #261 is merged, I'm going to close this. If it's still a problem, please re-open!
  Clever! Couldn't have done it better myself. I don't think this needs any unit tests ‚Äì could you add an entry in the changelog? We'll give people a day to look at #256 just in case, and we'll get this merged! Thanks for the PR :100: 
 Looks good, @nosrak113. :sparkler: 
 Released in https://raw.githubusercontent.com/CocoaPods/Specs/23ec77d5074667f94cc3820123b8e18fad5061fe/Specs/Moya/4.0.2/Moya.podspec.json as 4.0.2.
  Hmm, neat idea! I don't see a downside to it, other that we'd be leaking out information that a developer could misuse... Doesn't seem like a big risk to me. We'll give it some time for anyone else to chime in and then whip this up!

@nosrak113 If you'd like, I can give next steps for how you could submit a pull request to add this feature. No pressure ‚Äì just let me know if I can help!
  Fantastic, thanks a lot @bojan!
  Hey! Good question! The `onlineSignal` isn't a part of Moya, just our app. I actually just sent a PR changing the behaviour of the `onlineSignal` ‚Äì maybe that would help answer your question? https://github.com/artsy/eidolon/pull/527
  This looks OK to me; not too ¬´savy¬ª on `Carthage`; but not providing the last part of the `semver` will still work and will pick up minor releases?
 In my experience with Carthage, the last version (`2.0.2`) is picked up.
 Thanks @aschuch.

I think it won't hurt to merge this change.

Thanks
  :+1:
 Shouldn't the Cartfile specify `~> 2.0` instead of `~> 2.0.2`? Not sure about the exact implications of this, but pinning to a major version seems to be the better choice here. Opinions?
 Go for it :)
  Looks great, thanks!
  Hi there. I've noticed that this library is set up to resolve its own dependencies via CocoaPods, but shares the Pod project's framework targets to be built as shared so that Carthage can see them. So far so good.

The "issue" is that when installing Moya via Carthage, if you were to simply list Moya itself as a dependency, it will not fetch for example, Alamofire, which is a mandatory dependency of Moya.

Thus, our app that uses Moya must have the following entries in the Cartfile (since we also use ReactiveMoya):

```
github "Alamofire/Alamofire" ~> 2.0.2
github "Moya/Moya"   ~> 2.4.1
github "ReactiveCocoa/ReactiveCocoa" "swift2"
```

I think this can _possibly_ be remedied by including a Cartfile for Moya in the root of the repository that lists the dependencies. It won't need to be used obviously during development of Moya, but will provide a way for Carthage to know which deps to download + build. At the very least, I feel like this should be detailed in the README so that people don't have to debug this.
 I've also realized another fault due to Moya's project dependencies coming from the podspec. We are attempting to install Moya via Carthage with yesterday's Xcode beta, and using the `swift2` branch of ReactiveCocoa. Moya builds its own version of RAC that comes from its pod dependency on it. Because of this, and since it's an older version of RAC than we actually depend on, Carthage fails to build Moya's RAC w/ the beta command line tools.

The way this project is set up for Carthage is seemingly less than ideal. Is there some way that it can be changed to better support it (while retaining your support for CocoaPods)?
 Just brainstorming possible solutions here.

RXMoya, ReactiveMoya, and Moya could each have their own (shared) framework target inside of a dedicated xcodeproj (allowing carthage to build them), and then your subspecs could be kept to point to the same files still for people installing through pods. The demo project could install the library via either pods or carthage (or both, with two targets).
 We've gone through all this before, and eventually found that this was the least-bad ways to support Carthage users without placing an unreasonable amount of extra work on people maintaining and improving Moya. We're not moving to separate repos and multiple xcodeprojects to keep up to date for a a file or two per sub-project.

The alamofire PR looks like a good idea
 @orta There isn't a need for multiple repos as I understand it.  It's just having one single standard project w/ the 3 framework targets, and a Demo project that installs/uses it locally. Theoretically the Demo target(s) could even be in the same project file as the framework targets I think. The only maintenance I see being needed there is adding/removing references to source files to the framework targets when files are created/deleted, whereas they would be automatically included via the podspec's source file patterns.

When installed via Carthage, that project's 3 targets would be built and made available, as well as the dependencies listed in the Cartfile as expected. When installed with Pods, the podspecs work as they do now, generating targets to build etc.

Our team is currently working on a framework we plan to make available via Carthage, and would be nice to make usable via pods as well. So I'm genuinely interested from an author perspective what you feel the burdensome work deriving from such changes could be. It could help us save some time in the future potentially also :)
 Most projects will "just work" with Carthage,which is why I made `pod lib create` work with it by default and it's likely that most libs that ship with support come from CP. Moya seems to have hit the point where it was too complex to do it that way. A lot of this is in https://github.com/Moya/Moya/pull/215- but I'm afraid I'm going to decline your request for more information, given my position on the CP team.
 I don't see how most will "just work" ‚Äì factually, you are missing one single file at minimum that will _not at all disrupt your current setup_ (`Cartfile`) that is _required_ to have it checkout/build these frameworks, unless people want to use the ones Pods built (which requires going into the Pods build dir, rather than `Carthage/Build, and takes away dep version specification control from the depending target's Cartfile which is confusing to everyone). 
We ran into confusion at first when realizing Alamofire was missing when it's a direct dep of Moya, and then again when we adopted ReactiveMoya and ReactiveCocoa was missing. I can't quite see how maintaining a 2 line file is determined to be too much work; I think it could be at the very least a good compromise?

Otherwise, it reasonable to at least put proper usage instructions in the README? Saying use `github "Moya/Moya"` and that alone is gonna wind up with people going through the same aforementioned confusion, however brief (though this will be hard on beginner users of Carthage, which many are w/ it being new).

Also, not sure what's up with "declining request for information" (had a "whut" moment reading that actually) ‚Äì not only was it a pretty innocent request for opinion based on experience of what the "extra" work on similar goals we have was (in attempts of just understanding why not to properly support Carthage), but also stated that you're not saying anything because you work on Pods? I didn't realize there was a "don't use that guy's tool" war going on :'( Saying "we don't wanna support X because our Y will be supported by more people" serves only to perpetuate that truth. I was not trying to overstep or pry for information that isn't public or is special sauce... My apologies if I did. I will look at the PR you linked to and try to deduce what the deterrent was.

In the mean time I think we will just fork Moya and update it to support the dependency and Xcode versions we need. Thanks for the replies guys; no intention to come off abrasive, just want a better world where we can all use these sexy libraries without being constrained to certain dep managers :)

PS: fwiw as a random opinion, as someone who comes from a time before Pods/Carthage, it's also less desirable from a depending app setup that a library has no dedicated natural build targets for itself (in an xcodeproj) even with Carthage support not being considered. Makes manual integration via target deps + linking the framework impossible, as pods generating a project is the only way of building it.
 I agree with @gregpardo on this.

Like Orta stated already `Moya` grew to a ¬´too complex¬ª scenario where there's no ¬´works for all¬ª solution; I think supporting `Carthage` via the underlying `Pods` project works for _most_ of the cases and having a more ¬´detailed¬ª installation instruction for `Carthage` on the `README` would satisfy those scenarios not covered by the `Pods` project.
 Updating the README w/ proper directions for Carthage is an understandable compromise to the original issue topic. I think that is helpful from the perspective of someone using the library. :)

> The Cartfile is there now but I don't think it should include ReactiveMoya. Not all projects will need that dependency.

I think you mean `ReactiveCocoa`. While true, ReactiveMoya(+RAC) is already checked out + built anyway when Carthage builds all 3 framework targets in the Pods project (there are no subspec-specific installs w/ Carthage). Including RAC in the Cartfile would build that version into `Carthage/Build` (as expected anyway ‚Äì this will eliminate "hunting" for the build RAC result from Pods). Sure it will mean having 2 RAC builds, but that is already happening with the current setup (since dependent apps have to list it in their own Cartfile, breaking this rule here: https://github.com/Carthage/Carthage#nested-dependencies)
 That is correct, those all need checked out and built, though not all will need integrated into dependent targets (Rx/RAC mutually exclusive in this case).
 The only downside would be that for people installing Moya via Carthage with no intent to use the Reactive or Rx extensions will have to wait for Carthage to build its RxSwift and ReactiveCocoa checkouts. But this is sort of the nature of Carthage with there being no support for subspecs or any way to specify specific targets to build when checked out.
  I guess we haven't needed to set the request body directly. You can do that using the `requestClosure` if you associate a value with your enum case.

``` swift
let requestClosure = { (endpoint: Endpoint<YourAPI>, done: NSURLRequest -> Void) in
    let request = endpoint.urlRequest // This is the request Moya generates
    switch endpoint {
    case NeedsBodySetDirectly(let jsonArrays):
        let newRequest = ... // modify request to set the request body to encoded jsonArrays
        done(newRequest)
    default:
        done(request)
    }
}
let provider = MoyaProvider(requestClosure: requestClosure)
```

Our goal is mainly to abstract that messy stuff away and only do the mapping to parameters or body once, instead of at every request. 

Let me know if I can clarify anything.
 Is that a limitation of Swift's? As far as I know, you should be able to associate enums with custom types. 
 Ah yeah, thanks! We recently did a large rename and some of the documentation slipped throw :grimacing: 
  Continues some work done on https://github.com/Moya/Moya/pull/243. Mostly adding some newlines, removing an old file, and removing references to (defunct) inflight request tracking.

@petester42 I'll leave this up to you to review + merge? 
  Thanks a lot!
 :scream: beat me to it Ash :smile: 
  I think you can specify the specific branch of `RxSwift` on your `Podfile` with `tvOS` support and `CocoaPods` should be able to use the branch specified in the `Podfile` (as long as that doesn't break current implementation of `Moya`)
 ¬Ø\_(„ÉÑ)_/¬Ø  sorry; i thought you were trying to use a ¬´custom made¬ª `.podspec`.

It shouldn't take too much to support `tvOS`. I'll try to get to it today.
 Strange, our dependency on RxSwift is [~> 2.0.0-aplha-1](https://github.com/Moya/Moya/blob/a8a491bf14ab7ad4ce7793a204868fd05f03a4dd/Moya.podspec#L40). 

Esteban, it'd be great if you could do this ‚Äì I'm travelling and don't have good access to internet. If you need push rights for CocoaPods trunk, let me know. 
 @ashfurrow I just updated the `.podspec` to use `2.0.0-alpha.4` which is the one with `tvOS` support.

Also added all supported ¬´devices¬ª like so:

``` ruby
s.ios.deployment_target = '8.0'
s.osx.deployment_target = '10.9'
s.watchos.deployment_target = '2.0'
s.tvos.deployment_target = '9.0'
```

I can upload the `.podspec` but I can't push to trunk (I don't have push rights and the `pod spec lint` fails due to the dependency issue with `Alamofire`.

``` ruby
Resolving dependencies of
 -> Moya (3.0.0)
    - ERROR | [tvOS] unknown: Encountered an unknown error (The platform of the target `Pods` (tvOS 9.0) is not compatible with `Alamofire (2.0.2)`, which does not support `tvos`.) during validation.

Analyzed 1 podspec.

[!] The spec did not pass validation, due to 1 error.
```

We could have it living on a `tvOS` branch (the `.podspec`) while `Alamofire` merges that branch to `master` or makes an official release supporting it and people could use `Moya` for `tvOS` from our support branch.
 Sure ‚Äì it surprises me a library as popular as Alamofire doesn't have tvOS support on trunk yet. Putting the podspec on a branch for now sounds like a good plan. 
 Branch [`tvOS`](https://github.com/Moya/Moya/tree/tvOS) should address this.

Please @gregpardo test it and let me know if something is not working.

PS. I also modified the `Podfile` to use this branch
 Yeah; try to specify the `Podfile` like the `Demo` project in that branch => https://github.com/Moya/Moya/blob/tvOS/Demo/Podfile

Chances are you are missing this from the `Podfile`:

``` ruby
# Fix for `Alamofire` with `tvOS` support
  pod 'Alamofire', :git => "https://github.com/Alamofire/Alamofire", :branch => "tvOS"
```

---

_Bear in mind this is temporarily until `Alamofire` moves `tvOS` support to the `master`/official branch/release_
 Added 2 labels to it.

I think leaving it open would be better so we can keep it in mind.

I'll :lock: the issue though since it doesn't make sense to keep it open.

If any @Moya/contributors has other idea as to how to handle this I'm open to ideas.

Thanks for confirming the fix @gregpardo :bow: 
 Just noticed that when we merge `tvOS` with `master` we'll be able to close #192 as well since the `.podspec` on that branch already handles `OSX`, `watchOS` and `tvOS` :tada: 
 http://search.cocoapods.org/api/v1/pods.flat.ids.json?query=platform:tvos

tvOS support requires someone with the latest CP rc pushing, so it's got a pretty slow adoption ( plus my plugin undermines it somewhat )
 What an odd discrepancy. @Thomvis is there any reason the CocoaPods trunk version doesn't have TV support? 
 We should see an updated version tomorrow :)
 Result has been updated on Trunk: https://github.com/CocoaPods/Specs/blob/master/Specs/Result/0.6.0-beta.6/Result.podspec.json @petester42 are there any other that need updating? 
 Thanks to @Thomvis for his quick turnaround on that!
 OK, I've updated the [ReactiveCocoa podspec](https://github.com/ashfurrow/ReactiveCocoa/blob/v4.0-alpha.3-podspec/ReactiveCocoa.podspec) on my fork (see: [changes](https://github.com/ashfurrow/ReactiveCocoa/commit/6e9fcdaeeb7710289b57979e2e9ad68b69a6ffb6).)

Unfortunately, I don't have 7.1 installed at the moment so I can't validate + push to trunk. Will do when I get to NYC. 
 Oh, wait. Need to replicate `prepare_command` stuff. 
 Cool, did that: https://github.com/ashfurrow/ReactiveCocoa/commit/7dc4d95df1dd3166fb4acef6498662f695e55721 Just need to lint + push. 
 Opened https://github.com/ashfurrow/ReactiveCocoa/issues/4 to remind me
 Should be good to go ‚Äì validated with Xcode 7.1 just in case, and it worked :+1: 

https://raw.githubusercontent.com/CocoaPods/Specs/a6b9eb7156e4809e43056cd54b6f754d98be6150/Specs/ReactiveCocoa/4.0.1-alpha-3/ReactiveCocoa.podspec.json
 Make that `4.0.2-alpha-3` ‚Äì had a mistake in the podspec :grimacing: 

https://raw.githubusercontent.com/CocoaPods/Specs/112a7c37ff9e86ccb41c4e56a94ef55d7367658a/Specs/ReactiveCocoa/4.0.2-alpha-3/ReactiveCocoa.podspec.json
  This does a few things.
- All sample responses are now evaluated lazily, obviating the need for a `Closure` case in the sample response enum.
- The `EndpointSampleResponse` has been simplified. No one really understood what the difference between `Success` and `Error` was (looking at the unit tests, it doesn't look like _I_ even understood the difference).
- Adds documentation for authentication (HTTP and OAuth).
- Adds logging plugin based on @AlexanderKaraberov's work in #235).

Generally I really like how 3.0.0 has been coming along. Thanks to a lot of work from a lot of different contributors, Moya has gotten simpler and less complex, while also far more powerful. 

After this I thing we should go ahead and release 3.0.0 (see #236).

Fixes #200.
Fixes #220.
 Hey @aschuch ‚Äì you mentioned we can do in-place modification of the `Request` objects, right? I'm thinking that may be better than having the plugin functions return their own request ‚Äì less overhead. Thoughts? 
 Yup. Since `Alamofire.Request` is implemented as a class, we could simply modify the request object in place. There is no real need to return it, just illustrates the intent of the method and would be future proof in case `Alamofire.Request` might be changed to a struct or something.

I still think we could get rid of it now, can always change it back later...

Your implementation of the logger is pretty awesome as well :tada:
 OK cool. @aschuch I've pushed a change for that and would like your go-ahead: https://github.com/Moya/Moya/commit/55d8ed9eef1be7011247174a54a3ce77cb37c0df

The logger was a lot easier after @AlexanderKaraberov did all the work already üòÖ

One more thing ‚Äì I don't care for having to include Alamofire in the plugins. One of Moya's big selling points is that you don't have to care about Alamofire. We're leaking that up through our `manager` property and now the plugins. It's not a _huge_ deal, but I'd love to nip this in the bud. 

What if we created a new protocol in `Moya.swift` that included things in `Request` that you might want to do ‚Äì authentication, for example ‚Äì and then made `Request` conform to the protocol in an empty extension. The nice thing is since no one else uses the protocol, we can add more functions to it later if `Request` adds them, or if we forgot to add them. So expanding the protocol wouldn't be a breaking change. Thoughts? 
 Yeah, I like that a lot actually. Work is done in https://github.com/Moya/Moya/commit/d68c03e276a13f58c4ce3e185ca97042bcb5429b if anyone wants to discuss that specifically. 
 Looking good. 
I like the abstraction of the Request a lot. Much cleaner now. 
 @AlexanderKaraberov Yeah, just released 3.0! We'll be continuing to fix bugs that are reported, and implement features that are requested as they come up. If you have any ideas or suggestions, just open an issue :smile_cat: 
  I would like to propose a plugin system for Moya.
`MoyaProvider` can now be initialized with a set of `Plugin`s.  A `Plugin` receives callbacks to perform side effects wherever a request is sent or received.

For example, a plugin may be used to
- log network requests
- hide and show a network avtivity indicator
- inject additional information into a request

This kind of tackles #144 as well, as the number of additional closures is now much lower and can be initialized with an arbitrary number of plugins

I have also added plugins for the existing `CredentialClosure` and `NetworkActivityClosure` to make it easy for everyone to adopt this change. Maybe we should also try to build a plugin from the Logger in #235?

Would love to get some feedback on the idea or how to make this even more generic for everyone to use (I'm not super happy with the subclassing approach). :heart: 

Fixes #144.
 Generally looks great! I was a bit wary of the idea of "plugins", but I really like the implementation. 

I have a few pieces of general feedback:
- I saw the note about avoiding protocols ‚Äì let's see if we can think of something besides inheritance? Nothing comes to mind, though ...
- Should a plugin be able to distinguish between stubbed requests and real ones? 
- Maybe the plugin functions should accept the `manager` as a parameter? I dunno, probably unnecessary but it feels like something that _should_ happen. Thoughts?
- Could we call them something other than "plugins"? :stuck_out_tongue: 

Thanks again!

![](http://media.giphy.com/media/V2xbsCrxcLQSQ/giphy.gif)
 Thanks for the feedback. I'll push your remarks asap.
- First of, I don't really like the subclassing approach either. I tried a few things with protocols but none of them really seemed to work out. I'd love to discuss alternatives though.
- I decided to give the `Plugin` separate calls for stubbed requests and real ones, because the parameters are a bit different. This could, however, be abstracted into a single method on the plugin that accepts a stubbed/not-stubbed parameter.
- Could easily add the `manager` to the plugin functions, not sure what the plugin would do with it though. Do you have any use cases that come to mind?
- I am not too fond on the term _plugin_ either. Maybe _mixin_? _sideeffect_? I just named it plugin, because everyone is sort of familiar of this term. 

:boom:
 Ahhh, sorry I meant the `provider` parameter (through which, I guess, the `manager` would be accessible too).

I guess what I'm _really_ saying about the stubbed/not stubbed functions is that I don't think the plugin should even know if the request it's being called with is being stubbed or not. 

Nomenclature is hard, let's give it a think :)
 Also, I agree with using a logging plugin for this ‚Äì it looks like we're on board to go forward with this solution, so let's I'm going to close #235. Happy to recreate the logger from there as a plugin, if I could help. 
 And don't forget about the changelog! :poodle: 
 Wow :scream: 
Great idea and implementation @aschuch :bow: :ok_hand: 
 Ok, so I've removed the duplication of methods for stubbed/real requests and added the `provider` to the callbacks.

I have also put together a version [on a different branch](https://github.com/aschuch/Moya/commit/34c10bb4644868bc38a64cc84486549cfc556135) that shows how `Plugin` can be implemented in terms of a protocol. This requires a `PluginContainer` wrapper in order to keep a reference within `MoyaProvider` and satisfy the type system. 

I also tried to make  `PluginContainer` conform to `ArrayLiteralConvertible` to keep the API clean, but could not figure out a way to accept the type constraints.

``` swift
extension PluginContainer: ArrayLiteralConvertible {
    init<P: Plugin where P.T == T>(arrayLiteral elements: P...) {
        willSendRequestClosures = elements.map { $0.willSendRequest }
        didReceiveResponseClosures = elements.map { $0.didReceiveResponse }
    }
}
```
 Any opinions towards keeping the subclass vs. the protocol approach?
 Leaning towards protocols, personally. Will have time to review shortly. 
 Tricky problem ‚Äì I think the root of the issue is that we want the plugins to both be able to be used with any type of `MoyaTarget`, but refer to the specific type that's conforming to that target. 

What I mean is, I'm not sure we need to use a typealias'd protocol or a generic class. What about the following?

``` swift
public protocol Plugin {

    func willSendRequest<Target: MoyaTarget>(request: Alamofire.Request, provider: MoyaProvider<Target>, token: Target) -> Alamofire.Request

    func didReceiveResponse<Target: MoyaTarget>(data: NSData?, statusCode: Int?, response: NSURLResponse?, error: ErrorType?, provider: MoyaProvider<Target>, token: Target)

}
```

Even if someone wanted a plugin to support a _specific_ target type, they should be able to do that:

``` swift
class ExamplePlugin: Plugin {

    func willSendRequest<Target: MoyaTarget>(request: Alamofire.Request, provider: MoyaProvider<Target>, token: Target) -> Alamofire.Request {
        return request
    }

    func willSendRequest(request: Alamofire.Request, provider: MoyaProvider<HTTPBin>, token: HTTPBin) -> Alamofire.Request {
        return request
    }

    func didReceiveResponse<Target: MoyaTarget>(data: NSData?, statusCode: Int?, response: NSURLResponse?, error: ErrorType?, provider: MoyaProvider<Target>, token: Target) {

    }
}
```

@aschuch I'll send a PR over to your fork ‚Äì looking forward to hearing what you think. 
 Hmm, wait that might not work. Anyway, I'll play with it. 
 Nah, this is silly. You have a working solution, let's merge this PR and keep the idea of moving to a non-inheritance approach for another release. 
 Awesome. Thanks for your input everyone. :heart: 
  This looks _great_! Really good work. I've got a few _really_ small pieces of feedback that I'll provide inline. Additionally:
- Can you add a note to the changelog?
- Documentation can go in the `/docs` directory. Add it to the `Providers.md` file (which describes the provider initializer).
- The CI is failing because we really need to address #144. Could you update the `MoyaProvider` subclasses for ReactiveCocoa and RxSwift?

Let me know if I can help with anything ‚Äì thanks again! :cake:
 OK, that's all my feedback. Again, terrific work ‚Äì thanks!
 Looking good. 

One concern that I have: The default logger uses multiple `print` statements to log a single request/response. I guess that multiple simultaneous requests/responses (on different threads) could corrupt the log output in a way that could be misleading to the user...

I would like to suggest to at least accumulate a the log output of each of the `logNetwork...` methods into a single `String` that gets printed at the very end of the method. This way, a single log is somewhat _atomic_.
 Aye, that's a good idea @aschuch 
 NSLog is a good question. Honestly I don't know. Anyone have any resources? Blog posts? Surely Mike Ash has something to say on the matter...
 Yes, exactly ‚Äì just the parameters :smile_cat: 
 I think it is reasonable to accumulate the request log output into a string, then `print` the whole thing. That should be fine. Don't see any reason to use NSLog here. Also, I think its fine to log the request and the response separately (i.e. don't wait for a response to print request + response together).
 Yeah, I think `print` is fine :smile: Don't sweat the small stuff, eh?

@AlexanderKaraberov Do you want this in before we release 3.0? It's a matter of adding this feature to an existing release, or forcing users to adopt 3.0 (with breaking changes) to use it. 
 Closing in favour of new work to be done on #238.
 I think the logger is well-covered, but we've got lots of open issues ‚Äì feel free to dig in to any that look interesting to you!
  Afraid not. It's heavy reliance on Swift's enum functions make it impossible to back port.
  Well, it gets passed in to the Initializer ‚Äì the `MoyaProvider` is a generic type _on_ `MoyaTarget`, so it needs to know what the type is. I'm not sure if `MoyaProvider(GitHub.Zen)` would work, but I haven't tried it. There's no initializer that it could call ‚Äì or is this a Swift thing I'm not aware of? 
 @onmyway133 issues are for questions and clarifications, too! I want to make sure that we're on the same page. Let's start over:

What is happening that you don't expect? What is _not_ happening that you _do_ expect? 
 Yup! And you can only pass enum values of the correct type to the request method, since they're compile-time checked üéâ
 Closing, as I think this is sorted :+1: 
  Huh, good catch! And a great test! Could you add an entry to the changelog?
 Added it in, and merged to master. Thanks again!
  This caused issues for developers not expecting Moya to deduplicate network requests, as well as made it a _pain_ to test and maintain. Ideally, if people even want these, we can further subclass our Rx providers and limit the scope of what they do _just_ to inflight tracking. I don't think anyone will miss it, anyway. 
 Eek this shouldn't be a PR into master...
 My thoughts on this: Ideally this would be something that could be wrapped up in a plugin - it seems out of scope with "core Moya."

But in order to do this in a plugin, we would need to expand the plugin API to include an ability to delay/cancel requests. Not unreasonable, and a "MoyaRequestThrottler" could be really handy!

> On May 1, 2016, at 4:16 AM, Antoine van der Lee notifications@github.com wrote:
> 
> Passing by, as I was looking for this feature. I did miss it, as my app requests many of the same API endpoints at the same time. I was wondering why all these calls were fired.
> 
> Just for my understanding, what would ideally be the way to handle these duplicate calls and prevent them to be all fired? Should I create my own inflights and duplicate detection?
> 
> ‚Äï
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
 It may help to look in an older release to see how we used to do it. It might lend itself well to one solution or another. 
 It's tricky ‚Äì I'm not sure this can be done with a plugin, not without significantly changing what a plugin is and does. The best bet would probably be to subclass `MoyaProvider`, but that doesn't benefit users already using the `RxMoyaProvider` or `ReactiveMoyaProvider`. Not sure there's an easy answer to this, but I'd love to hear ideas!
 That makes sense and is a good solution, but we've had trouble before with "just add an initializer parameter" :smile: It eventually led to https://github.com/Moya/Moya/issues/144 and the idea of Moya plugins in the first place. I'm personally fine with it ‚Äì it's going to be a breaking change either way, so reconsidering plugins might be worth it.
 Looks cool! Want to add tests and submit a pull request? 
 Nope, it should be a matter of opening the workspace and hitting ‚åòU. What errors are you getting? 
 Tricky. Not sure relying on the plugins is the best way to test. You could use a custom endpoint closure or something similar. 2.4.1 was the last version of Moya to support this on all providers (it was even turned on by default!) and it was tested [like this](https://github.com/Moya/Moya/blob/2.4.1/Demo/DemoTests/MoyaProviderIntegrationTests.swift#L267) but wasn't super-great either. 
 Cool, thanks!
  These are meant for the 3.0.0 development branch, since they break things. 

Basically this renames a tonne of things that either no longer make sense, or never did :sweat_smile: Updated the docs and tried to add comments where possible. 
 These are some pretty big changes to the way we name things ‚Äì probably best to get input from @Moya/contributors 
 I definitely prefer the wording here.
 Cooool, thanks! I'll give some time for others to review, too. 
 will need a rebase, but good to merge from me
 OK, will merge when I get a chance. 
 OK, so this has had `master` and `3.0.0-develop` merged in. We should be good to go to merge this ‚Äì once we do, I don't see _too much_ stopping us from releasing 3.0.0 :tada: If anyone wants a final review, now's the time :smile: 
  Alamofire treats them as optional and behaves differently if they are `nil`, so we should allow optionals, too (I guess some servers differentiate between an empty HTTP body and a `nil` one).

Continued from #188. 
 This is fixed by https://github.com/Moya/Moya/pull/228 ‚Äì will be merged in an upcoming release (see #236).
  Pierre-Marc, this is _fantastic work_, thank you very much for your contribution! Well tested, well thought-out. Only thing I can find missing is an entry in the `CHANGELOG.md` file. 

Good to merge this once the changelog is in ‚Äì then we'll release a new version for CocoaPods/Carthage so people can start using this immediately.
  Awesome, thanks! First glance looks great, I'll do an in-depth review tomorrow. Maybe a generic constraint could avoid the forced cast? 
 This looks _amazing_ ‚Äì really well done both of you. I didn't see a changelog entry ‚Äì could you make one?

If this is a breaking change, I'd suggest we merge into the 3.0-develop branch instead of master. If it's _not_ a breaking change, I'm comfortable merging this.
 Sorry, didn't get to this today :( I will do it first thing tomorrow!
 :grimacing: This'll need changes from master pulled in. Let me know if I can help!
 Hmm, still showing as conflicted here: 

<img width="782" alt="screen shot 2015-09-21 at 10 55 06 pm" src="https://cloud.githubusercontent.com/assets/498212/10010084/d58647fc-60b3-11e5-98c1-def1564b6379.png">

Can you double-check? 
 Definitely, thanks :) I'll get back to you about this within a few hours. 
 OK, I'm not aware of anyone who uses the RAC 2 extensions for thoroughly than our app, and in migrating I only saw _one_ issue:

``` swift
let request = Provider.sharedProvider.request(.FindExistingEmailRegistration(email: email))

return request.map { (response) -> NSNumber in
    let moyaResponse = response as! MoyaResponse
    return moyaResponse.statusCode != 404
}
```

It said the type was ambiguous and was easily fixed. 

This feels OK to me, but I know @orta is the semver police here. We'll merge into master if we get the :+1: or merge into 3.0.0-develop otherwise. 
 OK, since _technically_ this is a a breaking change, and I don't want to give Moya users unexpected surprises when the `pod update`, I'm going to merge this into 3.0.0-develop instead. We'll be releasing 3.0 sometime this week, anyway, so you won't have to wait long to see this deployed :cake:

Thanks again for your awesome work!
 OK, cool ‚Äì this is merged in the develop branch, you can see your contributions to the history here: https://github.com/Moya/Moya/commits/3.0.0-develop
  Hey! Don't worry about asking a question on the repo, that's exactly the right thing to do :smile_cat: 

There's no first-class support for this kind of authentication-if-required behaviour. Moya abstracts network calls away, not your authentication. This is a limitation that's recently come up as a request by others, and we're planning on adding support to Moya: #209. 

I had a similar problem on an app I wrote using Moya. [My solution](https://github.com/artsy/eidolon/blob/e4a92cd40b789099297d4d49d5489efc64286269/Kiosk/App/Networking/XAppAuthentication.swift#L8-L26) uses the ReactiveCocoa extensions. Basically I filter all my API calls through one method. It returns a signal (kind of like a promise). The signal represents all the network stuff that has to happen to retrieve the `target`. So first it checks if it needs to re-authenticate, and includes that work in the signal it returns. 

If using the ReactiveCocoa or RxSwift extensions is something you're open to, I'd be happy to provide more details on what that might look like. 
 Sure! So, we're still using the RAC 2 API :cry: but the principles are the same. 

Here's a simplified version of our approach:

``` swift
func XAppRequest(token: ArtsyAPI) -> RACSignal {
    // This is just us looking for our auth tokens, which also expire.
    var appToken = XAppToken(defaults: NSUserDefaults.standardUserDefaults)

    // This is a signal that represents a request to update our auth token, *if* we have to. Nothing will be done unless we include this signal in our return value.
    let newTokenSignal = Provider.sharedProvider.request(ArtsyAPI.XApp).filterSuccessfulStatusCodes().mapJSON().doNext({ (response) -> Void in
        if let dictionary = response as? NSDictionary {
            let formatter = ISO8601DateFormatter()
            appToken.token = dictionary["xapp_token"] as? String
            appToken.expiry = formatter.dateFromString(dictionary["expires_in"] as? String)
        }
    }).logError().ignoreValues()

    // Signal that returns whether our current auth token is valid
    let validTokenSignal = RACSignal.`return`(appToken.isValid)

    // If the token is valid, just return an empty signal, otherwise return a signal that fetches new tokens.
    // After whichever of those completes, _then_ we attach our actual API-requesting signal.
    return RACSignal.`if`(validTokenSignal, then: RACSignal.empty(), `else`: newTokenSignal).then {
        return provider.request(token)
    }
}
```

I've written some comments inline ‚Äì let me know if I can clarify anything!
  Hmm. What are the contents of your Cartfile?

Actually, I'm pretty new at diagnosing Carthage issues. @justinmakaila does this look familiar? 
 @MarvinNazari could you clarify? I built the release of Moya with a version of CocoaPods _newer_ than 0.38.2. 

Again, not terribly familiar with Carthage (we _just_ added support) ‚Äì what happens if you remove the `Alamofire` and `ReactiveCocoa` lines from your Cartfile, out of curiosity? And just have `Moya` and let Carthage bring in the dependencies for you? 
  We're waiting on https://github.com/Moya/Moya/issues/118 to merge for RAC 3 support
 What Xcode version are you using? 
 Looks like it was a problem with ReactiveCocoa's choice to release 3.0.0 as a Swift 1.2 library. We were using `~> 3.0.0-swift`, and CocoaPods assumed that `3.0.0` would be compatible, so it tried to install that. I've pushed an updated Moya podspec that points to a proper 4.0 ReactiveCocoa version. Could you try `pod update ReactiveCocoa` and let us know? 
  Sounds like a good idea ‚Äì doesn't sound too difficult, either. We could hook into the existing provider initialization, if that makes sense, or use NSNotifications. Thoughts? 
 Aye, so this is what I was thinking:

A user could pass in an endpoint resolver or other callback we already have ‚Äì the one they pass in would log stuff. So that's how it could work now. With a new library, we could call a function that curries back a function to pass in. 

``` swift
Provider<TargetEnum>(endpointResolver: MoyaNetworkLogger.StandardLogger)
... or ...
Provider<TargetEnum>(endpointResolver: MoyaNetworkLogger.StandardLogger { target -> NSURLRequqest in
    return /* our custom request, which the logger will then log before passing onto Moya */
})
```

Make sense? 
 Hmm, good question. There's no existing way to log these at all ‚Äì we may have to add yet another callback to the provider :cry: 
 What if we added a property to the provider ‚Äì could be constant or not ‚Äì that conformed to a `Logger` protocol or something, and it gets callbacks about requests and responses. We could provide a basic logger, and people would be free to implement the protocol and provide their own. Thoughts? 
 Hey, this is _almost_ correct. 

``` swift
protocol Logger {
    // logging callbacks
}
```

Then provide a default:

``` swift
struct PlainLogger: Logger {
    // Do basic logging, basically print() all the requests/responses
}
```

Then have a new variable on the `MoyaProvider`.

``` swift
var logger: Logger? = nil
```

Then in our `request` method in the `MoyaProvider` itself, we can invoke the callbacks:

``` swift
logger?.logRequest(request)
...
logger?.logResponse(response)
```

I'm thinking the logger doesn't touch the `MoyaTarget` at all ‚Äì just the HTTP requests. Does that makes sense?
 Hmm, yeah. I suppose it makes more sense to be `let` :smile_cat: 

I think it should be optional, though, and default to `nil`. Many (most?) users won't want HTTP logging. 
 Yeah! 
 Awesome, looking forward to your pull request! Don't worry about getting it in immediately ‚Äì we've all got lives outside or GitHub üò∏
 This can be closed with the release of 3.0.
  Super! Don't forget to add a changelog entry with the update!
 Coooool this is up on CocoaPods trunk: https://raw.githubusercontent.com/CocoaPods/Specs/73d48221ff011b8eb62174b9761bca23c5ba78ca/Specs/Moya/2.2.2/Moya.podspec.json 

Thanks again!
  Hi there! No problem at all :) The Demo project on the current master requires Xcode 7 GM. For Xcode 6.4, you can check out the project in the [last release](https://github.com/Moya/Moya/tree/2.1.0). 

Note that the Demo project on master is currently not able to run an app, just unit tests. I'm working on fixing that in #215.
  Great bug report! This looks similar to #210. Hmm... we haven't found a solution to it yet, either. We'll figure this out :)
 Hmm. You ran `pod install`? What version of CocoaPods are you using? 
 Hmm. The CocoaPods version could be the problem. I remember skipping 0.38.2 but I can't remember why. Maybe updating would fix it?

Alternatively, using our last release with Xcode 6 is a good idea. Check out this tag: https://github.com/Moya/Moya/tree/2.1.0 and let us know how it goes :+1:
 Hmm. I'm seeing the same problem here. I'll investigate and get back to you and @zbeckman as soon as I have a solution. 
 Zacharias found that it was the podfile arrangement. I've pushed a commit that's yet to me merged: https://github.com/Moya/Moya/commit/a2be3c27bffc63427a980ebbcca6cb0c3f14fcec#diff-c2c2f4d15bfae1123d3167a807ac48d6R7
  This pull requests adds Carthage support to Moya, including its two extensions, RxMoya and ReactiveMoya. It builds off of @justinmakaila's work in #169 to include Carthage support, but works using a different solution that @orta and I implemented this afternoon. Let me explain.

In #154, we discussed a solution that involved splitting up Moya into several repositories to generate separate `.framework` files for each Moya, ReactiveMoya, and RxMoya. The solution in this PR instead uses thin podspecs _solely_ for the ReactiveCocoa and RxSwift extensions. This lets the `Pods` Xcode project build separately-named targets, which compile into the frameworks that Carthage needs.

The benefits of this approach are that we keep all of our code in _one_ repository instead of having to synchronize version numbers, tags, pull requests, and so on between three or four repositories. This would be a significant challenge.

The downsides are that we need to keep versions synced between the three podspecs (I've written a `rake` task to automate this). Additionally, if the public APIs to RxSwift or ReactiveCocoa change, Carthage users will need to continue to use the versions required by the CocoaPods builds. I actually kind of like the idea of one Moya existing in parallel on two dependency managers.
## Work Done
- We switched from a `Makefile` to a `Rakefile`.
- Automated releases.
- Re-added `Pods/` directory for Carthage support.
- Duplicated the RxMoya and ReactiveMoya subspecs into their own standalone podspecs, and trimmed them down.
- Removes unnecessary `Box` dependency from the Demo's `Podfile`.
- Updated documentation.
## Next Steps

The [ReactiveMoya](https://github.com/Moya/ReactiveMoya) and [RxMoya](https://github.com/Moya/RxMoya) repositories are no longer needed and should be deleted after this pull request is merged. Any existing Carthage users will need to update their Cartfiles.
## Notes

`MoyaResponse.swift` is included in both Carthage-specific podspecs, but it only appears once in the `Pods` project's file pane. The file is a member of both targets, but only appears once. The ambiguity between the files referenced in both frameworks led me to split up the unit tests into distinct files (to avoid having both `MoyaResponse`s in scope). I also tidied them up a bit.

Fixes #154.
Fixes #184.
Fixes #204.
Fixes #216.
 It generates all three frameworks when you do `github "Moya/Moya"` - as a user, you can choose which ones to integrate this way:

```
~/d/i/l/moya_cart ‚èõ  cat Cartfile
git "file:///Users/orta/dev/ios/libs/Moya" "internal_podspecs"

~/d/i/l/moya_cart ‚èõ  carthage update
*** Fetching Moya
*** Checking out Moya at "e6a00bff2b51838e4449afac952b3937d1cfa6de"
*** xcodebuild output can be found in /var/folders/mk/gxhr550d5mbcv5s9_f61x84h0000gn/T/carthage-xcodebuild.uPEpwO.log
*** Building scheme "Moya" in Pods.xcodeproj
*** Building scheme "ReactiveMoya" in Pods.xcodeproj
*** Building scheme "RxMoya" in Pods.xcodeproj

~/d/i/l/moya_cart ‚èõ  ls Carthage/Build/iOS
Moya.framework         ReactiveMoya.framework RxMoya.framework
```
 Right now that's not the case, but I don't see a reason to not make that behaviour default @ashfurrow ?

Plus it keeps all documentation consistent, that's the behaviour you get from CP.
 So you want the behaviour where you would always do `@import Moya;` and it would work fine regardless of which framework you've imported? This is totally doable using [module_name](https://guides.cocoapods.org/syntax/podspec.html#module_name) in the rx/RAC Podspecs. Also makes it consistent with CP.

I _think_ it would generate three differently named frameworks for drag & drop but they would all all work with `@import Moya;`. Can't guarantee that Xcode allows the generation of the three frameworks with the same module name, but can be tested. 
 OK, I'll play around with the `module_name` for the specs and verify it works :+1: 
 Hmm. Looks like it doesn't have the other Moya files. Makes sense since they're no longer subspecs. Thanks @gfontenot!
 @justinmakaila Looks like CocoaPods can't handle having frameworks with the same module name. 

```
[!] The 'Pods' target has frameworks with conflicting names: Moya.
```

This means that users will need to `import Moya`, `import RxMoya`, or `import ReactiveMoya` respectively. Switching flavours would mean a find-and-replace. Kind of a pain, but people don't often switch flavours, and it's not too much effort. It also fits better with the Carthage folks' philosophy. 

@gfontenot Running the command `carthage build --no-skip-current --platform iOS` (we don't support Mac yet) now produces the following results:

```
*** xcodebuild output can be found in /var/folders/c9/qfv9zg9n23v5yt50skqpmtg40000gn/T/carthage-xcodebuild.5IPQce.log
*** Building scheme "Moya" in Demo.xcworkspace
*** Building scheme "ReactiveMoya" in Demo.xcworkspace
*** Building scheme "RxMoya" in Demo.xcworkspace
```

This seems good to me :tada: 

There's a failure on CI ‚Äì looks like Xcode is getting confused about something when building the unit tests. Investigating now. 
 :green_apple: 
 Instead of removing the no-longer-needed [ReactiveMoya](https://github.com/Moya/ReactiveMoya) repo, we should transfer its ownership to someone so that GitHub redirects will work long enough for people to update their configs. @justinmakaila would you like it? 
 I've fixed #216 on this branch ‚Äì just rearranging the podfile a bit. I've run carthage locally and it seems to be :+1: 
 Hmm. Failing on CI, succeeding locally with Xcode, and failing from `xcodebuild` but for a _different_ reason. 
 OK, thanks @justinmakaila!
 Hmm, @justinmakaila I can't transfer it to you because you have a fork already. GitHub made me transfer it to me _first_ anyway, so the redirects will continue to work. Let me know if you still want it ‚Äì you'd need to delete your fork first.
 :tea: This is green again. I don't want to keep it open too much longer, or we're likely to get scope creep :sweat_smile: The Demo apps runs and the unit tests pass, and carthage builds fine ‚Äì going to give some more time for review, then merge and release 2.2.0 :tada:
  Hmm, seems likely. I'll see what I can do to reconfigure it.
 Thanks!
 I've merged this for now; will fix the errors and send a new PR so it's cleaner. 
  That's odd. How are you installing it? You'll need to manually point to Alamofire's Swift 2 branch in your podfile. It's working for me with this one: https://github.com/artsy/eidolon/blob/master/Podfile
 Hmm. I'll have to look at that tomorrow. Might be a change with the GM. 
 I'm going to work on getting it all to work this afternoon with the Xcode 7 GM. 
 OK cool, so this is working for me ([this PR](https://github.com/Moya/Moya/pull/212)).

@zbeckman Your podfile looks good to me. But you'll need to update things:

``` sh
pod update Box Result Alamofire Moya/ReactiveCocoa
```

Let us know if that works :cake: 
 The code on this PR is working for me locally: https://github.com/artsy/eidolon/pull/504
 Oh no! I had a similar issue yesterday but I can't recall exactly what fixed it. You've tried the routine fixes like deleting derived data and resetting the simulator? Are there any compiler warnings that seem related? 
 Here is our working build of [Moya + ReactiveCocoa](https://github.com/artsy/eidolon/blob/master/Podfile#L65-L67) - which generates this [lockfile](https://github.com/artsy/eidolon/blob/master/Podfile.lock)

``` ruby
pod 'Alamofire'
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'
```

Should get you the right setup, if you have been using older references for these branches - you may need to `pod update` to get the latest commits on those branches.
 I agree the README needs updating ‚Äì I'll roll that into https://github.com/Moya/Moya/pull/214 .
 I've been able to use CocoaPods to install Moya/ReactiveMoya without any problems on a fresh Xcode project (download it [here](http://cl.ly/433l3C18233J)). I did so using Xcode 7 GM and the following Podfile:

``` rb
use_frameworks!

target 'Test' do

pod 'Result', :head
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => 'https://github.com/Moya/Moya.git'

end
```

@zbeckman If that isn't working for you on your existing project, could you try cleaning your build directory? Command-Shift-K should do it in Xcode. It could be that Xcode's forgotten its derived data cache is stale. Let us know if any of that helps. 
 I've never used Carthage and CocoaPods together before ‚Äì not sure of how that'd work. What version of CocoaPods are you using? There's a similar issue in #216. 
 We've rearranged this repository since you initially had this problem. Could I ask you to try creating a new Xcode project, and `pod install` using the following pods? Please leave Carthage out so that we can narrow the problem down. 

``` rb
pod 'Result', :head
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => "https://github.com/Moya/Moya.git"
```

After `pod install`ing, open the project in Xcode 7 GM and run the app. Hopefully it'll work (it's working for me). 

If that doesn't work, please download [this Xcode project](http://cl.ly/3e1f342x2G2X) which I've prepared. It works on my machine. If it doesn't on your machine, we'll have a better idea of where to look. 

If that _does_ work, we'll try the same approach on your library. If you could undo the changes made when you were troubleshooting using git, that would be helpful. If it still doesn't work, then it could be something specific about your project. 

I'll continue looking for the solution on my end. Thanks for helping us figure out the problem! :cake: 
 Great work! I'm having trouble with the Demo project in #216 too. After adding pods to the specific target in the Podfile, it's now working! This kind of stuff has always tripped me up ‚Äì looping in @orta. 
 Great! I'm glad that's working. 

Box is no longer required at all. Result seems to have been updated on Trunk, so we can remove it too. Same with Alamofire ‚Äì used to need it specified for Swift 2 support, don't anymore. 
 BTW you can reduce test pod duplication by doing [something like this](https://github.com/orta/Elasticity/blob/master/Podfile#L31-L38).
 Seems like this is resolved, I'm going to close the issue. Don't hesitate to reopen, or open a new issue, if you run into any further problems. Thanks again for your help! :100: 
  Our `endpointResolver` currently returns an `NSURLRequest`, which is cool, but makes working with async APIs like [Heimdall](https://github.com/rheinfabrik/Heimdall.swift) very difficult (by the nature of OAuth, [these requests cannot be synchronous](https://github.com/rheinfabrik/Heimdall.swift/blob/f67abd632b6ccc4604ae8fa2b6eab9d6b7855310/Heimdall/Heimdall.swift#L193).

I'm thinking that the the endpointResolver is passed in a closure that accepts the NSURLRequest as an argument, and the resolver calls this closure when the request is finished. Suggestions?
 So I'm thinking something like this:

``` swift
public typealias RequestClosure = (Endpoint<Target>, NSURLRequest -> Void) -> Void
```

That the user passes in to the provider. It's a closure that's given the target, and another closure that accepts an NSURLRequest. The way you'd do this is something like:

``` swift
let provider = MoyaProvider<MyTarget>(requestClosure: { endpoint, done in
    let request = endpoint.urlRequest
    // Modify the request, asynchronously.
    done(request)
})
```

My implementation of `request()` looks something like this:

``` swift
public func request(token: Target, completion: Moya.Completion) -> Cancellable {
    let endpoint = self.endpoint(token)

    var innerCancellable: CancellableToken?
    var cancelled = false
    let outerCancellable = CancellableToken {
        innerCancellable?.cancel()
        cancelled = true
    }

    let performNetworking = { (request: NSURLRequest) in
        if cancelled { return }
        let stubBehavior = self.stubClosure(token)

        switch stubBehavior {
        case .Never:
            innerCancellable = self.sendRequest(request, completion: completion)
        default:
            innerCancellable = self.stubRequest(request, completion: completion, endpoint: endpoint, stubBehavior: stubBehavior)
        }
    }

    requestClosure(endpoint, performNetworking)

    return outerCancellable
}
```

The hard part is synchronously returning something from `request()` that can cancel an activity that hasn't yet been created. There's almost certainly something nicer than this, but I'm pretty tired :sleeping: 

@MarvinNazari what do you think? 
 Supper we could wrap the cancellation: 

``` swift
struct CancellableWrapper: Cancellable {
    var innerCancellable: CancellableToken? = nil

    private var isCancelled = false

    func cancel() {
        innerCancellable?.cancel()
    }
}
```

Which simplifies our implementation a bit: 

``` swift
public func request(token: Target, completion: Moya.Completion) -> Cancellable {
    let endpoint = self.endpoint(token)

    var cancellableToken = CancellableWrapper()

    let performNetworking = { (request: NSURLRequest) in
        if cancellableToken.isCancelled { return }

        let stubBehavior = self.stubClosure(token)

        switch stubBehavior {
        case .Never:
            cancellableToken.innerCancellable = self.sendRequest(request, completion: completion)
        default:
            cancellableToken.innerCancellable = self.stubRequest(request, completion: completion, endpoint: endpoint, stubBehavior: stubBehavior)
        }
    }

    requestClosure(endpoint, performNetworking)

    return cancellableToken
}
```
 Thanks! What do you think of the implementation? https://github.com/Moya/Moya/pull/230
 Fixed in https://github.com/Moya/Moya/pull/230 Will be released soon.
  Hey there! Great question ‚Äì this is covered in the [docs on endpoint mapping](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-). It should be straightforward, but let us know if you run into any problems :smile_cat: 
 Don't worry about it! Glad that's what you're looking for. 
  Cool ‚Äì looks great, thanks! 
  Meta-issue :)

I've not used gitter, and I don't really feel like inviting people to another Slack just for Moya :sweat_smile: I personally like issues because they're public, searchable, and anyone can easily participate. Even for things like roadmaps, I feel it makes sense. But I know my feelings aren't universal, too. Happy to go in whatever direction we need to to make a great library. 
 I've never used `Gitter` before TBH.

Would give it a try as long as someone could point me to the benefits of having a Gitter room vs only the issues here.

I think @colinta and @ashfurrow already made some valid points of pros for the issues in Github but I still don't know what are the benefits of the other option.
 Gitter's tend to end up like Alcatraz's : https://gitter.im/supermarin/Alcatraz - people come in with  questions but no-one gives answers.

Not to say that a slack doesn't have it's problem, or IRC; on CocoaPods we devs don't use the IRC so it's only usually for people who can help each other.
 I think the ¬´vast¬ª majority is against `Gitter`.

I agree that the fragmentation would be an issue.
How does `Gitter` work in regards of; I don't know. Google indexing? Would I get hits in Google pointing to `Gitter`? how long does the discussions in `Gitter` are stored? or are they discarded after X amount of bytes?

I think having an outlet for users to help themselves would be great; but ~~if~~ as long as there's not a way to preserve and index said discussions they would go to ¬´waste¬ª
 Gonna close this ‚Äì if we missed something in the discussion, or if it makes sense in the future, we'll revisit some sort of organizational chat :+1: :cake:
  This is great work, thanks @avf :cake: This is exactly how I would've implemented it, though it does make https://github.com/Moya/Moya/issues/144 even more important to deal with. 

Just a few things ‚Äì you'll need to pull in changes from the master branch so we can merge your pull request ‚Äì happy to help with that. 

Some tests would be nice, but it can be challenging to write them. If you like, we can write them together! Also, could you add an entry to the changelog? Make sure to give yourself credit!

Again, fantastic work :boom: 
 OK, sounds great! Feel free to reach out to ash@ashfurrow.com with questions. If I have some time this week, I'll send you some first steps that might help. 
 Hey! It's been a few weeks so I thought I'd check in. I never got around to writing some tests (busy weekend!) but this week I plan to get this merged. It'll take some work to resolve some conflicts ‚Äì I'll take care of those ‚Äì and I'll write a few tests. I'll post a new pull request and ask you to review it for us, if that's ok? Thanks again!
 Hey! So the tests you added look lovely. I just realized, though, that the `manager` we recently added should provide, this, right? The Alamofire's `Manager` class seems to handle a lot of customization of `NSURLSession` and requests. 

Do you think HTTP auth is common enough that we should have a closure specifically for it? Or should we stick to the manager? I like the closure since it keeps things abstracted with the `MoyaTarget` protocol. But it also adds yet another `init()` parameter :sweat_smile: Any thoughts, @avf?
 Thought about this more, and I really like you're implementation. It lets people auth on per-target instead of per-URL, which is the whole point of Moya. Great work, I'll get this merged ASAP. 
 OK, this is merged :tada: thanks again for your hard work, @avf. I've release 2.4.0 on CocoaPods trunk, and tagged a release on the repo for Carthage. 
  Yep!

Good thinking @skywinder 
  Yeah, good spot @skywinder 
  `Failure` is truly a network failure ‚Äì the status code is optional, even. It's meant to simulate when the device cannot connect to the internet. The `Success` case is a "success" in that the API returns some data. it's agnostic to the idea that a 404 would be a failure ‚Äì it succeeded because it returned data. 
 True, but there are also error conditions in The iOS network stack that we want to simulate. Maybe we should rename these two cases then. 
 That's a good idea, @damianesteban. I don't believe we actually use OAuth; we only need to add an HTTP header. 

I feel generally that Moya is spreading in a few different directions, and we don't have a set of best practices that demonstrate or implement common practices, like OAuth. I don't think we need to implement MoyaOAuth or anything :grimacing: but some examples of using common libraries would be very useful, too. 
 So, thanks for the suggestion!
 Awesome! Let us know how it goes!
 @Dschee it's a good question, and it's one that we've faced before. I'm up for the change, but it would mean abandoning the `Result` dependency and the nice functions that accompany it like `flatMap`. It's too bad we can't `typealias` specific cases of an enum.
 Yeah, we definitely can (I'm on the Result team) but I'm not sure it's a great idea, as you mention. Then again, I don't see any alternatives (I'm not a fan of documenting our way out of this ‚Äì basically just blaming the user). Let's sleep on it and see if we think of any alternatives? 
 There might be a better name than "Success", but having it broken out based on the status code implies knowledge of the server. I've worked with an app (a terrible one), where all responses were "200", and other servers use 404 for empty "array resources". 

But, instead of "Success", would "Response" be more appropriate?

> On Mar 25, 2016, at 9:48 AM, Cihat G√ºnd√ºz notifications@github.com wrote:
> 
> It just happened two days ago that one of my colleagues took over a project I implemented a new API class for using Moya and he was completely confused by the fact that an API error (regardless of 4xx or 5xx) was returned within the .Success case. Although I understand and like the fact that Moya only forwards network errors to the .Failure case what about renaming the generic .Success and .Failure cases to something more clear? For example simply adding Network as a prefix resulting to .NetworkSuccess and .NetworkFailure should already improve the clarity a lot. What do you think?
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
 "Response" sounds appropriate. I don't want to impose semantics on top of Alamofire, so maybe have `Response` and `Incomplete`?
 Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  The model is to return sampleData that reflects the info about the failure, just like on a success. We do this [here](https://github.com/artsy/eidolon/blob/5b724a68acd4e6e42d2e8b1092b4644ba6b6488b/KioskTests/Bid%20Fulfillment/RegistrationPasswordViewModelTests.swift#L14-L40) on a per-target basis. 
 `sampleData` is actually a closure that returns an `NSData` instance. The demo I posted showed how you could customize the `endpointsClosure` to return customized `Endpoint`s. 

I suppose what's probably confusing is the `Success` and `Failure` cases of the result. `Failure` is truly a network failure ‚Äì the status code is optional, even. It's meant to simulate when the device cannot connect to the internet. The `Success` case is a "success" in that the API returns some data. it's agnostic to the idea that a 404 would be a failure ‚Äì it succeeded because it returned data. 

I've opened https://github.com/Moya/Moya/issues/200 to make sure that we clarify this for other users. 

Does that answer your question? 
 I'm glad! I'm going to close the issue, but if you want to reopen later, or open a new issue, please feel free!
  I'm not sure this is Moya's responsibility, object mapping in Swift is still painful and there's no obvious winner given there's a [new one every day](https://cocoapods.org/?q=lang%3Aswift%20json) to back so we'd end up supporting a lot of different cases. I think @colinta's idea makes sense though, a separate pod that could act as a mapper.

FWIW though we didn't find it difficult at all to build our [own mapper](https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/RAC%2BJSONAble.swift) that worked with [function chaining](https://github.com/artsy/eidolon/blob/master/Kiosk/App/AppViewController.swift#L76).
 I don't think this is Moya's job, either, but Orta's right ‚Äì we may able to be clever about completion blocks that would allow users to easily do this, even without the chaining. It could be a neat demo, case study, or example in the docs. I'll give some more though to what it might look like. 
 If you're using CocoaPods, I've enjoyed using `pod lib create` ‚Äì your just add Moya as a dependency and `pod install`. 
 @lkuczborski we use something [like this](https://github.com/artsy/eidolon/blob/511ebb901289dbeb648cb9b0234e21ab1543c373/Kiosk/App/Networking/RAC%2BJSONAble.swift), but that's built atop signals. You're looking for something with callbacks. 

Well! Let's imagine. 

Basically, you'd want a block that takes a type and returns a closure that can be passed into Moya's `request` function. This hasn't been run through a compiler, but you get the idea:

``` swift
func moyaCompletionMapsTo<T: JSONAble.Type>(classType: T, completion:(T?) -> ()) -> MoyaCompletion {
    return { (data: NSData?, statusCode: Int?, response: NSURLResponse?, error: NSError?) -> () in
        // process the response somehow and store result (might be nil) in model
        completion(model)
    }
}
```

Then you'd call:

``` swift
provider.request(moyaCompletionMapsTo(Model.self, { model -> () in 
}))
```

Or something to that effect. Does that make sense? 
 @SRandazzo very cool!

>  I feel like pattern of subclassing MoyaProvider isn't the best decision

Agreed. We've actually opened https://github.com/Moya/Moya/issues/144 concerning the subclassing pattern. With Swift 2's protocol extensions, it might make sense to ditch the MoyaProvider class altogether :tada: 
 It feels like things like this would make great separate pods, for example here's my simple [Gloss + RxSwift](https://github.com/artsy/Emergence/blob/master/Emergence/Contexts/Networking/Observable%2BNetworking.swift) extension for Moya - that could happily be it's own thing in a similar way.
 So I messed around on a branch and experimented with making the plugin system middleware style. Where each plugin can transform data before reaching the next plugin. I realize this is a huge change and there may be another way to accomplish some of the same things. One major change in my experiment is that all data is now 'AnyObject?'. This could allow for easy means to mutate response data and such for something like ObjectMapper. 

https://github.com/gregpardo/Moya/tree/experiment/middleware-flow

And example of a plugin that can transform response data might look something like this...

``` Swift
public class ResponseTransformPlugin<Target: MoyaTarget>: Plugin<Target> {

    public override func didReceiveResponse(object: AnyObject?, statusCode: Int?, response: NSURLResponse?, error: ErrorType?, provider: MoyaProvider<Target>, target: Target) -> MoyaProvider<Target>.Response {
        object = target.responseTransform(object)
        return MoyaProvider<Target>.Response(object, statusCode: statusCode, response: response, error: error, provider: provider, target: target)
    }

}

public extension MoyaTarget {
    func responseTransform(object: AnyObject?) -> AnyObject?
}
```

Then the target could look something like this

``` Swift
extension MyTarget : MoyaTarget {
   // Other setup here first (baseUrl, path, etc)
   public func responseTransform(object:AnyObject?) -> AnyObject? {
       switch self {
        case .GetUser:
            let user = Mapper<User>().map(object)
            return user
        }
   }
}
```

Does this make any sense or have I taken some strange roundabout approach to attempting to give plugins more power easily?
 Hmm, I can see this making sense but I agree it is a bit roundabout. I was thinking that this really belongs in the RAC/RxSwift provider extensions? Something like what we currently do at Artsy: https://github.com/artsy/eidolon/blob/f95c0a5bf1e90358320529529d6bf431ada04c3f/Kiosk/App/Networking/RAC%2BJSONAble.swift

Or we could add another `request` method that accepted a class, too. Thoughts? 
 Well yeah it works both ways but the downside of the reactive extension approach is a couple things in my opinion. 
- Different extensions need to be written for RxSwift/ReactiveSwift
- Either needs an API wrapper for all requests to map them to the object or each time the request is called the object class to map to has to be specified

The later seems like the approach most have taken but it kind of goes around the simplicity of configuring your provider and being ready to go.

I guess noticed two things about the current system that may or may not need improving.
- Plugins cannot mutate data in a middleware like fashion (Perhaps this is actually simpler and preferred)
- Moya layer is confined to returning NSData thus not allowing plugins to override this naturally
 I like the approach. I think it's a nice bridge and keeps any mapping out of Moya's responsibilities. Would it be possible to write an ObjectMapper plugin that allows me to configure different maps per endpoint with this?
 Okay this looks like a great approach. I suppose whether something is a 'plugin' or not is not really important as someone can download a cocoapod of an approach like this and would get the functionality included. Now I just need to code an ObjectMapper RxSwift version!
 Sounds good. I guess this ticket could become add examples of how to implement this. I think providing some direction in the documentation on how to accomplish such a thing would be useful to a lot of people. It seems this is a feature that a lot of folks are having to hack together. 
 @ivanbruel This is _fabulous_ :tada: Great work! 

I think we should be able to close this issue once the Readme has been updated to point to Ivan's library. @ivanbruel: if the maintenance on you ever need a hand maintaining your library, just let us know!
 Sure, sounds like a kind of super-documentation around ObjectMapper and Carthage? Neato. 
 Cool, sounds like a bigger project. I think a mention in the Readme can help people looking for OM support now until we have the extensions documentation done. 
 Given https://github.com/Moya/Moya/pull/339 I'd like to close this issue. Is the larger project something we ought to open a new issue for? Maybe pointing back to this one for context? 
  So, I spoke with @irace this week about a really neat idea for network requests in offline situations. If I understood correctly, each network request would do the following:
1. Serialize the request and store it on disk.
2. Try the request if you're online.
3. If it fails, or if the device becomes online and there are stored requests, resend them up to with max resend / max lifetime criteria.

It would be cool to do something like this with Moya. Maybe not in the primary repo, but maybe an extension or something in another repo. 

If anyone has ideas for feature requests, reference implementations, or ideas for how we could elegantly architect this, please comment!
 Interesting idea!!
 Yeah, I don't feel super-strongly either way about it. 

## 

Ash Furrow
iOS Developer, Author
http://ashfurrow.com

> On Aug 24, 2015, at 12:49 PM, Justin Makaila notifications@github.com wrote:
> 
> Could this potentially help with things like #164? If we provide an offline cache and specify a TTL at the request level, and whether or not a request should use the cache, I think we could ditch the idea of inflight requests.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Awesome, @jarrodrobins if you're able to share an existing implementation, we could discuss ideas for implementing the same here. 
 Afraid not that I'm aware of.
 Looks like this was explored more recently in #713 and closed. Should we close this as well?  Hmm tricky. Let me take a look. 
 Maybe, but I feel like that would break the clear chain from target -> endpoint -> request. 

Could you provide more details about the nature of the request signing? Is this something that could be accomplished with HTTP headers alone? There are some details [here](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-) on how that could be accomplished. 
 Hmm, I tried to make the `Endpoint` an abstraction for URL requests with [all of these properties](https://github.com/Moya/Moya/blob/fa071c26244e5e2aff8ee98b42ac7ccb3cc4e60c/Moya/Endpoint.swift#L22-L27). I didn't anticipate a need to access the request itself. 

It could also be possible to switch based on the endpoint's URL in the resolver. 

``` swift
{ (endpoint: Endpoint<ArtsyAPI>) -> (NSURLRequest) in
    let request: NSMutableURLRequest = endpoint.urlRequest.mutableCopy() as NSMutableURLRequest
    switch endpoint.url.absoluteString {
    case let url where url.hasPrefix("http://theRequestThatNeedsAuthentication"):
        return /* signed request */
    }
    return request
}
```

It's a bit janky, but would that work?
 Definitely something to keep in mind! 
  Right now `Moya` compiles and works on its `swift-2.0` branch including `RxSwift` but `ReactiveCocoa` is lagging behind due to a non-official `podspec`.

We need to support `ReactiveCocoa` as a dependency working with `Swift 2.0`
 Sadly `ReactiveCocoa` dropped support for `CocoaPods` some versions ago.

This means that the `podspec` is not maintained by them and there's currently no `Swift 2.0` `podspec`.

I forked `ReactiveCocoa` and added a `podspec` to their 2.0 branch but I'm having some issues when trying to compile the pod.

TL;DR
I need to figure out a correct `podspec` for `Swift 2.0` :smile: 
 I maintain the podspec for ReactiveCocoa; is it out of date? 
 I think is up to date but if I try to point the pod to the `Swift 2.0` branch it fails telling me there's no pod at that location or something along those lines (can't remember the exact error right now).
 Hmm. You should be 
 ``` console
Fetching podspec for `Moya` from `../`
[!] Unknown external source parameters for `ReactiveCocoa`: `{:branch=>"swift2"}`
```
 Let me check because I just changed something and I might be writing the `Podfile` wrong
 What's the podfile look like? 
 Ok; here's the `Podfile`:

``` ruby
platform :ios, '8.0'

source 'https://github.com/CocoaPods/Specs.git'

use_frameworks!

pod 'ReactiveCocoa', :git => 'https://github.com/ReactiveCocoa/ReactiveCocoa', :branch => "swift2"
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift', :branch => 'rxswift-2.0'
pod 'Alamofire', :git => "https://github.com/Alamofire/Alamofire", :branch => "swift-2.0"

pod 'Moya/RxSwift', :path => "../"
pod 'Moya/ReactiveCocoa', :path => "../"
pod 'Moya', :path => "../"

target 'DemoTests' do

  pod 'Quick', :git => 'https://github.com/Quick/Quick', :branch => 'swift-2.0'
  pod 'Nimble', :git => 'https://github.com/Quick/Nimble', :branch => 'swift-2.0'
  pod 'OHHTTPStubs'

end
```

And here's the error:

``` console
Pre-downloading: `ReactiveCocoa` from `https://github.com/ReactiveCocoa/ReactiveCocoa`, branch `swift2`
[!] Unable to find a specification for 'ReactiveCocoa'.
```
 Tried pointing to your fork just in case; this is what I'm getting:

``` console
Pre-downloading: `ReactiveCocoa` from `https://github.com/ashfurrow/ReactiveCocoa`, branch `swift2`

[!] Error installing ReactiveCocoa
[!] /usr/local/bin/git clone https://github.com/ashfurrow/ReactiveCocoa /var/folders/xk/378q_x1x4b3289cbr_kjyhzr0000gn/T/d20150821-25846-1w2akmk --single-branch --depth 1 --branch swift2

Cloning into '/var/folders/xk/378q_x1x4b3289cbr_kjyhzr0000gn/T/d20150821-25846-1w2akmk'...
warning: Could not find remote branch swift2 to clone.
fatal: Remote branch swift2 not found in upstream origin
```
 My fork is _way_ out of date. 

Interesting ‚Äì I would've thought it would use the spec in trunk. You should be able to point to _your_ work and copy&paste this podspec into it: https://github.com/CocoaPods/Specs/blob/master/Specs/ReactiveCocoa/3.0-RC.1/ReactiveCocoa.podspec.json
 I'm using this: https://github.com/esttorhe/ReactiveCocoa/blob/swift2/ReactiveCocoa.podspec

I'll take a look at the one you provided and see what differs from mine
 I'm spending time this week to update our app to Swift 2 ‚Äì I'll try to get this working. 
 ![](http://i.giphy.com/JDnaQ8qn0Myuk.gif)
 Initial work is complete. I haven't finished yet, so I can't test, but [this](https://github.com/artsy/eidolon/pull/496/files#diff-4a25b996826623c4a3a4910f47f10c30R59) should help anyone currently stuck. I'm using my fork of ReactiveCocoa, and added a podspec to my branch. 
 I'ved pushed a version of ReactiveCocoa 3 with Swift 2 (Xcode 7 GM) support. Its version number is "3.0.0-swift2" and can be used in Podfiles _and_ in podspecs. 

Subsequently, I've updated the Moya podspec to use this new ReactiveCocoa version. There's a problem with the Carthage compatibility, but I'm hoping to have it wrapped up soon, and then I'll submit a PR. 
 OK, now all that's required for ReactiveCocoa extensions is the following in your podfile

``` rb
pod 'Moya/ReactiveCocoa'
```

And that's it! :tada:
  Hmm. I know @esttorhe is working on Swift 2 support on https://github.com/Moya/Moya/pull/181 ‚Äì maybe the Moya/Core subspec isn't being used from the `swift-2` branch? Maybe you need also

``` rb
pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'
```

But to be honest, I'm not sure of the Swift 2 support in Moya yet. Ill's if I can take a look today. 
 AFC right now but if you point to mits 2.0 branch (see the Demo Podfile in there) you'll be able to use everything sans ReactiveCocoa subspec

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Thu, Aug 20, 2015 at 8:22 AM -0700, "Ash Furrow" notifications@github.com wrote:

Hmm. I know @esttorhe is working on Swift 2 support on #181 ‚Äì maybe the Moya/Core subspec isn't being used from the swift-2 branch? Maybe you need also

pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'

But to be honest, I'm not sure of the Swift 2 support in Moya yet. Ill's if I can take a look today. 

‚Äî
Reply to this email directly or view it on GitHub.
 *Moya¬†

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Thu, Aug 20, 2015 at 8:22 AM -0700, "Ash Furrow" notifications@github.com wrote:

Hmm. I know @esttorhe is working on Swift 2 support on #181 ‚Äì maybe the Moya/Core subspec isn't being used from the swift-2 branch? Maybe you need also

pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'

But to be honest, I'm not sure of the Swift 2 support in Moya yet. Ill's if I can take a look today. 

‚Äî
Reply to this email directly or view it on GitHub.
 Omw.¬†
I'll check in my computer in a few¬†

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Thu, Aug 20, 2015 at 8:39 AM -0700, "EZabolotniy" notifications@github.com wrote:

I change my pod file to:

platform :ios, "8.0"

source 'https://github.com/CocoaPods/Specs.git'

use_frameworks!

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'

pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'rxswift-2.0'

pod 'RxCocoa', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'rxswift-2.0‚Äô

pod 'Moya/RxSwift', :path => "../"

pod 'Moya/ReactiveCocoa', :path => "../"

pod 'Moya', :path => "../"

and still have the following error:

[!] Unable to satisfy the following requirements:

Alamofire (fromhttps://github.com/Alamofire/Alamofire.git`, branch swift-2.0)required byPodfile`

Alamofire (~> 1.3.0) required by Moya/Core (2.0.0)

[!] Your Podfile has had smart quotes sanitised. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice.

Evgeniys-MacBook-Pro:Eventgram evgeniy$ open -e Podfile

‚Äî
Reply to this email directly or view it on GitHub.
 You are correct @EZabolotniy.

I forgot that we haven't merged my branch into Moya's `swift-2.0` due to the issue with `ReactiveCocoa`.

You should be able to use `Moya` with `Swift 2` if you change your `Podfile` to this:

``` ruby
platform :ios, '8.0'
use_frameworks!

pod 'Moya', :git => 'https://github.com/esttorhe/Moya', :branch => 'swift-2.0'
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire', :branch => 'swift-2.0'
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift', :branch => 'rxswift-2.0'
pod 'RxCocoa', :git => 'https://github.com/ReactiveX/RxSwift', :branch => 'rxswift-2.0'
```

With the caveat that you won't be able to use the `ReactiveCocoa` extensions ATM

---

Worth noting; I had to change my implementation; from when I created it to now @kzaher promoted `ReactiveX` to an organization and changed the name of the `Swift 2` branches.

I changed the `Podfile` accordingly and tested locally and `CocoaPods` can satisfy all the requirements; note that you'll have to point `Moya` to my branch for the time being since that `podspec` doesn't specify `Alamofire 1.3` as a dependency and leaves it open; then on the `Podfile` you can lock it to the `Swift 2.0` branch; same goes for the `RxSwift` dependencies
 @ashfurrow; would it be worth to merge my WIP branch into the `swift-2.0`?

I mean; right now that branch doesn't work and mine almost work except for `ReactiveCocoa` (which I'm hoping to clear some time to tackle that once and for all by the end of this week).

That way people can use `Moya` on `Swift 2.0` in a somewhat more ¬´official¬ª way
 I'm thinking merging it as-is is probably a good idea. It's not like we're merging into `master` or anything :)
 I think its ok to close this issue due to #194
  I think the `iOS 7` restriction is more along the lines that `Swift` pods are only supported with `use_frameworks!` flag in `CocoaPods`.

And dynamic frameworks are only available in 8.x and above.
 That makes sense ‚Äì OS X support seems pretty easy. iOS 7, though, confuses me a bit. How can Alamofire's podspec support iOS 7 if Swift pods require frameworks, and frameworks work only on iOS 8? Or am I misunderstanding something? 
 Ah, beat me to it @esttorhe  :)
 i think we hit `Comment` at the same time :see_no_evil: 
 Alamofire's [podspec](https://github.com/Alamofire/Alamofire/blob/master/Alamofire.podspec) points to `8.0` as you can see
 I think supporting 10.9 makes sense though, and should be ¬´trivial¬ª to add.
 Cool, I've opened up https://github.com/Moya/Moya/issues/192 to do just that. 
 Tricky, since ReactiveCocoa has a minimum OS X deploy target of 10.10. I'm having trouble getting this to work with a subspec having a different OS X deploy target. 

Since no one has requested this, I'm fine with closing this as-is. We have OS X support, which was one of the big parts; I'm on with 10.10.

If anyone wants to re-open and investigate, :tada:
  Our documentation is thorough, but not instructive. We need to do a better job of providing examples and real-world scenarios. 

(Continued from #188.)

> In general I would shoot for more complete examples. Newcomers as I am one, lack guidance. For example it wasn't quite clear at first for me if I have to implement my own Provider. Turns out it was sufficient to use the default one with a closure as an initialization parameter. ‚Äî@jk
 Might make sense for a more in-depth demo in a separate repo on this organization. 
 We have some real-ish examples in the documentation now. Do you think that is enough to close this issue?  @jk I'm glad you found the solution! Do you have any suggestions to improve the docs? 
 Cool, I've opened #189 ‚Äì let's collect all the suggestions, ideas, and feedback there :tada:
 No problem :) It's possible to specify parameter encoding on a per-target basis through the [endpoint resolver closure](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-). You can use the `endpointByAddingParameterEncoding` function on `Endpoint` to help. Form there, if you really need a `nil` body instead of an empty one (though I'm not sure there's a semantic difference...) you can use the URL encoding, or otherwise. 

Does that answer your question? 
 We've got a breaking-changes release coming up, so it's a good time to get these in. 

Alamofire has default `nil` parameters ‚Äì I think we should change to reflect their behaviour. Alamofire [already handles parameter encoding](https://github.com/Alamofire/Alamofire/blob/af231fd15eec9661853bf0b5b3ec5806c8155836/Source/ParameterEncoding.swift#L103-L117) ‚Äì it only uses URL parameter encoding if the request _can_ encode parameters in the URL, so that's work we don't have to do. Since we already require users to specify the HTTP verb on the target, I think that's sufficient. 

Does that make sense? 
 @Neirys I've opened #226 that you can subscribe to to be notified when it's finished. Or take a stab at it yourself! 
  But doing that wouldn't produce a framework as well?
Which are not available to be used on 7 iirc?

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Wed, Aug 19, 2015 at 6:13 AM -0700, "Justin Makaila" notifications@github.com wrote:

Add the .xcodeproj to your project, and then link the Moya.framework output against your project.

Let me know if you have any issues or need more clarification. 

‚Äî
Reply to this email directly or view it on GitHub.
 Maya itself should be usable without frameworks, but would require modification. 

Moya is built atop of Alamofire, so you'd need to have those `.swift` files in your project. Then you'd drop in the Moya `.swift` files, but that's not enough. Moya has `import Alamofire` statements that need to be removed first. Then in should work. 

A similar process _should_ work for ReactiveCocoa, but @mikejd you're right ‚Äì RAC 3 is iOS 8+ only. 
 Cool, glad to hear it worked out! :tractor: 
  Wow, nice catch! Thanks for the PR :cake: 

You mention the changelog ‚Äì very good point. We  Typically, breaking changes require a major update to Moya (so, we'd need to release 3.0.0 after merging this). However, a major release for _just_ a typo seems extreme, especially when it's on an optional parameter. @orta I'd appreciate your thoughts on this. 
 Yeah, afraid this _is_ a major version break.  Two options: 
- Make a backwards API compatible function?
- Save the PR till you're ready for a v3
 That makes sense to me ‚Äì we could add a new issue to remove it for 3.0. 
 Yep :+1: 
 Looks great, thanks! 
 good job
  Currently it takes a lot of steps:
1. Update podspec version.
2. In Demo directory, `pod update Moya`.
3. Commit.
4. Tag new version.
5. Push, including tags.
6. `pod trunk push Moya.podspec`.
7. Hope that current tag lints fine on trunk push.

We should automate this process, preferably using Fastlane. 
 ^ looks good, can do a `make release` task?
 I mean, your method looks good, we can automate it update and then to run `pod update` in the Moya dir via a make task :+1: 
  Cool, looks good! Could I get you to add an entry to the changelog, and maybe a line in the documentation? Then I think it'll be good to merge. Thanks again! 
 Sounds like a plan. I've just been using `git tag`, but I can deal with the release after if you want (it's a complicated process at the moment :\ ).
 Great, thanks!
 Cool, that's up: https://raw.githubusercontent.com/CocoaPods/Specs/c049a65c2b0fbe853846cd144d359f4a43d8dae5/Specs/Moya/2.1.0/Moya.podspec.json

Also opened #184 to make releasing easier. 
  Another option is to be fancy :cake: You could use method currying in some way:

``` swift
func countCompletion (completion: (Int -> Void)) -> ((data: NSData?, statusCode: Int?, response: NSURLResponse?, error: NSError?) -> Void) {
    return {  (data, status, response, error) -> () in
        if let data = data {
            let json: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: nil, error: nil)
            if let count = json["count"] as? Int {
                completion(count)
            } else {
                completion(-1)
            }
        }
    }
}
```

Then call `UserProvider.request(.Online, completion: countCompletion { count -> Void in /* your actual callback, accepting an Int */ })`.

This avoids subclassing, which I personally like, and "feels more Swift", whatever that means. 

@callmewhy The overarching question is how do _we_ deal with this, and I can only speak for myself, but I use the ReactiveMoya or RxMoya to turn these into signals/sequences. Here's [one random example](https://github.com/artsy/eidolon/blob/5b724a68acd4e6e42d2e8b1092b4644ba6b6488b/Kiosk/Bid%20Fulfillment/RegistrationPasswordViewModel.swift#L28). 
  Thanks
 Umm. Apparently cant merge from my phone due to the failed tests.
Will check from computer later
 @regexident Thanks a lot!

@esttorhe CI failures are intermittent (see #176). When this happens to me, I [do this](http://www.idownloadblog.com/2014/06/19/ios-8-safari-request-desktop-site/)
 Ha, yeah we need to get CI working again. 
 :+1:  good tip Ash; I'll do that next time
  Hey! Thanks for letting us know. I've not used `pod try Moya` more ‚Äì honestly I don't know how it works, but I'll take a look and let you know as soon as I figure it out. 
 Think someone needs to go into the folder and run a `pod update` since moya's update, there's a more modern issue around this, but it's basically this issue: https://github.com/CocoaPods/CocoaPods/issues/1623
 That's weird ‚Äì thought I'd done that. I'll give it a try. 
 I'm willing to bet that was done after tagging
 Mmmhmmmmm. 
 Having trouble getting `pod trunk push` to work, hold tight. 
 If its failing on the lint make sure your xcode-select is pointing to NOT Xcode7¬†
Something like that was happening to me yesterday

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Thu, Aug 6, 2015 at 6:48 AM -0700, "Ash Furrow" notifications@github.com wrote:

Having trouble getting pod trunk push to work, hold tight. 

‚Äî
Reply to this email directly or view it on GitHub.
 Good idea, @esttorhe. Checked and it's 6, which sucks since I _am_ getting a linker error. 

Set iTerm to "unlimited scrollback" to actually see the failure message. (Why is that _not_ the default??)
 I need to change that on my terminal as well now that you mention it.¬†

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Thu, Aug 6, 2015 at 6:51 AM -0700, "Ash Furrow" notifications@github.com wrote:

Good idea, @esttorhe. Checked and it's 6, which sucks since I am getting a linker error. 

Set iTerm to "unlimited scrollback" to actually see the failure message. (Why is that not the default??)

‚Äî
Reply to this email directly or view it on GitHub.
 Cooooool got it to work! @jk Could you try again? Or, rather, `pod try` again?

![](http://2.bp.blogspot.com/_g88-bL8l6H0/TLPAOwcfosI/AAAAAAAAAA8/UwAQw5vcdLI/s1600/3322267.jpg)
 <.<
 Oh yeah? I'm a pretty compulsive ‚åòK'er, but I'll be on the lookout for slowdown. 
  To match the ReactiveCocoa one. 
 Yeah, exactly! We'd need to unindent the code and add Swift code highlighting (see the existing README samples' markdown). :cake:
 Hey @argentounce ‚Äì good question!

The RxMoyaProvider is created using the _exact same_ method as a regular `MoyaProvider`. You just say:

``` swift
let provider = RxMoyaProvider<MyAPI>()
```

And that's it! All the examples in the docs that show how to configure the provider apply identically to the RxSwift and RAC providers. Demos for those projects are a great idea :100:
  Fixes #173.
 Looks like something was missed in https://github.com/ashfurrow/Moya/pull/172 
 Ha, yeah @colinta I hear you. From what I understand of Carthage, which is by choice not a lot, it's necessary. 
  OK cool, I'll merge and we can fix CI later. 

I don't think `master` is in a stable state to release a build, so you'll have to use this in your Podfile:

``` ruby
pod 'Moya', :head
```
 I don't believe so, `:head` fetches from the repo's `HEAD` iirc. 
 OK, so once #174 is done, I'll be release 2.0 in #149, so we should be :+1: soon. 
  :+1: 
  This image is misleading:

![](https://raw.githubusercontent.com/ashfurrow/Moya/master/web/bad.png)

It's the first image in the README and is in the "on-brand" Moya colours. A casual reader might infer that this is the Moya solution. 

We should make it clear that this is _not_ how Moya works, but is an example of the problem that Moya solves. Possible solutions:
- Desaturate the image to make it look sad.
- Add sad faces or sad face emojis :cry: 
- Add a rage-comic style "wtf" person ‚Äì [Jackie Chan](http://wallpaper.ultradownloads.com.br/276253_Papel-de-Parede-Meme-Jackie-Chan_1920x1440.jpg)? 
- Something else.

Suggestions? Thoughts? 
 Perhaps leave the introduction paragraph and then a section of

## Current state of apps

![](https://raw.githubusercontent.com/ashfurrow/Moya/master/web/bad.png)

<Rest of that section>

## How `Moya` solves this

![](https://github.com/ashfurrow/Moya/raw/master/web/good.png)
<Next paragraph explaining how Moya works>
 Honestly I like that the image uses `Moya` colors to keep it in sync and consistent with the rest of the README; looks ¬´prettier¬ª IMHO
 Yeah, that's a good point. Maybe desaturate them a little bit? 

![bad](https://cloud.githubusercontent.com/assets/498212/9091634/49359e7e-3b6f-11e5-8f06-4928713098d3.png)

Meh, that kind of sucks too. 
 hahahahaha; it makes me think of infomercials when people are terribly using a normal product product.

Put a filter to make it look ¬´old and archaic¬ª? ¬Ø\_(„ÉÑ)_/¬Ø
 ![bad-2](https://cloud.githubusercontent.com/assets/498212/9091876/b2a51e92-3b70-11e5-807f-e65de781836e.png)
 Hmm. 
 Nah, I think maybe a label saying "BAD" or something would be illustrative. 
 Perhaps the ¬´biggest¬ª issue is that the image is the first in the README and as you pointed out could be potentially confusing.

What about putting them both side by side with `current / Moya` as a footnote to the images?

PS. I think the label could work as well but I'm throwing ideas just in case
 might be better to try have both in one image (roughly chucked together)

![screen shot 2015-08-27 at 10 07 21 am](https://cloud.githubusercontent.com/assets/49038/9522553/788e7656-4ca3-11e5-8c1e-df89ff449553.png)

http://cl.ly/0E0u3H422C3F/moya-front.sketch
 @orta it's a good start, but I think it needs more character. Suggestion: 

![artboard 1](https://cloud.githubusercontent.com/assets/498212/9523674/38babc28-4ca9-11e5-8937-0200a6c753a6.png)
 :shipit: 
 this this is the direction we're after, I can spruce it up and give it some good arrows etc. I prefer the emoji.
 Sounds good to me!
  Thanks a lot, Justin! It's a huge PR ‚Äì I'll take a look at it this weekend. If any other contributors could lend a hand, that'd be :+1: 

Justin, could I please ask you to mark these improvements in the changelog? I see you've already updated the README ‚Äì awesome :tada: 

The tests are failing ‚Äì looks like a Circle configuration problem around the Demo workspace. Any ideas?
 It's common to check in the Pods directory for libraries, so this is duplicating all of that too: https://github.com/ashfurrow/Moya/tree/master/Demo/Pods

Personally, I'd remove both of them, and in the README tell people if they want to demo it run `pod try Moya`.  It's a huge amount of additional files for a lib that's probably 6-8 swift files big in reality.
 `pod try https://github.com/justinmakaila/Moya/` will let you test. You need to add a working Podfile to the Example dir, [this](https://github.com/ashfurrow/Moya/blob/master/Demo/Podfile) will probably do it.
 Yeah, I think it's time to separate out the demo from the library repo. 

I only included the Pods directory because I was told it was necessary for Carthage support. If someone were interested in writing a how-to blog post about supporting Carthage and CocoaPods, that would probably be a great service to the open source community. As a library owner, I remain confused about how my own library is structured and why. It's not a comfortable feeling. 
 This could be rolled into #168 where we could have a Demo repo for both Carthage and CocoaPods, separate from the main repo. 
 Downside of that is `pod try Moya` doesn't work
 How so? Never used pod try before. 
 It will go to the Moya podspec, find it's repo, download it and look for an xcodeproj + podfile. Separating the demo repo from the lib repo would make that tough. 
 Not right now, https://github.com/CocoaPods/cocoapods-try/issues/38
 I don't think moving the example to a separate repo is a good idea, other libraries don't do this. 

I'd move the `Pods` and the Carthage-whatever directories into `.gitignore` then add a note in the README that if you want to run the example you have to go to the example folder and run `pod install` or `carthage install`. Or for the no-effort approach `pod try Moya`. Again, this isn't some mega-huge library with thousands of moving parts.
 Amazing! Let me know if I can lend a hand. Thanks again! :boom: 
 Hey @justinmakaila ‚Äì would it be possible to have the Example app and tests still built using CocoaPods? 
 So Carthage relies on the Moya xcodeproject? I thought CocoaPods was generating one for us now. Sorry if I'm showing my ignorance here ‚Äì I'm sure you can understand my hesitation to make Moya depend on an unfamiliar tool. 
 OK, so. Touchy subject for some ‚Äì I want anyone reading this to know that I have a lot of respect for the developers who've built Carthage, for @justinmakaila and @neonichu who have done so much work to support Carthage in Moya, and for developers using Moya. If someone tries to turn this into a flamewar, I'll be very disappointed in them. 

:heart: 

Ok! So Moya actually predates Carthage by a few months ‚Äì Moya was build as a CocoaPod, which the capabilities and limitations of that tool in mind. 

Carthage was released, and people asked for Carthage support on Moya. I didn't know how to add it, but several contributors offered to help, which is fantastic :smile_cat: They asked for help from Carthage, but their developers said that subspec-like functionality [conflicts with their philosophy](https://github.com/Carthage/Carthage/issues/588#issuecomment-116137295). 

Undeterred, @justinmakaila and others laboured to come up with a solution that worked for both tools, requiring Moya to compromise on the original library structure (informed by CocoaPods). At last, we'd nearly accomplished this herculean task. 

My remaining issue is that this PR fundamentally changes Moya from a CocoaPod that could support Carthage, to a Carthage library that can incidentally be used with CocoaPods. This might seem like a trivial matter, and it's at this point that I need to recognize that _I_ no longer own Moya ‚Äì the community does. My own feelings matter a lot less.

But the community has been using Moya _as_ a CocoaPod for its entire lifetime, and a change of this foundational nature needs to be considered carefully. 

Respectfully, Justin, I think the Demo, unit tests, CI, and all that stuff should remain built atop CocoaPods. I realize this undoes some of the work you've put into this, so I'd like to do the work: I'll check out your fork, get Moya working atop CocoaPods again, ensure that Carthage support still works, then send a PR back into your branch so you can review my changes. Does that sound OK to you? We can hop on a google hangout to discuss this in person, too!
 Hey! This is still on my radar, just got sidetracked. 

As for the code structure, having the separate repos like https://github.com/Moya/ReactiveMoya is fine for _code_, but I think it's a good idea to keep all documentation and issue tracking in this main repo. This will keep the barrier to entry low (someone learning to use Moya shouldn't have to know how we structure our code to read our docs). Any objections? 
 Alrighty, I've disabled issues on the other repositories. We also need to update their READMEs to point to this repository. These other repos are basically just places to store files.

If we're centralizing docs here, I think it makes sense to centralize tests here as well. I can't see that being a problem with Carthage ‚Äì @justinmakaila does that sound OK? 
 Shouldn't be a problem ‚Äì we're restructuring the tests to run under CocoaPods, which won't have that problem. 
 Orta and I have implemented a solution that doesn't require us to split up the source code into three separate repositories, which I've PR'd in #215. @justinmakaila thank you so much for your work on this :smile_cat: 
  I've never had an open source project reach this level of popularity ‚Äì I think it's time we consider whether or not it makes sense to move Moya off of my own personal GitHub account. I've not run an organization before, either. 

Benefits:
- Easier to mention all contributors in important issues/PRs.
- Emphasizes that this is a community project and not a personal one.
- We could separate Moya into distinct repositories, one for the core, one for ReactiveCocoa, and one for RxSwift.
- Adding new, related libraries would be easy and be on the same organization.

Drawbacks:
- Existing podspecs, cartfiles, submodules will need to move over to the new URL (redirects seem to stop working after a month in my experience).
- I don't get my name all over the project anymore.

Is anyone else aware of other tradeoffs? @orta?
 If you're thinking about it, then it should probably be done. Given that `/moya` isn't free, you might want to consider if you can think of other sibling projects that could go with it.

The distinct repos sounds like a bunch of faffing though to me FWIW.
 Good points. 

Distinct repos would solve our Carthage problem; they refuse to implement subspec-style libraries because it "encourages large libraries." Could be something CocoaPods could do ‚Äì it crease a project now, maybe one with separate framework targets for different subspecs?
 Would probably be a pretty reasonable CP plugin for lib authors wanting to make binary releases.
 Leaning more in favour of this. We should probably add a [CoC](http://contributor-covenant.org) while we're at it. 
 So, since no one has any objections, I've decided to go ahead with this. Here are the steps we'll need to take:
- [x] Think of an organization name (this is the hardest part).
- [x] Create a new org.
- [x] Add Moya contributors as admins to the org.
- [x] [Transfer the repo](https://help.github.com/articles/transferring-a-repository/) to the org.
- [x] Create an org [code of conduct](http://contributor-covenant.org/version/1/2/0/).
- [x] Send a PR to CocoaPods/Specs to change the git URLs to the new endpoint. (Right?)

Any other steps? Any suggestions on a name? 
 >  Send a PR to CocoaPods/Specs to change the git URLs to the new endpoint. (Right?)

Yep, the default redirects will work, but not forever.

> Any suggestions on a name?

MoyaAPI, MoyaNetworking, nothing strikes me as awesome. Will ask @moya if it can be transferred.
 Cool, yeah. 

@colinta Initially, it'd just be this repo and probably a demo or two showing how to use Moya. In the long run, I'd love to see the org grow to include new functional-ish ways to use Swift to solve problems on iOS and OS X. It would be awesome to have a sort of meta repo where we could keep a list of ideas for projects. That way if someone had an idea, or needs an idea, they have a space they can get more help than on their own.
 @orta Thanks for asking :)
 Given the lack of a reply from @moya I think it might make sense to go with MoyaAPI ?
 Or MoyAwesome :stuck_out_tongue: 

MoyaAPI just seems so... _pedestrian_. 
 It's possible, but the user could have private activity that we just can't see. I don't want to write them off :)

Moya is named after [a living spaceship](https://en.wikipedia.org/wiki/List_of_Farscape_characters#Moya). **puts on nerd glasses** Moya doesn't speak, so she doesn't have a voice actor, but she's biologically bonded to a pilot, voiced by Lani Tupu. It's [been suggested](https://twitter.com/twannl/status/628670104667070464) that using some variation of that name might work, though those names are taken. I'd be pretty cool with using another homage to Farscape, too, but everything I found was too on the nose. 
 Nah, https://github.com/Leviathan/ is taken. 
 I've been in contact with GitHub support, and https://github.com/Moya is now an organization I control. I'll be adding contributors as team members there, then transferring and doing related chores hopefully today, maybe tomorrow. 

:tada:
 Awesome sauce! :tada: 

:clap: 
 OK, so I've submitted a PR to update the Moya podspecs: https://github.com/CocoaPods/Specs/pull/13370

Circle CI needs to enabled the iOS beta on the Moya organization, so our CI will be broken until they flip that switch. 

I've also submitted this PR on Moya to update docs, CI, etc: https://github.com/Moya/Moya/pull/175 If one of @Moya/contributors could take a look, that'd be awesome!
  Hey, thanks so much! This is a great step forward. @esttorhe has done some work in #162 ‚Äì maybe you two could work together?

Until RxSwift renames `defer`, if it does, you just need to surround it in backticks like ``defer ``.
  I did this originally to implement inflight request tracking; a multicast connection's `autoconnect()` generates a new signal every time (subscribed to the same underlying signal), so I couldn't store it in the requests dictionary. I got a little frustrated and settled with a solution that appeared to work. I should review the docs and implementation. Since Moya has good test coverage, we can be sure that any changes don't break behaviour :smile: 
 Fixed in https://github.com/Moya/Moya/pull/232 ‚Äì currently in 3.0.0-develop branch. 
  Yeah, that's a fair point. We use comparisons based on the URL, the HTTP method, all the parameters, and the body. I would think that sending the same request twice would be different, but I suppose this is an assumption. 

Any suggestions? We could extend behaviour in the `MoyaProvider` class ‚Äì maybe a closure like this?

```
typealias ShouldCheckInflightRequests = (Endpoint) -> (Bool)
```

That way people _can_ opt-out on a per-endpoint bases if they want? Open to suggestions on this. 
 Hmm. Maybe a good default implementation would specify that GET and HEAD requests are coalesced, but POST PUT PATCH and DELETE ones are not. That seems like a sane default to me. Thoughts?

As for the inflight caching ‚Äì using a token makes sense to me. 
 Yeah, I dunno. Seems like this might be more trouble than it's worth, but @aschuch and @kzaher are right ‚Äì this should definitely be opt-in. 
 Fixed in https://github.com/Moya/Moya/pull/232 ‚Äì currently in 3.0.0-develop branch. 
  Ok, so I have tried to fix this, but it broke my test when I added the `>- variable`. It won't complete whet this is present.

The sync is working well on RxSwift but it won't complete if added to the `ReactiveCocoaMoyaProvider`.

Here is the test for the RxSwift to see if you can help me with that. I don't like the way it is but I couldn't think of another way:

``` swift
it("returns identical observables for inflight requests") {
    let target: GitHub = .Zen
    var response: MoyaResponse!
    let outerSignal = provider.request(target)
    outerSignal >- subscribeNext { (response) -> Void in
        expect(provider.inflightRequests.count).to(equal(1))
        let innerSignal = provider.request(target)
        innerSignal >- subscribeNext { (object) -> Void in
            expect(provider.inflightRequests.count).to(equal(1))
        }
    }
    expect(provider.inflightRequests.count).to(equal(0))
}
```
 Thanks for bringing up the issue, @kzaher ‚Äì good catch! Hand't considered the signals coming from other threads >.<

@alcarvalho Thanks for the help! It's a tricky problem and a _very_ difficult use case to test. Could I ask you to open a pull request, with your work and new tests? We can have a conversation about it there :fireworks: 
 Sure, @ashfurrow. Done! :wink: 
 This was fixed when #166 was merged. 
  Awesome, thanks!
 no problem :) Probably a good idea. 
 That's great! And there's someone working on the migration of RxSwift
already.

Maybe we'll have soon. ;)

On Fri, Jul 3, 2015 at 18:54 Ash Furrow notifications@github.com wrote:

> no problem :) Probably a good idea.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/ashfurrow/Moya/pull/162#issuecomment-118432120.
 Great, thank you!

Now the tests are failing because some files are pointing to the absolute path on someone's computer. Maybe yours?

```
‚å¶  unable to read module map contents from 'Target Support Files/Pods-Alamofire/Pods-Alamofire.modulemap': Error Domain=NSCocoaErrorDomain Code=260 "The file ‚ÄúPods-Alamofire.modulemap‚Äù couldn‚Äôt be opened because there is no such file." UserInfo=0x7feb2a75bdc0 {NSFilePath=/Users/distiller/Moya/Demo/Pods/Target Support Files/Pods-Alamofire/Pods-Alamofire.modulemap, NSUnderlyingError=0x7feb2a7768f0 "The operation couldn‚Äôt be completed. No such file or directory"}
```

This `/Users/distiller/Moya/Demo/Pods/Target Support Files/Pods-Alamofire/Pods-Alamofire.modulemap` folder is inside someone's home folder. :wink: 
 Are the tests working on your machine? From the log I can see now is matter configuring the correct version of XCode on the `circleci.yml` file. But this could be just the beginning. :worried:  
 I see. After you get the tests running locally we'll need to see what is the correct XCode 7 version for Circle CI, if they support it already. Just to make sure the tests are passing there too. 
 Hey there @vCrespoP! I'm not sure the status ‚Äì I've not been using Swift 2 yet, but that will change soon, so I'll have some work time to devote to it. 
 Sadly (or for our own safety) we can't point `podspec` dependencies to specific branches and that's why I left all dependencies on this `PR` without version specific tags.

If you take a look at the `Demo` `Podfile` you'll see it like this:

``` ruby
platform :ios, '8.0'

source 'https://github.com/CocoaPods/Specs.git'

use_frameworks!

#pod 'ReactiveCocoa', :git => "https://github.com/reactivecocoa/reactivecocoa.git", :branch => "swift2"
pod 'RxSwift', :git => "https://github.com/kzaher/RxSwift.git", :branch => "feature/swift2.0"
pod 'Alamofire', :git => "https://github.com/Alamofire/Alamofire", :branch => "swift-2.0"

pod 'Moya/RxSwift', :path => "../"
#pod 'Moya/ReactiveCocoa', :path => "../"
pod 'Moya', :path => "../"

target 'DemoTests' do

  pod 'Quick', :git => 'https://github.com/Quick/Quick', :branch => 'swift-2.0'
  pod 'Nimble', :git => 'https://github.com/Quick/Nimble', :branch => 'swift-2.0'
  pod 'OHHTTPStubs'

end
```

That's in order to satisfy the `Swift 2.0` requirements that can't be specified on the `podspec`.
As for `ReactiveCocoa` haven't had the time to tinker with the custom made `podspec` to point to a `Swift 2.0` branch and thus, the status on that front is still the same :snowflake: 
 Hey @esttorhe ‚Äì could you close this, rebase from `master`, then submit a _new_ PR into Moya's `swift-2.0` branch? 
 @ashfurrow I'm headed out to get my :eyes: checked and won't be able to use the computer for 3-4 hours.

I'll close and rebase later today or tomorrow morning tops.
 Cool, thanks!
 FYI started this late last night with my eye sight barely functioning and couldn't get too far due to my :eyes: being too tired.

Today is a brand new day :city_sunset: and I'll hope to have this done by _EOD_ today
 Take your time! The last thing we want is for you to get strained and burn out on open source :)
 The rebase is done; I'm going to close this issue BUUUUUUUUT

I can't compile on √ü5; getting the following

``` console
Module file was created by an older version of the compiler; rebuild 'Security' and try again: /Applications/Xcode-7.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphonesimulator/x86_64/Security.swiftmodule
```
 Or maybe I won't because I'll need to rename the branch or something else in order for Github to let me open a new `PR` (can't from the same `branch`)
 I've had that happen before. Silly GitHub. 

![](https://38.media.tumblr.com/96175edf52520fea3c47f0588fb55ba5/tumblr_mjkd49n4xk1rt8levo5_500.gif)

Maybe rename your branch, push, then PR into `swift-2`?
 ## I did it!!

![](http://i2.wp.com/metrouk2.files.wordpress.com/2015/05/shia-labeouf-video-still.jpg?crop=70px%2C14px%2C325px%2C183px&resize=650%2C366&quality=80&strip=all&w=450&h=253)
  That's a really great point, thanks!

PR looks good ‚Äì would you mind adding an entry to the changelog? 
 Interesting! I'll take a look later. It could be just that ReactiveCocoa was not intended to be used standalone, or that I didn't anticipate this need when I made the podspec. 
 Yeah, looks like ReactiveCocoa's `Core` subspec is not intended to be used standalone. CocoaPods bundles in whatever UI stuff you need depending on your platform. Could be that this is a use case the ReactiveCocoa developers _did_ intend, but they don't contribute to the podspec. 

Thanks again for the contribution!
  Hmm. I'm not quite sure what to make of this. Hoping @neonichu knows. 
 I'm going to move this to #154 ‚Äì there's a discussion there surrounding Moya and Carthage. 
  Thanks!
  Hey, totally! Great idea! I've pushed a `swift-2.0` branch so we can follow that there. If you're able to, a PR into that branch would be very much appreciated :)
 I'm not attached at all ‚Äì @neonichu asked to add the `Pods/` directory and its friends for Carthage support. If we don't need that, that's cool with me. 

![](https://s-media-cache-ak0.pinimg.com/originals/d9/be/72/d9be72f4ac11c7da286fa98e99c929f3.jpg)
 Hmm, sorry, I'm re-reading this and I thought you meant to pods _directory_. I'd feel more comfortable keeping the demo project built with CocoaPods. 
 Can this be closed with #194 ?
 Sounds good. 
  Hi there @XBeg9 ‚Äì good question. The `request` function purposefully returns a `CancellableToken` to obscure the underlying Alamofire implementation. The idea is that you shouldn't need to know that Moya uses Alamofire "under the hood", so returning the request defeats that purpose. 

So, how do we make it so you can use this mapping library, which looks pretty cool. That library is actually a thin wrapper around [ObjectMapper](https://github.com/Hearst-DD/ObjectMapper), which you could use directly. That's not a satisfying answer, I know. 

An alternative would be to extend the `MoyaProvider` in another subspec in a similar way that AlamofireObjectMapper does. It shouldn't be that much work, but I'm swamped until the weekend.

What sounds like the best solution to you? Does anyone else have suggestions? 
 So I'm thinking that we'd have `extension MoyaProvider` that would call through to the original `Request`, but also take a callback block similar to AlamofireObjectMapper. So it would call through to the original `request` function, then do something in the callback to map the objects, then call its own callback. 

So it would look something roughly like this:

```
func someRequest(target, someCallback) {
    request(target) { (thing) -> () in
        let mappedObject = ObjectMapperCallOrWhatever
        someCallback(mappedObject)
    }
}
```

Does that make sense? 
  Yeah, it doesn't appear to ‚Äì apologies for that. @neonichu or anyone else with Carthage know-how: what would be involved in adding support for the RxSwift subspec? 
 Oh, I see. So someone using Moya with Carthage now just _has_ to also use ReactiveCocoa, even if they only want the original `MoyaProvider`, not the ReactiveCocoa subclass? 
 RxSwift was the original name of the RAC 3 proof of concept. It also happens to be the name of a [Swift-based reactive extensions library](https://github.com/kzaher/RxSwift). The library is young but growing. Whether there's enough demand for this from Carthage users, I don't know. 
 @MarvinNazari Wouldn't be a bad idea if this was a Carthage-only repository, but I'm a CocoaPods user and this _is_ the right way to use CocoaPods. 

I feel like the Moya team have been very flexible on a number of issues in order to support Carthage. Frankly, I'm tired of jumping through hoops to support a nascent dependency manager that ignores community feedback. 
 @MarvinNazari Sorry, that was very rude of me. I don't mean to dump this on you ‚Äì I've been growing frustrated at this process for some time now. Splitting the functionality into multiple repos would be a good idea, but I don't think it's the right solution for Moya.
 @MarvinNazari I'm glad you like our library :) I wish there were a better way to support your use case. Hopefully the Carthage people will help.

Like, how do they do they manage different frameworks for different platforms? Could that work somehow? 
 Yeah, exactly. Could we leverage that technique? 
 Hmm. The target would be an issue, since CocoaPods lumps the subspaces into the same framework. 

So we'd basically need to create and maintain a separate Xcode project solely for Carthage support, right? 
 I'd appreciate that, Justin, thanks! 
 Cool, this looks great @justinmakaila ‚Äì want to submit a PR to add those instructions to the README? 
 @justinmakaila sounds cool, thanks! Send the PR over and we can take a look there :tada:
 Now that we have an organization, could we use submodules somehow to dump the necessary files for Moya, Moya/RAC, and Moya/RxSwift into separate repositories? I don't really know how Carthage works. 
 @gfontenot That sounds like a really intriguing solution ‚Äì I had never considered having subspecs use a different `source` ‚Äì @orta any reason why that'd be a bad idea? I personally like having all the source files in one repo, but if it solves our projects with Carthage support, then it seems like a reasonable compromise. 

I'll add you two to the org. Thanks so much for your help!
 CP can do the submodule fine too :+1: 
 Super, thanks @justinmakaila! GitHub repo transfers are messy ‚Äì I've created the other repos on the Moya organization for you, and you should have push rights. Just add a remote for them, pull, merge, and push.

``` sh
cd RxMoya
git remote add upstream https://github.com/Moya/RxMoya.git
git pull upstream master 
*** Merge any conflicts ***
git push upstream master
```

And repeat. I've created an RxCore repo for the shared resources, in case you need it. 

Let me know if I can do anything more to help! I really appreciate your work, and the work of everyone here to come up with a solution that works for everyone :tada: Good job, team. 

![](https://s-media-cache-ak0.pinimg.com/originals/d9/be/72/d9be72f4ac11c7da286fa98e99c929f3.jpg)
 Ah, sorry ‚Äì first time using GH organizations :) Try again?
 So @justinmakaila what are the next steps? Are the other repos working with Carthage? Swift 1.x or Swift 2? Do we just need to update CocoaPods now?

If the other repos are still works-in-progress, we should consider adding a note to their READMEs. And maybe include instructions for their corresponding CocoaPods subspecs' installations. Does that make sense? 
 Super, cool! So if everything is working with Carthage, there's only a few things left to do:
1. Ensure the new repos with RxMoya and ReactiveMoya are up-to-date with this one. 
2. Remove files from this repo.
3. Update podspec to point to the two new repos.
4. Test/lint podspec
5. Ensure `pod try` continues to work.
6. Release a new version of Moya.

Let me know if I'm forgetting anything. 

All sounds good? I can get started as early as this weekend, unless someone wants to do it sooner. 
  To my knowledge, no-one has stepped up to keep the Carthage/RAC branch in sync, we'd welcome a PR making sure it supports the latest from you.
 Yeah, to be honest I'm not entirely sure how dependency resolution with Carthage works. If it were CocoaPods, I'd fork the Moya repo and point to my fork in the Podfile. 

@neonichu: you added Carthage support ‚Äì any ideas? 
 Cool, thanks @aschuch ! I wasn't sure how the `~> 3.0` signifier works in Carthage. 
  :+1:  thanks
  tl;dr Moya doesn't currently support this.

Hmm. Interesting question. Alamofire seems to [handle this with `NSURLCredential`](https://github.com/Alamofire/Alamofire/blob/922c1ca3580b7adc9235bede1e99580e02ad3e9f/Source/Request.swift#L76-L80). Is this how you've done HTTP auth in the past? 

Maya doesn't currently have support for this, but using the `sharedSession` `NSURLSession`, so you _should_ be able to set things there and have all HTTP requests use those credentials. Obviously that's not a great fix, though. 

I guess what this would really need is some kind of (optional) way to specify which `NSURLSession` to use: the default, or one configured for your endpoints alone. 

Others are likely more familiar with the network library underneath Alamofire. Anyone have suggestions on how to implement this? 
 That makes sense. But it also adds a lot of complexity around individual API calls. Developers now need to remember which endpoints need auth and which don't, and that need is spread across their entire codebase. 

I think we need one of two things:
- an optional part of the `MoyaTarget` protocol that specifies per-target credentials
- an optional closure in the `MoyaProvider` initializer that gets last-moment chance to specify credentials based on the target. If it returns credentials, they're added to the request in the provider. 

I like the second option better because most users don't need HTTP basic auth and it keeps our protocol leaner. What do you think? 
 That would be lovely! Please let me know if you'd like to bounce ideas around or anything :smile: 
 Cool, thanks for the update @davidbarsky. Please let us know if there's anything else you'd like to see added to Moya!
  This is great, @lluisgerard ‚Äì very good catch. Thanks!
  As per @alloy's discussion in #135.
 :+1: 
 :bow:
  It uses default values for its initializers that need to be duplicated by subclasses. 

``` swift
public init(endpointClosure: EndpointClosure = MoyaProvider.DefaultEndpointMapping,
    requestClosure: RequestClosure = MoyaProvider.DefaultRequestMapping,
    stubClosure: StubClosure = MoyaProvider.NeverStub,
    networkActivityClosure: Moya.NetworkActivityClosure? = nil,
    credentialClosure: CredentialClosure? = nil,
    manager: Manager = Alamofire.Manager.sharedInstance) {

    self.endpointClosure = endpointClosure
    self.requestClosure = requestClosure
    self.stubClosure = stubClosure
    self.networkActivityClosure = networkActivityClosure
    self.credentialClosure = credentialClosure
    self.manager = manager
}
```

Dunno how we could do this.. 
 This is really tricky. Basically our providers are containers for data (their configs) and a `request` method. That's, like, the definition of a class. 

I suppose we could move `MoyaProvider` to be a protocol and put `request()` in a protocol extension? Or maybe turn Moya into a `struct` instead of a class. The real hassle is just updating initializers that don't do anything but call `super.init(...` so structs would remove that pain most of the time. Or maybe we could use composition instead of inheritance? 
 Alternatively, it seems a bit odd that subclasses _must_ override the initializer. 

``` swift
override public init(endpointClosure: EndpointClosure = MoyaProvider.DefaultEndpointMapping,
    requestClosure: RequestClosure = MoyaProvider.DefaultRequestMapping,
    stubClosure: StubClosure = MoyaProvider.NeverStub,
    networkActivityClosure: Moya.NetworkActivityClosure? = nil,
    credentialClosure: CredentialClosure? = nil,
    manager: Manager = Alamofire.Manager.sharedInstance) {

        super.init(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, networkActivityClosure: networkActivityClosure, credentialClosure: credentialClosure, manager: manager)
}
```

All the subclasses ever do is call `super.init()`. How can we abstract this?
 Maybe instead of subclassing, we can add extensions to the existing `MoyaProvider` type? 
 I like the idea of using protocols to extend the primary type, but I'm concerned about the constraints that would introduce for existing users who are currently subclassing (say, `RxSwiftProvider`). I'm going to look through [Eidolon](http://github.com/artsy/eidolon) for how we use Moya, and see if there are any foreseeable problems before starting an implementation.
 Fixed in #238.
 Well, it was addressed in the sense that subclassing the provider no longer requires so many initializer parameters and repeating their default values. What you're describing sounds like a new issue. I have subclassed `RxMoyaProvider` [here](https://github.com/artsy/eidolon/blob/1c746f9a9c6420cda9f691468783fee67376e8b1/Kiosk/App/Networking/Networking.swift#L7) without issues. 
 Subclassing in Swift usually requires calling a designated initializer in the superclass, I'm not sure of a great way to avoid this in Moya. Do you have suggestions?  

## 

Ash Furrow
https://ashfurrow.com/  

On April 30, 2016 at 12:24:01 PM, nikita leonov (notifications@github.com(mailto:notifications@github.com)) wrote:

> I see. Yes, it is easier to define default parameters now, but it still require overriding designated initializer. Actually situation does not change in compare with what you writing in Oct, 1. Here is current experience of subclassing ‚Äî https://www.evernote.com/l/AEaV5Z1HlZRGprguAUiszmTarcbrRgFzQA0
> 
> ‚Äî
> You are receiving this because you modified the open/close state.
> Reply to this email directly or view it on GitHub(https://github.com/Moya/Moya/issues/144#issuecomment-215976739)
 Interesting. I suppose what I meant was, a reason to subclass would be to provide custom behaviour, which may need to be given as an initializer parameter Subsequently, you'd want to define all the usual default values and would also need to call the super-initializer. I would love to hear ideas to solve either of those problems ‚Äì please keep us in the loop about your progress, maybe on a new issue? 
  :+1:
Would also put MoyaResponse file inside a newly created ReactiveCore
folder.

On Fri, Jun 12, 2015 at 04:59 Alexander Schuch notifications@github.com
wrote:

> At the moment, I find it hard to browse code on the Github repo.
> I think we should consider adding a folder structure to make browsing Moya
> on Github a better experience.
> 
> I would keep everything the same but introduce a new Moya folder that
> contains all the relevant files.
> - üìÅDemo
> - üìÅdocs
> - üìÅweb
> - üìÅMoya
>   -- Endpoint.swift
>   -- Moya.swift
>   -- MoyaResponse.swift
>   -- üìÅReactiveCocoa
>   --- Moya+ReactiveCocoa.swift
>   --- RACSignal+Moya.swift
>   -- üìÅRxSwift
>   --- Moya+RxSwift.swift
> - README.md
> - Moya.podspec
> - etc...
> 
> Thoughts?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/ashfurrow/Moya/issues/138.
 No, it's used by reactive in general, meaning ReactiveCocoa and RxSwift, right now. I have extracted it from the ReactiveCocoa integration when I implemented the RxSwift provider to be a common core.

But there's a ticket #134 to remove all comments from file's headers.
 @SRandazzo the lack of an xcproj is strange to me too. The way I do it here is by opening the Demo to edit the code for the library. Not the most intuitive.
 I like this idea ‚Äì will do. 

As for a dedicated project/workspace, what would be the advantages of using one? The library is installed using CocoaPods; the Demo project is for illustrating the library's use and for its unit tests. That could be moved into a test-only project, sure. What advantages would there be of having another project/workspace? 
  Does it make sense now that we're saying that `parameters` are on the target, and `path` is on the path, given that either property depends on the enum's associated values? 

/cc @chriseidhof
  I want other people to feel like they own Moya, too, so it survives in the long run.

What I'm looking for is people who can:
- Reply to questions.
- Help diagnose/fix issues people have.
- Help form a roadmap for future releases.

All when you have time and feel like it. It's not meant to be a burden.

> Don't ever feel bad for not contributing to open source. ‚Äî@alloy

Thanks to @searls for the push to do this. 

If you're interested in helping out ‚Äì when it's convenient for you ‚Äì comment on this issue and I'll add you as a committer with push access.

/cc @colinta @orta @skywinder @garnett @aschuch @raphaelmor @powerje @process255 @powerje @neonichu @Thomvis @alcarvalho @joshuatbrown @SRandazzo @pietbrauer @juhagman @vandyshev @jspahrsummers @lipka @stephencelis 
 Super awesome!
 Awesome. @neonichu since you mentioned it, I've added you as an owner to the pod in CocoaPods trunk. 
 I would love to help, too! I am still in the early stages of adopting it, but our new app's communication layer will be all using Moya. :+1: 
 Gonna call this done! Thanks for your help, everyone :cake:
 @alloy I like it. As though adding more contributors should be a regularly part of open source. :bow:
 Yeah, go for it üéâ The guidelines Orta linked to are great, please let me know if I can help at all, and let me know how it goes! 
  Cool, thanks!
  Both are accurate (think "provider" as in `MoyaProvider` class), but I like your wording better. Thanks! 
  Awesome, thank you! 
  Thanks!
 Cool! Open an issue if you have any questions! 
  Cooooool thanks!
  Cool, thanks Boris! 
 OK cool. I've got a PR open for checking in the Pods directory. Once that is :green_apple: , I'll merge and you can rebase from master? Or should it be safe to merge directly in?

/cc @MichaelMcGuire
 Ha, meeerrrrge conflict. 
 @neonichu Wanna rebase so I can merge? 
 :red_circle: can you `pod install` or `update` or whatever needs to pass?
  Lots of changes:
- Documentation revamp. Expanded a bunch and added examples. 
- Parameters moved from `request()` functions to the target enums, instead. 
- HTTP methods moved from `request()` functions to target enums, instead. 
- The result of the last two is that there is only one `request()` method in the non-reactive `MoyaProvider` class, and one more in the `ReactiveProvider` class. 
- Related changes to the endpoint-resolving closure.
- `SampleResponse` enum now accepts a closure that returns sample data instead of the data itself.

Overall, I think this is a general simplification of the Moya framework. Lots of things that made sense when I started this didn't turn out being as useful as I had anticipated. This really supports a simple use: setup a target enum and create a provider. No messing around with `Endpoint`s at all anymore, unless you want to.

Once merged, I'll release this as a `1.0.0`, since it has breaking changes (noted in the changelog). 

Fixes #123 (documentation)
Fixes #74 (move parameters to target)
Fixes #60 (moves HTTP method to target)
 Thanks for the feedback! Yeah, my fingers were getting pretty tired >.<
  Neat! I'll take a look :rocket: 
 Hey! I've thought it over, and I don't know if this tool is right for this project. It seems to heavily rely on using labels and GitHub comments appropriately, but most of the time, I don't do that on Moya. I think the changelog generator is a really great idea, but it's not a good fit for this project. 

Thanks again for the suggestion!
  You absolute troll. 
 ‚ù§Ô∏è
  This looks amazing! :heart_eyes_cat: 

One small nitpicky note: The rest of the tests use spacing around the expectation, like `expect(thing).to( beNil() )` ‚Äì it's something that @orta got me doing and I think it looks nicer. 

Otherwise, looks awesome. Very nice job with the tests :+1:
 Hey there!

Sorry, missed the update. I'll take a look in a bit ‚Äì gonna merge the swift-1.2 branch into master and get back to you. 
 Ha, yeah. Jet lag took me out of commission for the past two days, too. 

Why don't I try to submit a PR to your branch that does the ReactiveProvider tests? Then we can do that separately, then merge this one into `swift-1.2`, then `swift-1.2` into `master` then :tada:
  Neat idea!

I think the base case for non-Reactive providers would be to return an opaque object; one that has no public members except a `cancel()` function. The object (or struct) would wrap the `Request` object from Alamofire to avoid a leaky abstraction. Then it would be up to the caller to do anything ‚Äì or not ‚Äì with the returned value. 

It wouldn't even be a breaking change, unless the call to `request()` was the online line in a closure that has a `Void` return value. 

For the Reactive extension, it's a bit trickier but not difficult. We currently have a side-effect that if the subscription to the signal is cancelled before the request finishes, we remove the request from the inflight cache. We would just need to add a call to `cancel()` [here](https://github.com/ashfurrow/Moya/blob/ad1e2266e8820433270eca3ba98aa01c787879a3/Moya%2BReactiveCocoa.swift#L74-L79). 
 Great questions! 
1. Hmm. Good question. I think `.Delayed` makes sense. 
2. This is a really interesting point. I really dislike having a tonne of different parameters in the completion block and making the user of the library try to figure out what they all mean, but my primary use of Moya is with ReactiveCocoa, so I only wrapped Alamofire (figured those people know what's best). In this case, I think we should stick as close to the behaviour as possible. If `NSURLSessionTask` completes with an error, then :+1:. It might not even be necessary to do that, since Moya uses their completion block to invoke its completion, so maybe cancelling the task is sufficient to have Alamofire call Moya, which calls its completion. Thoughts? 
3. Yeah, keeping it as-is is perfect. It's more like "is a request inflight" more than anything. 
 Oh, and let's go on the latest Xcode ‚Äì we can merge into the `swift-1.2` branch, which'll be merged into master shortly anyway. 
  :bow: A pull request with the extensions would be awesome! Let me know what I can do to help. 
 I've not looked too extensively into this, and would appreciate guidance or assistance.

Maybe we could add this new functionality to the _existing_ `ReactiveMoyaProvider` class? Or would we want a 3.0-only class? Since the two APIs are interchangeable, it might make sense to have only one class. 
 @rpowell that would be lovely! 
 @justinmakaila has implemented a solution on another repository (pasted below). We can't incorporate this change into the library yet because it's a breaking change to existing users, and we need to update Moya to the next major version (3.0.0). I'd like to get a Swift 2, Carthage-compatible release out _first_ (see #215) and then incorporate Justin's work, since it looks great :100: 

``` swift
/// Subclass of MoyaProvider that returns SignalProducer<MoyaResponse, NSError> instances when requests are made. Much better than using completion closures.
public class ReactiveCocoaMoyaProvider<T where T: MoyaTarget>: MoyaProvider<T> {
    /// Current requests that have not completed or errored yet.
    /// Note: Do not access this directly. It is public only for unit-testing purposes (sigh).
    public var inflightRequests = Dictionary<Endpoint<T>, Signal<MoyaResponse, NSError>>()

    /// Initializes a reactive provider.
    override public init(endpointClosure: MoyaEndpointsClosure = MoyaProvider.DefaultEndpointMapping, endpointResolver: MoyaEndpointResolution = MoyaProvider.DefaultEnpointResolution, stubBehavior: MoyaStubbedBehavior = MoyaProvider.NoStubbingBehavior, networkActivityClosure: Moya.NetworkActivityClosure? = nil) {
        super.init(endpointClosure: endpointClosure, endpointResolver: endpointResolver, stubBehavior: stubBehavior, networkActivityClosure: networkActivityClosure)
    }

    public func request(token: T) -> SignalProducer<MoyaResponse, NSError> {
        let endpoint = self.endpoint(token)

        if let existingSignal = inflightRequests[endpoint] {
            /// returns a new producer which forwards all events of the already existing request signal
            return SignalProducer { sink, disposable in
                /// connect all events of the existing signal to the observer of this signal producer
                existingSignal.observe(sink)
            }
        }
        else {
            /// returns a new producer which starts a new producer which invokes the requests. The created signal of the inner producer is saved for inflight request
            return SignalProducer { [weak self] sink, _ in
                let producer: SignalProducer<MoyaResponse, NSError> = SignalProducer { [weak self] sink, disposable in
                    let cancellableToken = self?.request(token) { data, statusCode, response, error in
                        if let error = error {
                            if let statusCode = statusCode {
                                sendError(sink, NSError(domain: error.domain, code: statusCode, userInfo: error.userInfo))
                            } else {
                                sendError(sink, error)
                            }
                        } else {
                            if let data = data {
                                sendNext(sink, MoyaResponse(statusCode: statusCode!, data: data, response: response))
                            }
                        }
                        sendCompleted(sink)
                    }

                    disposable.addDisposable {
                        if let weakSelf = self {
                            objc_sync_enter(weakSelf)
                            // Clear the inflight request
                            weakSelf.inflightRequests[endpoint] = nil
                            objc_sync_exit(weakSelf)
                            // Cancel the request
                            cancellableToken?.cancel()
                        }
                    }
                }

                /// starts the inner signal producer and store the created signal.
                producer |> startWithSignal { [weak self] signal, _ in
                    objc_sync_enter(self)
                    self?.inflightRequests[endpoint] = signal
                    objc_sync_exit(self)
                    /// connect all events of the signal to the observer of this signal producer
                    signal.observe(sink)
                }
            }
        }
    }

    public func request(token: T) -> RACSignal {
        return toRACSignal(self.request(token))
    }
}

/// Extension for mapping to a certain response type
public extension ReactiveCocoaMoyaProvider {
    public func requestJSON(token: T) -> SignalProducer<AnyObject, NSError> {
        return request(token) |> mapJSON()
    }

    public func requestJSONArray(token: T) -> SignalProducer<NSArray, NSError> {
        return requestJSON(token) |> mapJSONArray()
    }

    public func requestJSONDictionary(token: T) -> SignalProducer<NSDictionary, NSError> {
        return requestJSON(token) |> mapJSONDictionary()
    }

    public func requestImage(token: T) -> SignalProducer<UIImage, NSError> {
        return request(token) |> mapImage()
    }

    public func requestString(token: T) -> SignalProducer<String, NSError> {
        return request(token) |> mapString()
    }
}

/// MoyaResponse free functions

public func filterStatusCode(range: ClosedInterval<Int>) -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<MoyaResponse, NSError>  {
    return { producer in
        return producer |> flatMap(.Latest, { response in
            if range.contains(response.statusCode) {
                return SignalProducer(value: response)
            } else {
                return SignalProducer(error: ReactiveMoyaError.StatusCode(response).toError())
            }
        })
    }
}

public func filterStatusCode(code: Int) -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<MoyaResponse, NSError> {
    return filterStatusCode(code...code)
}

public func filterSuccessfulStatusCodes() -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<MoyaResponse, NSError> {
    return filterStatusCode(200...299)
}

public func filterSuccessfulAndRedirectCodes() -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<MoyaResponse, NSError> {
    return filterStatusCode(200...399)
}

/// Maps the `MoyaResponse` to a `UIImage`
public func mapImage() -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<UIImage, NSError> {
    return { producer in
        return producer |> flatMap(.Latest, { response in
            if let image = UIImage(data: response.data) {
                return SignalProducer(value: image)
            } else {
                return SignalProducer(error: ReactiveMoyaError.ImageMapping(response).toError())
            }
        })
    }
}

/// Maps the `MoyaResponse` to JSON
public func mapJSON() -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<AnyObject, NSError> {
    return { producer in
        return producer |> flatMap(.Latest, { response in
            var error: NSError?
            if let json: AnyObject = NSJSONSerialization.JSONObjectWithData(response.data, options: .AllowFragments, error: &error) {
                return SignalProducer(value: json)
            } else {
                return SignalProducer(error: ReactiveMoyaError.JSONMapping(response).toError())
            }
        })
    }
}

/// Maps a JSON object to an NSArray
public func mapJSONArray() -> SignalProducer<AnyObject, NSError> -> SignalProducer<NSArray, NSError> {
    return { producer in
        return producer |> flatMap(.Latest, { json in
            if let json = json as? NSArray {
                return SignalProducer(value: json)
            } else {
                return SignalProducer(error: ReactiveMoyaError.JSONMapping(json).toError())
            }
        })
    }
}

/// Maps a JSON object to an NSDictionary
public func mapJSONDictionary() -> SignalProducer<AnyObject, NSError> -> SignalProducer<NSDictionary, NSError> {
    return { producer in
        return producer |> flatMap(.Latest, { json in
            if let json = json as? NSDictionary {
                return SignalProducer(value: json)
            } else {
                return SignalProducer(error: ReactiveMoyaError.JSONMapping(json).toError())
            }
        })
    }
}

/// Maps the `MoyaResponse` to a String
public func mapString() -> SignalProducer<MoyaResponse, NSError> -> SignalProducer<String, NSError> {
    return { producer in
        return producer |> flatMap(.Latest, { response in
            if let string =  NSString(data: response.data, encoding: NSUTF8StringEncoding) as? String {
                return SignalProducer(value: string)
            } else {
                return SignalProducer(error: ReactiveMoyaError.StringMapping(response).toError())
            }
        })
    }
}
```
 Fixed in https://github.com/Moya/Moya/pull/224 ‚Äì merged into the 3.0.0-develop branch. 
  Cool, thanks! 

![](http://media.giphy.com/media/V2xbsCrxcLQSQ/giphy.gif)

Pretty sure this is failing on travis because of Swift 1.2. However, I would be more comfortable if we could add a command to the Makefile like `make test_carthage_build` or something to ensure that we can test Carthage's integration process and everything in the future. Does that sound OK? 
 Also a good idea. 

> On May 14, 2015, at 10:51 AM, Orta notifications@github.com wrote:
> 
> Could switch to CircleCI
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Travis build won't work with Swift 1.2 because they're still on Xcode 6.2 :cry: 

The more and more I think about it, the more I'm not really comfortable with Carthage files in the main repo. I'm totally cool with people using Moya and Carthage, but I'm not personally going to use it and I'm afraid of what happens when we go to implement new Moya features. Contributors would have to make sure that Moya works in CocoaPods _and_ Carthage, which is doubling deployment effort for this repo :confused: In the worst case, we say we have Carthage support but it doesn't work.

I'm open to suggestions ‚Äì if you comfortable with it, I'd love to let you handle Carthage and have the README contain instructions to use the Cartfile on your fork. Then you could pull in updates to your fork.

That's a lot to ask, though. 
 Hmm. Having the projects together would be nicer from a "fewer files in the repo" perspective, but it's really that I'm afraid that having Carthage supports is a promise to developers using Moya, and one that I'm not confident I can keep. 

But you're right ‚Äì this isn't a problem that only we have. I'm hoping that the community can solve this problem at a higher level so library authors aren't in this awkward spot. Maybe [this](https://github.com/neonichu/Rome) could help? 

For now, I would be much obliged if you were to maintain a fork with Carthage and submit a new PR updating the README to point Carthage users to use your repo :bow: :heart:
 From what people working on this repo and others have experienced, adding Carthage is not as minimal as you might expect. My issue is the problem of misleading developers by saying "we support Carthage", when I don't use it and won't know if Moya supports it correctly.
 Not at all! We're all after the same goal: making our own jobs easier. Take your time ‚Äì whenever you have a chance. 
  Sounds good to me ‚Äì CI is gonna break since Travis is sucky. Can you update the README status, too? 
 Thought they were still in invite-only beta?
 Cooool. 
 Thanks for the PR!
  üôá thanks! 
  Great idea! I think Alamofire supports this already, so there is an opportunity to leverage their code while being clever about how we expose the functionality. 
 OK, cool. We can start there then :)
 Help on this would be very much appreciated. I'm catching up on some work for the remainder of the week, and won't have time to look at it for a while. 
 This is a fundamentally new behaviour for Moya. I'm trying to figure out the best way to add it to our existing API without overly complicating things. 

If we want to use the existing `request()` function, then we would need to have a way to distinguish targets between upload and regular HTTP requests. We _could_ add `.Upload` to the `Moya.Method` enum, which would be easy, but would break parity with the HTTP verbs and the `Alamofire.Method` enum. 

On the other hand, if we add a new optional property to `MoyaTarget` for uploading (say, we call it `uploadData`), we could ignore the method of the target and assume it's uploading based on the presence of a non-`nil` `uploadData`. 

In either case, we would still need to figure out the progress callback. Maybe we could incorporate it into the cancellable token somehow maybe? 

Neither option really sits with me. We could, instead, have a new `upload` method on the `MoyaProvider` class. We would still need the optional `uploadData` property, the API would become _slightly_ more complicated, and it would be some duplicated code in `MoyaProvider` and its subclasses. 

Anyone have any feels about this?
 If only Swift had support for default parameters to Enums, we could have `.POST` and others with an optional parameter with a default to `nil`. 

But even if we don't have that support, we could just add more verbs that accept that to `Moya.Method`.
 Not yet, do you want to give it a shot and open a PR @clooth?
 Cool, that would be great! Feel free to ask questions in issues.

As for an implementation of this, I figure there's two part "entry points" where you could specify multipart upload: the `MoyaTarget` protocol or the `request` function. I think I'd prefer adding another function, or expanding the existing `request` function to handle it. Not sure of specifics, but you get the idea. 
 Let's make this happen!

How about creating a subprotocol, `MultipartFormUploadable` (I think we should get rid of this Moya namespacing too, but that's kinda just me) that inherits from `MoyaTarget` ‚Äì we overload `request` to take the more specific type, and to use it, and require an extra function to vend either an NSData, NSStream or a closure that returns those things to supply the body.

This might be the groundwork for a more strongly typed set of targets that more closely specify their methods of encoding and requesting, though that is perhaps an exercise best left to the reader.
 Played around with your ideas a bit, @swizzlr. A problem I'm running into is that if using something like:

``` swift
public protocol MultipartFormUploadable: MoyaTarget { }

public enum UploadDataProvider {
    case Data(NSData)
    case File(NSURL)
    case Stream(NSInputStream)
}

extension MoyaProvider where Target: MultipartFormUploadable {
    public func request(target: Target, provider: UploadDataProvider, completion: Moya.Completion) -> Cancellable
}
```

Then your _entire_ target type is then needing to conform to this protocol, or you need a second provider and target type for your multipart endpoints. While it doesn't seem like a necessarily common occurrence with a buffer of common sense, someone could technically call this version of `request()` with a `POST` target that is **not** multipart with a random (valid) data provider, since there's no way to distinguish between multipart and non-multipart enum target cases. Any better ideas for separation and compile-time verification of these types of endpoint targets?
 Yeah, this is why I think adding another `request` function specific to multipart uploading would be the best approach. 
 @ashfurrow Yeah, that is what I demonstrated above in the extension, but saw potential confusion with. Since the entire enum type must conform to `MultipartFormUploadable`, there's no way to determine whether a specific enum case should be able to be used for a multipart upload or not. This means it's not "perfectly strict" in that it can't warn or error if you try to misuse it in this way (misuse meaning call the overloaded version of `request()` in the extension with a data provider, on a target enum case that doesn't take multipart data). If you do so, you're stuck waiting potentially for the server to WTF at you for trying to upload data to a POST endpoint that doesn't take it, if that will even happen. In short, there's something that we know would at compile time, but can't enforce with the compiler in any way that I can think of, at least with targets as enum types.
 This makes total sense to me! 

> On Nov 18, 2015, at 4:49 AM, Guido Hendriks notifications@github.com wrote:
> 
> Maybe we should not focus on multipart/form-data, but on uploads in general. In Alamofire there are 4 types of uploads:
> 
> File
> Data
> Stream
> MultipartFormData
> I would say we add some kind of request type, which can be either Request or Upload (we could add Download too). Based on the request type it would execute the right Alamofire methods with the needed data from the target. That would also mean adding some kind of UploadType enum for all the supported upload types.
> 
> This way you maintain the abstraction. If you were adding a request specifically for uploads, you'd be picking the request type when executing a request, but that's something that the target should know.
> 
> Please do correct me if I'm wrong, but this seems like a step in the right direction to me.
> 
> ‚Äï
> Reply to this email directly or view it on GitHub.
 David, could you attach an example of the Ello.Target that would need to use Request and Upload types? I want to be sure I'm following you...

> On Nov 18, 2015, at 2:26 PM, David Warner notifications@github.com wrote:
> 
> I think, ideally, we'd like to be able to use the same endpoints for both Requests and Uploads, and therefore directly provide the DataProvider as a parameter to the request function. I ran with @JRHeaton's idea of a protocol extension to MoyaTarget, MultipartFormUploadable. I posted some of the implementation below and would love any feedback!
> 
> public protocol MultipartFormUploadable: MoyaTarget { }
> 
> extension MoyaProvider where Target: MultipartFormUploadable {
> 
> ```
> public func request(target: Target, parts: [MultipartBodyPart], completion:Moya.Completion) -> Cancellable {
>     precondition(target.method == .POST, "Uploads require Moya.method to be .POST")
> 
>     let endpoint = self.endpoint(target)
>     let stubBehavior = self.stubClosure(target)
>     var cancellableToken = CancellableWrapper()
> 
>     let performNetworking = { (request: NSURLRequest) in
>         if cancellableToken.isCancelled { return }
> 
>         switch stubBehavior {
>         case .Never:
>             cancellableToken.innerCancellable = self.sendUpload(target, request: request, parts: parts, completion: completion)
>         default:
>             cancellableToken.innerCancellable = self.stubRequest(target, request: request, completion: completion, endpoint: endpoint, stubBehavior: stubBehavior)
>         }
>     }
> 
>     requestClosure(endpoint, performNetworking)
> 
>     return cancellableToken
> }
> ```
> 
> }
> The sendUpload function would take an additional parameter representing a collection of each part of the multi-part upload, with those parts represented by the MultipartBodyPart struct. We could then have some helper function on the Manager that takes that collection and returns an Alamofire request.
> 
> public struct MultipartBodyPart {
> 
> ```
> public enum DataProvider {
>     case Data(NSData)
>     case File(NSURL)
>     case Stream(NSInputStream)
> }
> 
> public let name: String
> public let provider: DataProvider
> 
> // Additional stream parameters
> public let length: UInt64
> public let fileName: String
> public let mimeType: String
> ```
> 
> }
> 
> ```
> func sendUpload(target: Target, request: NSURLRequest, parts: [MultipartBodyPart], completion: Moya.Completion) -> CancellableToken {
>     guard let request = manager.uploadRequest(request, parts : parts) else {
>         var cancellableToken = CancellableWrapper()
>         cancellableToken.isCancelled = true
>         return cancellableToken.innerCancellable!
>     }
> 
>     return sendRequest(target, request: request, completion: completion)
> }
> ```
> 
> public extension Manager {
> 
> ```
> private func uploadRequest(request: NSURLRequest, parts: [MultipartBodyPart]) -> Request? {
> 
>     let formData = MultipartFormData()
> 
>     for part in parts {
>         switch part.provider {
>         case .Data(let data):
>             formData.appendBodyPart(data: data, name: part.name)
> 
>         case .File(let file):
>             formData.appendBodyPart(fileURL: file, name: part.name)
> 
>         case .Stream(let stream):
>             formData.appendBodyPart(stream: stream, length: part.length, name: part.name, fileName: part.fileName, mimeType: part.mimeType)
>         }
>     }
> 
>     do {
>         let data = try formData.encode()
>         return self.upload(request, data: data)
>     } catch {
>         return nil
>     }
> }
> ```
> 
> }
> ‚Äï
> Reply to this email directly or view it on GitHub.
 Yup that's about what I was imagining, and I wouldn't want those two endpoints either.

> On Nov 18, 2015, at 4:23 PM, David Warner notifications@github.com wrote:
> 
> @colinta pretty much any endpoints that could take optional data. I may not be completely understanding @GuidoHendriks solution, but I'd like to not have to write multiple enum cases for, say a "Create Account" request that may or may not take image data. Essentially, I want one "Create Account" endpoint to which I can optionally pass one or multiple NSData, NSURL, NSInputStream parameters.
> 
> Essentially, I'd like to avoid extraneous enum cases like this...
> 
> public enum API: MoyaTarget {
> 
> ```
> case CreateAccount(name: String, type: String, description: String)
> 
> case CreateAccountWithImageData(name: String, type: String, description: String, imageData : NSData)
> ```
> 
> }
> 
> extension API  {
> 
> ```
> public var requestType: RequestType {
>     switch self {
>     case .CreateAccount:
>         return .Request
> 
>     case .CreateAccountWithImageData:
>         return .Upload
>     }
> ```
> 
> }
> ‚Äï
> Reply to this email directly or view it on GitHub.
 Fixed in #483.
  Hmm. The only reason I can think of is that Moya hasn't been updated for Swift 1.2 yet, but Alamofire has. Suggestions? 
 Haha yeah. I should get on that ... I'll rename the issue. 
 Pretty busy for the next five or so days. Feel free to take a stab at it in the mean time ;)
 This is fixed as of https://github.com/ashfurrow/Moya/releases/tag/0.8.0 .
  This is a great idea! I think I'd prefer to have a closure as a parameter to the MoyaProvider initializer, or a variable property, that is called to begin/end. That way developers using something like [this](https://cocoapods.org/pods/BOTNetworkActivityIndicator) can provider their own implementations. Thoughts? 
 Hey @avgx! Is there anything I can do to help on this? 
 Cool, OK. The PR isn't _quite_ accurate, but I like the idea. Basically, you could have two network calls: A and B. A is slow, but B is fast. First we start A, then start B. B finishes quickly, but A is still running. However, since B finished, we set our `hasNetworkActivity` to `false`. 

I'm really interested in this ‚Äì I'll work on it today and let you know. 
 So I've got my idea up here: https://github.com/ashfurrow/Moya/pull/112 It still needs tests, but does that make sense? 
 Cool, I'm going to close this @avgx ‚Äì if I can help in any other way, or if the solution in #112 isn't sufficient for your needs, please let me know! 
  Hey, awesome! Thanks :) The CI is failing because Travis. Gonna merge!
  I'll create a new bump for ReactiveCocoa on CocoaPods trunk :)
 OK `3.0-alpha.3` is on Trunk. 
 I'll update the pod spec, then push. 
  Hey! These have been merged in. I updated the dependency on ReactiveCocoa on CocoaPods trunk. I don't have access to do so with Alamofire, our other dependency, so you need to have a Podfile that declares you're using their pre-release version _first_.

``` rb
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'xcode-6.3'
pod 'Moya', :git => 'https://github.com/ashfurrow/Moya.git', :branch => 'swift-1.2'

# Or, if you're using ReactiveCocoa extensions...
pod 'Moya/Reactive', :git => 'https://github.com/ashfurrow/Moya.git', :branch => 'swift-1.2'
```

I just tried that on a test project and it seemed :+1: so feel free to re-open this issue if you're still experiencing problems and we'll work through it!
 @te-chris Glad to hear that! As always, don't hesitate to open an issue if you have a question, if something doesn't work the way you expect it to based on the documentation, etc. 
  Wonderful ‚Äì at it's tested :heart_eyes_cat: 
  The ReactiveCocoa version requires a specific version of LlamaKit; you'll need to use the same version in your Podfile. 
 Ah, apologies. The README looks out of date. Only include the pod names and not their :git components. 
 I'll update the README soon. 
  Interesting! I think this comes down to a couple things:
- Do redirected responses contain a response body?
- Does Alamofire handle redirects transparently?

I believe the answer to the first question depends on your server/API. I don't know the answer to the second question. @kylef ?

Do you think having something like `filterSuccessfulStatusAndRedirectCodes` would be worth it? 
 Sounds good! 
  Cool! @kylef has a cool repo. Maybe we could use it, or even borrow ideas from it: https://github.com/kylef/WebLinking.swift
 Could use the [representor pattern](https://github.com/the-hypermedia-project/charter#representor-pattern) too. Some closure that can return a(n optional?) new endpoint based on the previous response. This kind of thing would be really easy with the ReactiveCocoa extension: the signal for the initial request could emit another signal for a follow-up or something. 
 This should be fixed [with this issue](https://github.com/ashfurrow/Moya/issues/74), which makes parameters like the ones you've discussed part of the target protocol. 
  we don't need to submit to the app store, as it's an internal tool, I believe that beta 2 should have fixed the issues around deployment to app store.
  @colinta Hey! Sorry I haven't reviewed this yet. I just moved from Amsterdam to New York and some things have fallen between the cracks. I'll get to it ASAP ‚Äì thanks for contributing!
 Looks great! Tests would be :+1: Let me know if I can help getting them running on your machine. 
 Hmm. To be honest, I'm _totally_ cool with breaking changes, so don't worry about it. We're versioning the library so people can update if/when they want to. 

I don't know if `@autoclosure` is going to work going forward. Swift 1.2 changes the semantics surrounding this construct such that these types of closures cant be stored for later ‚Äì they must be executed immediately (as far as I understand it). I think moving to a pure closure would be OK. 
 Oh, and `bundle exec pod install` or just `pod install` should fix the error with testing. 
 What folder are you running it from? 
 Try it in the `Demo` directory, where the Podfile is. 
 I think the first option, adding a new case to the enum, would be awesome. Avoiding `@autoclosure` seems to be a good idea for now. Let me know if I can help!
 @alloy? Only on Slack :) I've left Amsterdam, sadly. 
 Looks awesome! 
  Cool ‚Äì please feel free to open up another issue if you have any questions or want clarification on anything. 
  That's strange, it shouldn't complain at all. If you look in the unit tests, you'll find code like the following that works fine: 

``` swift
let target: GitHub = .Zen
provider.request(target, completion: { (data, statusCode, response, error) in
    if let data = data {
        // ...
    }
})
```

It's very strange that you're seeing this error, and I'd really appreciate your help in tracking down what's going on. The first thing I'd like you to do is make sure that you're on the latest version of Moya (since we've added a few parameters to the completion handler ‚Äì something also not added to the readme yet oops). Next, if you're still seeing the error, could I ask you to upload a sample project somewhere? One that demonstrates the error ‚Äì that way we can troubleshoot what's going on and get a fix for everyone. 

Thanks again for bringing this to my attention, and I'm sorry I couldn't answer earlier ‚Äì I was at a conference all weekend. 

Thanks! :beers:
 Sorry this took so long ‚Äì thanks again for your help! :bamboo: 
  Cool, looks great! I'll add a test to verify the app no longer crashes later, unless you send another PR before then :)

:beers: 
  I can see the value in making sure that the network code is run asynchronously, but tying your network callbacks to the assumption that they'll have a short, undetermined delay is probably not the best practice to be encouraging. 

So maybe not a delay, but some kind of mechanism to defer to the next invocation of the runloop? 
 Very good point ‚Äì I hadn't considered stubs much outside a testing context. This is a great idea. I'll look into it more. 
 Yeah, we stub responses based on a heuristic to check if you have access to the API or not. I can also see it being valuable in rapid application prototyping, where the API isn't ready or stable yet. Thinking of adding a(n optional?) property to the enum protocol that allows developers to specify a delay. Thoughts? 
 IMO cool, as long as 0 doesn't jump out of being synchronous 
 We can use an enum with associated values. Something like:

``` swft
enum StubBehavior {
    case .Immediate
    case .Delay(seconds: Int)
}
```
 :+1: 
  :+1: 
 Thanks @jspahrsummers !
 Not sure. Any suggestion, @jspahrsummers? 
  Awesome! Thanks so much, @steam!

The CI failure is not your fault ‚Äì I'll get it fixed up ASAP. Could you write a quick test or two on your end for the new NSData associated value? 
 Nah, not fixed yet, but this looks awesome! :beers:
  Hi there! Got your email too. I'll take a look as soon as I can. Happy holidays!
 Would strongly recommend taking a look at the [Eidolon](https://github.com/artsy/eidolon) source code to see if it has something that you're looking for.
 Hmm. Eidolon uses the default parameter encoding, so it won't be much help. I'm trying out your sample code now and I'll let you know what I find. 
 OK, I think I've got things working. First, the `URLRequestConvertible` actually belongs to Alamofire, so you need to have `import Alamofire` at the top of your file. This is a leaky abstraction on my part ‚Äì I'll open an issue.

OK, so now for some Swift stuff. The syntax surrounding closures as variables is ... not intuitive :smile: I played around with things until I got the following to work: 

``` swift
let xmlParameterEncoding: (URLRequestConvertible, [String: AnyObject]?) -> (NSURLRequest, NSError?) = { convertible, parameters -> (NSURLRequest, NSError?) in
    //this is just to get things working
    return (convertible.URLRequest, nil)
}

let closure = { (target: EyeQEndPoints, method: Moya.Method, parameters: [String: AnyObject]) -> Endpoint< EyeQEndPoints> in
    return Endpoint< EyeQEndPoints>(URL: url(target), sampleResponse: .Success(200, target.sampleData), method: method, parameters: parameters, parameterEncoding: Moya.ParameterEncoding.Custom(xmlParameterEncoding))
}

let abcd = MoyaProvider(endpointsClosure: closure )
```

A few important notes: the `xmlParameterEncoding` closure has the variables _names_, not types, after the `{`, and I had to fully qualify  the `.Custom` with `Moya.ParameterEncoding`, since Alamofire exposes an identical enum with the same name. 

But that should do it! Let me know if I can clarify anything. 
 Awesome! I'll close this. Feel free to reopen or open a new issue if you have other questions. 
  Hi there! Thanks for opening this. Can you clarify where this link is? I can't seem to find it. 
 Ah, gotcha. I will fix that. 

The two readme's serve different purposes ‚Äì the other one is only named a readme because GitHub will render it as markdown when looking at the "docs" folder. 
  This is likely an issue that CocoaPods is having with signing frameworks (the PR is [here](https://github.com/CocoaPods/CocoaPods/pull/2835)). CocoaPods with Swift support is still prerelease, remember. 

You've got essentially two options: try and update CocoaPods to see if the latest version will support deploying (I honestly don't know), or change to use Moya as a submodule for now (this is what I had to do about a week ago ‚Äì and it broke my heart a little). 

If you have questions regarding either option, let me know here and I'll do my best to answer them. 
 Could be related to https://github.com/CocoaPods/CocoaPods/pull/2873

We had to delay a deploy because of this, but that was before this PR, unsure how stable that is
 We created a branch from the commit just before we switched to CocoaPods and cherry-picked the commits we needed from after we switched. You can check out the branch here: https://github.com/artsy/eidolon/tree/si-deploy
 Should be done now. Please reopen if not. 
  I'll take a look tomorrow. 
 Or whenever. Soon, though. 
 Hard to get a feel of this from the PR ‚Äì can you high-level it for me? Does it still run all of the tests? 
 Why not have carthage run `pod install`?
 Hmmm. I obviously fall on one side of this, but I think it's important to look at this like a library author. If the author uses CocoaPods, then they'll probably support CocoaPods with their libraries. Likewise with Carthage or even (_shudders_) submodules. 

Me, I use CocoaPods for my apps, so when I need to use Moya, I need it available as a pod. 

@swizzlr Can you high-level this for me? What's the problem? CocoaPods just lists the files and the dependencies ‚Äì it doesn't require a project file. So if Carthage does, fine, let's include one or whatever it needs, but I want to run my demo app and unit testing project using CocoaPods. I thought the point of Carthage was that I could define my dependencies in a text file or something? If I have to still include submodules, then what's the point? 
 We found a solution from the CP side that allows us to generate a single xcodeproj that makes a framework, it would be a command that generates all the necessary files for people that prefer build artefacts. 

See https://github.com/CocoaPods/CocoaPods/issues/2885
 @swizzlr Hey t-swizzle ‚Äì any update on this? Dunno what to do with it. 
 Cooooool :palm_tree: 
  [This](https://github.com/neonichu/Rome) might help. 
 Cool! 

So Moya doesn't have Swift 1.2 support yet because I'm still stuck on Swift 1.1. A PR onto the `swift-1.2` branch would be :+1: 

As for Carthage, I'm amenable to Carthage support for Moya ‚Äì it's just been that no one has asked for it yet. Someone tried once but apparently it was really hard? I dunno. If you want to send a separate PR for that (onto `master`), that would also be welcome!

![](http://media.giphy.com/media/V2xbsCrxcLQSQ/giphy.gif)
 Hey @te-chris! A new issue would be very much appreciated. Thanks! 
 Awesome! I'm wary about having two different demo projects. Would it be possible to have two projects that point to the same .swift files? 
 Maybe even the different targets in the same project? 
 @neonichu / @kylefuller / @segiddins do we have something that can generate Cartfile.resolved from a Podfile.lock. I wouldn't expect the carthage team to build something similar, but is it something we can try? Looks simple enough.

I don't think having two complete projects is a smart idea, two repos is even worse. As reasonable project owners we will probably have to re-write our project to support Carthage. 
 Closing this in favour of the solution discussed [here](https://github.com/ashfurrow/Moya/pull/117). 
  Awesome ‚Äì figured that was the issue (I'm on vacation atm, otherwise I would've replied earlier). I'll change and let you know. 
 Thanks @ryancrosby !
 You should be good now. 
  Thanks! :beers: 
  Definitely the oops ‚Äì thanks! 
  I get a warning like:

```
NSForwarding: warning: object 0x7f8943920a10 of class 'Kiosk.MoyaResponse' does not implement methodSignatureForSelector: -- trouble ahead
Unrecognized selector
```
 `MoyaResponse` just needs to subclass NSObject so that RAC's `rac_description` category method is available on it. 
 To be honest, I've been really busy. I'd gladly merge a pull request, though. 
  This has been a painful process.

Basically I've burnt everything to the ground and started over. I also need to manage our dependencies manually because Xcode is too stupid to realize it can't build "ReactiveCocoa-OSX" on an iOS app. 

Intermittently failing for some other linker reason. Can't wait for CocoaPods. <edit>Now uses CocoaPods</edit>

Fixes #76.
 :green_apple: 
 This looks good to me. :+1: 
  From our use in [Eidolon](https://github.com/artsy/eidolon/), we almost always call `request` with the [`defaultParameters`](https://github.com/artsy/eidolon/blob/29cfd75f3a63ed2d320a87659953f7cd5071ecb4/Kiosk/App/Networking/ArtsyAPI.swift#L40-L114) we've defined on our target, since the target contains all the details necessary for the action, anyway. So why not codify that requirement? 

Thoughts anyone? 
 I had debated building a `provider.request(Identifier).get()` that does default parameters, successful status code and toJSON. Which is basically the same each time.
 So have `request` return something that has a `get` function on it, and delay the execution of the request until it's invoked? 
 I meant more like a shortcut for the request + `.filterSuccessfulStatusCodes().mapJSON()`
 So the default parameters will be merged with the ones provided by the caller, I think. That way API calls needing parameters only have to manage them once instead of every API call. This calculation should be as part of the target `enum`, just like the path. 

I think Orta's suggestion would make sense if we weren't making [HTTP methods part of the API](https://github.com/ashfurrow/Moya/issues/60).
  Very cool ‚Äì let me know if I can be of any assistance. My next big push on Moya is https://github.com/AshFurrow/Moya/issues/68 , so your experience with this might be helpful. 
 ( our API supports swagger, we definitely would like this ;) )
 I don't even know what swagger is ‚Äì so I'll check it out. 
 might not be that useful, perhaps this should be built into Paw as a plugin. 
http://luckymarmot.com/paw
 Any news on this?

This would be super awesome! I have thought about doing it myself, but never took a look at it.

The problem I see, is with JSON (de)serialization, because Swift does not have a good reflection system (as of 1.2 at least) to support a reflection library, so all must be done manually. If the generator takes care of that too, would be great. :)
 https://github.com/lkuczborski/SwiftMoyaCodeGenerator from @lkuczborski does some of this
 and for people who care about Swagger: https://github.com/luckymarmot/Paw-SwaggerImporter
 Delegating that responsibility to  @ashfurrow :u5408: 
 @lkuczborski I can take a look, want to point me to a PR or something? 
 Will try to take a look tomorrow and let you know :+1: 
 @lkuczborski Hey there! Apologies for the delay ‚Äì I've taken a look and it all seems :100: to me. Note: I am not an Paw extension expert :grimacing: But from a Moya perspective it all looks :+1: 
 Is there any more discussion/movement here or should we close this? Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Thanks! :beers:
  :+1:
  This was fixed here: https://github.com/ashfurrow/Moya/commit/abaf6cb0adaf
  Thanks! :beers:
  It is strictly for callers or subclasses, to avoid having an optional parameter. You can see it used [here](https://github.com/AshFurrow/Moya/blob/master/Moya%2BReactiveCocoa.swift#L97) in a subclass. 

It's not documented anywhere, though it should be, but the "Moya" way to do this is to define a `defaultParameters` property on the enum ([here](https://github.com/artsy/eidolon/blob/24d8ee07edb4daaa0b7e840a9ca751edebc1d99e/Kiosk/App/Networking/ArtsyAPI.swift#L37-L113) is an example), and then you have a few options. At Artsy, we explicitly pass in our own properties _or_ the default ones any time we make a request (see [this example](https://github.com/artsy/eidolon/blob/24d8ee07edb4daaa0b7e840a9ca751edebc1d99e/Kiosk/Bid%20Fulfillment/BidCheckingNetworkModel.swift#L98-L99)). Alternatively, in the `endpointsClosure` used when creating the `MoyaProvider`, your mapping can pass in the parameters:

``` swift
let endpointsClosure = { (target: ArtsyAPI, method: Moya.Method, parameters: [String: AnyObject]) -> Endpoint<ArtsyAPI> in
    let endpoint: Endpoint<ArtsyAPI> = Endpoint<ArtsyAPI>(URL: url(target), sampleResponse: .Success(200, target.sampleData), method: method, parameters: parameters)

    return endpoint.endpointByAddingParameters(target.defaultParameters)
    }
}

let provider = MoyaProvider(endpointsClosure: endpointsClosure)
```

You could even have an `endpointsClosure` that always used the default parameters unless the caller had included ones that overrode them, which is probably the best idea now that I think of it. Something to consider for the future. 

Does that answer your question?
 Agreed, I've opened https://github.com/AshFurrow/Moya/issues/68
 Just an update, I've written some documentation here: https://github.com/AshFurrow/Moya/pull/75

Also I've been thinking about making `defaultParameters` part of the target requirements. Would love input: https://github.com/AshFurrow/Moya/issues/74
  Hmm. Is it possible that the version of Alamofire is newer than the submodule in this repo? 
 OK, cool, well then it's on me to update our version. I'm pretty busy for the next day or so, so if you submitted a pull request, that would be welcome. Otherwise, I'll update it tomorrow. 
 That would be awesome! If you do, make a note of it in the changelog, too!
  right now a test suite doing some networking looks like:

``` swift
    beforeSuite { () -> () in
        // Force provider to stub responses
        APIKeys.sharedKeys = APIKeys(key: "", secret: "")
        Provider.sharedProvider = Provider.StubbingProvider()
    }

    afterSuite { () -> () in
        // Reset provider
        APIKeys.sharedKeys = APIKeys()
        Provider.sharedProvider = Provider.DefaultProvider()
    }

    it("returns some data") {
        setDefaultsKeys(nil, nil)

        var called = false
        XAppRequest(.Auctions).subscribeNext({ (object) -> Void in
            called = true
        })

        expect(called).to(beTruthy())
    }

    ... etc
```

This is fine, and it goes and access pre-rendered stubs etc. I'd like some choice, and to allow making something like this (excusing broken syntax):

``` swift
  let networkProvider = Provider.runtimeProvider()
  beforeSuite { () -> () in
      Provider.sharedProvider = networkProvider
  }

  afterSuite { () -> () in
      Provider.sharedProvider = Provider.DefaultProvider()
  }

  it("returns some data") {

      var called = false

      networkProvider.responseString(.Auctions) {
        return "{ 'foo':'bar' }"
      }

      XAppRequest(.Auctions).subscribeNext({ (object) -> Void in
          called = true
      })

      expect(called).to(beTruthy())
  }


```

with maybe the potential of returning strings, json objects and data?
 Ah, interesting. So to decouple the creation of the target from the stubbed responses. It kind of violates a bit of the functional-ness of everything, and the purpose really is so the SUTs have access to stubbed responses without being any the wiser. 

I can see a potentially better option with something like the following maybe? 

``` swift
// Inside an it closure
Provider.sharedProvider = networkProvider.responseString(.Auctions) { "{'foo': 'bar'}" }
```

The `responseString` method could return a wrapped `MoyaProvider` so that the original instance remains unmodified. You could even chain subsequent calls to `responseString` to re-stub multiple methods. Would that solve the issue, and further more, would this be a supplement to or a replacement of the existing stubbing methods? 
 yeah
 Well, for the 1.0 release, we moved `sampleData` to be a closure that returns data, so it could return different things on different invocations. I know it's not enough, but it might help, and might help figure out better ideas. 
 I'm thinking we'll have a new initializer that does two things: 
- accepts an argument of some kind of representation of new stubbing behaviour to be defined.
- sets a private/internal property ‚Äì something like a "parent provider" that, when performing requests, would call through to the parent if the request didn't meet the newly added stubbing behaviour. 

In this way, you could chain things together, and every request would start at the bottom and work its way up:

``` swift
let newProvider = provider.addStubbing(someRequest)
    .addStubbing(someOtherRequest)
    .addStubbing(someFinalRequest)
```

Or something like that. Does anyone have idea thoughts on this approach?
 I was thinking more like you would need to specify both a target _and_ an `EndpointSampleResponse` to accompany it. 

``` swift
let request = Api.Status
let response = EndpointSampleResponse.Success(200, { /* Some sample data here */ })
let newProvider = provider.addStubbedResponse(response, forRequest: request)
```

Or something to that effect. 
 I'm thinking that the stubbed responses would be used for any request matching that `Api` enum. This makes sense to me as a simple use case, which is what this would provide. 

It's already possible to create this behaviour using custom endpoint resolvers that are passed into the `MoyaProvider` initializer. What this feature would do, in my mind, would let you have a sort of shorthand for this where only one or two requests need to be stubbed differently, for a specific test case. 

Does that make sense? So something like you have would work-ish, but the behaviour would be more consistent with the default Moya stubbing behaviour. 
 Maybe this complicated test case would fit better as a separate test component. Even more integrated with Nimble as a matcher or something like that.

That way, we could have an implementation of this matcher as something that expects to be called in that particular order and when called respond with that particular stub response.

This is would work very much like RSpec, if anyone is acquainted to Ruby code:

``` ruby
it "should call 'bar' with appropriate arguments" do
  expect(subject).to receive(:bar).with("an argument I want")
  subject.foo
end
```
 Neat, I hadn't even considered marchers for Moya. I was only thinking of functional or view snapshot tests. The idea of testing that a request was made... hmm. Sounds useful, but is it something to encourage? 

Like, it's possible now for sure, but a bit of work. I can't think of many scenarios where testing that a request was made would be more ideal than testing the actions based on the network response. Does that make sense? Curious about the use case. 
 Yeah, I don't really have a use case for that. I just remembered of that when I saw @colinta's comment.

But something that generally annoys me when writing tests with stubbed requests is that we usually only test the response component of it. Not what we send to the request. With this mechanism we could have both.
 What do you guys think about revisiting this and how it might fit in with #881 ? Since there hasn't been any activity on this thread for some time, I am going to go ahead and close it. Please re-open or create a new issue if you would like to discuss further. Thanks.  Will do. 
  @powerje Awesome, looks great! I see you updated the sample app, too. My bad for letting it get out of date ‚Äì thanks! 

Could you add a line to the changelog specifying what was done and your GitHub username for credit? 

So maybe modify `failureEndpointsClosure` to return a 401 error code (or whatever), then add something like this to the MoyaProviderSpec:

``` swift
describe("a failing reactive provider") {
    var provider: ReactiveMoyaProvider<GitHub>!
    beforeEach {
        provider = ReactiveMoyaProvider(endpointsClosure: failureEndpointsClosure, stubResponses: true)
    }

    it("returns the HTTP status code as the error code") {
        var code: Int?

        provider.request(.Zen).subscribeError({ (error) -> Void in
            code = error.code
        })

        expect(code).toNot(beNil())
        expect(code).to(equal(401))
    }
}
```

Thanks again!
 @plasmaphonic hey there ‚Äì I've opened https://github.com/AshFurrow/Moya/issues/51 in order to help answer your question. 
 Bedankt!
 :+1: 
  Oops - thanks! 
  :+1:
  dank u!
  Ha, oops. Sorry about that! That image is sadly being removed anyway in #21, but it's good to merge. 
  Fixes #2.
 Yeah, I really like this. Merging. 
  So this is a tough one that I need to figure out an abstraction for. The basic gist is as follows: You set up a `MoyaProvider` with a bunch of endpoints. Cool, right? Except as of this moment, you access the API like this:

``` swift
let provider = MoyaProvider(endpoints: [
                    Endpoint(URL: "http://rdjpg.com/300/200/", sampleResponse: {
                        /* doesn't matter */
                    })
                ])

...

provider.request("http://rdjpg.com/300/200/", completion: { (object: AnyObject?) -> () in
    ...
})
```

Not cool ‚Äì let's avoid stringly-typedness in this library. 

Is there a way to provide a compile-time check that the endpoint actually exists? Can we set up some sort of enum or token or something that you pass in when you create the endpoint, and then reuse that token later on when calling the API? It needs to be something accessible by both whoever sets up the API at app launch, likely the app delegate, and anyone else who wants to access it (view controllers, network layers, whoever). 

It's tricky since I want a clear separation of this library and the app code. Since each app has a different API, this abstraction ‚Äì whatever it ends up being ‚Äì needs to be something defined in _app code_, but is used by the library. 

So I need a thing that someone using this library creates, uses to register the endpoint, then uses somewhere else in order to access the API. Any thoughts? 
 I have endpoints generated by the user of the library, another developer. The user of an app can't define any. 
 I really, realy dig these. We could even go further and abstract away the need for a URL string, which would decouple its 1-1 relationship with an endpoint. That way, you could provide a different URL depending on parameters, etc. I'll put together a pull request. 
 Cool. Take a look at #6 and let me know what you think. 
/n  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1249?src=pr&el=h1) Report
> Merging [#1249](https://codecov.io/gh/Moya/Moya/pull/1249?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/c29fb183ed917c5fb53e71260abe02ee32668a66?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1249/graphs/tree.svg?src=pr&token=CjZLHCNgNn&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1249?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           9.0.0-dev    #1249   +/-   ##
==========================================
  Coverage      81.59%   81.59%           
==========================================
  Files             24       24           
  Lines            766      766           
==========================================
  Hits             625      625           
  Misses           141      141
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1249?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Endpoint.swift](https://codecov.io/gh/Moya/Moya/pull/1249?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL0VuZHBvaW50LnN3aWZ0) | `92.3% <100%> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1249?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1249?src=pr&el=footer). Last update [c29fb18...fc9f89e](https://codecov.io/gh/Moya/Moya/pull/1249?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1248?src=pr&el=h1) Report
> :exclamation: No coverage uploaded for pull request base (`10.0.0-dev@a684307`). [Click here to learn what that means](https://docs.codecov.io/docs/error-reference#section-missing-base-commit).
> The diff coverage is `78.72%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1248/graphs/tree.svg?token=CjZLHCNgNn&width=650&height=150&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1248?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##             10.0.0-dev    #1248   +/-   ##
=============================================
  Coverage              ?   83.98%           
=============================================
  Files                 ?       24           
  Lines                 ?      768           
  Branches              ?        0           
=============================================
  Hits                  ?      645           
  Misses                ?      123           
  Partials              ?        0
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1248?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaError.swift](https://codecov.io/gh/Moya/Moya/pull/1248?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFFcnJvci5zd2lmdA==) | `28% <0%> (√∏)` | |
| [Sources/Moya/Plugins/NetworkActivityPlugin.swift](https://codecov.io/gh/Moya/Moya/pull/1248?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvTmV0d29ya0FjdGl2aXR5UGx1Z2luLnN3aWZ0) | `100% <100%> (√∏)` | |
| [Sources/Moya/MoyaProvider+Defaults.swift](https://codecov.io/gh/Moya/Moya/pull/1248?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitEZWZhdWx0cy5zd2lmdA==) | `76% <25%> (√∏)` | |
| [Sources/Moya/Endpoint.swift](https://codecov.io/gh/Moya/Moya/pull/1248?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL0VuZHBvaW50LnN3aWZ0) | `93.22% <97.05%> (√∏)` | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1248?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1248?src=pr&el=footer). Last update [a684307...42ecf86](https://codecov.io/gh/Moya/Moya/pull/1248?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Using Moya 9.0.0 Beta 1 version and since that, Moya will ignore and discard all parameters built in `TargetType` `task`. This is a breaking change, requiring to revert back to version 8.x.x, as it is useless for any API that requires parameters:

```
enum User {
    case register([String : Any])
    case ping
}

extension User : TargetType {
    var task: Task {
        switch self {
            case .register(let parameters):
                // All parameters here are ignored.
                return .requestParameters(parameters: parameters, encoding: JSONEncoding.default)
            default:
                return .requestPlain
        }
}
```

What is the solution for this? Exploring `MoyaProvider+Internal` shows that the only time Moya will call to `Task` type is at line 96:

```
switch target.task {
    case .requestPlain, .requestData, .requestParameters, .requestCompositeData, .requestCompositeParameters:
```

Since this task is a Swift Enum returning parameters, here they are completely ignored. I was unable to find any other code that would call to `.requestParameters` task type.

How to solve this?

 I created the `Endpoint` manually, and apparently with old API, this was not required, but with new the default task will always be `.requestPlain`. Might be a good idea to remove default parameter, since I just wasted 3 hours figuring this out, why it doesn't work. Since task is still called again from the internal code, it can quickly be confusing where this is applied. Issue can be closed. :) Sorry.  Xcode 8.3.3
ModelMapper (6.0.0)
Moya (8.0.5)
Moya-ModelMapper (4.1.1)
RxSwift (3.6.1)

mapObject throws error "jsonMapping(Status Code: 200, Data Length: 296)" it looks like struct initializer is not getting called.


```swift
import Mapper

struct User: Mappable {
    let birth: String
    let id: String
    let photo: String?
    let email: String
    let token: String
    let gender: String

    init (map: Mapper) throws {
        
        try birth = map.from("birth")
        try id = map.from("id")
        photo = map.optionalFrom("photo")
        try email = map.from("email")
        try token = map.from("token")
        try gender = map.from("gender")
    }
}
```

```swift
func registerRequest(email: String, password: String, birthTimeStamp: UInt, isMale: Bool) -> Observable<User> {
        return provider!.request(.signUp(email: email, password: password, birthTimeStamp: birthTimeStamp, isMale: isMale)).filterSuccessfulStatusCodes().mapObject(type:User.self)
    }
```

Example Json:

```json
{
	"id": "D46A4CE2-BD5C-C77F-FF39-AF62292BF200",
	"birth": "527644800000",
	"gender": "male",
	"photo": null,
	"photo_width": "0",
	"photo_height": "0",
	"email": "atesta10029@gmail.com",
	"name": "atesta10029@gmail.com",
	"token": "88E7D4C1-B08B-0B76-FFA7-395627AC8000"
}
```  <!--
  0 Errors
  0 Warnings
  0 Messages
  1 Markdown
-->

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 950 | File should contain 400 lines or less: currently contains 950 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 7 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 571 lines 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1243?src=pr&el=h1) Report
> Merging [#1243](https://codecov.io/gh/Moya/Moya/pull/1243?src=pr&el=desc) into [10.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/a69db1df6a5e92ea3d721fa27e2f19bb30ffca03?src=pr&el=desc) will **increase** coverage by `1.98%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1243/graphs/tree.svg?width=650&height=150&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1243?src=pr&el=tree)

```diff
@@              Coverage Diff               @@
##           10.0.0-dev    #1243      +/-   ##
==============================================
+ Coverage          83%   84.98%   +1.98%     
==============================================
  Files              24       24              
  Lines             753      766      +13     
==============================================
+ Hits              625      651      +26     
+ Misses            128      115      -13
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1243?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/1243?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `83.1% <0%> (+1.42%)` | :arrow_up: |
| [Sources/Moya/MultipartFormData.swift](https://codecov.io/gh/Moya/Moya/pull/1243?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL011bHRpcGFydEZvcm1EYXRhLnN3aWZ0) | `100% <0%> (+75%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1243?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1243?src=pr&el=footer). Last update [a69db1d...bb054a0](https://codecov.io/gh/Moya/Moya/pull/1243?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  <!--
  0 Errors
  0 Warnings
  0 Messages
  1 Markdown
-->

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 910 | File should contain 400 lines or less: currently contains 910 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 7 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 543 lines 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1242?src=pr&el=h1) Report
> Merging [#1242](https://codecov.io/gh/Moya/Moya/pull/1242?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/9a17935bbfafb49c44d854cc3034e321c49f76a5?src=pr&el=desc) will **increase** coverage by `1.41%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1242/graphs/tree.svg?width=650&token=CjZLHCNgNn&height=150&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1242?src=pr&el=tree)

```diff
@@             Coverage Diff              @@
##           9.0.0-dev   #1242      +/-   ##
============================================
+ Coverage      78.58%     80%   +1.41%     
============================================
  Files             24      24              
  Lines            775     775              
============================================
+ Hits             609     620      +11     
+ Misses           166     155      -11
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1242?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/1242?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `72.24% <0%> (+4.84%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1242?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1242?src=pr&el=footer). Last update [9a17935...90bc22f](https://codecov.io/gh/Moya/Moya/pull/1242?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1241?src=pr&el=h1) Report
> Merging [#1241](https://codecov.io/gh/Moya/Moya/pull/1241?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/9a17935bbfafb49c44d854cc3034e321c49f76a5?src=pr&el=desc) will **increase** coverage by `1.78%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1241/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1241?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1241      +/-   ##
=============================================
+ Coverage      78.58%   80.36%   +1.78%     
=============================================
  Files             24       24              
  Lines            775      774       -1     
=============================================
+ Hits             609      622      +13     
+ Misses           166      152      -14
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1241?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/RxMoya/Single+Response.swift](https://codecov.io/gh/Moya/Moya/pull/1241?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvU2luZ2xlK1Jlc3BvbnNlLnN3aWZ0) | `100% <√∏> (√∏)` | :arrow_up: |
| [Sources/Moya/Endpoint.swift](https://codecov.io/gh/Moya/Moya/pull/1241?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL0VuZHBvaW50LnN3aWZ0) | `92.3% <100%> (+26.26%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1241?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1241?src=pr&el=footer). Last update [9a17935...e58d0d7](https://codecov.io/gh/Moya/Moya/pull/1241?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 <!--
  0 Errors
  2 Warnings: Consider adding supporting doc...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The <code>Cartfile</code> or <code>Cartfile.resolved</code> was updated, but there were no changes in the <code>podspec</code>. Did you forget updating the <code>podspec</code>?</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
     <!--
  0 Errors
  1 Warning: Consider adding supporting doc...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProvider+Internal.swift | 212 | Function should have complexity 10 or less: currently complexity equals 14 
MoyaProvider+Internal.swift | 94 | Function should have 5 parameters or less: it currently has 7 
MoyaProviderSpec.swift | 737 | Opening braces should be preceded by a single space and on the same line as the declaration. 
MoyaProviderSpec.swift | 769 | Opening braces should be preceded by a single space and on the same line as the declaration. 
MoyaProviderSpec.swift | 868 | File should contain 400 lines or less: currently contains 868 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 7 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 516 lines 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
  Hello,

This is my first open source contribution. 
Hope I have done this right.

With reference to #1210.

Thanks I think the issue #1208 was with the dependency of ReactiveSwift. The user was enforcing a lower version.

I am not sure what addition @BasThomas wanted. Thank you for your support everyone! Looking forward to contribute :)  The problem ocurs on version 8.0.5 and 9.0.0-alpha1

```swift

    var headers: [String : String]? {
        
        return ["Content-Type": "image/jpeg"]
    }

    var task: Task {
        
        switch self {
        case .image( let image), .profileImage(let image):
            
            guard let reducedImage = UIImageJPEGRepresentation(image, 0.2) else {
                fatalError("Cant parse to data")
            }
            
            let multipart = MultipartFormData.init(provider: .data(reducedImage), name: "image", fileName: "image.jpeg", mimeType: "image/jpeg")
            
            let list = [multipart]
            return .upload(.multipart(list))
        }
    }
```

when i make the request the content-type changes to multipart/form-data, i have tried to use endpointClousre, but always have the same result the content-type changes to multipart/form-data  <!--
  0 Errors
  1 Warning: Consider adding supporting doc...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProvider+Internal.swift | 94 | Function should have 5 parameters or less: it currently has 7 
MoyaProviderSpec.swift | 862 | File should contain 400 lines or less: currently contains 862 
TestHelpers.swift | 3 | Limit vertical whitespace to a single empty line. Currently 2. 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 7 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 510 lines 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1234?src=pr&el=h1) Report
> Merging [#1234](https://codecov.io/gh/Moya/Moya/pull/1234?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/486a9339f242c22e3cb23c7aa30c5678cdfb7858?src=pr&el=desc) will **increase** coverage by `0.08%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1234/graphs/tree.svg?width=650&height=150&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1234?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1234      +/-   ##
=============================================
+ Coverage      79.16%   79.24%   +0.08%     
=============================================
  Files             24       24              
  Lines            763      766       +3     
=============================================
+ Hits             604      607       +3     
  Misses           159      159
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1234?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/1234?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `67.88% <100%> (+0.44%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1234?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1234?src=pr&el=footer). Last update [486a933...0e1b13e](https://codecov.io/gh/Moya/Moya/pull/1234?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  I am using the following pods.  How to make RxSwift and Moya go hand in hand in Swift 4 ?


```swift
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'swift4.0'
pod 'RxCocoa', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'swift4.0'
pod 'Moya/RxSwift', :git => 'https://github.com/Moya/Moya.git', :branch => '9.0.0-dev'
```

[!] Unable to satisfy the following requirements:

- `RxSwift (from `https://github.com/ReactiveX/RxSwift.git`, branch `swift4.0`)` required by `Podfile`
- `RxSwift (= 4.0.0-alpha.1)` required by `Podfile.lock`
- `RxSwift (~> 4.0.0-alpha.1)` required by `RxCocoa (4.0.0-alpha.1)`
- `RxSwift (= 1.4)` required by `Moya/RxSwift (1.1.0)`

  <!--
  0 Errors
  2 Warnings: Any changes to library code sh...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 768 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 770 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 774 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 780 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 787 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 790 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 892 | File should contain 400 lines or less: currently contains 892 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 7 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 530 lines 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->

Hello, great library you have here! I have created a Target that uses a POST and JSON Encoding:

```swift
...
    var method: Moya.Method {
        switch self {
        case .create:
            return .post
        }
    }

    var parameters: [String: Any]? {
        switch self {
        case .create(_, _, let message):
            var params: [String: Any] = [
                "message": message
            ]

            return params
        }
    }
    
    var parameterEncoding: ParameterEncoding {
        switch self {
        case .create:
            return JSONEncoding.default
        }
    }
...
```

When I submit a request using this, it sends the HTTP headers as ```application/x-www-form-urlencoded``` and not as ```application/json```. This appears like a bug to me, but it may be my ignorance as well...

Thank you for reading!

EDIT: Could it be because I am using an endpointClosure for my authentication token?

```swift
    static func endpointsClosure<T>() -> (T) -> Endpoint<T> where T: TargetType {
        return { target in
            var endpoint: Endpoint<T> = Endpoint<T>(url: URL(target: target).absoluteString, sampleResponseClosure: { .networkResponse(200, target.sampleData) }, method: target.method, parameters: target.parameters)

            if let accessToken = Session.instance.mToken?.accessToken {
                endpoint = endpoint.adding(newHTTPHeaderFields: ["Authorization": "Bearer \(accessToken)"])
            }

            return endpoint
        }
    }
``` After much hassle in google, I realized my endpointsClosure has to correctly create the endpoint via the default endpoint function on the RxMoyaProvider class and then add headers to it. My previous solution was essentially ignoring what Moya would have set as a default by not using that method.

```swift
let endpointsClosure = { (target: Target) -> Endpoint<Target> in
        var endpoint = AuthenticatedAPIProvider.defaultEndpointMapping(for: target)

        if let accessToken = Session.instance.mToken?.accessToken {
            endpoint = endpoint.adding(newHTTPHeaderFields: ["Authorization": "Bearer \(accessToken)"])
        }

        return endpoint
    }
```  <!--
  0 Errors
  0 Warnings
  0 Messages
  1 Markdown
-->

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
TestHelpers.swift | 3 | Limit vertical whitespace to a single empty line. Currently 2. 
Single+MoyaSpec.swift | 258 | Lines should not have trailing whitespace. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1229?src=pr&el=h1) Report
> Merging [#1229](https://codecov.io/gh/Moya/Moya/pull/1229?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/c5cb8f65840019fd84692d1c828e1313158a614d?src=pr&el=desc) will **increase** coverage by `2.75%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1229/graphs/tree.svg?src=pr&token=CjZLHCNgNn&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1229?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1229      +/-   ##
=============================================
+ Coverage       76.4%   79.16%   +2.75%     
=============================================
  Files             24       24              
  Lines            763      763              
=============================================
+ Hits             583      604      +21     
+ Misses           180      159      -21
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1229?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/RxMoya/Single+Response.swift](https://codecov.io/gh/Moya/Moya/pull/1229?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvU2luZ2xlK1Jlc3BvbnNlLnN3aWZ0) | `100% <0%> (+100%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1229?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1229?src=pr&el=footer). Last update [c5cb8f6...96479a2](https://codecov.io/gh/Moya/Moya/pull/1229?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  this my project crash

```swift
(9938, 102186, '2017-08-06 08:11:28', 'Incident Identifier: XXX
CrashReporter Key: 
Hardware Model:      iPhone7,1
Process:         XXX
Path:            XXX
Identifier:      XXX
Version:         XXX
Code Type:       ARM-64
Parent Process:  ? [1]

Date/Time:       2017-03-31 17:07:45.000 +0800
OS Version:      iOS 10.0.2 (14A456)
Report Version:  104

Exception Type:  EXC_BREAKPOINT (5)
Exception Codes: 0x00000000 at 0x00000001000a8734
Crashed Thread:  0

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   bitpie                          0x00000001000a8734 0x100014000 + 608052
1   bitpie                          0x00000001000a8584 0x100014000 + 607620
2   bitpie                          0x00000001000a553c 0x100014000 + 595260
3   Moya                            0x0000000100b2997c 0x100b14000 + 88444 (MoyaProvider.requestNormal(A, queue : DispatchQueue?, progress : (ProgressResponse) -> ()?, completion : (Result<Response, Error>) -> ()) -> Cancellable + 2604)
4   Moya                            0x0000000100b2b878 0x100b14000 + 96376 (MoyaProvider.cancelCompletion((Result<Response, Error>) -> (), target : A) -> () + 2832)
5   Moya                            0x0000000100b2f0c8 0x100b14000 + 110792 (MoyaProvider.notifyPluginsOfImpendingStub(for : URLRequest, target : A) -> () + 11764)
6   Moya                            0x0000000100b2deec 0x100b14000 + 106220 (MoyaProvider.notifyPluginsOfImpendingStub(for : URLRequest, target : A) -> () + 7192)
7   Moya                            0x0000000100b2f40c 0x100b14000 + 111628 (MoyaProvider.notifyPluginsOfImpendingStub(for : URLRequest, target : A) -> () + 12600)
8   Moya                            0x0000000100b26718 0x100b14000 + 75544 (protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance CancellableToken + 248)
9   Alamofire                       0x00000001008874d4 0x100844000 + 275668 (DownloadRequest.responsePropertyList(queue : DispatchQueue?, options : PropertyListSerialization.MutabilityOptions, completionHandler : (DownloadResponse<Any>) -> ()) -> Self + 2480)
10  Alamofire                       0x000000010088ae34 0x100844000 + 290356 (type metadata accessor for DownloadResponseSerializer + 2892)
11  libdispatch.dylib               0x0000000186c65200 0x186c64000 + 4608 (<redacted> + 24)
12  libdispatch.dylib               0x0000000186c651c0 0x186c64000 + 4544 (<redacted> + 16)
13  libdispatch.dylib               0x0000000186c69d6c 0x186c64000 + 23916 (_dispatch_main_queue_callback_4CF + 1000)
14  CoreFoundation                  0x0000000187d89f2c 0x187cad000 + 905004 (<redacted> + 12)
15  CoreFoundation                  0x0000000187d87b18 0x187cad000 + 895768 (<redacted> + 1660)
16  CoreFoundation                  0x0000000187cb6048 0x187cad000 + 36936 (CFRunLoopRunSpecific + 444)
17  GraphicsServices                0x0000000189739198 0x18972d000 + 49560 (GSEventRunModal + 180)
18  UIKit                           0x000000018dc90628 0x18dc15000 + 505384 (<redacted> + 684)
19  UIKit                           0x000000018dc8b360 0x18dc15000 + 484192 (UIApplicationMain + 208)
20  bitpie                          0x000000010004d550 0x100014000 + 234832
21  libdyld.dylib                   0x0000000186c985b8 0x186c94000 + 17848 (<redacted> + 4)

Thread 1:
0   libsystem_kernel.dylib          0x0000000186daaa88 0x186d8b000 + 129672 (__workq_kernreturn + 8)
1   libsystem_pthread.dylib         0x0000000186e6d36c 0x186e6c000 + 4972 (_pthread_wqthread + 1452)

Thread 2:
0   libsystem_kernel.dylib          0x0000000186daaa88 0x186d8b000 + 129672 (__workq_kernreturn + 8)
1   libsystem_pthread.dylib         0x0000000186e6d36c 0x186e6c000 + 4972 (_pthread_wqthread + 1452)

Thread 3:
0   libsystem_kernel.dylib          0x0000000186daaa88 0x186d8b000 + 129672 (__workq_kernreturn + 8)
1   libsystem_pthread.dylib         0x0000000186e6d188 0x186e6c000 + 4488 (_pthread_wqthread + 968)

Thread 4 name:  com.apple.uikit.eventfetch-thread
Thread 4:
0   libsystem_kernel.dylib          0x0000000186d8c16c 0x186d8b000 + 4460 (mach_msg_trap + 8)
1   libsystem_kernel.dylib          0x0000000186d8bfdc 0x186d8b000 + 4060 (mach_msg + 72)
2   CoreFoundation                  0x0000000187d89cec 0x187cad000 + 904428 (<redacted> + 192)
3   CoreFoundation                  0x0000000187d87908 0x187cad000 + 895240 (<redacted> + 1132)
4   CoreFoundation                  0x0000000187cb6048 0x187cad000 + 36936 (CFRunLoopRunSpecific + 444)
5   Foundation                      0x00000001887c4b1c 0x1887b8000 + 51996 (<redacted> + 304)
6   Foundation                      0x00000001887e560c 0x1887b8000 + 185868 (<redacted> + 96)
7   UIKit                           0x000000018e605c7c 0x18dc15000 + 10423420 (<redacted> + 136)
8   Foundation                      0x00000001888c250c 0x1887b8000 + 1090828 (<redacted> + 1024)
9   libsystem_pthread.dylib         0x0000000186e6f860 0x186e6c000 + 14432 (<redacted> + 240)
10  libsystem_pthread.dylib         0x0000000186e6f770 0x186e6c000 + 14192 (_pthread_start + 284)

Thread 5 name:  com.apple.NSURLConnectionLoader
Thread 5:
0   libsystem_kernel.dylib          0x0000000186d8c16c 0x186d8b000 + 4460 (mach_msg_trap + 8)
1   libsystem_kernel.dylib          0x0000000186d8bfdc 0x186d8b000 + 4060 (mach_msg + 72)
2   CoreFoundation                  0x0000000187d89cec 0x187cad000 + 904428 (<redacted> + 192)
3   CoreFoundation                  0x0000000187d87908 0x187cad000 + 895240 (<redacted> + 1132)
4   CoreFoundation                  0x0000000187cb6048 0x187cad000 + 36936 (CFRunLoopRunSpecific + 444)
5   CFNetwork                       0x00000001884a3cec 0x1883d7000 + 838892 (<redacted> + 336)
6   Foundation                      0x00000001888c250c 0x1887b8000 + 1090828 (<redacted> + 1024)
7   libsystem_pthread.dylib         0x0000000186e6f860 0x186e6c000 + 14432 (<redacted> + 240)
8   libsystem_pthread.dylib         0x0000000186e6f770 0x186e6c000 + 14192 (_pthread_start + 284)

Thread 6:
0   libsystem_kernel.dylib          0x0000000186daa314 0x186d8b000 + 127764 (__semwait_signal + 8)
1   libsystem_c.dylib               0x0000000186cc827c 0x186cbb000 + 53884 (nanosleep + 212)
2   libsystem_c.dylib               0x0000000186d32290 0x186cbb000 + 488080 (sleep + 44)
3   KSCrash                         0x0000000100a481bc 0x100a2c000 + 115132 (ksccd_init + 828)
4   libsystem_pthread.dylib         0x0000000186e6f860 0x186e6c000 + 14432 (<redacted> + 240)
5   libsystem_pthread.dylib         0x0000000186e6f770 0x186e6c000 + 14192 (_pthread_start + 284)

Thread 7 name:  KSCrash Exception Handler (Secondary)
Thread 7:
0   libsystem_kernel.dylib          0x0000000186d8c16c 0x186d8b000 + 4460 (mach_msg_trap + 8)
1   libsystem_kernel.dylib          0x0000000186d8bfdc 0x186d8b000 + 4060 (mach_msg + 72)
2   KSCrash                         0x0000000100a4fa3c 0x100a2c000 + 145980 (kscm_machexception_getAPI + 1032)
3   libsystem_pthread.dylib         0x0000000186e6f860 0x186e6c000 + 14432 (<redacted> + 240)
4   libsystem_pthread.dylib         0x0000000186e6f770 0x186e6c000 + 14192 (_pthread_start + 284)

Thread 8 name:  KSCrash Exception Handler (Primary)
Thread 8:

Thread 0 crashed with ARM-64 Thread State:
  cpsr: 0x0000000020000000     fp: 0x000000016fdea460     lr: 0x00000001000a8584     pc: 0x00000001000a8734 
    sp: 0x000000016fdea220     x0: 0x00000001012ac180     x1: 0x00000001708766c0    x10: 0x0000000000000001 
   x11: 0xbaddc0dedeadbead    x12: 0x0000000000000000    x13: 0x00000001744652b0    x14: 0x0000000000000002 
   x15: 0xffffffffffffffff    x16: 0x0000000186de06c8    x17: 0x0000000187cd55a0    x18: 0x0000000000000000 
   x19: 0x0000000000000000     x2: 0x0000000000000008    x20: 0x0000000174434370    x21: 0x00000001708766c0 
   x22: 0x0000000100614b28    x23: 0x000000010055ba20    x24: 0x0000000000000000    x25: 0x0000000000000000 
   x26: 0x0000000000000000    x27: 0x0000000100ee8c80    x28: 0x000000017044ef70    x29: 0x000000016fdea460 
    x3: 0x0000000186df0250     x4: 0x0000000100e5caa4     x5: 0x0000000000000020     x6: 0x000000000000000a 
    x7: 0x0000000000000000     x8: 0x0000000170461f40     x9: 0x0000000170461f40 

Binary Images:

Extra Information:

Stack Dump (0x000000016fdea1d0-0x000000016fdea2c0):

00000000000000000000000000000000000000000000000020BA550001000000284B610001000000C0668770010000007043437401000000000000000000000060A4DE6F0100000084850A0001000000A3A3A3A3A3A3A3A3A1A1A1A10000000076006A20516DF72D206DC4AC0100000000002F010100000000000000000000004067877001000000006787700100000000000000000000000000000000000000000000000000000001C0C4AC0100000000002F010100000000002F0101000000F0A2DE6F01000000D883D4870100000000A3DE6F01000000D883D4870100000076006A20516DF72DB8DBC4AC01000000

Notable Addresses:
{
    \"stack@0x16fdea220\": {
        \"address\": -6655295901103053917,
        \"class\": \"NSString\",
        \"type\": \"objc_object\",
        \"value\": \":::\"
    },
    \"x11\": {
        \"address\": -4981613549350699347,
        \"class\": \"NSNumber\",
        \"type\": \"objc_object\",
        \"value\": -2.31205e+16
    }
}

Application Stats:
{
    \"active_time_since_last_crash\": 0,
    \"active_time_since_launch\": 0,
    \"application_active\": false,
    \"application_in_foreground\": true,
    \"background_time_since_last_crash\": 0,
    \"background_time_since_launch\": 0,
    \"launches_since_last_crash\": 146,
    \"sessions_since_last_crash\": 146,
    \"sessions_since_launch\": 1
}')
```

i don't know why crashÔºåhope your help„ÄÇ
 sorry,the development process did not encounter such a crash.the new company wants me to fix the crash in the crash,which is part of it. i'm sorry, i didn't make it clear.Our project will collect crash information for centralized processing, which is one of the crash logs.i don't know whether it is a crash in the debugging process or a crash that occurs during the customer's use.so i didn't have the console output.now to check the information about the breakpoint, trouble you thank you.  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1225?src=pr&el=h1) Report
> Merging [#1225](https://codecov.io/gh/Moya/Moya/pull/1225?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/f2787a29c54544cd079345c02dd002990e940863?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1225/graphs/tree.svg?height=150&width=650&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1225?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           9.0.0-dev    #1225   +/-   ##
==========================================
  Coverage      76.25%   76.25%           
==========================================
  Files             24       24           
  Lines            758      758           
==========================================
  Hits             578      578           
  Misses           180      180
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1225?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1225?src=pr&el=footer). Last update [f2787a2...1af4117](https://codecov.io/gh/Moya/Moya/pull/1225?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  <!--
  0 Errors
  2 Warnings: Any changes to library code sh...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The library files were changed, but the tests remained unmodified. Consider updating or adding to the tests to match the library changes.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1224?src=pr&el=h1) Report
> Merging [#1224](https://codecov.io/gh/Moya/Moya/pull/1224?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/f2787a29c54544cd079345c02dd002990e940863?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1224/graphs/tree.svg?token=CjZLHCNgNn&src=pr&height=150&width=650)](https://codecov.io/gh/Moya/Moya/pull/1224?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           9.0.0-dev    #1224   +/-   ##
==========================================
  Coverage      76.25%   76.25%           
==========================================
  Files             24       24           
  Lines            758      758           
==========================================
  Hits             578      578           
  Misses           180      180
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1224?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [...ources/ReactiveMoya/ReactiveMoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/pull/1224?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVNb3lhQXZhaWxhYmlsaXR5LnN3aWZ0) | `65.38% <√∏> (√∏)` | :arrow_up: |
| [Sources/RxMoya/RxMoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/pull/1224?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhQXZhaWxhYmlsaXR5LnN3aWZ0) | `0% <√∏> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1224?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1224?src=pr&el=footer). Last update [f2787a2...9fb12a5](https://codecov.io/gh/Moya/Moya/pull/1224?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Hi I have just jumped on-board to Moya. I've checked out the basic walkthrough and have set up my API swift file.

I noticed that the failure case doesn't handle all errors.

What is your recommended approach to handling more error status code from my server (ie. 400, 401, 403, 404, 500)?

P.S. Sample project would be wonderful!

Hope to learn and contribute! 
Thanks. Hi @SD10 ,

Thank you for your reply!

The following was what I was looking for:
```swift
do {
    try moyaResponse.filterSuccessfulStatusCodes()
    let data = try moyaResponse.mapJSON()
}
catch {
    // show an error to your user
}
```

I am not sure about the recommended approach for error catching in this case. 
I want to print out the error description but the error object doesn't contain an error description property.

I.e:
Error = 401
Error Description = "Unauthorized ‚Äì You are not authorized to this action"

My server returns me something like this which falls into the error in the catch:
```json
{
    "errors": [
        {
            "status": 401,
            "title": "A confirmation email was sent to your account at '%{email}'. You must follow the instructions in the email before your account can be activated",
            "detail": "",
            "source": ""
        }
    ]
}
```

Any recommended approach for printing out error description would be great!
Thanks.

 @AndrewSB Thanks for your response!
However, it isn't exactly what I was looking for.

The problem I am facing from using:
```swift
do {
    try moyaResponse.filterSuccessfulStatusCodes()
    let data = try moyaResponse.mapJSON()
    print(data)
} catch {
    print(error)
}
```
Is that the error caught does not contain the error description.

The catching of the `error` prints something like this:
`statusCode(Status Code: 401, Data Length: 106)`

I then try to retrieve the JSON from `moyaResponse.data`.

However, it only gave me:
`statusCode(Status Code: 401, Data Length: 106)`

When I was expecting the following to return (from testing with Postman):
```json
{
    "errors": [
        {
            "status": 401,
            "title": "A confirmation email was sent to your account at '%{email}'. You must follow the instructions in the email before your account can be activated",
            "detail": "",
            "source": ""
        }
    ]
}
```

This way, I can get the error message from the title key and do something with it.

Basically, I want is to get the JSON to get the error message.
 UPDATE
Turned out this was what I was looking for:

```swift
switch result {
case let .success(moyaResponse):
    do {
        try moyaResponse.filterSuccessfulStatusCodes()
        let data = try moyaResponse.mapJSON()
    } catch {
        if let error = error as? MoyaError {
            do {
                let body = try error.response?.mapJSON()
            } catch {
                print(error)
            }
        }
    }
case let .failure(error):
    // TODO: handle the error == best. comment. ever.
    break
}
```

It isn't the cleanest, but the body was what I was looking for :)
Thank you @SD10  and @AndrewSB for your help!  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 pod 'Moya/RxSwift' 
![8142ed46-50f2-46b4-b758-c5a629efb9d0](https://user-images.githubusercontent.com/6631373/29357841-8ed16d48-82ab-11e7-8f20-31197c7347cd.png)
 I won't specify the 'moya/rxswift' version. pod 'Moya/Moya', :git => 'https://github.com/Moya/Moya.git', :branch => '9.0.0-dev'
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'swift4.0'
Can do it.   ÔºöÔºâthank you.  <!--
  0 Errors
  2 Warnings: Any changes to library code sh...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The library files were changed, but the tests remained unmodified. Consider updating or adding to the tests to match the library changes.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
  Hi @sunshinejr, I happen to need an example of this quite badly. Is there any example out there that you've seen which can help?

If yes, that would be awesome!  I can confirm that it works. Thank you for the quick fix @sunshinejr! # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1218?src=pr&el=h1) Report
> Merging [#1218](https://codecov.io/gh/Moya/Moya/pull/1218?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/0c25037dcf2a4213124fe0a423656b14ee0209d4?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1218/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1218?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           9.0.0-dev    #1218   +/-   ##
==========================================
  Coverage      76.31%   76.31%           
==========================================
  Files             24       24           
  Lines            760      760           
==========================================
  Hits             580      580           
  Misses           180      180
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1218?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1218?src=pr&el=footer). Last update [0c25037...b012d8a](https://codecov.io/gh/Moya/Moya/pull/1218?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  I've just tested again. When I put `github "Moya/Moya" "9.0.0-dev"` into my Cartfile, run `carthage update` and run the app, I get the error.

Once I replace it with `github "Moya/Moya" "4bcac8144fd438b9b93c2a9907a8581dfd899278"` (which is the commit right before #1212 and #1213 were merged), run `carthage update` and run the app it works correctly. So the issue must have been introduced either with #1212 or with #1213. Maybe the new file `Single+Response.swift` accidentally got into the Moya main target? Cause it has an `import RxSwift` which looks like the source for the error. I checked, it works. Thank you @sunshinejr! üéâ   I want to use a custom response when comming from UITests for a specific path.
So basically, when calling a path like "endPointThatShouldReturnAStub404" i want to return 404 and a sampleResponse. Otherwise i want to return regular stubs as you can see here (``` MoyaProvider<ApiProvider>(stubClosure: MoyaProvider.immediatelyStub) ```).
So when im passing an argument "CUSTOM_STUB" i want to stub reponses depending on the target.path. How can i do this?

```swift
    static func setProvider() -> MoyaProvider<ApiProvider> {
        var provider: MoyaProvider<TWApiProvider> = MoyaProvider<ApiProvider>(stubClosure: MoyaProvider.immediatelyStub)
        if ProcessInfo().arguments.contains("CUSTOM_STUB") {
            let endpointClosure = { (target: ApiProvider) -> Endpoint<ApiProvider> in
                switch target.path {
                case "endPointThatShouldReturnAStub404":
                    return Endpoint<ApiProvider>(url: url(route: target), sampleResponseClosure: {.networkResponse(404, target.sampleData)}, method: target.method, parameters: target.parameters)
                default:  ///endPointThatShouldReturnARegularStub
                    return Endpoint<ApiProvider>(url: url(route: target), sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
                }
            }
  //  **The problem is here cause im adding a default endpointClosure**
            provider = MoyaProvider<TWApiProvider>(endpointClosure: endpointClosure)
        }
        return provider
    }
```
 Not exactly. 
I want also for the default case continue stubbing. And for "endPointThatShouldReturnAStub404" return a custom stub.

So imagine this situation, you have all your endpoints stubbed and no other requeriment.
You can have something like: ```var provider: MoyaProvider<TWApiProvider> = MoyaProvider<ApiProvider>(stubClosure: MoyaProvider.immediatelyStub) ```
This is ok since stubs all your requests with a 200 with a json from sampleData.
Now imagine you want to do a test for a specific endpoint that relies that other still stubbed as before but for this endPoint you want to return a 404 and another json.

So in other words:
```swift
let stubClosure = { (target: TargetType) -> Moya.StubBehavior in 
    switch target.path {
    case "endPointThatShouldReturnAStub404":
        return // i want to return a custom stub like 404 and specific json
    default:
        return .immediate
    }
}
```
 @SD10 with my first approach?
      returning ```return Endpoint<ApiProvider>(url: url(route: target), sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)```i get no stub, it just do the network call when i call apiProvider.request(.404case), i want to get the sampleClosure
 @SD10 why you think with just this
```swift
                default:  ///endPointThatShouldReturnARegularStub
                    return Endpoint<ApiProvider>(url: url(route: target), sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
```
i would get a stub instead of a regular network call?
No, i just set this when creating the provider.
```let apiProvider = UITestsSupport.setProvider()```
 @SD10 just thing you have an API Contract but the API still not ready. So you just create a provider with ```(stubClosure: MoyaProvider.immediatelyStub)``` and in your sample data you just return what the backend would return with 200 status code.  But if you also want to test that what would happen when a certain endpoint fails you need more than that, i dont want to return the sampleData i defined there cause its the regular response, i want to customize that, makes more sense? @SD10 i know, the think is that i don't want to never stub, i want to still stubbing, but with a customized stub for a specific path. With this approax:
```swift
provider = MoyaProvider<TWApiProvider>(endpointClosure: endpointClosure, stubClosure: MoyaProvider.immediatelyStub)
```
How in my tests i determine which calls are stubbed are which are not? Seems i'm missunderstood that cause makes no sot much sense to me that you actually can create a Provider setting both, but still unsure how to determine which ones goes into which closure.
And yes i know i'm overriding it, cause its not the the behaviour that i want when i found set "CUSTOM_STUB". 

 But in any case seem i didnt explain it properly what i wanted to achieve.

By parts:

1- One and most important
This initialization was till i opened the tick perfecly fine, and i want to continue the sampleData from my Provider still gets returned. Cause there is NO real API at this moment.

```Swift
var provider: MoyaProvider<TWApiProvider> = MoyaProvider<ApiProvider>(stubClosure: MoyaProvider.immediatelyStub)
```

2- Now that i have **all** the network calls stubbed from my previous initialization, i want for an specific path to return a 404 response. Just in the case that "CUSTOM_STUB" is set. Maybe i need to create another Provider instead of doing this, i dunno.

3- Im doing this from UITests

Im gonna re-read the doc and tell you about if i see something clear this morning. Doesnt help at all. 
It says _But usually you want the same stubbing behavior for all your targets._ Yes for all the targets its ok, but i want for a specific one return a 404.

```swift
            let stubClosure = { (target: ApiProvider) -> Moya.StubBehavior in
                switch target {
                case .404case: ???
                default: return .immediate
                }
            }
```

In the 404 case i would like to return something like ```EndpointSampleResponse.networkResponse(404, Data())```. 
So from your previous comment i think i can't achieve with just a stubClosure. I need also a endPointClosure.
```swift
            let endPointClosure = { (target: ApiProvider) -> Endpoint<TWApiProvider> in
                switch target {
                case ..404case:
                    return ???
                default:
                    return //I dont want here to make a real request, i want to still stubbing.
                }
            }
```
In the 404case i want to return always the EndpointSampleResponse.networkResponse(404, Data()), not just creating an Endpoint  like ``` return Endpoint<ApiProvider>(url: url(route: target), sampleResponseClosure: {.networkResponse(404, target.sampleData)}, method: target.method, parameters: target.parameters)``` cause it will make the actual request since i dunno after creating a Regular endpoint how the calls can go throught the sample response if you dont create just a stubClosure when initializing. If you create a provider like this: ``` let provider = MoyaProvider<MyService>()```when the sampleResponse will be returning instead of the actual request? If you are in UnitsTests it gets returned instead of the request? ```swift
    static func setProvider() -> MoyaProvider<ApiProvider> {
        var provider: MoyaProvider<ApiProvider>!
        if ProcessInfo().arguments.contains("STUB_TAGS") {
            let endPointClosure = { (target: ApiProvider) -> Endpoint<ApiProvider> in
                let sampleClosure = { () -> EndpointSampleResponse in
                    switch target {
                    case .404target: return EndpointSampleResponse.networkResponse(400, target.sampleData)
                    default: return EndpointSampleResponse.networkResponse(200, target.sampleData)
                    }
                }
                return Endpoint<TWApiProvider>(url: url(route: target), sampleResponseClosure: sampleClosure)
            }

            provider = MoyaProvider<ApiProvider>(endpointClosure: endPointClosure)
        } else {
            provider = MoyaProvider<ApiProvider>(stubClosure: MoyaProvider.immediatelyStub)
        }
        return provider
    }
```
After reading again the docs I think this soltuion could work for me. But i dont know why if i initialize the Provider with this Endpoint the sample response closure never gets executed, instead it makes the real url calls. I think i got it. So basically when you provide an endpointClosure and a stubClosure if you return .immediate or .delayed it will go to the endpointClosure and grab the sampleData. 
So finally it works! Thx you a lot! If you are curious how i implemented this here it is:

```swift
    static func setProvider() -> MoyaProvider<ApiProvider> {
        var provider: MoyaProvider<ApiProvider>!
        if ProcessInfo().arguments.contains("STUB_TAGS") {
            let endPointClosure = { (target: ApiProvider) -> Endpoint<ApiProvider> in
                let sampleClosure = { () -> EndpointSampleResponse in
                    switch target {
                    case .400target:
                        return EndpointSampleResponse.networkResponse(400, target.sampleData)
                    default:
                        return EndpointSampleResponse.networkResponse(200, target.sampleData)
                    }
                }
                return Endpoint<ApiProvider>(url: url(route: target), sampleResponseClosure: sampleClosure)
            }
            provider = MoyaProvider<ApiProvider>(endpointClosure: endPointClosure, stubClosure: MoyaProvider.immediatelyStub)
        } else {
            provider = MoyaProvider<ApiProvider>(stubClosure: MoyaProvider.immediatelyStub)
        }
        return provider
    }
```  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1215?src=pr&el=h1) Report
> Merging [#1215](https://codecov.io/gh/Moya/Moya/pull/1215?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/2dfd629c2990fbf45b61b2e6ba43b622fded68b0?src=pr&el=desc) will **increase** coverage by `0.15%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1215/graphs/tree.svg?height=150&width=650&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1215?src=pr&el=tree)

```diff
@@             Coverage Diff              @@
##           9.0.0-dev   #1215      +/-   ##
============================================
+ Coverage      76.25%   76.4%   +0.15%     
============================================
  Files             24      24              
  Lines            758     763       +5     
============================================
+ Hits             578     583       +5     
  Misses           180     180
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1215?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Plugins/AccessTokenPlugin.swift](https://codecov.io/gh/Moya/Moya/pull/1215?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvQWNjZXNzVG9rZW5QbHVnaW4uc3dpZnQ=) | `100% <100%> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1215?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1215?src=pr&el=footer). Last update [2dfd629...09cebda](https://codecov.io/gh/Moya/Moya/pull/1215?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  <!--
  0 Errors
  0 Warnings
  0 Messages
  1 Markdown
-->

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Single+Response.swift | 9 | Lines should not have trailing whitespace. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1213?src=pr&el=h1) Report
> Merging [#1213](https://codecov.io/gh/Moya/Moya/pull/1213?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/4bcac8144fd438b9b93c2a9907a8581dfd899278?src=pr&el=desc) will **decrease** coverage by `2.16%`.
> The diff coverage is `0%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1213/graphs/tree.svg?src=pr&width=650&token=CjZLHCNgNn&height=150)](https://codecov.io/gh/Moya/Moya/pull/1213?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1213      +/-   ##
=============================================
- Coverage      78.48%   76.31%   -2.17%     
=============================================
  Files             23       24       +1     
  Lines            739      760      +21     
=============================================
  Hits             580      580              
- Misses           159      180      +21
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1213?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/RxMoya/Single+Response.swift](https://codecov.io/gh/Moya/Moya/pull/1213?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvU2luZ2xlK1Jlc3BvbnNlLnN3aWZ0) | `0% <0%> (√∏)` | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1213?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1213?src=pr&el=footer). Last update [4bcac81...36a354c](https://codecov.io/gh/Moya/Moya/pull/1213?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  <!--
  0 Errors
  2 Warnings: Any changes to library code sh...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The library files were changed, but the tests remained unmodified. Consider updating or adding to the tests to match the library changes.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1212?src=pr&el=h1) Report
> Merging [#1212](https://codecov.io/gh/Moya/Moya/pull/1212?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/4bcac8144fd438b9b93c2a9907a8581dfd899278?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1212/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1212?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           9.0.0-dev    #1212   +/-   ##
==========================================
  Coverage      78.48%   78.48%           
==========================================
  Files             23       23           
  Lines            739      739           
==========================================
  Hits             580      580           
  Misses           159      159
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1212?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/RxMoya/RxMoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/pull/1212?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhQXZhaWxhYmlsaXR5LnN3aWZ0) | `0% <√∏> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1212?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1212?src=pr&el=footer). Last update [4bcac81...f3dece8](https://codecov.io/gh/Moya/Moya/pull/1212?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->

moya version: ~> 8.0.3
this is postman:
![a477e398-f2b7-4e99-b841-cd204af5fffc](https://user-images.githubusercontent.com/17894304/29165275-c5012f22-7df4-11e7-817b-3fdeafea7362.png)
I want to add text as form-data like postman
This is way i use now, only image,no text.how to do? 
```swift
public var task: Task {
        switch self {
            case let .uploadImages(imageDatas, _):
            var mutDatas = [MultipartFormData]()
            for (index, value) in imageDatas.enumerated() {
                mutDatas.append(MultipartFormData(provider: .data(value), name: "images", fileName: "files\(index).jpeg", mimeType: "image/jpeg"))
            }
            return .upload(.multipart(mutDatas))
        case let .uploadHeadIconImage(imageData):
            var mutDatas = [MultipartFormData]()
            mutDatas.append(MultipartFormData(provider: .data(imageData), name: "file", fileName: "file\(index).jpeg", mimeType: "image/jpeg"))
            return .upload(.multipart(mutDatas))
        }
    }
```
or, there is a other way to get it? @sunshinejr It work well, thanks!  Hi, I am installing Moya 8.0.5 and found this problem. I can't install Moya via Carthage, it stopped in `Building scheme "ReactiveMoya" in Moya.xcodeproj`. 

This is the error log
```
*** Building scheme "Moya" in Moya.xcodeproj
*** Building scheme "RxMoya" in Moya.xcodeproj
*** Building scheme "ReactiveMoya" in Moya.xcodeproj
Build Failed
	Task failed with exit code 65:
```

And then, I checked its log file. It says that it has undeclared `DateScheduler`
`myproject/Carthage/Checkouts/Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:9:32: error: use of undeclared type 'DateScheduler'`

Here is my Cartfile
```ruby for CocoaPods
github "skywinder/ActionSheetPicker-3.0" "2.2.0"
github "Alamofire/Alamofire" "4.3.0"
github "Moya/Moya"
github "Ekhoo/Device" "2.0.1"
github "hackiftekhar/IQKeyboardManager" "v4.0.8"
github "auth0/JWTDecode.swift" "2.0.0"
github "marmelroy/Localize-Swift" "1.7.1"
github "Hearst-DD/ObjectMapper" "2.2.2"
github "antitypical/Result" "3.1.0"
github "ReactiveX/RxSwift" "3.2.0"
github "rs/SDWebImage" "3.8.2"
github "SVProgressHUD/SVProgressHUD" "2.1.2"
github "SnapKit/SnapKit" "3.1.1"
github "TTTAttributedLabel/TTTAttributedLabel" "2.0.0"
github "kasketis/netfox" "01c8a05f3a376180691c7fc61e76eae49ed9ac1f"
github "RxSwiftCommunity/Action" "2.2.1"
github "ReactiveCocoa/ReactiveSwift" "1.0.0"
```

Is there anything I missed?
Thank you! I switched to `Moya 8.0.2` that support with `ReactiveSwift 1.0.0`, so here is my Cartfile

```
github "skywinder/ActionSheetPicker-3.0" "2.2.0"
github "Alamofire/Alamofire" "4.3.0"
github "Ekhoo/Device" "2.0.1"
github "hackiftekhar/IQKeyboardManager" "v4.0.8"
github "auth0/JWTDecode.swift" "2.0.0"
github "marmelroy/Localize-Swift" "1.7.1"
github "Hearst-DD/ObjectMapper" "2.2.2"
github "antitypical/Result" "3.1.0"
github "ReactiveX/RxSwift" "3.2.0"
github "rs/SDWebImage" "3.8.2"
github "SVProgressHUD/SVProgressHUD" "2.1.2"
github "SnapKit/SnapKit" "3.1.1"
github "TTTAttributedLabel/TTTAttributedLabel" "2.0.0"
github "kasketis/netfox" "01c8a05f3a376180691c7fc61e76eae49ed9ac1f"
github "RxSwiftCommunity/Action" "2.2.1"
github "ReactiveCocoa/ReactiveSwift" "1.0.0"
github "Moya/Moya" "8.0.2"
```

But when I install it, I got 

```
MyProject/Carthage/Checkouts/Moya/Sources/Moya/MoyaAvailability.swift:42:64: error: 'Error' has been renamed to 'MoyaError': Moya.Error has been renamed to MoyaError in version 8.0.0
```  Moya: 8.0.5

I'm using RxSwift with Moya,  the readme file uses `provider.rx` but I can't 
And there is a `RxMoyaProvider` in Moya 
Which one is the recommended method to do things ?

```swift
provider = MoyaProvider<GitHub>()
provider.rx.request(.userProfile("ashfurrow")).subscribe { event in
    switch event {
    case let .next(response):
        image = UIImage(data: response.data)
    case let .error(error):
        print(error)
    default:
        break
    }
}
```

 Thanks guys!! Will read more details     <!--
  0 Errors
  2 Warnings: Any changes to library code sh...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The library files were changed, but the tests remained unmodified. Consider updating or adding to the tests to match the library changes.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
  I have add pod 'Moya/RxSwift' to my Podfile, after pod update,  I can't find MoyaProvider+Rx.swift in my pod sub-folder.

cocospod is 1.3.0
xcode 8.3.3 `target 'xxx' do

  # Pods for xxx
  pod 'SwiftProtobuf', '~> 0.9.903'
  pod 'CoreStore', '~> 4.0'           
  pod 'XCGLogger', '~> 5.0.1'         
  pod 'Moya/RxSwift'               
  pod 'CryptoSwift'                   
  pod 'SwiftyJSON'                  
  pod 'ObjectMapper'                
  pod 'KeychainAccess'              
  pod 'SwiftyUserDefaults'           
end`

 I try to use Moya with RxSwift as the document: https://github.com/Moya/Moya/blob/master/docs/RxSwift.md

provider have no rx property,
only use the RxMoyaProvider,  the document is not update? ![screen shot 2017-08-09 at 09 26 27](https://user-images.githubusercontent.com/5305009/29101481-06ba748e-7ce5-11e7-8b26-2c176a68847b.png)
In the pod folder Moya/RxSwift , have no  MoyaProvider+Rx.swift

Very strange. I got it,  this is Moya version 8.0.5 version. MoyaProvider+Rx.swift is in version 9.0  I added Moya to my Cartfile:

```
github "Moya/Moya"
```
```
carthage update Moya
```

Then I added code from [Basic Usage](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md) to my project. It doesn't build (screenshot with errors is at the end).

There seem to be a problem with the Alamofire dependency.

This happens using the simulator. I haven't tested on a device yet (also can't do this right now).

I also tried to add Alamofire directly to the Cartfile, and use e.g. `Alamofire.URLEncoding.default` instead of the typealias provided by Moya, but in that case I get "dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire".

This is my output of `carthage update Moya` (without the explicit Alamofire dependency)

> *** Fetching ReactiveCocoa 
> *** Fetching Moya
> *** Fetching Fakery
> *** Fetching Log
> *** Fetching ReactiveSwift
> *** Fetching Nimble
> *** Fetching ReactiveReSwift
> *** Fetching Quick
> *** Fetching Result
> *** Fetching Alamofire
> *** Fetching RxSwift
> *** Checking out Alamofire at "4.5.0"
> *** Checking out ReactiveSwift at "1.1.5"
> *** Checking out Moya at "8.0.5"
> *** Downloading RxSwift.framework binary at "Oxygen.1"
> *** Checking out Result at "3.2.3"
> *** xcodebuild output can be found in /var/folders/ck/lyyjs8_101dgf9tc411z5rdc0000gn/T/carthage-xcodebuild.DEBmCu.log
> *** Building scheme "Alamofire macOS" in Alamofire.xcworkspace
> *** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
> *** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
> *** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
> *** Building scheme "Result-Mac" in Result.xcodeproj
> *** Building scheme "Result-iOS" in Result.xcodeproj
> *** Building scheme "Result-tvOS" in Result.xcodeproj
> *** Building scheme "Result-watchOS" in Result.xcodeproj
> *** Building scheme "ReactiveSwift-macOS" in ReactiveSwift.xcworkspace
> *** Building scheme "ReactiveSwift-iOS" in ReactiveSwift.xcworkspace
> *** Building scheme "ReactiveSwift-tvOS" in ReactiveSwift.xcworkspace
> *** Building scheme "ReactiveSwift-watchOS" in ReactiveSwift.xcworkspace
> *** Building scheme "Moya" in Moya.xcodeproj
> *** Building scheme "RxMoya" in Moya.xcodeproj
> *** Building scheme "ReactiveMoya" in Moya.xcodeproj


Here also a screenshot with the errors:
<img width="673" alt="screen shot 2017-08-07 at 15 03 27" src="https://user-images.githubusercontent.com/1381744/29027869-bee686ba-7b82-11e7-80dd-3d46c8485ec5.png">
 Update: I forgot to add the path to the copy-frameworks script. Reset the Carthage setup and downloading Moya (without explicit Alamofire) again (it takes forever...), will write again when I can test it.

Update 2: No it doesn't work only with Moya, will try again adding Alamofire...

Update 3: Ok, I got it working:

1. Add (only) Moya to Cartfile.

2. Add the frameworks of Moya and dependencies to "Linked frameworks and libraries".

3. Add the paths to Moya and dependencies frameworks to the copy-frameworks script.  Dear Moya maintainers, I was using this library to hit an URL, which always ended up treated as an RTO.

I tried to hit a URL that returns this JSON:
```json
{
    "data": null
}
```

It's a plain GET request with Content-Type and Token header, and it returns HTTP 200 when I tried it using Postman or other platform (e.g. Android). Strangely, the similar request ended up as a RTO error:

```
Error Domain=NSURLErrorDomain Code=-1001 "The request timed out." UserInfo={NSUnderlyingError=0x7f91593088b0 {Error Domain=kCFErrorDomainCFNetwork Code=-1001 "(null)" UserInfo={_kCFStreamErrorCodeKey=-2102, _kCFStreamErrorDomainKey=4}}, NSErrorFailingURLStringKey=[REDACTED], NSErrorFailingURLKey=[REDACTED], _kCFStreamErrorDomainKey=4, _kCFStreamErrorCodeKey=-2102, NSLocalizedDescription=The request timed out.
```

I initially used RxMoyaProvider and tried to change it with MoyaProvider, only to find the same error occurs. The code I'm using is roughly like this:

```swift

provider.request(.currentTarget)
    .subscribe(
        onNext: { [weak self] response in
            // Response code handling here
        },
        onError: {  [weak self] error in
            // Error code handling here					
        }
    )
    .addDisposableTo(disposeBag)

```

I'm currently using Moya 8.0.5, along with Alamofire 4.5.0 and RxSwift 3.4.0, all of them installed through Carthage. As the title mentioned, this only occurs in iOS 8 & 9, both in simulator and device.

Any help would be appreciated. Thanks in advance! Wait - upon further inspection, it turns out I used `JSONEncoding` for the target's `parameterEncoding`, where it supposed to have no JSON parameter. Changing it to `URLEncoding` fixes this issue.

Apologies for the rubber-ducking, stay awesome dear Moya team!  Does Moya support it?  create one MoyaProvider instance in my ViewController,  and more than one request it in viewDidLoad @SD10 I don't find any document, after my research, I think can support,  because the request returned task is a cancelable object.  like NSURLSession, can make mutil-requests on a single instance  Only `Moya+Alamofire.swift` need to import Alamofire to avoid leaking abstractions. <!--
  0 Errors
  1 Warning: Any changes to library code sh...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProvider+ReactiveSpec.swift | 288 | Prefer `!= nil` over `let _ =` 
MoyaProvider+ReactiveSpec.swift | 60 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider+ReactiveSpec.swift | 61 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider+ReactiveSpec.swift | 62 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider+ReactiveSpec.swift | 63 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider+ReactiveSpec.swift | 152 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider+ReactiveSpec.swift | 153 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider+ReactiveSpec.swift | 154 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider+ReactiveSpec.swift | 155 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider+RxSpec.swift | 179 | Prefer `!= nil` over `let _ =` 
MoyaProviderSpec.swift | 862 | File should contain 400 lines or less: currently contains 862 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 7 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 513 lines 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 @sunshinejr Sure, I'll try. Thanks :]  ```swift
# Uncomment the next line to define a global platform for your project
# platform :ios, '9.0'

target 'MoyaTest' do
  # Comment the next line if you're not using Swift and don't want to use dynamic frameworks
  use_frameworks!

  # Pods for MoyaTest
  pod 'Moya', '~> 8.0.5'
  target 'MoyaTestTests' do
    inherit! :search_paths
    # Pods for testing
  end

  target 'MoyaTestUITests' do
    inherit! :search_paths
    # Pods for testing
  end

end
```
in NetworkLoggerPlugin.swift 19 line errorÔºö
Static method 'reversedPrint(_:terminator:items:)' is fileprivate and cannot be referenced from a default argument value
I just finished pod...
I don't know what happened
xcode version 9.0 beat thanks,i resolves the problem.  The project is a self-built certificate. How can I verify HTTPS for the moya setup? @sunshinejr  @pedrovereza  
Thank you very much for your help. I have read the open direct mouth and tried to customize the manager and let the manager be the parameter of Moya, but it is not useful. Is my func wrong? Thank you again for helping me!!


Could you tell me the two person's instant messaging, for example, WeChat or something?


 @sunshinejr  OK this is my code 

```Swift
var baseLink: String = "http://api.news18a.com/"

enum MoyaNewsCar {
  case hotSpot,video,live,business,evaluating,shopping,newCar,useCar,calture,travel,technology,market
}

extension MoyaNewsCar: TargetType {

  var baseURL: URL {
    return URL(string: baseLink)!
    
  }
  

  var path: String {
      return "init.php"
  }
  
 
  var method: Moya.Method {
      return .get
  }
  

  var parameters: [String: Any]? {
    switch self {
    case .hotSpot:
      return [
        "m": "ina_app",
        "c": "index",
        "a": "index_new"
      ]
    case .video:
      return [
        "m": "ina_app",
        "c": "vedio",
        "a": "focus"
      ]
    case .live:
      return [
        "m": "ina_app",
        "c": "vedio",
        "a": "new_live"
      ]
    case .business: 
      return [
        "m": "ina_app",
        "c": "index",
        "a": "storylist",
        "storyType": "industry"
      ]
    case .evaluating:
      return [
        "m": "ina_app",
        "c": "index",
        "a": "storylist",
        "storyType": "evaluation"
      ]
    case .shopping:
      return [
        "m": "ina_app",
        "c": "index",
        "a": "storylist",
        "storyType": "guide"
      ]
    case .newCar:
      return [
        "m": "ina_app",
        "c": "index",
        "a": "storylist",
        "storyType": "newCar"
      ]
    case .useCar:
      return [
        "m": "ina_app",
        "c": "index",
        "a": "storylist",
        "storyType": "useCar"
      ]
    case .calture:
      return [
        "m": "ina_app",
        "c": "index",
        "a": "storylist",
        "storyType": "culture"
      ]
    case .travel:
      return [
        "m": "ina_app",
        "c": "index",
        "a": "storylist",
        "storyType": "travel"
      ]
    case .technology:
      return [
        "m": "ina_app",
        "c": "index",
        "a": "storylist",
        "storyType": "technology"
      ]
    case .market:
      return [
        "m": "ina_app",
        "c": "index",
        "a": "storylist",
        "storyType": "market"
      ]
    }
    
  }
  
  
  var parameterEncoding: ParameterEncoding {
    return URLEncoding.default
  }
  
  var sampleData: Data {
    return "{}".data(using: String.Encoding.utf8)!
  }
  
 
  var task: Task {
    return .request
  }
  
  /// ÊòØÂê¶ÊâßË°åAlamofireÈ™åËØÅ„ÄÇÈªòËÆ§‰∏∫"false"
  var validate: Bool {
    return true
  }
}

class NewsNetServer: NSObject {
  
 
  var netWorkDataType: MoyaNewsCar! = .hotSpot
  
  
  public func moyaGetData(type: MoyaNewsCar, success: @escaping (_ result : NSDictionary) -> (),failed: @escaping (_ error : String) -> ()) -> Void {
    MoyaNewsCarProvider.request(type) { (result) in
      do {
        let response = try result.dematerialize()
        let value = try response.mapNSDictionary()
        success(value)
      } catch {
        let errorPrint = error as CustomStringConvertible
        let errorMessage = errorPrint.description
        failed(errorMessage)
      }
    }
  }

}

//MARK: - Private Method -
extension NewsNetServer {
  
}



extension Moya.Response {
  func mapNSDictionary() throws -> NSDictionary {
    let any = try self.mapJSON()
    guard let dictionary = any as? NSDictionary else {
      throw MoyaError.jsonMapping(self)
    }
    return dictionary
  }
  
  func mapNSArray() throws -> NSArray {
    let any = try self.mapJSON()
    guard let array = any as? NSArray else {
      throw MoyaError.jsonMapping(self)
    }
    return array
  }
  
}


let MoyaNewsCarProvider = MoyaProvider<MoyaNewsCar>(endpointClosure: endpointClosure ,plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])


let endpointClosure = { (target: MoyaNewsCar) -> Endpoint<MoyaNewsCar> in
  let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
  return defaultEndpoint.adding(newHTTPHeaderFields: ["VersionCode": "201"])
}


private func JSONResponseDataFormatter(_ data: Data) -> Data {
  do {
    let dataAsJSON = try JSONSerialization.jsonObject(with: data)
    let prettyData = try JSONSerialization.data(withJSONObject: dataAsJSON, options: .prettyPrinted)
    return prettyData
  } catch {
    return data
  }
}
```
   <!--
  0 Errors
  1 Warning: The library files were changed...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The library files were changed, but the tests remained unmodified. Consider updating or adding to the tests to match the library changes.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1193?src=pr&el=h1) Report
> :exclamation: No coverage uploaded for pull request base (`9.0.0-dev@62a73bc`). [Click here to learn what that means](https://docs.codecov.io/docs/error-reference#section-missing-base-commit).
> The diff coverage is `50%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1193/graphs/tree.svg?width=650&height=150&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1193?src=pr&el=tree)

```diff
@@             Coverage Diff              @@
##             9.0.0-dev    #1193   +/-   ##
============================================
  Coverage             ?   79.53%           
============================================
  Files                ?       23           
  Lines                ?      738           
  Branches             ?        0           
============================================
  Hits                 ?      587           
  Misses               ?      151           
  Partials             ?        0
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1193?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Plugins/NetworkLoggerPlugin.swift](https://codecov.io/gh/Moya/Moya/pull/1193?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvTmV0d29ya0xvZ2dlclBsdWdpbi5zd2lmdA==) | `91.8% <50%> (√∏)` | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1193?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1193?src=pr&el=footer). Last update [62a73bc...8a84015](https://codecov.io/gh/Moya/Moya/pull/1193?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Hi, I am new on use Moya
I read on documentation, we can create custom plugins to handle before and after request, i just wanna ask how to get Http status code when error, I try down cast MoyaError to AFError but not succesfully but when I cast to NSError return succesfully, this my code:

```
public final class RequestAlertPlugin: PluginType {
    
    var viewController: UIViewController
    
    public init(viewController: UIViewController) {
        self.viewController = viewController
    }
    
    // MARK: Plugin
    /// Called by the provider as soon as the request is about to start
    public func willSend(_ request: RequestType, target: TargetType) {
        
        UIApplication.shared.isNetworkActivityIndicatorVisible = true
    }
    
    /// Called by the provider as soon as a response arrives, even if the request is canceled.
    public func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType) {
        
        UIApplication.shared.isNetworkActivityIndicatorVisible = false
        
        switch result {
        case .failure(let moyaError):
            
            /**
             * Result is MoyaError need casting to MoyaError to access error properties
             */
            let moyaError = moyaError as MoyaError
            switch moyaError {
            case .underlying(let nsError):
                /**
                 * Result is Error type need casting to NSError to access error properties
                 */
                let nsError = nsError as NSError
                let alertViewController = UIAlertController(
                    title: "Error",
                    message: NetworkError(error: nsError).localizedDescription,
                    preferredStyle: .alert
                )
                    alertViewController.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
                
                self.viewController.present(alertViewController, animated: true)
            default:
                
                break
            }
            
            break
        default:
            
            break
        }
    }
}
```

- github "Moya/Moya" "8.0.5" Yes, I have try with Apiary data but not working as expeted, Error always call at . underlying not at statusCode, any reference for error type like hard error (that come from swift NSError / CFError type) and soft error that return Http status code Oke no problem @SD10, thanks for the response. I just want to know why it call underlying but when I requested through by Alamofire error return Http error code üò∏   Hi there,

I'm calling a request using Moya and I see these errors in the console:
```
Jul 26 16:54:40  MyApp[87616] <Error>: +++++ HOLE: real delegate responds but we don't: 'URLSession:task:didFinishCollectingMetrics:'
Jul 26 16:54:40  MyApp[87616] <Error>: +++++ HOLE: real delegate responds but we don't: 'URLSession:task:didFinishCollectingMetrics:'
```

From Podfile.lock
```
  - Moya (8.0.4):
    - Moya/Core (= 8.0.4)
  - Moya/Core (8.0.4):
    - Alamofire (~> 4.1)
    - Result (~> 3.0)
```

I've spent some time to narrow down where the log message is coming from and it seems that the source is this method from MoyaProvider+Internal.swift:
```swift
    func sendRequest(_ target: Target, request: URLRequest, queue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -> CancellableToken {
        let initialRequest = manager.request(request as URLRequestConvertible)
        let alamoRequest = target.validate ? initialRequest.validate() : initialRequest
        return sendAlamofireRequest(alamoRequest, target: target, queue: queue, progress: progress, completion: completion)
    }
````

And more specifically this line in Moya:
```swift
let initialRequest = manager.request(request as URLRequestConvertible)
```

Seeing this error in the console worries me. Also, it's true that this message is printed by Alamofire, but maybe you know more about it. The API that I'm calling works.

Should I be worried?
How can I fix this error? Hey @sunshinejr. This is what I did as well - Do a Google Search and see where is it coming from. I found the same 2 sources. The weird thing is that I don't use neither of them. 

I was debugging step by step and after jumping through this line of Alamofire the log message appeared. I didn't find the log message in the source code of Alamofire. 

Another thing that I've tried is to use Alamofire directly to load the exact same endpoint request and I didn't see any log messages.

It's a mystery to me. For now, I stopped the integration of Moya in the project until I resolve that since it's worrying me and my manager is very strict with warnings and error log messages or warning log messages.

Thank you for looking into that :)
My guess is that since this is something new, it will pass sometime till somebody else asks or resolves the issue.  moya->core->AccessTokenPlugin.swift
import Result
error:modile complied with swift 4.0 cannot be imported in swift 3.0 :myPath thank you  Current Moya Readme shows:

| Swift version | Moya version  |
| ------------- | ------------- |
| 3.X           | >= 8.0.0      |

* Can you double check that Moya 8.0.0 is OK for Swift 3.2 (on Xcode 9)? Otherwise, please specify the Moya branch/version for it
* Can you document the Moya branch/version for Swift 4?  * update ReactiveSwift to 2.0
* update RxSwift to 3.6.1 They only thing that worries me that some people won't be able to migrate to ReactiveSwift 2.0 quickly since there're some breaking changes, so as the new Moya. @BasThomas done <!--
  0 Errors
  2 Warnings: Consider adding supporting doc...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The library files were changed, but the tests remained unmodified. Consider updating or adding to the tests to match the library changes.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 @sunshinejr should I rebase my branch to `9.0.0-alpha.1` ? @sunshinejr rebased. @ashfurrow thank you!  as it's described on title,how to  controll whether to show a loading view.
i know plugin like NetworkActivityPlugin in demo support show/hide loading view, but it works for all api request . 

i want to show loading/hide view depending on the specific api type.  

for example,to get one's profile, i want to request silently but to request a list , i want user know our app is loading.     Hello Community, I just making request for update ReactiveSwift dependency to 2.0. @sunshinejr I wanted to do PR. I'm sure that it should be very easy PR. But I didn't find quickly how to configure the project dependencies for contributing. Could anyone please assist? Is it just one Carthage command? @SD10 thank you! created PR #1185  <!--
  0 Errors
  1 Warning: Big PR, try to keep changes sm...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Big PR, try to keep changes smaller if you can</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
GiphyAPI.swift | 11 | Force unwrapping should be avoided. 
GiphyAPI.swift | 42 | Force unwrapping should be avoided. 
GiphyAPI.swift | 52 | Force unwrapping should be avoided. 
GitHubAPI.swift | 22 | Force unwrapping should be avoided. 
GitHubAPI.swift | 33 | Force unwrapping should be avoided. 
GitHubAPI.swift | 72 | Force unwrapping should be avoided. 
GitHubAPI.swift | 74 | Force unwrapping should be avoided. 
GitHubAPI.swift | 76 | Force unwrapping should be avoided. 
GitHubAPI.swift | 88 | MARK comment should be in valid format. 
GitHubAPI.swift | 99 | Files should have a single trailing newline. 
GitHubUserContentAPI.swift | 11 | Force unwrapping should be avoided. 
GitHubUserContentAPI.swift | 54 | Force unwrapping should be avoided. 
GitHubUserContentAPI.swift | 52 | Lines should not have trailing whitespace. 
GitHubUserContentAPI.swift | 56 | Lines should not have trailing whitespace. 
GitHubUserContentAPI.swift | 59 | Files should have a single trailing newline. 
MoyaProvider.swift | 102 | Function should have 5 parameters or less: it currently has 6 
MoyaProviderSpec.swift | 863 | File should contain 400 lines or less: currently contains 863 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
GiphyAPI.swift | 4 | Variable name should start with a lowercase character: 'GiphyProvider' 
GitHubAPI.swift | 16 | Variable name should start with a lowercase character: 'GitHubProvider' 
GitHubUserContentAPI.swift | 4 | Variable name should start with a lowercase character: 'GitHubUserContentProvider' 
GitHubUserContentAPI.swift | 50 | Variable name should start with a lowercase character: 'DefaultDownloadDestination' 
MoyaProviderSpec.swift | 8 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 513 lines 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
  Hi all,
I'm using Moya 8.0.

I found something similar to this:
```swift
let provider = ReactiveSwiftMoyaProvider<JokesService>(stubScheduler: scheduler, stubClosure: MoyaProvider.immediatelyStub)
```
How I can use TestScheduler with RxMoyaProvider ?

Thank you,
you're doing a great job!
<!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 Hi guys,
I'm trying to test a more complex situation with Drivers :P 
It's based on Drivers example here https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample-iOSTests/RxExample_iOSTests.swift 

Here's my view model:

```swift
class JokesViewModel {
    
    let jokes: Driver<[Joke]>
    
    init(
        refreshDriver: Driver<Void>,
        jokesProvider: RxMoyaProvider<JokesService>
        ) {
        
        jokes = refreshDriver
            .flatMapLatest { _ in
                return jokesProvider
                    .request(.random(numJokes: 5))
                    .mapArray(type: Joke.self, keyPath: "value")
                    .asDriver(onErrorJustReturn:[])
                    .debug("DEBUG!! random call")
        }
        .debug("DEBUG!! jokes")
    }
}

```

And here's my test:
```swift
class ChuckNorrisJokesMVVMTests: XCTestCase {
    
    override func setUp() {
        super.setUp()
    }
    
    func testJokes() {
        let scheduler = TestScheduler(initialClock: 0)
        
        driveOnScheduler(scheduler) {
    
            let refreshDriver = scheduler
                .createHotObservable([next(0, ())])
                .asDriver(onErrorJustReturn: ())
            
            let provider = RxMoyaProvider<JokesService>(stubClosure: MoyaProvider.immediatelyStub)
            let viewModel = JokesViewModel(refreshDriver: refreshDriver, jokesProvider:provider)
            
            let recordedJokes = scheduler.record(source: viewModel.jokes)
        
            scheduler.start()
            
            XCTAssertEqual(2, recordedJokes.events.count)
        }
        
    }
    
}

extension TestScheduler {
    func record<O: ObservableConvertibleType>(source: O) -> TestableObserver<O.E> {
        let observer = self.createObserver(O.E.self)
        let disposable = source.asObservable().bind(to: observer)
        self.scheduleAt(100000) {
            disposable.dispose()
        }
        return observer
    }
}

```

When I run the test, I can see in debug outputs that the driver is subscribed but no items are coming from the moya service:

> 

2017-07-24 17:28:38.784: DEBUG!! jokes -> subscribed
2017-07-24 17:28:38.791: DEBUG!! random call -> subscribed
2017-07-24 17:28:38.797: DEBUG!! jokes -> isDisposed
2017-07-24 17:28:38.797: DEBUG!! random call -> isDisposed

> 

If I run the application, everything is working and I get data from the request, so it seems something related to the test thread or test scheduler.... Help! :)  <!--
  0 Errors
  1 Warning: Consider adding supporting doc...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
  Hello, i want to implement refresh token with Moya and RxSwift but i don't solve my issue

but i don't understand, when my response is 401, i want to make another request ( refresh token ) and after that i want to retry my old request but i don't understand how to do that, someone can help me

i implement this code in this issue https://github.com/Moya/Moya/issues/744 but i don't know how and when i make my refresh request before to execut my old request Thanks for your help @sunshinejr !!
MY CONTROLLER
```Swift
//Get User info action button

    @IBAction func requestUser(_ sender: UIButton) {
        getUser().subscribe(onNext: { (user) in
            print(user)
        }, onError: { (error) in
            print("ERROR SECOND TRY ", error)
        }, onCompleted: { 
            print("Completed")
        }) { 
            print("Disposed")
        }.addDisposableTo(disposeBag)
    }


//Get user with fail token for simulate error request for to do my refresh token request and retry my old request

    func getUser() -> Observable<User?>  {
        let providerUser = myRxProvider<UserEndPoints>(plugins: [AccessTokenPlugin(token: "FailToken")])

        //I don't understand why i need to implemente the callback
        providerUser.authenticationBlock = { (_ done: () -> Void) -> Void in
            print("DONE")
            done()
        }

        let response = providerUser.request(.ReadCurrent()).mapObjectOptional(type: User.self)
        return response
    }

/* AUTHENTIFICATION PROVIDER #744 
I implemente the issue #744 i don't understand the callback first and how and where i need to make my refresh request for after execute my old request */

    public typealias AuthenticationBlock = (_ done: () -> Void) -> Void

    public enum Error: Swift.Error {
        case missingAuthenticationBlock
        case invalidCredentials
    }


    public class myRxProvider<Target>: RxMoyaProvider<Target> where Target: TargetType {
    
        private let disposeBag = DisposeBag()
        public var authenticationBlock: AuthenticationBlock?
    
        public override init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping,
                         requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping,
                         stubClosure: @escaping StubClosure = MoyaProvider.neverStub,
                         manager: Manager = MoyaProvider<Target>.defaultAlamofireManager(),
                         plugins: [PluginType] = [],
                         trackInflights: Bool = false) {
        
            super.init(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, manager: manager, plugins: plugins, trackInflights: trackInflights)
        }
    
        public override func request(_ token: Target) -> Observable<Response> {
            return _request(token)
        }

        private func _request(_ token: Target, isSecondTryAfterAuth: Bool = false) -> Observable<Response> {
            return super.request(token)
                .flatMap { [unowned self] response -> Observable<Response> in
                    
                    //check the response status code if error make a refresh token
                    if response.statusCode == 401 || response.statusCode == 403 {
                        
                        //Check if me second try fail return error and move to login view
                        if isSecondTryAfterAuth {
                            return Observable<Response>.error(Error.invalidCredentials)
                        }

                        //Need to make a request for resfresh my token and after i have my response,
                        //change my header authorisation token to my old request and execute old request
                        self.refreshTokenAction().subscribe(onNext: { (refreshToken) in
                            print(resfreshToken)
                            //Here after i have my new token, change header autorisation and add new token
                            //into the header
                            //try the old request with new header
                        }, onError: { (error) in
                            print("ERROR REFRESH", error)
                        }, onCompleted: {
                            print("completed")
                        }, onDisposed: {
                            print("disposed")
                        })
                    
                        //I don't understand the callback ...
                        guard let authenticationBlock = self.authenticationBlock else {
                            throw Error.missingAuthenticationBlock
                        }
                    
                        //i think is here where my old request is execute
                        return Observable.create { observer in
                            authenticationBlock {
                                self._request(token, isSecondTryAfterAuth: true)
                                    .subscribe { event in
                                        switch event {
                                        case .next(let element):
                                            print("test element", element)
                                        case .error(let error):
                                            observer.on(event)
                                        case .completed:
                                            print("test completed")
                                        }
                                    }.addDisposableTo(self.disposeBag)
                            }
                            return Disposables.create()
                        }
                    } else {
                        return Observable.just(response)
                    }
            }
        }
    

        //Refresh token request
        //We suppose the params is valid
        func refreshTokenAction() -> Observable<Token?> {
            let providerToken = myRxProvider<TokenEndPoints>()
            providerToken.authenticationBlock = { (_ done: () -> Void) -> Void in
                print("TOKEN IS REFRESH")
            }
        
            let response = providerToken.request(.Update(refreshToken: "Riox8RWVm8lmxxxMaMLF4PMz65MMZp4_oaq5_sjEK8c=")).mapObjectOptional(type: Token.self)
            return response
        
        }
    }
```

I hope you can help me, if you don't understand something, i can tell you more for understand @sunshinejr or someone else, if you have any exemple with refresh token and retry old request after the refresh you can show me thanks you so much @AndrewSB 
I read the issue but i don't understand all, if you have any idea for help me in my code, this will be great!! 
i take look to #748 i need more time for understand, i'm just begin with RxSwift And Moya Well i don't solve my issue @sunshinejr @AndrewSB any idea?  When i use moya In a Controller that content webview
I was never reveice webview fail delegate

```
func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {
        print("Âä†ËΩΩÂ§±Ë¥•")
    }
```
It error's log 
```
WebViewController.swift:349:68: 'Error' is ambiguous for type lookup in this context
WebViewController.swift:349:68: Found this candidate (Swift.Error)
WebViewController.swift:349:68: Found this candidate (Moya.Error)
```
If i was write Swity.Error ,The delegate never run when webview load fail

so,How can I do for this problem?

  Xcode9.0 beta have compile error CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
    cd /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods
    export DEVELOPER_DIR=/Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer
    export PATH="/Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    export SDKROOT=/Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.0.sdk
    /Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc -incremental -module-name SQLite -Onone -enforce-exclusivity=checked -D COCOAPODS -sdk /Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.0.sdk -target arm64-apple-ios8.0 -g -module-cache-path /Users/luoyang/Library/Developer/Xcode/DerivedData/ModuleCache -Xfrontend -serialize-debugging-options -embed-bitcode-marker -enable-testing -index-store-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Index/DataStore -swift-version 3 -I /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift -I /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/CocoaPods/iphoneos -F /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift -c -j4 /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/AggregateFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Blob.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Collation.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Connection.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/CoreFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/CustomFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Expression.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Foundation.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/FTS4.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/FTS5.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Helpers.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Operators.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Query.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/RTree.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Schema.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Setter.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Statement.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Value.swift -output-file-map /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/SQLite.swift-OutputFileMap.json -parseable-output -serialize-diagnostics -emit-dependencies -emit-module -emit-module-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/SQLite.swiftmodule -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-generated-files.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-own-target-headers.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-project-headers.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift/include -Xcc -I/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/Headers/Private -Xcc -I/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/Headers/Public -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/DerivedSources/arm64 -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/DerivedSources -Xcc -DPOD_CONFIGURATION_DEBUG=1 -Xcc -DDEBUG=1 -Xcc -DCOCOAPODS=1 -emit-objc-header -emit-objc-header-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/SQLite-Swift.h -import-underlying-module -Xcc -ivfsoverlay -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/unextended-module-overlay.yaml -Xcc -working-directory/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods

CompileSwift normal arm64 /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/AggregateFunctions.swift
    cd /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods
    /Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/AggregateFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Blob.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Collation.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Connection.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/CoreFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/CustomFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Expression.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Foundation.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/FTS4.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/FTS5.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Helpers.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Operators.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Query.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/RTree.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Schema.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Setter.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Statement.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Value.swift -target arm64-apple-ios8.0 -Xllvm -aarch64-use-tbi -enable-objc-interop -sdk /Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.0.sdk -I /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift -I /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/CocoaPods/iphoneos -F /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift -enable-testing -g -import-underlying-module -module-cache-path /Users/luoyang/Library/Developer/Xcode/DerivedData/ModuleCache -swift-version 3 -enforce-exclusivity=checked -D COCOAPODS -serialize-debugging-options -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-generated-files.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-own-target-headers.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-project-headers.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift/include -Xcc -I/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/Headers/Private -Xcc -I/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/Headers/Public -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/DerivedSources/arm64 -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/DerivedSources -Xcc -DPOD_CONFIGURATION_DEBUG=1 -Xcc -DDEBUG=1 -Xcc -DCOCOAPODS=1 -Xcc -ivfsoverlay -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/unextended-module-overlay.yaml -Xcc -working-directory/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods -emit-module-doc-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/AggregateFunctions~partial.swiftdoc -serialize-diagnostics-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/AggregateFunctions.dia -Onone -module-name SQLite -emit-module-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/AggregateFunctions~partial.swiftmodule -emit-dependencies-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/AggregateFunctions.d -emit-reference-dependencies-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/AggregateFunctions.swiftdeps -o /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/AggregateFunctions.o -embed-bitcode-marker -index-store-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Index/DataStore -index-system-modules

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:10: note: while building module 'Darwin' imported from /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:
#include <stdarg.h>     /* Needed for the definition of va_list */
         ^
<module-includes>:1:9: note: in file included from <module-includes>:1:
#import "sys/cdefs.h"
        ^
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sys/cdefs.h:587:10: error: 'sys/_symbol_aliasing.h' file not found
#include <sys/_symbol_aliasing.h>
         ^
<module-includes>:1:9: note: in file included from <module-includes>:1:
#import "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h"
        ^
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:10: error: could not build module 'Darwin'
#include <stdarg.h>     /* Needed for the definition of va_list */
         ^
/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Connection.swift:32:8: error: could not build Objective-C module 'CSQLite'
import CSQLite
       ^

CompileSwift normal arm64 /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Blob.swift
    cd /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods
    /Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/AggregateFunctions.swift -primary-file /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Blob.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Collation.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Connection.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/CoreFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/CustomFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Expression.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Foundation.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/FTS4.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/FTS5.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Helpers.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Operators.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Query.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/RTree.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Schema.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Setter.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Statement.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Value.swift -target arm64-apple-ios8.0 -Xllvm -aarch64-use-tbi -enable-objc-interop -sdk /Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.0.sdk -I /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift -I /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/CocoaPods/iphoneos -F /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift -enable-testing -g -import-underlying-module -module-cache-path /Users/luoyang/Library/Developer/Xcode/DerivedData/ModuleCache -swift-version 3 -enforce-exclusivity=checked -D COCOAPODS -serialize-debugging-options -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-generated-files.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-own-target-headers.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-project-headers.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift/include -Xcc -I/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/Headers/Private -Xcc -I/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/Headers/Public -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/DerivedSources/arm64 -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/DerivedSources -Xcc -DPOD_CONFIGURATION_DEBUG=1 -Xcc -DDEBUG=1 -Xcc -DCOCOAPODS=1 -Xcc -ivfsoverlay -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/unextended-module-overlay.yaml -Xcc -working-directory/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods -emit-module-doc-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Blob~partial.swiftdoc -serialize-diagnostics-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Blob.dia -Onone -module-name SQLite -emit-module-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Blob~partial.swiftmodule -emit-dependencies-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Blob.d -emit-reference-dependencies-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Blob.swiftdeps -o /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Blob.o -embed-bitcode-marker -index-store-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Index/DataStore -index-system-modules

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:10: note: while building module 'Darwin' imported from /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:
#include <stdarg.h>     /* Needed for the definition of va_list */
         ^
<module-includes>:1:9: note: in file included from <module-includes>:1:
#import "sys/cdefs.h"
        ^
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sys/cdefs.h:587:10: error: 'sys/_symbol_aliasing.h' file not found
#include <sys/_symbol_aliasing.h>
         ^
<module-includes>:1:9: note: in file included from <module-includes>:1:
#import "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h"
        ^
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:10: error: could not build module 'Darwin'
#include <stdarg.h>     /* Needed for the definition of va_list */
         ^
/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Connection.swift:32:8: error: could not build Objective-C module 'CSQLite'
import CSQLite
       ^

CompileSwift normal arm64 /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Collation.swift
    cd /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods
    /Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/AggregateFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Blob.swift -primary-file /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Collation.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Connection.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/CoreFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/CustomFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Expression.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Foundation.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/FTS4.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/FTS5.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Helpers.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Operators.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Query.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/RTree.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Schema.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Setter.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Statement.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Value.swift -target arm64-apple-ios8.0 -Xllvm -aarch64-use-tbi -enable-objc-interop -sdk /Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.0.sdk -I /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift -I /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/CocoaPods/iphoneos -F /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift -enable-testing -g -import-underlying-module -module-cache-path /Users/luoyang/Library/Developer/Xcode/DerivedData/ModuleCache -swift-version 3 -enforce-exclusivity=checked -D COCOAPODS -serialize-debugging-options -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-generated-files.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-own-target-headers.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-project-headers.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift/include -Xcc -I/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/Headers/Private -Xcc -I/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/Headers/Public -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/DerivedSources/arm64 -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/DerivedSources -Xcc -DPOD_CONFIGURATION_DEBUG=1 -Xcc -DDEBUG=1 -Xcc -DCOCOAPODS=1 -Xcc -ivfsoverlay -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/unextended-module-overlay.yaml -Xcc -working-directory/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods -emit-module-doc-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Collation~partial.swiftdoc -serialize-diagnostics-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Collation.dia -Onone -module-name SQLite -emit-module-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Collation~partial.swiftmodule -emit-dependencies-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Collation.d -emit-reference-dependencies-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Collation.swiftdeps -o /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Collation.o -embed-bitcode-marker -index-store-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Index/DataStore -index-system-modules

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:10: note: while building module 'Darwin' imported from /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:
#include <stdarg.h>     /* Needed for the definition of va_list */
         ^
<module-includes>:1:9: note: in file included from <module-includes>:1:
#import "sys/cdefs.h"
        ^
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sys/cdefs.h:587:10: error: 'sys/_symbol_aliasing.h' file not found
#include <sys/_symbol_aliasing.h>
         ^
<module-includes>:1:9: note: in file included from <module-includes>:1:
#import "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h"
        ^
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:10: error: could not build module 'Darwin'
#include <stdarg.h>     /* Needed for the definition of va_list */
         ^
/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Connection.swift:32:8: error: could not build Objective-C module 'CSQLite'
import CSQLite
       ^

CompileSwift normal arm64 /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Connection.swift
    cd /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods
    /Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/AggregateFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Blob.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Collation.swift -primary-file /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Connection.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/CoreFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/CustomFunctions.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Expression.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Foundation.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/FTS4.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/FTS5.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Helpers.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Operators.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Query.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Extensions/RTree.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Schema.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Typed/Setter.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Statement.swift /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Value.swift -target arm64-apple-ios8.0 -Xllvm -aarch64-use-tbi -enable-objc-interop -sdk /Users/luoyang/Downloads/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.0.sdk -I /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift -I /Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/CocoaPods/iphoneos -F /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift -enable-testing -g -import-underlying-module -module-cache-path /Users/luoyang/Library/Developer/Xcode/DerivedData/ModuleCache -swift-version 3 -enforce-exclusivity=checked -D COCOAPODS -serialize-debugging-options -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-generated-files.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-own-target-headers.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/SQLite-project-headers.hmap -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Products/Debug-iphoneos/SQLite.swift/include -Xcc -I/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/Headers/Private -Xcc -I/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/Headers/Public -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/DerivedSources/arm64 -Xcc -I/Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/DerivedSources -Xcc -DPOD_CONFIGURATION_DEBUG=1 -Xcc -DDEBUG=1 -Xcc -DCOCOAPODS=1 -Xcc -ivfsoverlay -Xcc /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/unextended-module-overlay.yaml -Xcc -working-directory/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods -emit-module-doc-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Connection~partial.swiftdoc -serialize-diagnostics-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Connection.dia -Onone -module-name SQLite -emit-module-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Connection~partial.swiftmodule -emit-dependencies-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Connection.d -emit-reference-dependencies-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Connection.swiftdeps -o /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Build/Intermediates.noindex/Pods.build/Debug-iphoneos/SQLite.swift.build/Objects-normal/arm64/Connection.o -embed-bitcode-marker -index-store-path /Users/luoyang/Library/Developer/Xcode/DerivedData/Olliix-hhcydkvnvnavetcbofimvgbggqgl/Index/DataStore -index-system-modules

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:10: note: while building module 'Darwin' imported from /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:
#include <stdarg.h>     /* Needed for the definition of va_list */
         ^
<module-includes>:1:9: note: in file included from <module-includes>:1:
#import "sys/cdefs.h"
        ^
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sys/cdefs.h:587:10: error: 'sys/_symbol_aliasing.h' file not found
#include <sys/_symbol_aliasing.h>
         ^
<module-includes>:1:9: note: in file included from <module-includes>:1:
#import "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h"
        ^
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/sqlite3.h:35:10: error: could not build module 'Darwin'
#include <stdarg.h>     /* Needed for the definition of va_list */
         ^
/Users/luoyang/Documents/ÂÖ¨Âè∏È°πÁõÆ/Olliix/Code/branches/dev_v1.1/Olliix/Pods/SQLite.swift/Sources/SQLite/Core/Connection.swift:32:8: error: could not build Objective-C module 'CSQLite'
import CSQLite
       ^  I am currently developing an app using Moya 8.0.5 and I have to consume an API that uses Bearer HTTP Auth with a token that expires every 8 hours.

Is there an easy way in Moya to reauthenticate (aka call an endpoint to update the token) when it expires, and then redo the request? I can't rely on a timestamp to know if the token is expired and have to do it after a request returns http status 401.

Currently I am checking in every endpoint response if the HTTP status is 401, and if it is, I call an endpoint to get a new token and then redo the original request with it.

Thank you!  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1173?src=pr&el=h1) Report
> Merging [#1173](https://codecov.io/gh/Moya/Moya/pull/1173?src=pr&el=desc) into [optional-response-thread-param](https://codecov.io/gh/Moya/Moya/commit/d1758cb4865b1466607c9d4cf4e3af10a065aa45?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1173/graphs/tree.svg?token=CjZLHCNgNn&src=pr&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1173?src=pr&el=tree)

```diff
@@                       Coverage Diff                       @@
##           optional-response-thread-param    #1173   +/-   ##
===============================================================
  Coverage                           76.39%   76.39%           
===============================================================
  Files                                  22       22           
  Lines                                 733      733           
===============================================================
  Hits                                  560      560           
  Misses                                173      173
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1173?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1173?src=pr&el=footer). Last update [d1758cb...37c5876](https://codecov.io/gh/Moya/Moya/pull/1173?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  This plugin adds support for Basic Authorization header using an API key. @sunshinejr seems like a good idea.
Not sure what would be the use case for `none` (lowercase in Swift 3). Also I only see the implementation for Bearer in `AccessTokenAuth`.
Anyway you seem to have implemented most of it in your comment so feel free to go ahead and include this code wherever it makes more sense. 

We (currently) don't have a need for OAuth in our project, and I'm also using [SugarMoya](https://github.com/devxoul/MoyaSugar) -> `httpHeaderFields` property to add Basic Auth instead of a plugin.
Note: SugarMoya has a really nice wrapper for Moya by using `Route`. You might want to consider adding it to Moya. @SD10 that explain why I couldn't see the implementation for OAuth. I thought I was looking at the wrong file.
As I mentioned, we are currently not using OAuth so I don't have any code from my project to contribute besides Basic Authentication. `AccessTokenPlugin` only implementers Bearer so I'm not sure it makes sense to add OAuth on top of Basic Authorization. @SD10 I'm definitely not an expert in OAuth - but the implementation is a lot more complicated than just adding another field to the http header. There are entire frameworks that handle OAuth. 
 Let's do it. How do I setup an environment where I can build and run tests? Great. I'll find time as soon as I can take a break. Got a tight deadline on a new app üôÇ Hmm, I wouldn't have time this week while I'm at work. Possibly on the weekend but I wouldn't want to be the one blocking anything üò≥ @sunshinejr, Just saw your comment - thanks for understanding! I'm overwhelmed at the moment but once things cool down I'll definitely come back and contribute.  Hello guys,

so I've discovered this great Library and want to use it with ReactiveCocoa. 

I'm trying to implement Network wrapper based on [this](https://github.com/Moya/Moya/blob/master/docs/Examples/WrappingInAdapter.md). However I'm unable to proceed. 

First of all I don't even know if those callbacks are the right choice when dealing with ReactiveCocoa. 
Also it says "_Invalid conversion from throwing function of type '(_) throws -> ()' to non-throwing function type '(Event<_, _>) -> Void'_"
And lastly it says "_use of unresolved identifier 'error'_"

What am I doing wrong?

```swift
import Moya
import SwiftyJSON

struct Network {
    
    static let endpointClosure = { (target: MyService) -> Endpoint<MyService> in
        let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
        
        // Sign all non-authenticating requests
        switch target {
        case .authenticate:
            return defaultEndpoint
        default:
            return defaultEndpoint.adding(newHTTPHeaderFields: ["Token": GlobalAppStorage.authToken])
        }
    }
    
    static let provider = ReactiveSwiftMoyaProvider<MyService>(endpointClosure: endpointClosure)
    
    static func request(
        target: MyService,
        success successCallback: @escaping (JSON) -> Void,
        error errorCallback: @escaping (_ statusCode: Int) -> Void,
        failure failureCallback: @escaping (MoyaError) -> Void
        ) {
        provider.request(target).retry(upTo: 2).start() { event in
            switch event {
            case let .value(response):
                do {
                    try response.filterSuccessfulStatusCodes()
                    let json = try JSON(response.mapJSON())
                    successCallback(json!)
                }
                catch error {
                    errorCallback(error)
                }
            case let .failed(error):
                failureCallback(error)
            default:
                break
            }
        }
    }
}
``` First of all, thank you for your answer, I really appreciate it. 

Yes, the project is using ReactiveCocoa everywhere, but I'm quite new to that, but I felt making classic closures out of SignalProducers was not the best idea. So thank you for clarification on that. 

Will try to implement composition and will post PR when ready and good.

Also I may bother you with a few questions here and there, if that's okay.

Thank you for now :) 

**Edit**: Although I've successfully managed to get that piece of code working, I was actually creating new SignalProducer and returning that one in next step. So I've figured that this approach wasn't the best one.   Hi everyone,
First of all, thanks for such an awesome library. The problem I am having is to send custom objects as parameters for POST BODY request. For example my endpoint expects the following json format

> {
> user: {
> "email": "a@a.com",
> "address": "xyz"
> },
> "parameter": "value"
> }

In general, it can be a complicated json object that can map to a Swift model X for example.

In Retrofit (the android counterpart), this works out of the box like

> Call<XResponse> xRequest(@Body X request); 

Do we have a tool for implicit json serialization from X to json in Moya?
 Thanks a lot @sunshinejr for help. That did the trick. Actually an unrelated question:

How is 

`return endpoint.adding(newParameterEncoding: JSONEncoding.default)
`

different from

defining parameterEncoding like this

```swift
    public var parameterEncoding: ParameterEncoding {
        switch self {
        case .login, .enrollUser, .resetPassword, .choosePassword:
            return JSONEncoding.default
        default:
            return URLEncoding.default
        }
    }
```

The latter worked for me with Wrap library. Saved my dayÔºÅ Thx  In Xcode 9 (Beta 2) the binaries are instrumented to gather coverage data if a build scheme has "Gather coverage data" option enabled in Test action.
See discussion here for more details: https://forums.developer.apple.com/message/243580

The simplest solution to remedy the issue is to disable "Gather coverage data" option in build schemes, which this commit does. # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1169?src=pr&el=h1) Report
> Merging [#1169](https://codecov.io/gh/Moya/Moya/pull/1169?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/155475bcc517ae6aa0b2c581172ae8c40b16c1d1?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1169/graphs/tree.svg?height=150&token=CjZLHCNgNn&src=pr&width=650)](https://codecov.io/gh/Moya/Moya/pull/1169?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           9.0.0-dev    #1169   +/-   ##
==========================================
  Coverage      75.26%   75.26%           
==========================================
  Files             23       23           
  Lines            748      748           
==========================================
  Hits             563      563           
  Misses           185      185
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1169?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1169?src=pr&el=footer). Last update [155475b...9f2af17](https://codecov.io/gh/Moya/Moya/pull/1169?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1168?src=pr&el=h1) Report
> Merging [#1168](https://codecov.io/gh/Moya/Moya/pull/1168?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/d53c5502913cd3e6a1763b5394a240e5a6d242a8?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1168/graphs/tree.svg?height=150&width=650&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1168?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1168   +/-   ##
=======================================
  Coverage   77.11%   77.11%           
=======================================
  Files          22       22           
  Lines         721      721           
=======================================
  Hits          556      556           
  Misses        165      165
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1168?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1168?src=pr&el=footer). Last update [d53c550...136568b](https://codecov.io/gh/Moya/Moya/pull/1168?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->

First, thank you for this great library. It works pretty nicely. The problem is not coding issue but configuration. It seems that Apple has added some new verification rules for submitted binaries. 
I have an app which uses Moya as a dependency using Carthage.
Carthage config: ```github "Moya/Moya``` resolved Moya version ```8.0.5```

I've built and tested my app and uploaded to iTunes Connect and the upload was successful but the binary processing failed:
```
Dear developer,

We have discovered one or more issues with your recent delivery for "<app name>". To process your delivery, the following issues must be corrected:

Invalid Bundle - Disallowed LLVM instrumentation. Do not submit apps with LLVM profiling instrumentation or coverage collection enabled. Turn off LLVM profiling or code coverage, rebuild your app and resubmit the app.

Once these issues have been corrected, you can then redeliver the corrected binary.

Regards,

The App Store team
```

Of course, it was very difficult to figure out what was the problem. I've check all Xcode settings in my app but didn't find anything suspicious. I've also posted a question in Apple forum: [Invalid Bundle - Xcode 9 Beta 2](https://forums.developer.apple.com/thread/81893?q=Xcode%209%20beta)

Luckily, I've got response from on the Apple forum that was helpful. 
I've went through all my 3rd party library dependencies and checked build settings and build scheme settings for all of them.
During this search I've found that _Moya_, _RxMoya_, _ReactiveMoya_ schemes have ```Gather coverage data``` enabled. 
I needed to disable this settings during the build for all the build schemes (_Moya_, _RxMoya_, _ReactiveMoya_) for Moya to be able to get my app's binary successfully processed by iTunes Connect.

So, I guess we need to turn this setting off otherwise people will fail their binary submission.
 @sunshinejr hi, just created a pull request: https://github.com/Moya/Moya/pull/1169
Please, verify it.   <!--
  0 Errors
  1 Warning: Any changes to library code sh...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProvider.swift | 98 | Function should have 5 parameters or less: it currently has 6 
ReactiveSwiftMoyaProvider.swift | 49 | Function should have 5 parameters or less: it currently has 6 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1164?src=pr&el=h1) Report
> Merging [#1164](https://codecov.io/gh/Moya/Moya/pull/1164?src=pr&el=desc) into [optional-response-thread-param](https://codecov.io/gh/Moya/Moya/commit/8f582715ba6d25c85c3ed9048919697c243c5711?src=pr&el=desc) will **decrease** coverage by `0.11%`.
> The diff coverage is `81.81%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1164/graphs/tree.svg?token=CjZLHCNgNn&height=150&src=pr&width=650)](https://codecov.io/gh/Moya/Moya/pull/1164?src=pr&el=tree)

```diff
@@                        Coverage Diff                         @@
##           optional-response-thread-param    #1164      +/-   ##
==================================================================
- Coverage                           76.51%   76.39%   -0.12%     
==================================================================
  Files                                  22       22              
  Lines                                 728      733       +5     
==================================================================
+ Hits                                  557      560       +3     
- Misses                                171      173       +2
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1164?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/1164?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.27% <100%> (√∏)` | :arrow_up: |
| [...urces/ReactiveMoya/ReactiveSwiftMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1164?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVTd2lmdE1veWFQcm92aWRlci5zd2lmdA==) | `51.72% <100%> (√∏)` | :arrow_up: |
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1164?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `88.7% <75%> (-2.52%)` | :arrow_down: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1164?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1164?src=pr&el=footer). Last update [8f58271...36c9a96](https://codecov.io/gh/Moya/Moya/pull/1164?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=h1) Report
> Merging [#1163](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/155475bcc517ae6aa0b2c581172ae8c40b16c1d1?src=pr&el=desc) will **increase** coverage by `2.77%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1163/graphs/tree.svg?width=650&height=150&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1163      +/-   ##
=============================================
+ Coverage      75.26%   78.04%   +2.77%     
=============================================
  Files             23       23              
  Lines            748      747       -1     
=============================================
+ Hits             563      583      +20     
+ Misses           185      164      -21
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/ReactiveMoya/MoyaProvider+Reactive.swift](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvTW95YVByb3ZpZGVyK1JlYWN0aXZlLnN3aWZ0) | `94.73% <100%> (+63.96%)` | :arrow_up: |
| [Sources/RxMoya/RxMoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhQXZhaWxhYmlsaXR5LnN3aWZ0) | `0% <0%> (-100%)` | :arrow_down: |
| [...ources/ReactiveMoya/ReactiveMoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVNb3lhQXZhaWxhYmlsaXR5LnN3aWZ0) | `62.96% <0%> (-7.41%)` | :arrow_down: |
| [Sources/RxMoya/MoyaProvider+Rx.swift](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvTW95YVByb3ZpZGVyK1J4LnN3aWZ0) | `94.73% <0%> (+10.52%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=footer). Last update [155475b...10ab03c](https://codecov.io/gh/Moya/Moya/pull/1163?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1162?src=pr&el=h1) Report
> Merging [#1162](https://codecov.io/gh/Moya/Moya/pull/1162?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/b8bd7ece12cd80020c8c7a99386a720a74d43041?src=pr&el=desc) will **increase** coverage by `1.05%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1162/graphs/tree.svg?height=150&token=CjZLHCNgNn&width=650&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1162?src=pr&el=tree)

```diff
@@             Coverage Diff              @@
##           9.0.0-dev   #1162      +/-   ##
============================================
+ Coverage      78.04%   79.1%   +1.05%     
============================================
  Files             23      22       -1     
  Lines            747     737      -10     
============================================
  Hits             583     583              
+ Misses           164     154      -10
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1162?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [...ources/ReactiveMoya/ReactiveMoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/pull/1162?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVNb3lhQXZhaWxhYmlsaXR5LnN3aWZ0) | `65.38% <√∏> (+2.42%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1162?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1162?src=pr&el=footer). Last update [b8bd7ec...7e79c58](https://codecov.io/gh/Moya/Moya/pull/1162?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1161?src=pr&el=h1) Report
> Merging [#1161](https://codecov.io/gh/Moya/Moya/pull/1161?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/22e2be5ea3ee137625e079b6afcb5ffd38bab997?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1161/graphs/tree.svg?width=650&token=CjZLHCNgNn&height=150&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1161?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1161   +/-   ##
=======================================
  Coverage   77.11%   77.11%           
=======================================
  Files          22       22           
  Lines         721      721           
=======================================
  Hits          556      556           
  Misses        165      165
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1161?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1161?src=pr&el=footer). Last update [22e2be5...5d292ab](https://codecov.io/gh/Moya/Moya/pull/1161?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1160?src=pr&el=h1) Report
> Merging [#1160](https://codecov.io/gh/Moya/Moya/pull/1160?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/ecd72bae5e97c0c205042f521c5247a0325505d2?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1160/graphs/tree.svg?width=650&src=pr&token=CjZLHCNgNn&height=150)](https://codecov.io/gh/Moya/Moya/pull/1160?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1160   +/-   ##
=======================================
  Coverage   77.11%   77.11%           
=======================================
  Files          22       22           
  Lines         721      721           
=======================================
  Hits          556      556           
  Misses        165      165
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1160?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1160?src=pr&el=footer). Last update [ecd72ba...988397e](https://codecov.io/gh/Moya/Moya/pull/1160?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1159?src=pr&el=h1) Report
> Merging [#1159](https://codecov.io/gh/Moya/Moya/pull/1159?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/9dded0c4a88dea7add6ff01b53c4c2618404d210?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1159/graphs/tree.svg?width=650&token=CjZLHCNgNn&height=150&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1159?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1159   +/-   ##
=======================================
  Coverage   77.11%   77.11%           
=======================================
  Files          22       22           
  Lines         721      721           
=======================================
  Hits          556      556           
  Misses        165      165
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1159?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1159?src=pr&el=footer). Last update [9dded0c...cab54a6](https://codecov.io/gh/Moya/Moya/pull/1159?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1158?src=pr&el=h1) Report
> Merging [#1158](https://codecov.io/gh/Moya/Moya/pull/1158?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/32221eb217c09fb2198b0ff18159fd76527ee4be?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1158/graphs/tree.svg?width=650&token=CjZLHCNgNn&height=150&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1158?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1158   +/-   ##
=======================================
  Coverage   77.11%   77.11%           
=======================================
  Files          22       22           
  Lines         721      721           
=======================================
  Hits          556      556           
  Misses        165      165
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1158?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1158?src=pr&el=footer). Last update [32221eb...c130f63](https://codecov.io/gh/Moya/Moya/pull/1158?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1157?src=pr&el=h1) Report
> Merging [#1157](https://codecov.io/gh/Moya/Moya/pull/1157?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/346af2b3af18a7f09b241b502f646ba9b6ac88fc?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1157/graphs/tree.svg?token=CjZLHCNgNn&src=pr&height=150&width=650)](https://codecov.io/gh/Moya/Moya/pull/1157?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1157   +/-   ##
=======================================
  Coverage   77.11%   77.11%           
=======================================
  Files          22       22           
  Lines         721      721           
=======================================
  Hits          556      556           
  Misses        165      165
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1157?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1157?src=pr&el=footer). Last update [346af2b...9da1083](https://codecov.io/gh/Moya/Moya/pull/1157?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Moya 8.0.0

```swift
func getPersonDetails(personID: String) -> Observable<Person>? {
return Observable.create{ observer in
            let _ = self.provider
                .request(.getPersonDetails(personID: personID))
                .filterSuccessfulStatusCodes()
                .mapJSON()
                .subscribe(onNext: { response in
                    observer.onNext(Person(json: JSON(response)))
                }, onError: { error in
                    print(error.localizedDescription)
                    observer.onError(error)
                })
            return Disposables.create()
            }
        }
}
```
assuming the api will return an error and I can retrieve the error code, how can i retrieve the response json payload?
 @sunshinejr tried your code, but errorResponse.response is nil

```swift
do {
     let errorResponse = error as? Moya.MoyaError
     if let body = try errorResponse?.response?.mapJSON(){
          print(body)
     }
} catch {
     print(error)
}
``` @SD10 
> You can use errorResponse?.errorDescription if you'd like.

i tried printing the `errorResponse?.errorDescription` and the output is `Optional("Response status code was unacceptable: 470.")` 

how to determine which case of MoyaError it is?
 @SD10  ohh i see, is there any workaround so that we could get the error response body without altering Moya? @SD10 ugh looks like i need to write alomofire again üò≠  @ledikari In my case, I use the 9.0.0-dev branch, and no problem for now, it is very stable. (And you have access to the error body:) ) @jeryRazakarison thats an interesting option. I will try to do it.

@sunshinejr any idea on when Moya 9.0 will be released?

edit:

@jeryRazakarison i tried 9 but i see changes. Like what happened to `.filterSuccessfulStatusCodes() .mapObject(type: Balance.self) .mapJSON()` and `.request()` ? they all dissapeared  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1155?src=pr&el=h1) Report
> Merging [#1155](https://codecov.io/gh/Moya/Moya/pull/1155?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/2611d06305b6ddfa6a12766eb59585a28991a256?src=pr&el=desc) will **decrease** coverage by `0.54%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1155/graphs/tree.svg?width=650&src=pr&token=CjZLHCNgNn&height=150)](https://codecov.io/gh/Moya/Moya/pull/1155?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           master    #1155      +/-   ##
==========================================
- Coverage   77.08%   76.54%   -0.55%     
==========================================
  Files          22       22              
  Lines         720      729       +9     
==========================================
+ Hits          555      558       +3     
- Misses        165      171       +6
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1155?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Plugins/NetworkLoggerPlugin.swift](https://codecov.io/gh/Moya/Moya/pull/1155?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvTmV0d29ya0xvZ2dlclBsdWdpbi5zd2lmdA==) | `93.44% <100%> (+0.1%)` | :arrow_up: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/1155?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.27% <0%> (-1.41%)` | :arrow_down: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1155?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1155?src=pr&el=footer). Last update [2611d06...eff08ee](https://codecov.io/gh/Moya/Moya/pull/1155?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  I'm using the latest version of Moya with RxSwift and I've encountered a logical issue for which I can't find a solution, at the moment.

Let's say that I have a `UITableViewController` with a `ViewModel` that implements the following interface:

```swift
protocol ListViewModelType {
	
	var items: Observable<[Item]> { get }
	
}
```

The `items` property is implemented as (using _EVReflection_):

```swift
var items: Observable<[Therapy]> {
		get {
			let provider = RxMoyaProvider<ItemService>()
			return provider
				.request(.all)
				.map(toArray: Item.self)
		}
	}
```

In the `viewDidLoad` method of the `UITableViewController`, I have set up a binding between the `items` property and the `tableView` via the following code:

```swift
self.viewModel.items
			.bind(to: tableView.rx.items(cellIdentifier: cellIdentifier, cellType: cellType)) { row, element, cell in
				// cell configuration code
			}
			.disposed(by: self.disposeBag)
```

Now, I would like to refresh the content of the `UITableView` to reflect changes that the user has done through other parts of the app. Considering that the `RxMoyaProvider` returns an `Observable`, this should be easily done through another value emitted by the `Observable`, but I don't know how to communicate to the provider that it should refresh the content from the server and put it into the same `Observable`.

Am I missing something here? Is there a more recommended way to bind a `UITableView` to a list of objects coming from a `RxMoyaProvider`? Hi @sunshinejr ,

First of all, thanks for your help.

I've also asked [this question](https://stackoverflow.com/questions/44886093/repeat-request-in-rxmoya/44889220?noredirect=1#comment76757503_44889220) on StackOverflow and they came out with a solution very similar to yours (even if, I think that yours is more elegant).

The thing that I don't like of this solution is that I have to declare an Observable (maybe a `Variable`) in each `ViewController` that I manually change and which triggers the refresh on each `ViewModel`. 

Ideally, I would expect to have some sort of _wrapper_ that joins the `RxMoyaProvider` with the resulting `Observable` and exposes a method (something like `redo()` or `request()` once again) that does exactly the same thing, but behind the scenes.

What do you think? Ok, I see the challenge here. Well, let's close this for now. When I'll have some spare time I'll try to push a new branch with some ideas; then we'll be able to discuss if they works and should be merged or not.  <!--
  0 Errors
  2 Warnings: Big PR, try to keep changes sm...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Big PR, try to keep changes smaller if you can</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The <code>Cartfile</code> or <code>Cartfile.resolved</code> was updated, but there were no changes in the <code>podspec</code>. Did you forget updating the <code>podspec</code>?</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=h1) Report
> Merging [#1153](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/80fab6746231f863f941cf489650109ebf7e6384?src=pr&el=desc) will **decrease** coverage by `0.95%`.
> The diff coverage is `50.64%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1153/graphs/tree.svg?token=CjZLHCNgNn&width=650&height=150&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1153      +/-   ##
=============================================
- Coverage      76.22%   75.26%   -0.96%     
=============================================
  Files             22       23       +1     
  Lines            736      748      +12     
=============================================
+ Hits             561      563       +2     
- Misses           175      185      +10
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `84.74% <√∏> (√∏)` | :arrow_up: |
| [Sources/RxMoya/RxMoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhQXZhaWxhYmlsaXR5LnN3aWZ0) | `100% <100%> (√∏)` | |
| [Sources/ReactiveMoya/MoyaProvider+Reactive.swift](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvTW95YVByb3ZpZGVyK1JlYWN0aXZlLnN3aWZ0) | `30.76% <30.76%> (√∏)` | |
| [Sources/RxMoya/MoyaProvider+Rx.swift](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvTW95YVByb3ZpZGVyK1J4LnN3aWZ0) | `84.21% <33.33%> (√∏)` | |
| [...ources/ReactiveMoya/ReactiveMoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVNb3lhQXZhaWxhYmlsaXR5LnN3aWZ0) | `70.37% <73.07%> (+70.37%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=footer). Last update [80fab67...bd4f48d](https://codecov.io/gh/Moya/Moya/pull/1153?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
How to mak a upload request without MultipartFormData?(cause the image is not need)
I have define endpoint and add custom 'Content-type' header, but it's not success

endpoint.adding(httpHeaderFields: ["Content-type": "multipart/form-data; boundary=\(Alamofire.MultipartFormData.BoundaryGenerator.randomBoundary())"])

```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 ```swift
enum Router {
    case test(account: String, image: UIImage?)
}

extension Router: TargetType {
        case .test(let account, let _):
            return ["account": account]
}

var task: Task {
    switch self {
    case .test:
        // Is this right?
        if let multipartBody = self.multipartBody, multipartBody.count > 0 {
            return .upload(UploadType.multipart(multipartBody))
        }
        return .request
    default:
        return .request
    }
}

var multipartBody: [MultipartFormData]? {
    switch self {
    case .test(_, let image):
        guard let uploadImage = image else {
            return nil
        }
        guard let cardFrontImageData = UIImageJPEGRepresentation(uploadImage, 0.5) else {
            return nil
        }
        let imageData = MultipartFormData(provider: .data(cardFrontImageData), name: "serviceImg", fileName: "photo.jpg", mimeType:"image/jpeg")
        return [imageData]
    }
}
```

If the image is nil, the server response 'the current request is not a multipart request'? I have an error with the 'Router test', the image is 'UIImage' optional.
And the  method is 'post'.
I use charles watch the request 'Content-type' is not 'multipartdata'(Actual it's 'formdata'?), so it's error If it's no image, the request 'Content-Type' would be below
Request Headers: ["Content-Type": "application/x-www-form-urlencoded; charset=utf-8"]

And the server arise error.

What I mean is in 'MoyaProvider+Internal.swift' line 89:
`
                case .upload(.multipart(let multipartBody)):
                    guard !multipartBody.isEmpty && target.method.supportsMultipart else {
                        fatalError("\(target) is not a multipart upload target.")
                    }
`
Is this must be MultipartFormData's count > 0? @sunshinejr  
I didn't think of ' Data() ', Thanks  At the moment, the NetworkLoggerPlugin, which is very useful to debug automatically encoded parameters, outputs the `httpBody` as a not-human-readable string (or, in other words, it outputs the string already encoded to be sent via HTTP).

I have modified the NetworkLoggerPlugin plugin to output a human-readable string to simplify debugging.

_Disclaimer: this is my first pull request to such a big project. If this is not the correct way to pull changes to your project, please just tell me and I'll take the necessary steps to follow your rules. I apologize in advance for any error that I might have made._ # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1151?src=pr&el=h1) Report
> Merging [#1151](https://codecov.io/gh/Moya/Moya/pull/1151?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/2611d06305b6ddfa6a12766eb59585a28991a256?src=pr&el=desc) will **decrease** coverage by `0.57%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1151/graphs/tree.svg?width=650&height=150&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1151?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           master    #1151      +/-   ##
==========================================
- Coverage   77.08%   76.51%   -0.58%     
==========================================
  Files          22       22              
  Lines         720      728       +8     
==========================================
+ Hits          555      557       +2     
- Misses        165      171       +6
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1151?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/1151?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.27% <0%> (-1.41%)` | :arrow_down: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1151?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1151?src=pr&el=footer). Last update [2611d06...988caff](https://codecov.io/gh/Moya/Moya/pull/1151?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 Ok, @sunshinejr , I see your point

I've made some changes to allow an arbitrary and optional function to be passed to the constructor that can perform any kind of operation on the `httpBody`.

If nothing is passed, the behaviour is to fallback to your implementation.

The optional function takes the original `Data` object to let the client handle different types of encoding or anything that's not a string. Ok, done! I'm sorry: what's your indentation style? This is what I see on Xcode: I don't see nothing wrong with indentation.

![screen shot 2017-06-30 at 18 11 07](https://user-images.githubusercontent.com/863842/27744362-83a52916-5dbf-11e7-841e-65a40cf7d0b4.png)
  Saw the opportunity to reuse this code while playing with the project. Just a bit of gardening. <!--
  0 Errors
  2 Warnings: Any changes to library code sh...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The library files were changed, but the tests remained unmodified. Consider updating or adding to the tests to match the library changes.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1149?src=pr&el=h1) Report
> Merging [#1149](https://codecov.io/gh/Moya/Moya/pull/1149?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/722eee8dcc8c86f9036333b3461eaca1f8aab537?src=pr&el=desc) will **increase** coverage by `0.57%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1149/graphs/tree.svg?src=pr&token=CjZLHCNgNn&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1149?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           master    #1149      +/-   ##
==========================================
+ Coverage   76.51%   77.08%   +0.57%     
==========================================
  Files          22       22              
  Lines         728      720       -8     
==========================================
- Hits          557      555       -2     
+ Misses        171      165       -6
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1149?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/1149?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `63.67% <100%> (+1.4%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1149?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1149?src=pr&el=footer). Last update [722eee8...66ae6a9](https://codecov.io/gh/Moya/Moya/pull/1149?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  This is a follow-up on #1136 and is based on the current state of #1147. We should not merge this until #1147 was merged and Swift 4 nears completion.

What I have done here is to implement the intention behind #1136 with the new approach we have taken in #1147. Although the code is like I would expect it to work, the Swift compiler (currently) seems not to be able to work with this code. I'm still getting the same error as in #1136, for example:

```swift
case let .request(.jsonEncodable(encodable, encoder)):
    preparedRequest.httpBody = encoder.encode(encodable) // ERROR: Cannot invoke 'encode' with an argument list of type '(Encodable)'
    cancellableToken.innerCancellable = self.sendRequest(target, request: preparedRequest, queue: queue, progress: progress, completion: networkCompletion)
```

If you know how we can work around this issue, then please let me know. I couldn't find a good alternative solution or quick fix for this.

Here's what is done in this PR:

- [x] Add `jsonEncodable` and `propertyListEncodable` cases to `RequestDataType`
- [x] Add `compositeJsonEncodable` and `compositePropertyListEncodable`, too
- [x] Integrate the new cases into the request creation logic

The following are TODOs:

- [ ] Fix the above mentioned compiler error (find alternative)
- [ ] Update Changelog
- [ ] Update Tests
- [ ] Update Documentation <!--
  0 Errors
  4 Warnings: PR is classed as Work in Progr...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          4 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">PR is classed as Work in Progress</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The library files were changed, but the tests remained unmodified. Consider updating or adding to the tests to match the library changes.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProvider+Internal.swift | 103 | TODOs should be avoided (Add exception handling here). 
MoyaProvider+Internal.swift | 111 | TODOs should be avoided (Add exception handling here). 
MoyaProvider+Internal.swift | 120 | TODOs should be avoided (Add exception handling here). 
MoyaProvider+Internal.swift | 129 | TODOs should be avoided (Add exception handling here). 
MoyaProvider+Internal.swift | 139 | TODOs should be avoided (Add exception handling here). 
MoyaProvider+Internal.swift | 159 | TODOs should be avoided (Add exception handling here). 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
  This solution was dicussed starting here:
https://github.com/Moya/Moya/issues/1135#issuecomment-310913115

Specifically this PR does the following:
- [x] Remove `parameters` and `parameterEncoding` from everywhere
- [x] Extend `Task` with different types of request data (e.g. `data` & `compositeEncoded`)
- [x] Flatten the `DownloadType` and `UploadType` enums into the `Task` type
- [x] Use those new task cases to set url params & http body appropriately
- [x] Update Tests
- [x] Update Docs
- [x] Write a migration guide
- [x] Add Changelog entry
- [x] Handle the `TODO:` comments (exception handling) appropriately

This solves the most apparent part of #1135 and it probably also solves #314. <!--
  0 Errors
  1 Warning: Big PR, try to keep changes sm...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Big PR, try to keep changes smaller if you can</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
GiphyAPI.swift | 11 | Force unwrapping should be avoided. 
GiphyAPI.swift | 34 | Force unwrapping should be avoided. 
GiphyAPI.swift | 44 | Force unwrapping should be avoided. 
GitHubAPI.swift | 22 | Force unwrapping should be avoided. 
GitHubAPI.swift | 33 | Force unwrapping should be avoided. 
GitHubAPI.swift | 72 | Force unwrapping should be avoided. 
GitHubAPI.swift | 74 | Force unwrapping should be avoided. 
GitHubAPI.swift | 76 | Force unwrapping should be avoided. 
GitHubAPI.swift | 88 | MARK comment should be in valid format. 
GitHubAPI.swift | 99 | Files should have a single trailing newline. 
GitHubUserContentAPI.swift | 11 | Force unwrapping should be avoided. 
GitHubUserContentAPI.swift | 45 | Force unwrapping should be avoided. 
GitHubUserContentAPI.swift | 43 | Lines should not have trailing whitespace. 
GitHubUserContentAPI.swift | 47 | Lines should not have trailing whitespace. 
GitHubUserContentAPI.swift | 50 | Files should have a single trailing newline. 
MoyaProvider+Internal.swift | 94 | Function should have 5 parameters or less: it currently has 7 
MoyaProviderSpec.swift | 833 | File should contain 400 lines or less: currently contains 833 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
GiphyAPI.swift | 4 | Variable name should start with a lowercase character: 'GiphyProvider' 
GitHubAPI.swift | 16 | Variable name should start with a lowercase character: 'GitHubProvider' 
GitHubUserContentAPI.swift | 4 | Variable name should start with a lowercase character: 'GitHubUserContentProvider' 
GitHubUserContentAPI.swift | 41 | Variable name should start with a lowercase character: 'DefaultDownloadDestination' 
MoyaProviderSpec.swift | 8 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 493 lines 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 I have just integrated my fork into the project where I'm using the `Encodable` type.

Here's how my target now looks:

```swift
import Foundation
import Moya

enum MyTarget {
    case createUser(CreateUserRequest)
    case signIn(SignInRequest)
}

// MARK: - TargetType Protocol Implementation
extension MyTarget: TargetType {
    var baseURL: URL {
        return URL(string: "https://example.com/api/v1/")!
    }

    var path: String {
        switch self {
        case .createUser:
            return "user"

        case .signIn:
            return "session"
        }
    }

    var method: Moya.Method {
        return .post
    }

    var sampleData: Data {
        return Data()
    }

    var task: Task {
        switch self {
        case .createUser(let createUserRequest):
            let requestData = encode(createUserRequest)
            return .request(.data(requestData))

        case .signIn(let signInRequest):
            let requestData = encode(signInRequest)
            return .request(.data(requestData))
        }
    }
}

// MARK: - Helper Methods
extension Tm5Target {
    private func encode<T: Encodable>(_ encodable: T) -> Data {
        do {
            return try JSONEncoder().encode(encodable)
        } catch {
            fatalError("Could not encode '\(type(of: encodable))' using JSONEncoder. Error: \(error)")
        }
    }
}
```

It builds fine and I think it should work (haven't tested yet). But this is how the usage might look now. Just to have something to **review**. @ashfurrow Sure, why not. Think that makes sense. Just rebased onto the current master and added the requested change. The task computed property example from above now looks like this:

```swift
    var task: Task {
        switch self {
        case .createUser(let createUserRequest):
            return .requestData(encode(createUserRequest))

        case .signIn(let signInRequest):
            return .requestData(encode(signInRequest))
        }
    }
``` Shall I flatten the `UploadType` and `DownloadType` enums into the `Task` enum as well? It would be consistent, for sure. But I'm not sure cause there's no pressing issue with them and it would require more people to change their code when updating to a newer version, so I'd understand if we would keep them as is. But we should probably tackle that in a different PR anyways to keep this lean. Any preferences on how to deal with the exceptions thrown in places like this:

```swift
do {
    preparedRequest = try parameterEncoding.encode(preparedRequest, with: parameters)
} catch {
    // TODO: Add exception handling here
}
```

@ashfurrow @sunshinejr ?

I think, I could deal with the other TODO steps left myself, but I'm not sure about that one. Sorry for letting you wait for two weeks, I've been on vacation this entire time. Now that I'm back I've had a look onto your feedback @sunshinejr and commented on them (two of three I fixed). Also I have flattened the upload and download types into the `Task` enum. Unfortunately I will need more help to handle the exceptions properly (the TODOs).

Other than that, is there anything that speaks against merging this except for the TODOs on the initial Post that are still open? If not, then I would proceed implementing the TODOs so we can merge this soon. Okay, I have now worked through my TODOs. Except for the exception handling, I think this is now finished. I've removed the `[WIP]` from the title cause I think it's theoretically mergeable as it is, cause I can imagine the work on the exception handling could be decided upon later and the TODO's kept in code until then, as it is right now.

Btw, when I updated the docs, I've seen that some examples are outdated and I didn't fix that (although my code change has to do with it) cause it is using an old syntax of Alamofire. Specifically I'm talking about https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md

We should think about removing or updating it in a different PR / Issue. Just rebased onto the current master so things are updated (and tests can pass, hopefully). Worked through your comments again and rebased. Are you planning to add this to the current release after the alpha is out? Would be awesome to see this in the next version. :) @SD10 Just worked through your comments, looking forward for your feedback this weekend!

@sunshinejr No problem, just rebased onto `9.0.0-alpha.1`. üéâ  @sunshinejr I worked through your comments, should be all fixed now.

Regarding the CI: I'm running the tests locally but seems like I did not see the demo apps. :)
Those were not building and I actually saw that in one of them there was a multipart upload that also required parameters to be sent along. Since this could also happen on uploading a file, I've added two more cases: `uploadFileParameters` and `uploadMultipartParameters`. @SD10 I've just rebased to master after #1181 was merged and updated the Basic example file. Note that there's one point I'm not sure about ([see here](https://github.com/Moya/Moya/pull/1147/files#r130229006)) ‚Äì other than that I think the file should be ready. @SD10 I've just checked all other example files and found two more which need to be updated: `ArrayAsRootContainer.md` and `OptionalParameters.md`. I've updated the latter but I can't update the first as already explained in my previous comment https://github.com/Moya/Moya/pull/1147#issuecomment-316640623.

I hope this is what you were expecting! FYI: I have just tried adding fix-its via `@available` lines in a reintroduced `MoyaAvailability.swift` file but I couldn't cover any of the cases this PR changes. Specifically my code looked as follows with the reason why it doesn't work as comments:

```swift
import Foundation

extension TargetType {
    @available(*, unavailable, message: "parameters has been removed in version 9.0.0, use new task case .requestParameters instead")
    public var parameters: [String: Any]? { fatalError() } // does not show up in a type conforming to TargetType

    @available(*, unavailable, message: "parameterEncoding has been removed in version 9.0.0, use new task case .requestParameters instead")
    public var parameterEncoding: ParameterEncoding { fatalError() } // does not show up in a type conforming to TargetType
}

extension Task {
    @available(*, unavailable, message: "upload has been removed in version 9.0.0, use new task cases .uploadFile, .uploadMultipart or .uploadCompositeMultipart instead")
    case upload // leads to an error: "Enum 'case' is not allowed outside of an enum"
    // NOTE: Adding in `Task` directly leads to "Switch must be exhaustive, consider adding a default clause" errors
}
``` Thanks @sunshinejr, I've worked through your comments and rebased onto the `9.0.0-dev` branch! # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=h1) Report
> Merging [#1147](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/cd290c7808140f9e4ba2bc15bdd1bce94b3313e4?src=pr&el=desc) will **decrease** coverage by `1.05%`.
> The diff coverage is `58.33%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1147/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1147      +/-   ##
=============================================
- Coverage      79.53%   78.48%   -1.06%     
=============================================
  Files             23       23              
  Lines            738      739       +1     
=============================================
- Hits             587      580       -7     
- Misses           151      159       +8
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/TargetType.swift](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1RhcmdldFR5cGUuc3dpZnQ=) | `100% <√∏> (√∏)` | :arrow_up: |
| [Sources/Moya/MultiTarget.swift](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL011bHRpVGFyZ2V0LnN3aWZ0) | `100% <√∏> (√∏)` | :arrow_up: |
| [Sources/Moya/MoyaProvider+Defaults.swift](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitEZWZhdWx0cy5zd2lmdA==) | `95% <100%> (-0.24%)` | :arrow_down: |
| [Sources/Moya/Endpoint.swift](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL0VuZHBvaW50LnN3aWZ0) | `66.03% <36.36%> (-27.97%)` | :arrow_down: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `67.44% <76%> (+3.76%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=footer). Last update [cd290c7...2216c2f](https://codecov.io/gh/Moya/Moya/pull/1147?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 Thank you everyone for reviewing and going all the way with me. You're the best! üí™ üëè üëç   Adds warning rule to Dangerfile. See #1145 for more details. # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1146?src=pr&el=h1) Report
> Merging [#1146](https://codecov.io/gh/Moya/Moya/pull/1146?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/0dad20e76d13553a2926436e0b5d2ad761167a2d?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1146/graphs/tree.svg?token=CjZLHCNgNn&src=pr&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1146?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1146   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1146?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1146?src=pr&el=footer). Last update [0dad20e...29ab166](https://codecov.io/gh/Moya/Moya/pull/1146?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 Yeah, you are right, it's not very transparent.. Any ideas how to demonstrate functionality? Maybe dummy PR based on this branch?  Nice idea, adds just the one thing missing from my "TODOs" list in PRs like #1147 ‚Äì now I would not need to add those points explicitly, they all are listed in the PR via Danger. üëç 

(Except for "write a migration guide" which, I think, we cannot automate so easily.) If we happen to integrate #1147 (which @sunshinejr mentioned [here](https://github.com/Moya/Moya/issues/1135#issuecomment-310925543)) then it definitely will, cause it removes `parameters` and `parameterEncoding` which everybody using Moya had to implement. :)   # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1142?src=pr&el=h1) Report
> Merging [#1142](https://codecov.io/gh/Moya/Moya/pull/1142?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/5f7c8f62ddfa0cd53c6193e8d6007fcfa8cdea3e?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1142/graphs/tree.svg?width=650&src=pr&token=CjZLHCNgNn&height=150)](https://codecov.io/gh/Moya/Moya/pull/1142?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1142   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1142?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1142?src=pr&el=footer). Last update [5f7c8f6...e559323](https://codecov.io/gh/Moya/Moya/pull/1142?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1140?src=pr&el=h1) Report
> Merging [#1140](https://codecov.io/gh/Moya/Moya/pull/1140?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/80fab6746231f863f941cf489650109ebf7e6384?src=pr&el=desc) will **increase** coverage by `0.01%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1140/graphs/tree.svg?src=pr&token=CjZLHCNgNn&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1140?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1140      +/-   ##
=============================================
+ Coverage      76.22%   76.24%   +0.01%     
=============================================
  Files             22       22              
  Lines            736      745       +9     
=============================================
+ Hits             561      568       +7     
- Misses           175      177       +2
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1140?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/RxMoya/RxMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1140?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhUHJvdmlkZXIuc3dpZnQ=) | `90.47% <100%> (-4.27%)` | :arrow_down: |
| [...urces/ReactiveMoya/ReactiveSwiftMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1140?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVTd2lmdE1veWFQcm92aWRlci5zd2lmdA==) | `56.25% <100%> (+3.7%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1140?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1140?src=pr&el=footer). Last update [80fab67...27bb5ea](https://codecov.io/gh/Moya/Moya/pull/1140?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 <!--
  0 Errors
  1 Warning: The <code>Cartfile</code> or <...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The <code>Cartfile</code> or <code>Cartfile.resolved</code> was updated, but there were no changes in the <code>podspec</code>. Did you forget updating the <code>podspec</code>?</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderIntegrationTests.swift | 35 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 39 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 91 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 101 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 105 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 189 | Lines should not have trailing whitespace. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
  According to issue : #1137  <!--
  0 Errors
  2 Warnings: Any changes to library code sh...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProvider+Internal.swift | 285 | Lines should not have trailing whitespace. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1139?src=pr&el=h1) Report
> Merging [#1139](https://codecov.io/gh/Moya/Moya/pull/1139?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/5f7c8f62ddfa0cd53c6193e8d6007fcfa8cdea3e?src=pr&el=desc) will **decrease** coverage by `0.2%`.
> The diff coverage is `0%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1139/graphs/tree.svg?height=150&width=650&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1139?src=pr&el=tree)

```diff
@@            Coverage Diff            @@
##           master   #1139      +/-   ##
=========================================
- Coverage   76.51%   76.3%   -0.21%     
=========================================
  Files          22      22              
  Lines         728     730       +2     
=========================================
  Hits          557     557              
- Misses        171     173       +2
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1139?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/1139?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `61.71% <0%> (-0.57%)` | :arrow_down: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1139?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1139?src=pr&el=footer). Last update [5f7c8f6...10e8dd2](https://codecov.io/gh/Moya/Moya/pull/1139?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 Is this merge? I have the same problem. @sunshinejr 
Hope you add it soonüç∫ @sunshinejr Could you help @syegin finish this PR and release it asap? We also have the same problem for several APIs.
At the moment, I have to manually create MultiFormData like PR in API Target.  Hi,

I am using Moya 8.0.5 and i want to add custom http headers to the request. But still i couldn't found a way to achieve this while conforming to the TargetType protocol.

<!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 Thank you very much. It helps üëç   I've noticed a bug in my project and using Moya 8.0.5.

In endpoint closure, I'm adding some additional parameters and request tasks working as expected. However, one of my task which is an upload multipart, missing these additional parameters. After some debugging, i figured out that:

```swift
if let parameters = target.parameters {
                parameters
                    .flatMap { key, value in multipartQueryComponents(key, value) }
                    .forEach { key, value in
                        if let data = value.data(using: .utf8, allowLossyConversion: false) {
                            form.append(data, withName: key)
                        }
                }
            }
```
In sendUploadMultipart function of MoyaProvider+Internal, formatdata is appending 'target.parameters', not 'endpoint.parameters'. By passing endpoint to function, the problem goes away. Btw, It'is a similar issue with #1066

@sunshinejr, it seems we can't add parameters directly to multipartformdata array just because it's a let constant. But we can generate a new multipart array adding endpoint's parameters with an array extension or a function. Maybe this:

```swift
private extension Array where Element == MultipartFormData {
    
    func appendParameters(_ parameters: [String:Any]?) -> [MultipartFormData] {
        var formData = self
        if let parameters = parameters {
            parameters
                .flatMap { key, value in multipartQueryComponents(key, value) }
                .forEach { key, value in
                    if let data = value.data(using: .utf8, allowLossyConversion: false) {
                        formData.append(MultipartFormData.init(provider: .data(data), name: key))
                    }
            }
        }
        return formData
    }
}
```

And our function call turns to this: 

```swift
cancellableToken.innerCancellable = self.sendUploadMultipart(target, request: preparedRequest, queue: queue, multipartBody: multipartBody.appendParameters(endpoint.parameters), progress: progress, completion: networkCompletion)
```

And finally we need to delete the part that adding target.parameters in sendUploadMultipart function. I've also tested it and worked in my project. I can make these changes you wish, no problem. Thanks for this great library btw :)  This is an exploration of my idea explained in #1135 which fixes the same issue.

Unfortunately, I'm getting an error which renders this PR useless as it is right now:
> Cannot invoke 'encode' with an argument list of type '((Encodable))'

This error appears in places such as 
```swift
request.httpBody = try? JSONEncoder().encode(encodable)
```
since the `encodable` parameter is of a generic type (`Encodable`).

Does anybody have a good solution for preventing this issue? Then I can continue exploring this.

Note that I have removed all convenience methods for `parameters` and `parameterEncoding` as a first step. We could (and probably should) reintroduce them later. Also I have not yet included a solution for the side-requirement of fixing #314 (which we could tackle using the same approach as well as explained [here](https://github.com/Moya/Moya/issues/1135#issuecomment-310677003)). I think we should discuss that in a subsequent PR.

**TODOs:**
- [x] Explain the basic idea using code
- [ ] Make the code usable
- [ ] Update the Docs
- [ ] Update the Tests
- [ ] Write a migration guide
- [ ] Write a changelog entry <!--
  0 Errors
  4 Warnings: PR is classed as Work in Progr...
  0 Messages
  0 Markdowns
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          4 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">PR is classed as Work in Progress</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The library files were changed, but the tests remained unmodified. Consider updating or adding to the tests to match the library changes.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 For now, yes. But note that this included **real** support for the Encodable types, so we might want to add something like that later. But this, yes, this is now deprecated and should be closed. Let's wait what Alamofire does in order to support the `Encodable` type as September comes closer ... I've created #1148 which is a simple reincarnation of this PR, but based on the approach we have introduced in #1147. I know we might not need it at all if Alamofire integrates it somehow themselves. But if they don't we might need it.

Also, I'd like learn why I get the compiler error in there and how to work around it anyways, so I've also created it because of technical reasons. I'd like to at least play around with that API and see if it works well from the consumer side. Maybe the Alamofire guys introduce support, but we don't like it? You never know ... üòÑ   I'm currently writing an app to be **released after the official release of iOS 11** that'll only support iOS 11 onwards. So naturally I'm using the **Xcode 9** betas and I've also decided to write code in **Swift 4** from the beginning. What I try right now is to combine the great new possibilities with the **`Encodable` and `Decodable` protocols with Moya**. While there's #1118 for adding native support for the `Decodable` protocol, I'm currently **struggling with the `Encodable` protocol**.

My idea was to **encapsulate the request parameters into it's own type** (they are completely different than the response data, so it's `Encodable` only):

```swift
struct SignInRequest: Encodable {
    // MARK: - Sub Types
    struct AppInfo: Encodable {
        let clientName: String
        let clientVersion: String
        let platformName: String
        let platformVersion: String
        let pushToken: String?
    }

    // MARK: - Stored Instance Properties
    let appInfo: AppInfo
    let username: String
    let password: String
}
```

My API target looks like this:

```swift
enum MyTarget {
    case signIn(SignInRequest)
    case profile(String) // example for classical approach
}
```

Now when making `MyTarget` conform to `TargetType` I have to provide the `parameters` and `parameterEncoding` computed properties. But the `parameters` have a return type of `[String : Any]?` which I can't create using `JSONEncoder` and also the API of `ParameterEncoding` is not flexible enough to write an own type that would conform to it and use the new `Encodable` inference from Swift 4.

**What I need** would be something like this as a _replacement_ of `parameters` and `parameterEncoding`:

```swift
var requestData: RequestData? {
   switch self {
   case .signIn(let request):
       return .jsonEncodable(request)

   case .profile(let id):
       return .parameterEncoding(["id": id], URLEncoding.default)
   }
}
```

For this to work, we would need to add a `RequestData` type like so:

```swift
enum RequestData {
    case jsonEncodable(Encodable)
    case parameterEncoding([String: Any], ParameterEncoding?) // a default parameter encoding could be provided in the TargetType, too (with an empty default implementation)
}
```

What do you think? I think we should definitely support `Encodable` types as first class citizens as many people will use them instead of mappers. The only question is, how can we make the `TargetType` flexible enough to support them?

Any ideas around how I could get this work with Moya 8.0 would be appreciated as well (for the time until this issue is fixed). Or did I miss something and can use `Encodable` already somehow in a good way? Cause AFAIK Moya is intended to be as flexible as possible. The fact that `JSONEncoder` returns Data ist exactly **the reason** why I've created `RequestData`. Its purpose is to allow both variants, the "classic" variant with `parameters` and `parameterEncoding` **and** using the `JSONEncoder` and its Data return type. With little changes elsewhere too this should allow us to use the above example to specify APIs.

I think the biggest drawback about this approach is the fact that it's a breaking change and everybody would need to use the `requestData` instead of `parameters` and `parameterEncoding`. Also note that it's not so easy any more to group same `parameterEncoding` cases together to just return once, but usually that should not be a problem when we add an option to define a `defaultParameterEncoding`.

I know I can fork this (although I could also create a branch within this repo), but I'd like to get some feedback first as we could tackle this problem in many different ways. Anybody else who needs this? @BasThomas why do you "really need a `[String: Any]` for parameters."? I see that it's the case right now (and also with Alamofire) but you could implement a new ParameterEncoding that takes a `Data` object instead of `[String: Any]` as its input. 
I really think that the built-in`Encodable` and `Decodable` protocols are the way to go forward. @mbuchetics I agree that `Encodable` is the way to go forward. But we also have to consider that people are using Moya in their released apps and migration should not be too hard. We should not force Moya consumers to use `Encodable`, there will still be valid reasons not to use that approach.

So, we can't simply drop the parameters without an alternative (IMHO), thus I'm still keeping them with my `RequestData` wrapper. What I try is to abstract away the return type of the params and making it flexible with my `RequestData` enum. There could be a different return type for each case, e.g. `Data` for `.jsonEncoder` and `[String: Any]` for Alamofires `parameterEncoding`. It just needs to be handled somewhere down in Moya. `Data` should be straightforward to handle though, as URLRequest has native support for setting the body via `Data` (which is probably also the reason why the `.encode` method of `JSONEncoder` has a return type of `Data`, I guess). I'm going to implement my above suggestion then, as it seems I did not misunderstand the issue here. This way we can figure out if we can come up with an even better solution to this problem or keep my approach. I'm gonna try to post an initial PR until sometime tomorrow. I like your approach with the enum. 

Another approach would be to keep the `parameters` as is and add an additional `data` property on `TargetType`. A new ParameterEncoding, let's call it `DataEncoding` could take the data and simply set it as `HTTPBody` whereas other encodings could behave the same way they are doing right now.
This would not break any existing code.

But I wouldn't worry to much about breaking existing apps if the migration is simple and easy to do. There were changes of this scope before (`ParameterEncoding`, `task`). Thanks for the alternative. I've already thought about this solution. The problem with it is, that when having both type of API endpoints, the developer has to ensure that all cases of the TargetType are covered and split correctly between the two options. I think the risk that developers forget a case or specify two different types for a case is very high and would lead to some kind of error or unexpected behavior. That's why I introduced the enum, which is a little more code to write but prevents any such issues. You are correct with the added complexity.
However, I don't think yo necessarily need to split it up between the two options. There could be a case where you would want both, the `parameters` and the `data`, e.g. if you have a request that needs both, a URL query string and a HTTP body. So far, it always required workarounds such as https://github.com/Moya/Moya/issues/314
The `ParameterEncoding` could decide whether it uses `parameters`, `data` or both. 

But as I said before, I also like your enum solution. Hmm, I see your point now. I've actually used that workaround, too. üòÑ

So, let's think about this for a second. Until now we had to provide `[String: Any]?` and we could only specify one type of `parameterEncoding`. My approach does abstract away the type of `[String: Any]?` by using `RequestData` as the return type ‚Äì but I'm still keeping the fact that you can only specify one.

What if we just changed the return type to `[RequestData]` so people could potentially return multiple of them? Does that make sense? Are there any other cases except for the URL params and body case where this would be useful? Cause if not, I tend to say that a return type of `[RequestData]` would be too confusing for many and would open the door for misuse cause people could put any number of things in there.

In my opinion we should rather cover the one exception case with special treatment rather than make the return type an array if there's no other useful case. (Although I'm not strongly opinionated on that.) But if there's another useful case that we can think of, I think it makes sense to implement it that way. What do you think?

Also what's the take of other @Moya/contributors on this issue and ideas on how to approach it? I think this is a core change and therefore should be validated by more contributors. Here's an idea on how we could cover the one case with url params and body data with my approach:

```swift
enum RequestData {
    case jsonEncodable(encodable: Encodable)
    case parameterEncoding(parameters: [String: Any], parameterEncoding: ParameterEncoding)
    case urlAndBodyParameterEncoding(urlParameters: [String: Any], bodyParameters: [String: Any], bodyEncoding: ParameterEncoding)
}
```

The case `urlAndBodyParameterEncoding` would specify both URL parameters **and** body parameters. The body parameter encoding can be further specified (so people can choose between `JSONEncoding`, `PropertyListEncoding` or any of their custom encoding).

I think this is a better approach than to expect a return type of `[RequestData]` and works well with my approach explained on my initial post. I think the combination of URL query parameters and an Encodable would also
be useful.
Not sure if those rather obscure variants should be in the enum or if there
is a better way to handle those.

On 23 June 2017 at 16:16:49, Cihat G√ºnd√ºz (notifications@github.com) wrote:

> Here's an idea on how we could cover the one case with url params and body
> data with my approach:
>
> enum RequestData {
>     case jsonEncodable(encodable: Encodable)
>     case parameterEncoding(parameters: [String: Any], parameterEncoding: ParameterEncoding)
>     case urlAndBodyParameterEncoding(urlParameter: [String: Any], bodyParameters: [String: Any], bodyEncoding: ParameterEncoding)
> }
>
> The case urlAndBodyParameterEncoding would specify both URL parameters
> *and* body parameters. The body parameter encoding can be further
> specified (so people can choose between JSONEncoding, PropertyListEncoding
> or any of their custom encoding).
>
> I think this is a better approach than to expect a return type of
> [RequestData].
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/1135#issuecomment-310677003>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAM6_XeB_Z613PyljaFNBJQ8uSkY13LOks5sG8jRgaJpZM4OCUcf>
> .
>
 What is it that makes you think they‚Äòre obscure? Their name? And wich ones, only the last one, right? I've created an initial PR in #1136 to implement my approach. Please have a look ‚Äì I'm not sure yet if it even works. Thus, your feedback is welcome! I agree that it would make sense to have this supported via Alamofire and I am surprised that there is no discussion of this over there already. 
Why do you think that Swift 4 has a long way to go? I think the new feature are all defined and most of them implemented, so I'd rather see them supported in Moya sooner than later. The transition to Swift 4 will be a lot quicker than with Swift 3. Why wait for this feature until September/October? The Encodable type will most likely not change at all as it was showed off during WWDC in detail without any hint on any possible changes that are planned to be made. I agree that any Alamofire-internal change would be welcome to cover this, but why not support this in a branch and further explore what else could be tackled by this approach, cause until now we are pretty dependent on Alamofires parameters solution, which was also the reason why #314 still isn‚Äòt really solved.

 If we really want to depend on Alamofire on this, we should at least get the opinion of its contributors on supporting `Encodable` before we decide that we just wait. Cause my gut feeling is that we might need to add some kind of enum into Moya anyways cause their solution might not be via the parameters and parameterEncoding, we just don‚Äòt know and could wait for nothing in the end. I'm in for the idea of introducing a **more flexible parameter providing approach** in general and using this to simplify the `task` along the way. That could even cover the usage of `Encodable` by default (without any specific changes for that). I'm not sure though what all the cases mean that you are providing. Specifically:

1. In the case of `parameters([String: Any])` in `RequestType` ‚Äì how are the params encoded, URL for GET and JSON for others by default? Or URL encoded always per default? Or something else?
2. What are all the cases in `DownloadType`? I'm guessing that `destination(DownloadDestination)` replaces the existing `request(DownloadDestination)`? What are the others then?
3. In `DownloadType` for the case `case composite(urlParameters: [String: Any], bodyParameters: [String: Any])`: How do we know the encoding to be used for encoding the body parameters?

Also, given we would tackle the above change, I think as a consequence quite some parts of the code & tests need to be changed & updated. Do you have an idea on how we could split the introduction of them into separate PRs so we don't have one big PR? **Regarding Point No. 1**

I understand what you mean. I think expecting there to be a `defaultParameterEncoding` present for this case will be hard for the user to understand/memorize.

Here's my **alternative suggestion:**

Let's add a `defaultParameterEncoding` to the `TargetFile` and provide a default implementation for it that simply returns `URLEncoding.default`.

Additionally let's entirely remove the `parameters([String: Any]` case. Instead users would be able to use the case `encoded(parameters: [String: Any], encoding: ParameterEncoding)` and provide `defaultParameterEncoding` for the `encoding:` parameter of that case. This would prevent any confusion and even make the existence/usage of the encoding explicit. Regarding Point No. 2: I understand now and this totally makes sense (sounds like it was quite annoying to specify params alongside a download request?).

Regarding Point No 3: Okay, let's add the bodyEncoding there then. If we use my `defaultParameterEncoding` suggested above, this would be useful here, too. Please note that there is now https://github.com/Alamofire/Alamofire/issues/2181 around which tracks support for the `Encodable` type right within Alamofire. As it is our main dependency, I think their approach to integrate this feature should be considered before finally deciding on how to implement this.

Please also note that the contributors have already **confirmed** that they have plans to support both `Encodable` and `Decodable` types in release version 5 in https://github.com/Alamofire/Alamofire/issues/2177. I've just created #1147 which implements @sunshinejr's suggestions with my suggested changes above. Note that I decided to make two more changes than explained above:

1. Rename `RequestType` to `RequestDataType` since there was a name collision with a type in the Result framework
2. I've split `composite` up into `compositeEncoded` and `compositeData` since that is more consistent in my opinion (someone might need url parameters using `Data` as well)

Here's what the above four types now look like:

```swift
/// Represents a type of upload task.
public enum UploadType {

    /// Upload a file.
    case file(URL)

    /// Upload "multipart/form-data"
    case multipart([MultipartFormData])
}

/// Represents a type of download task.
public enum DownloadType {

    /// Download a file to a destination.
    case destination(DownloadDestination)

    /// Download a file to a destination with extra parameters using the given encoding.
    case encoded(DownloadDestination, parameters: [String: Any], encoding: ParameterEncoding)
}


/// Represents an HTTP task.
public enum Task {

    /// A basic request task.
    case request(RequestDataType)

    /// An upload task.
    case upload(UploadType)

    /// A download task.
    case download(DownloadType)
}

/// Represents a type of request.
public enum RequestDataType {

    /// A requests body set with data.
    case data(Data)

    /// A requests body set with parameters and encoding.
    case encoded(parameters: [String: Any], encoding: ParameterEncoding)

    /// A requests body set with data, combined with url parameters.
    case compositeData(urlParameters: [String: Any], bodyData: Data)

    /// A requests body set with parameters and encoding, combined with url parameters.
    case compositeEncoded(urlParameters: [String: Any], bodyParameters: [String: Any], bodyEncoding: ParameterEncoding)
}
``` This was fixed via #1147.   We migrating our old code to Swift 2.3 and facing this issue. How to change to RequestResultClosure? 
Thanks,

```.swift
//Old Code with NSURLRequest
let requestClosure = { (endpoint: Endpoint<T>, closure: (NSURLRequest -> ())) in
        let urlRequest: NSMutableURLRequest = NSMutableURLRequest(URL: endpoint.urlRequest.URL!, cachePolicy: endpoint.urlRequest.cachePolicy, timeoutInterval: endpoint.urlRequest.timeoutInterval)
 
        closure(urlRequest)
    }
//New Code with RequestResultClosure
let requestClosure = { (endpoint: Endpoint<T>, closure: (MoyaProvider.RequestResultClosure -> ())) in
        let urlRequest: NSMutableURLRequest = NSMutableURLRequest(URL: endpoint.urlRequest.URL!, cachePolicy: endpoint.urlRequest.cachePolicy, timeoutInterval: endpoint.urlRequest.timeoutInterval)
 
       
        closure(urlRequest)// How to pass RequestResultClosure ?
    }


``` Thanks @sunshinejr . I got swift 2.3 closure [Tag 7.0.4](https://github.com/Moya/Moya/blob/7.0.4/Demo/Tests/MoyaProviderSpec.swift#L222-L227)
```.swift
//Old Code with NSURLRequest Swift 2.2
let requestClosure = { (endpoint: Endpoint<T>, closure: (NSURLRequest -> ())) in
        let urlRequest: NSMutableURLRequest = NSMutableURLRequest(URL: endpoint.urlRequest.URL!, cachePolicy: endpoint.urlRequest.cachePolicy, timeoutInterval: endpoint.urlRequest.timeoutInterval)
 
        closure(urlRequest)
    }
//New Code with RequestResultClosure Swift 2.3   Repository Tag 7.0.4
let requestClosure = { endpoint, closure in
        let urlRequest: NSMutableURLRequest = NSMutableURLRequest(URL: endpoint.urlRequest.URL!, cachePolicy: endpoint.urlRequest.cachePolicy, timeoutInterval: endpoint.urlRequest.timeoutInterval)
 
        closure(.Success(urlRequest)
    }
```  20150520 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1132?src=pr&el=h1) Report
> Merging [#1132](https://codecov.io/gh/Moya/Moya/pull/1132?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/5f7c8f62ddfa0cd53c6193e8d6007fcfa8cdea3e?src=pr&el=desc) will **decrease** coverage by `2.71%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1132/graphs/tree.svg?token=CjZLHCNgNn&src=pr&height=150&width=650)](https://codecov.io/gh/Moya/Moya/pull/1132?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           master    #1132      +/-   ##
==========================================
- Coverage   76.51%   73.79%   -2.72%     
==========================================
  Files          22       22              
  Lines         728      729       +1     
==========================================
- Hits          557      538      -19     
- Misses        171      191      +20
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1132?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/RxMoya/RxMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1132?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhUHJvdmlkZXIuc3dpZnQ=) | `42.1% <0%> (-52.49%)` | :arrow_down: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1132?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1132?src=pr&el=footer). Last update [5f7c8f6...ef0eb93](https://codecov.io/gh/Moya/Moya/pull/1132?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Hello,

Is it possible using Moya to perform an URLSessionUploadTask in background to send for example image even if the user return to home?

Thanks in advance! Thank you @sunshinejr! It's exactly what I was searching about.  Hi i am using swift 3. ios 10 and xcode 8.2.
i am calling two function hitAPIForSignUp() and  hitAPIForGetUserProfile(). second one is working but first one is not PLEASE guide me what i am doing wrong here.

```swift
import UIKit
import SwiftyJSON
import Alamofire
import SJSwiftSideMenuController


func hitAPIForSignUp(){
        let BASE_URL = "http://fireworksmobile.com/hiton/api/"

let SIGN_UP_API = "educator/register_educator.php?"






         let apiSignUp = BASE_URL + SIGN_UP_API
        
       
        
        let email = "abc1@gmail.com"
        let password = "12345"
        let centername = "biselahore"
        let city = "lahore"
        let state = "pakistan"
        let contactno = "03224056920"
        let address = "walton lahore"
        
        
        
       
        
        let date = "1495707285"
        let vc = "dbb9748ac4a0fb1f04674abcd4af681c"
       // let custid = "2"
        
        var siggnUpRUL = apiSignUp
        
        
        siggnUpRUL.append("date=")
        siggnUpRUL.append(date)
        
       
        
        siggnUpRUL.append("&vc=")
        siggnUpRUL.append(vc)
        
        siggnUpRUL.append("&email=")
         siggnUpRUL.append(email)
        
      
        siggnUpRUL.append("&centername=")
        siggnUpRUL.append(centername)
        siggnUpRUL.append("&contactnumber=")
        siggnUpRUL.append(contactno)
        siggnUpRUL.append("&address=")
        siggnUpRUL.append(address)
        
        
        siggnUpRUL.append("&pass=")
        siggnUpRUL.append(password)
        siggnUpRUL.append("&city=")
        siggnUpRUL.append(city)
        siggnUpRUL.append("&state=")
        siggnUpRUL.append(state)
        
        

     
        
        NetworkManager.NETWORK_MANAGER.postDataToServerAndGetResult(data: nil, API: siggnUpRUL){
            
            (result: JSON) in
            
            print("got back: \(result)")
            
        }
        
    }



func postDataToServerAndGetResult(data:NSDictionary?, API:String, onCompletion: @escaping (JSON) -> Void) {
        
        var tempResponse : JSON = JSON.null
        var request = URLRequest(url : URL(string: API)!)
       // let myURL = URL(string: API)!
        //var request: URLRequest = URLRequest(url: myURL as URL)
        
       
        
        request.httpMethod = "POST"
        
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        
        Alamofire.request(API, method: .post, parameters: nil, encoding: URLEncoding.default)
            .responseJSON { response in
                
                switch response.result {
                    
                case.success(let data):
                    print("Successfully grabbed response", data)
                    tempResponse = JSON(data)
                    print("Response is ", tempResponse)
                    onCompletion(tempResponse)
                    
                case.failure(let error):
                    print("request failed with error \(error)")
                    onCompletion(nil)
                    
                }
                
        }
        
        
    }
```

This function is working but hitAPIForSignUp() not working even code is same.

```swift
func hitAPIForGetUserProfile(){

        let GET_CUSTOMER_PROFILE_API = "educator/profile_educator.php?"
        let api = BASE_URL + GET_CUSTOMER_PROFILE_API
        let date = "1495707285"
        let vc = "dbb9748ac4a0fb1f04674abcd4af681c"
        let custid = "2"
        
        var completeURL = api
        
        completeURL.append("date=")
        completeURL.append(date)
        
        
        completeURL.append("&vc=")
        completeURL.append(vc)
        
        completeURL.append("&custid=")
        completeURL.append(custid)
        
        
        
        NetworkManager.NETWORK_MANAGER.postDataToServerAndGetResult(data: nil, API: completeURL){
            
            (result: JSON) in
            
            print("got back: \(result)")
            
        }
        
    }
``` Hi @BasThomas  Yes i am not using Moya. @ranayahya It's difficult to tell with the code you posted, possibly this line:
```Swift
var request = URLRequest(url : URL(string: API)!)
```
Aside from that, it's best if you don't open issues under open source projects you're not using. 
The maintainers put a lot of time and effort into resolving issues and don't need extra unrelated work.

That being said, I recommend asking these types of questions on: [stackoverflow](https://stackoverflow.com). It is perfect for this üëç Good luck!  Hello 

I have a .post request with parameters to be sent in url like following:
http://xxxxx/token?userName=Mike&password=123
but the "?" is encoded to "%3F" 
http://xxxxx/token%3FuserName=Mike&password=123

I tried putting them in the parameters, but in .post requests it is sent as body not url parameters

Any Help please? it works! Thanx a million for your fast response @sunshinejr I have tested it but the url is send empty without the parameters. what can be the issue with this ? me too and .queryString is useless   Agree with Thomas!  @pedrovereza I think `URLRequestConvertible` should be marked as open instead of internal to custom parameterEncoding.

Or if is there any other elegant way to custom parameterEncoding?  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1127?src=pr&el=h1) Report
> Merging [#1127](https://codecov.io/gh/Moya/Moya/pull/1127?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/aa33a0466d7333516691b3e5212c5acb41990928?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1127/graphs/tree.svg?width=650&height=150&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1127?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1127   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1127?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1127?src=pr&el=footer). Last update [aa33a04...74f910f](https://codecov.io/gh/Moya/Moya/pull/1127?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  I'd like to bring back an old subject: #425, I know it has been closed but since there was a solution suggested, I think it could be worth a second though!

In the current state of Moya, everyone has to implement `sampleData` in the `TargetType`. It's great to make testing APIs easy, but I don't think it's right to have to embed the stubbed response directly in the app instead of having them only in the tests target.

I know there was a few potential workaround for this in #425, but they all comes with downsides: won't work anymore on simulators, breaks the target types basic flow...  In the end, I completely agree with Hirad's solution: adding a `sampleData` response to `StubClosure`, and removing `sampleData` from `TargetType`. 

One downside that Ash brought up: it won't encourage people to add tests, but I do think, if people doesn't want to test, they will just return `Data()`. So, in the end, I see more advantages of this implementation than the current one (except that it's introducing a breaking change).

Could it become a reality soon? üôÉ  I completely agree with @tbaranes. I find the inclusion of testing code directly in the app unpalatable. As someone who is passionate about testing, I would like to have this separation of concerns.

I don't really believe testing is a practice that can be encouraged through an API. If one does not see the benefit of or appreciate writing tests, they are simply are not going to do so.

Furthermore, from the perspective of responsibility, I think it makes far more sense for `sampleData` to be the concern of the `Provider` as opposed to the `TargetType`. 

 I was, for a long time, of the "let's encourage testing" mindset, but these days I'm leaning more towards having a good separation of concerns, and hoping people choose to take the time to have stubbed responses (but it's up to them).

I think including it in the provider makes a ton of sense, I'm on board with this change. I'm always trying to test my apps, and I usually do. But I have never used the `sampleData` for that. If I want to test parsing JSON data into my Swift objects, I write specific tests for that ‚Äì it's part of the model then, though. If I want to test that the API answers the way I expect it to, `sampleData` doesn't help with that either.

I've never found good usage for the `sampleData` anyways, so nowadays I'm actually defaulting to `return Data()`, too. Maybe I missed something about stubbing, but from my point of view other tests are much more useful, so I'd welcome this change! By the way, why are we not using the GitHub Projects feature to manage what goes into our next releases? That would give us a good overview and prevent using a PR like https://github.com/Moya/Moya/pull/1124 for that. Or are there any concerns? Ahh, I overlooked the milestones. That's a good alternative, of course.

To keep the discussion to this topic: Could we add this issue to the milestone 9.0.0 board until it proves to be more complicated than it currently looks? Cause this change doesn't look overly complex to me. üòÑ  I tried taking a crack at it. If we use the approach of adding a response to `StubClosure`:
``` Diff
-typealias StubClosure = TargetType -> Moya.StubBehavior
+typealias StubClosure = TargetType -> (Moya.StubBehavior, Response)
```
This requires that `StubClosure` is also passed to the method `defaultEndpointMapping(target:)`.

This is because `defaultEndpointMapping(target:)` is a class method so I won't have access to the `stubClosure` instance property to get the data for the `sampleResponseClosure`. It is currently just receiving the `sampleData` from the `TargetType`.

I think this is the only thing a little awkward about this approach.

Another thing to point out, what I didn't like is how it broke a lot of the tests that were written without the use of a `MoyaProvider`. If a test is written using just an `Endpoint` then we have no way to retrieve `sampleData` because the current implementation gets it from the  `TargetType`.

I would have to create some sort of namespace in my TestTarget to store all the `sampleData` in order to remove the resulting boilerplate code.

Any insight, suggestions, and corrections are appreciated üòÖ  What about providing a default implementation for `sampleData` in `TargetType`:
```swift
extension TargetType {
   var sampleData: Data {
      return Data()
   }
}
```
I think this is the implementation that most people who are not using testing are doing already: 
Why not make it default?

Then in the Test Target people can provide a new implementation for `sampleData`:
```swift
// Example TargetType used in App
enum MyAppTargets: TargetType {
    case zen
}

// Test Target Implementation
extension MyAppTargets {
    var sampleData: Data {
        // return sample data for testing
    }
}
```
I think this is a far easier way to remove test code from the Main Target and less damaging to the API. However, if we're concerned about moving `sampleData` to the provider from a responsibility perspective then this is not a valid solution. @pedrovereza I don't know if this is a hard rule but if Moya is no longer going to force people to write networking tests then this seems like a good case for a default implementation.

I'd also like to point out the contrast that the `MoyaProvider` has the default behavior of `StubBehavior.never` -- it makes sense to default `sampleData` to `Data()` to match this.

From #861 this is an excerpt by @scottrhoyt:

> As for sampleData, even as an ardent unit tester, I think there is a difference between first-class support of unit testing and first-class forcing people to write testing code. We all know very few projects get started with full test suites in place. If tests do eventually get added, it is often done at a later date (i.e. not much TDD going on). The amount of Moya code that starts off with
```swift

var sampleData: Data {
  return Data()
}
```
> considerably outnumbers the amount of code that is using sampleData in it's intended fashion. This search backs that up at least for public repos. By adding even a little bit of friction to selecting Moya as your networking layer because of it's verbosity and forcing of unit testing code into your app, we just encourage people to go a different route that will be harder for them to add unit tests once they get to the point that they realize they need it. While it is admirable to say that we can change testing etiquette by forcing people to implement sampleData, the reality is that it's still just a--confusing for anyone that isn't familiar with Moya--Data() away from being ignored and that is what most people are doing. Changing testing behavior will require a bigger impetus than a single networking library, but every single networking library should still support it in some way. Frankly I think Moya should go further to support testing by providing an easy way for test data to be stored in fixtures because if you want to use real returns from even a moderate-complexity API, the TargetType code quickly gets bloated back to unreadable status.

It's a large read but my takes from it are:
- Forcing people to implement `sampleData` makes it harder to get Moya up and running
- `sampleData` is required prematurely (long before unit tests are written)
- Having `sampleData` in the `TargetType` bloats the file, especially with a complex API
 I've also been considering the possibility of a `TestTargetType` protocol:
```swift
protocol TestTargetType: TargetType {
    var sampleData: Data { get }
    var stubBehavior: Moya.StubBehavior { get }
}
```
Moya users can then conform to this protocol inside of their testing target. This adds the benefits of:
- moving `sampleData` to the Test Target
- allows more fine grain control over `stubBehavior` eg.) stubBehavior based on specific target case

Moya provider could then route a request based on whether a Target is a `TestTargetType`:
```swift
extension MoyaProvider where Target: TestTargetType {

    func requestNormal(_ target: Target, queue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -> Cancellable {
        // Return stubbed response
    }
}
```
This could even improve the MoyaProvider because if the target is not a `TestTargetType` then the provider knows it doesn't have to handle anything regarding stubbing. You could remove something like the `StubClosure` from the initializer of the `MoyaProvider` as well. @SD10 I completely agree with your proposal of adding a separate protocol that we can extend from our `TargetType` to provide the `sampleData` and other testing behavior. In production (mainly with heavy data exchange applications), provide those, for example, json files into the application and adding MB of useless code is a heavy drawback... For now I have to provide a `Data()` default to `sampleData` to avoid this, but I want to test it as well...  Moya have four submodule, `Moya/Core`, `Moya/RxSwift`, `Moya/ReactiveCocoa` and `Moya/ReactiveSwift`, the default submodule is `Moya/Core`. (`Moya/ReactiveCocoa` and `Moya/ReactiveSwift` have the same meaning, maybe we do not need `Moya/ReactiveCocoa` any more . )

Now they are in one repo, maybe we can made them  separate , for example,  [Charts](https://github.com/danielgindi/Charts) used to have two sub submodule, `Charts/Core` and `Charts/Realm`, but the author separate them to two dependent repo , [Charts](https://github.com/danielgindi/Charts) and [ChartsRealm](https://github.com/danielgindi/ChartsRealm) , in a few month ago. 

I think in this way we can make Moya simple and reduce dependency problem.
 @BasThomas 
@pedrofjfmartins 

YES, you are right, stabilization is one of the most important things in our work.

I just said *reduce dependency problem*, forgive me, the statement is not exact, it's my fault, what I want to say is that *separate repo can make dependency simple*. For example, separate repo can reduce  Carthage's built time, and each submodule would have their specific demo, maybe this is more convenient for user.

You can have a look at https://github.com/danielgindi/Charts/issues/1756 .
@petester42 How do you think about this ?

 I agree that there exists a problem for Carthage users, but in my opinion this is a Carthage issue, which is why I just started the discussion with my suggestion [here](https://github.com/Carthage/Carthage/issues/437#issuecomment-308558226) on that topic on the Carthage side again. I hope the reactions (starting with [this](https://github.com/Carthage/Carthage/issues/1227#issuecomment-308592491)) are going to develop into the right direction.

So, I see the need for faster build times and I agree that we should not add additional maintenance costs just to work around an issue of a package manager. Problems should be solved where they lie.  <!--
  0 Errors
  1 Warning: Big PR, try to keep changes sm...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Big PR, try to keep changes smaller if you can</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
ViewController.swift | 114 | Unused parameter "action" in a closure should be replaced with _. 
ViewController.swift | 10 | Lines should not have trailing whitespace. 
ViewController.swift | 14 | Lines should not have trailing whitespace. 
ViewController.swift | 24 | Lines should not have trailing whitespace. 
ViewController.swift | 49 | Lines should not have trailing whitespace. 
ViewController.swift | 53 | Lines should not have trailing whitespace. 
ViewController.swift | 61 | Lines should not have trailing whitespace. 
ViewController.swift | 68 | Lines should not have trailing whitespace. 
ViewController.swift | 70 | Lines should not have trailing whitespace. 
ViewController.swift | 76 | Lines should not have trailing whitespace. 
ViewController.swift | 85 | Lines should not have trailing whitespace. 
ViewController.swift | 90 | Lines should not have trailing whitespace. 
ViewController.swift | 101 | Lines should not have trailing whitespace. 
ViewController.swift | 109 | Lines should not have trailing whitespace. 
ViewController.swift | 133 | Lines should not have trailing whitespace. 
ViewController.swift | 116 | Unused parameter "action" in a closure should be replaced with _. 
ViewController.swift | 9 | Lines should not have trailing whitespace. 
ViewController.swift | 12 | Lines should not have trailing whitespace. 
ViewController.swift | 16 | Lines should not have trailing whitespace. 
ViewController.swift | 19 | Lines should not have trailing whitespace. 
ViewController.swift | 26 | Lines should not have trailing whitespace. 
ViewController.swift | 28 | Lines should not have trailing whitespace. 
ViewController.swift | 43 | Lines should not have trailing whitespace. 
ViewController.swift | 51 | Lines should not have trailing whitespace. 
ViewController.swift | 55 | Lines should not have trailing whitespace. 
ViewController.swift | 63 | Lines should not have trailing whitespace. 
ViewController.swift | 70 | Lines should not have trailing whitespace. 
ViewController.swift | 72 | Lines should not have trailing whitespace. 
ViewController.swift | 78 | Lines should not have trailing whitespace. 
ViewController.swift | 87 | Lines should not have trailing whitespace. 
ViewController.swift | 92 | Lines should not have trailing whitespace. 
ViewController.swift | 103 | Lines should not have trailing whitespace. 
ViewController.swift | 105 | Lines should not have trailing whitespace. 
ViewController.swift | 107 | Lines should not have trailing whitespace. 
ViewController.swift | 111 | Lines should not have trailing whitespace. 
ViewController.swift | 114 | Lines should not have trailing whitespace. 
ViewController.swift | 127 | Lines should not have trailing whitespace. 
ViewController.swift | 131 | Lines should not have trailing whitespace. 
ViewController.swift | 135 | Lines should not have trailing whitespace. 
ViewController.swift | 137 | Lines should not have trailing whitespace. 
ViewController.swift | 141 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 35 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 91 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 101 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 105 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 483 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 
MoyaProviderSpec.swift | 500 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 
MoyaProviderSpec.swift | 769 | File should contain 400 lines or less: currently contains 769 
ReactiveSwiftMoyaProviderTests.swift | 65 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 66 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 67 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 68 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 152 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 153 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 154 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 155 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxSwiftMoyaProviderTests.swift | 180 | Prefer `!= nil` over `let _ =` 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 8 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 462 lines 
Observable+MoyaSpec.swift | 7 | Function name should start with a lowercase character: 'ImageJPEGRepresentation(_:_:)' 
Observable+MoyaSpec.swift | 11 | Function name should start with a lowercase character: 'ImageJPEGRepresentation(_:_:)' 
SignalProducer+MoyaSpec.swift | 7 | Function name should start with a lowercase character: 'ImageJPEGRepresentation(_:_:)' 
SignalProducer+MoyaSpec.swift | 11 | Function name should start with a lowercase character: 'ImageJPEGRepresentation(_:_:)' 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1124?src=pr&el=h1) Report
> Merging [#1124](https://codecov.io/gh/Moya/Moya/pull/1124?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/7724451139cc22640228bf760fb92843f52366c4?src=pr&el=desc) will **increase** coverage by `2.68%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1124/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1124?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1124      +/-   ##
=============================================
+ Coverage      73.54%   76.22%   +2.68%     
=============================================
  Files             22       22              
  Lines            737      736       -1     
=============================================
+ Hits             542      561      +19     
+ Misses           195      175      -20
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1124?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Plugins/NetworkActivityPlugin.swift](https://codecov.io/gh/Moya/Moya/pull/1124?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvTmV0d29ya0FjdGl2aXR5UGx1Z2luLnN3aWZ0) | `100% <√∏> (√∏)` | :arrow_up: |
| [Sources/RxMoya/RxMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1124?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhUHJvdmlkZXIuc3dpZnQ=) | `94.73% <100%> (+51.14%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1124?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1124?src=pr&el=footer). Last update [7724451...a132929](https://codecov.io/gh/Moya/Moya/pull/1124?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  I have never used or written a Moya plugin, I'd like to hear what people are using them for (logging/debugging I suppose?).  But from a purely swift language point of view, wouldn't it be enough to have default implementations of the `Plugin` methods via an extension?  Having all these plugins is useful when you only want to write one method/feature, but more verbose and tedious if you wanted to implement more than that.

If we provided default/empty implementations of the `Plugin` methods then plugin authors could just write the methods they want/need, and the API would be simpler. Shoot, I just looked up `Plugin.swift` and I see that it *already* implements empty/default methods.  So we've got that already.

I'm re-reading everything now. After looking at `Plugins.swift`, I agree that we could revisit what we are doing with plugins.  But I'm not yet convinced that what you're proposing here is a step forward, it feels like a side step.  The reason I think that is because most of these methods are already in PluginType; all except the request and endpoint methods.

Using a "plugin" to implement those closures introduces a point of confusion for me - is it just *one* plugin that should create those?  What if multiple plugins can create the endpoint?  The example you provided has an `endpoint` argument, where does that come from?  What would it be used for in that plugin?  I don't think this is a compelling use case to do away with the current closure-based API.

I think we should attack this from a different point of view - instead of refactoring (into what is basically an equivalent system, but not backwards compatible), let's take a look at what people are trying to accomplish with plugins, and make sure we are allowing those use cases.

In short: I love the idea of refactoring plugins to make sure they are serving their purpose!  Do we have any more examples of that?  Moya Version: 8.0.5

The current version of `RxSwift` dependency is not compatible with Xcode 9 and Swift 3.2. Thus, projects can't be compiled.
```ruby
ss.dependency "RxSwift", "~> 3.0"
```

I've solved this just by changing the dependency version. I can create a PR if it's needed.
```ruby
ss.dependency "RxSwift", "~> 3.5"
``` How about `>= 3.0`? That's weird. So this is my scenario: I have both Xcode and Xcode-beta on my Mac. After updating Xcode to 8.3.3, it failed to work, but after a `pod update` it worked. Sorry for this false positive and thanks for the fast response. I'm closing the issue.  <!--
  0 Errors
  1 Warning: Any changes to library code sh...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Any changes to library code should be reflected in the Changelog. Please consider adding a note there.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProvider+Defaults.swift | 42 | Force unwrapping should be avoided. 
MoyaProvider+Defaults.swift | 44 | Force unwrapping should be avoided. 
MoyaProvider+Defaults.swift | 40 | Lines should not have trailing whitespace. 
MoyaProvider+Defaults.swift | 43 | Lines should not have trailing whitespace. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1121?src=pr&el=h1) Report
> Merging [#1121](https://codecov.io/gh/Moya/Moya/pull/1121?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/5106077bf1aad58e7d8ca766e3e746d3dc6ca6d7?src=pr&el=desc) will **increase** coverage by `0.09%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1121/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1121?src=pr&el=tree)

```diff
@@            Coverage Diff            @@
##           master   #1121      +/-   ##
=========================================
+ Coverage   76.51%   76.6%   +0.09%     
=========================================
  Files          22      22              
  Lines         728     731       +3     
=========================================
+ Hits          557     560       +3     
  Misses        171     171
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1121?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider+Defaults.swift](https://codecov.io/gh/Moya/Moya/pull/1121?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitEZWZhdWx0cy5zd2lmdA==) | `96.42% <100%> (+0.42%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1121?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1121?src=pr&el=footer). Last update [5106077...6d710b0](https://codecov.io/gh/Moya/Moya/pull/1121?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 Hey @GuiFoA, could you provide a bit of sample code for your request so others can assist you with what's not working? You may want to check out: https://github.com/Moya/Moya/issues/1119 @GuiFoA let me see if I understand correctly.
~https://www.XXX.net/buildAction.do?mbGetIndexJson is your base URL and the entire URL.~
~You are not appending any path component to the baseURL?~

If you just share the piece of code causing this issue, we can resolve this more efficiently :) @GuiFoA I just got the chance to look at the Demo.

The problem is you're using `?` inside of your path -- which isn't common practice.
```Swift
    //parmenter 'city'
    static let homepage = "/buildAction.do?mbGetIndexJson"
```

This method you provided by concatenating the path yourself is possible:

```Swift
// Using this method is possible
let publicParamEndpointClosure = { (target: DemoService) -> Endpoint<DemoService> in
    
    // get the complete url by myself
    let url = DemoURL.base + target.path
    
    let endpoint = Endpoint<DemoService>(url: url, sampleResponseClosure: { .networkResponse(300, target.sampleData) }, method: target.method, parameters: target.parameters, parameterEncoding: target.parameterEncoding)
    
    return endpoint
}
```

Another idea I have for you is:

```Swift
extension DemoService:TargetType {
  
  var baseURL: URL { return URL(string: DemoURL.base + queryPath)! }
  
  var queryPath: String {
    switch self {
    case .getInfo:
      return DemoURL.homepage
    }
  }

  var path: String {
    return ""
  }
```  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1120?src=pr&el=h1) Report
> Merging [#1120](https://codecov.io/gh/Moya/Moya/pull/1120?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/5106077bf1aad58e7d8ca766e3e746d3dc6ca6d7?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1120/graphs/tree.svg?token=CjZLHCNgNn&src=pr&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1120?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1120   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1120?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1120?src=pr&el=footer). Last update [5106077...6a58b0b](https://codecov.io/gh/Moya/Moya/pull/1120?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Just use params instead of embedding em on your own @pete183 Have you got to solve the issue? @pete183 I don't want to add params, I want to send it as path, as this is the next url coming in my pagination which I can append after my base path @pete183 So the problem was in headers I was getting next and previous urls sub path which I should append after base path
ex **http://www.basepath.com/apis/v1**  is base path
and next and previous path comes like **questions/?page=2&topic=xyz**
Now I need to append this after base url so I was trying to append this path **/v3/questions/?page=2&topic=xyz** but due to encoding I ended up with unwanted encoded characters for = and others

I have finally solved it using
```swift
public var baseURL: URL {
        switch self {
        case .whenPath(let nextUrl):
            return URL(string: self.appSettingsService.networkConfig.baseUrl+nextUrl)!
         default:
            return URL(string: self.appSettingsService.networkConfig.baseUrl)!
        }
    }

```  It seems like handling response JSON is a highly debated topic due to there being so many JSON serialization libraries and no determined best practice. 

However, with the addition of the `Codable` protocol to the Swift 4 Standard Library, I think this will become a widely used approach. I'm wondering if the Moya community would be willing to add some basic extensions to `Moya.Response` to map `Decodable` types. 

Since `Codable` is part of the Standard Library I think it's a safe addition to Moya's core.

A rough API would be:

```Swift
    func mapObject<D: Decodable>(with decoder: JSONDecoder) throws -> D {}
    func mapObject<D: Decodable>(atKeyPath keyPath: String, with decoder: JSONDecoder) throws -> D {}
```

Moya already supports mapping to JSON, Images, and Strings

Regardless, these are not difficult extensions to write on our own or provide in a community extension. @sunshinejr thank you for the feedback. I would be willing to provide the implementation for this feature when Moya is ready to start the Swift 4 migration. Including writing the Rx/Reactive extensions, documentation, and testing. If there's anything else I can do the contribute in the meantime, please feel free to let me know. Please note that there is now https://github.com/Alamofire/Alamofire/issues/2180 around which tracks support for the `Decodable` type right within Alamofire. As it is our main dependency, I think their approach to integrate this feature should be considered before finally deciding on how to implement this.

Please also note that the contributors have already **confirmed** that they have plans to support both `Encodable` and `Decodable` types in release version 5 in https://github.com/Alamofire/Alamofire/issues/2177.  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=h1) Report
> Merging [#1117](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=desc) into [optional-response-thread-param](https://codecov.io/gh/Moya/Moya/commit/b11060b3dbe320f830104098e0405a90a563fbf7?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `72.22%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1117/graphs/tree.svg?token=CjZLHCNgNn&src=pr&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=tree)

```diff
@@                       Coverage Diff                       @@
##           optional-response-thread-param    #1117   +/-   ##
===============================================================
  Coverage                           76.51%   76.51%           
===============================================================
  Files                                  22       22           
  Lines                                 728      728           
===============================================================
  Hits                                  557      557           
  Misses                                171      171
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/RxMoya/RxMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhUHJvdmlkZXIuc3dpZnQ=) | `94.44% <100%> (√∏)` | :arrow_up: |
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `91.22% <100%> (√∏)` | :arrow_up: |
| [Sources/Moya/Moya+Alamofire.swift](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWErQWxhbW9maXJlLnN3aWZ0) | `82.6% <100%> (√∏)` | :arrow_up: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.27% <52.94%> (√∏)` | :arrow_up: |
| [...urces/ReactiveMoya/ReactiveSwiftMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVTd2lmdE1veWFQcm92aWRlci5zd2lmdA==) | `51.72% <60%> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=footer). Last update [b11060b...0c034df](https://codecov.io/gh/Moya/Moya/pull/1117?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Swift 3.1
Moya 8.0.5

### Is it possible to place parameters in URL when I have a request with `POST` method?

My goal is to create a request with parameters included in URL. So the request should look like this:

`POST` https://google.com/123/somePath?parameterId=someId

Unfortunately, when I create request with `POST` method all parameters are placed outside URL. I made some tests and I've discovered that when I change the method to `GET`, then all works fine.

<img width="1061" alt="screen shot 2017-06-08 at 11 24 21" src="https://user-images.githubusercontent.com/9297748/26922220-c6ce0740-4c3e-11e7-8134-87f1d31ef737.png">

Below my code and cURL for both requests:

github url: https://github.com/k8mil/MoyaBaseURL


```swift
enum MyApi {
    case postWithURLParameters
}

extension MyApi: TargetType {

    var baseURL: URL {
        return URL(string: "https://google.com")!
    }

    var path: String {
        return "/123/somePath"
    }

    var method: Moya.Method {
        //return .get //it works
        return .post
    }

    var parameters: [String: Any]? {
        return ["parameterId": "someId"]
    }

    var parameterEncoding: ParameterEncoding {
        return URLEncoding.default
    }

    var sampleData: Data {
        return Data()
    }

    var task: Task {
        return .request
    }
}

@objc func doRequest() {
    provider.request(MyApi.postWithURLParameters) {
        result in
        print(result)
    }
}
```

```
curl -H "Host: google.com" -H "Accept-Language: en;q=1.0" -H "Accept: */*" -H "User-Agent: MoyaBaseURL/1.0 (k8mil.MoyaBaseURL; build:1; iOS 10.3.0) Alamofire/4.4.0" --compressed https://google.com/123/somePath?parameterId=someId
```

```
curl -H "Host: google.com" -H "Content-Type: application/x-www-form-urlencoded; charset=utf-8" -H "Accept: */*" -H "User-Agent: MoyaBaseURL/1.0 (k8mil.MoyaBaseURL; build:1; iOS 10.3.0) Alamofire/4.4.0" -H "Accept-Language: en;q=1.0" --data-binary "parameterId=someId" --compressed https://google.com/123/somePath
```
 According to this: 

https://stackoverflow.com/questions/14551194/how-are-parameters-sent-in-an-http-post-request

It seems to be specially designed for `POST`.  @sunshinejr 
Thanks for pointing that. However, finally I'll stay with default way, so my `POST`place the parameters into request body. :)   ```swift
provider.request(Network.uploadPic(img: data), queue: nil, progress: { (response) in
                print(CGFloat(response.progress))
                
                view.progress = CGFloat(response.progress)
                
                if response.completed {
                    view.removeFromSuperview()
                }
                
            }, completion: { (result) in
```

I can upload image success. But progress is wrong.It`s always 1.0 It was a bug in previous versions. What version are you using?  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1113?src=pr&el=h1) Report
> Merging [#1113](https://codecov.io/gh/Moya/Moya/pull/1113?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/988caffbfa2f6476cd43a18666156596a542437d?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1113/graphs/tree.svg?token=CjZLHCNgNn&width=650&height=150&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1113?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1113   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1113?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1113?src=pr&el=footer). Last update [988caff...31a816a](https://codecov.io/gh/Moya/Moya/pull/1113?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Hello. I could not get the json fixture file working for specs when following the example provided in readme. I updated readme to use the approach that worked for me. Looks like `Data(base64Encoded: path)` only encodes the String path into data, and does not actually read json data from the file. 

 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1112?src=pr&el=h1) Report
> Merging [#1112](https://codecov.io/gh/Moya/Moya/pull/1112?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/784f60999b85320a984b133ece061a1b662fa9b3?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1112/graphs/tree.svg?token=CjZLHCNgNn&src=pr&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1112?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1112   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1112?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1112?src=pr&el=footer). Last update [784f609...a9678b5](https://codecov.io/gh/Moya/Moya/pull/1112?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Hi, I am using Moya to handle the network operations in my project and I have been here couple times. Before I have been using my own logging -which very basic prints and it was really hard to debug from it- so I decided to use NetworkLoggerPlugin and NetworkActivityPlugin. However, the print outs are very mixed up. 


<img width="581" alt="screen shot 2017-06-03 at 00 37 25" src="https://cloud.githubusercontent.com/assets/6718272/26745771/e2677d9a-47f4-11e7-874c-f1435ffbae6a.png">
 
And my code; 

```
open static func Provider() -> MoyaProvider<NetworkAPI> {
        return MoyaProvider<NetworkAPI>(endpointClosure: NetworkProvider.endpointClosure, manager: NetworkManager.manager, plugins: [NetworkLoggerPlugin(verbose: true, cURL: true)])
    }
```

 Before I was able to use it with `formatter: JSONResponseDataFormatter` but now it throws `unresolved identifier` error. Can someone please explain how to do that with some code? I examined the documentation but I couldn't figure out how to use it. If someone helps I will be very appreciated. 
 I think I used this code piece in my code, but it was deleted somehow. anyway, thanks a lot üòÉ   Hi, 

I want use Moya in my framework with **Allow app extension API only** flag enabled, but I have a Xcode warning that says: **Linking against dylib not safe for use in application extension**. 
I think this is due to the fact that Moya haven't app extension flag enabled.

How can I solve? 
Thank you for your help Nobody can help me?
 Thank you :)   On 8.0.4 version i can't get attributes "title" and "text" on the data returned from get requests. 
Each other attribute looks perfectly fine.
Those 3 attributes appear to be presents on the response data but empty.

Thanks for the effort guys! I'm sorry but i don't have enough time atm to create a demo :(

Anyway, NetworkLoggerPlugin is logging this: 

["Moya_Logger: [30/05/2017 22:21:23] Request: http://api.supersecretendpoint.com/exhibitions", "Moya_Logger: [30/05/2017 22:21:23] Request Headers: [:]", "Moya_Logger: [30/05/2017 22:21:23] HTTP Request Method: GET"]
["Moya_Logger: [30/05/2017 22:22:07] Response: <NSHTTPURLResponse: 0x174034fa0> { URL: http://api.supersecretendpoint.com/exhibitions } { status code: 200, headers {\n    Connection = \"Keep-Alive\";\n    \"Content-Type\" = \"application/json; charset=utf-8\";\n    Date = \"Tue, 30 May 2017 20:21:50 GMT\";\n    \"Keep-Alive\" = \"timeout=5, max=100\";\n    Server = Apache;\n    \"Transfer-Encoding\" = Identity;\n    \"X-Powered-By\" = \"PHP/5.3.29, PleskLin\";\n} }"]

I have this issue also on version 8.0.3
When i perform the request with plain alamofire and postman, i get the correct response with "title" and "text" parameters.
The request is a get and the json is valid.

This is my request service
```swift
import Moya
import SwiftyJSON
import Result

class RequestsService {
    
    static let manager = RequestsService()
    
    var provider: MoyaProvider<RequestsEnum>
    
    init() {
        let endpoint = { (target: RequestsEnum) -> Endpoint<RequestsEnum> in
            return Endpoint<RequestsEnum>(
                url: target.baseURL.appendingPathComponent(target.path).absoluteString,
                sampleResponseClosure: {.networkResponse(2000, target.sampleData)},
                method: target.method,
                parameters: target.parameters
            )
        }

        self.provider = MoyaProvider(endpointClosure: endpoint, plugins: [NetworkLoggerPlugin()], trackInflights: true)
    }

    func performRequests(callback: @escaping () -> Void) {
        let requests: [RequestsEnum] = [.getExhibitions]

        for request in requests {
            RequestsService.manager.provider.request(
                request,
                completion: { result in
                    self.defaultHandler(type: request, result: result, callback: callback)
                })
        }
    }
    
    func defaultHandler(type: RequestsEnum, result: Result<Response, MoyaError>, callback: () -> Void) {
        switch result {
        case let .success(response):
            let json = JSON(data: response.data)
            switch type {
            case .getExhibitions:
                let exhibitions = json.arrayValue.map({ json in Exhibition(json: json) })
                print(exhibitions)
                break
            }
        case let .failure(error):
            print("request error: ", error)
            break
        }
    }
}

enum RequestsEnum {
    case getExhibitions
}
```

And this is my request service specification
```swift
extension RequestsEnum: TargetType {
    var baseURL: URL {
        return URL(string: ConfigService.endpoint)!
    }
    var path: String {
        switch self {
        case .getExhibitions:
            return "/exhibitions
        }
    }
    var method: Moya.Method {
        return .get
    }
    var parameters: [String: Any]? {
        return nil
    }
    var parameterEncoding: ParameterEncoding {
        return JSONEncoding.default
    }
    var sampleData: Data {
        return Data()
    }
    var task: Task {
        return .request
    }
}
```

I don't know if it's useful, but somehow, sometimes the request works correctly

Thanks again Looks like I have a problem with the responseData method of Alamofire, it doesn't return those 2 attributes... 
The responseJSON is working fine though

Sorry for the waste of time.  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1106?src=pr&el=h1) Report
> Merging [#1106](https://codecov.io/gh/Moya/Moya/pull/1106?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/4512a2a4bc8019cf006434378ac6a0640f34f35f?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1106/graphs/tree.svg?width=650&height=150&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1106?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1106   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1106?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1106?src=pr&el=footer). Last update [4512a2a...30e7994](https://codecov.io/gh/Moya/Moya/pull/1106?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1105?src=pr&el=h1) Report
> Merging [#1105](https://codecov.io/gh/Moya/Moya/pull/1105?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/4512a2a4bc8019cf006434378ac6a0640f34f35f?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1105/graphs/tree.svg?token=CjZLHCNgNn&width=650&src=pr&height=150)](https://codecov.io/gh/Moya/Moya/pull/1105?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1105   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1105?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1105?src=pr&el=footer). Last update [4512a2a...5d429f1](https://codecov.io/gh/Moya/Moya/pull/1105?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1103?src=pr&el=h1) Report
> Merging [#1103](https://codecov.io/gh/Moya/Moya/pull/1103?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/a74c4da753dc5ae292d7cb40d516c99049cac4a8?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1103/graphs/tree.svg?src=pr&width=650&token=CjZLHCNgNn&height=150)](https://codecov.io/gh/Moya/Moya/pull/1103?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1103   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1103?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1103?src=pr&el=footer). Last update [a74c4da...30839d4](https://codecov.io/gh/Moya/Moya/pull/1103?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Not sure what step I may be missing, but when pulling down the latest version of Moya.git (8.0.4) I'm only seeing 3 macOS targets within the project file (Moya, RX, and Reactive)

Thanks! They look like Mac OS targets but they are cross platform. Just pick iPhone or simulator when running and it will just work.   # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1101?src=pr&el=h1) Report
> Merging [#1101](https://codecov.io/gh/Moya/Moya/pull/1101?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/a74c4da753dc5ae292d7cb40d516c99049cac4a8?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1101/graphs/tree.svg?width=650&height=150&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1101?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1101   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1101?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1101?src=pr&el=footer). Last update [a74c4da...8346267](https://codecov.io/gh/Moya/Moya/pull/1101?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  <!--
  0 Errors
  1 Warning: The <code>Cartfile</code> or <...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The <code>Cartfile</code> or <code>Cartfile.resolved</code> was updated, but there were no changes in the <code>podspec</code>. Did you forget updating the <code>podspec</code>?</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Error+MoyaSpec.swift | 4 | Function should have complexity 10 or less: currently complexity equals 19 
Error+MoyaSpec.swift | 55 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 28 | Force unwrapping should be avoided. 
MoyaProviderIntegrationTests.swift | 32 | Force unwrapping should be avoided. 
MoyaProviderIntegrationTests.swift | 36 | Force unwrapping should be avoided. 
MoyaProviderIntegrationTests.swift | 23 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 143 lines 
MoyaProviderIntegrationTests.swift | 17 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 26 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 31 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 35 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 39 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 41 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 45 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 53 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 65 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 68 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 81 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 95 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 100 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 107 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 110 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 114 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 115 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 121 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 125 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 133 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 140 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 143 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 151 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 163 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 168 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 177 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 182 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 185 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 193 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 198 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 202 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 218 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 234 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 240 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 252 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 255 | Lines should not have trailing whitespace. 
MoyaProviderIntegrationTests.swift | 268 | Lines should not have trailing whitespace. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1099?src=pr&el=h1) Report
> Merging [#1099](https://codecov.io/gh/Moya/Moya/pull/1099?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/c4e58ee23db4aaec944505a2f7b001a89b602d7d?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1099/graphs/tree.svg?token=CjZLHCNgNn&width=650&height=150&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1099?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1099   +/-   ##
=======================================
  Coverage   76.51%   76.51%           
=======================================
  Files          22       22           
  Lines         728      728           
=======================================
  Hits          557      557           
  Misses        171      171
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1099?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1099?src=pr&el=footer). Last update [c4e58ee...8170445](https://codecov.io/gh/Moya/Moya/pull/1099?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  I known we can get the sampleData as response, but I don't know how to write test for request? If there have any examples about how to make unit test? Thanks  No promises or set time frame but I'd like to take a stab at this. I think a Playground driven approach would result in a more fine-grained and chronological learning experience. Compile time errors might even make it easier to maintain than static documentation üòÖ. So if anyone has something to add to the discussion feel free to let me know.

I think the concern regarding maintenance of a website and playground is insightful and agree it would be difficult to maintain a large amount of content. I also agree that if the community decides to go both directions, then we should find a way to reuse as much documentation as possible.

Would anyone else like to see this?


 

 Hey there everyone, this is something I'd like to move forward on. I've started a branch here:
https://github.com/SD10/Moya/tree/playground

Basically, I took the [Targets.md](https://github.com/Moya/Moya/blob/master/docs/Targets.md) documentation and converted it to a playground file. I'm trying to re-use as much as the existing docs as possible, however, if we're looking for an authentic walkthrough I can do that too.

I think reusing as much existing documentation as possible will make things easier to maintain. I also like the idea of having our static documentation backed up by a compiled playground. This will immediately trigger errors for out of date documentation.

I'd just like some feedback on my approach before continuing. One thing I'd like to know is if the wording in the Playground file should mirror the Documentation exactly. My current implementation paraphrased the existing documentation.

Thanks for any feedback! @sunshinejr I replied to your suggestions. Thank you, I really appreciate the feedback.  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1095?src=pr&el=h1) Report
> Merging [#1095](https://codecov.io/gh/Moya/Moya/pull/1095?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/caadf45aaa7e262e2d992224cd2f4decd0806980?src=pr&el=desc) will **increase** coverage by `2.71%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1095/graphs/tree.svg?src=pr&token=CjZLHCNgNn&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1095?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           master    #1095      +/-   ##
==========================================
+ Coverage   73.79%   76.51%   +2.71%     
==========================================
  Files          22       22              
  Lines         729      728       -1     
==========================================
+ Hits          538      557      +19     
+ Misses        191      171      -20
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1095?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/RxMoya/RxMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1095?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhUHJvdmlkZXIuc3dpZnQ=) | `94.59% <100%> (+52.48%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1095?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1095?src=pr&el=footer). Last update [caadf45...17e15a6](https://codecov.io/gh/Moya/Moya/pull/1095?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  env:
    'RxSwift', ' 3.2.0'
    'Moya', ' 8.0.4'
    'Moya/RxSwift', ' 8.0.4'
```swift
DLog(message: "upload image start")
TBXNetwork.provider.requestWithProgress(FileAPI.uploadImage(policy: policy, image: image).target)
.do(onNext: { (response) in
    DLog(message: String(format: "index %d - progress %lf", index, response.progress))
})
.filterCompleted()
.debug()
.mapJson()
.subscribe(
    onNext: { json in
        handler(true, (index, json["data"]["url"].string!))
    },
    onError: { error in
        DLog(message: error.localizedDescription)
        handler(false, (index, error.localizedDescription))
    },
    onCompleted: {
        DLog(message: "upload image complete")
    }
)
.addDisposableTo(self.disposeBag)
```

logs:
```
[code.swift:line:96]- upload image start
2017-05-21 16:37:56.820: code.swift:102 (uploadImage(uid:token:type:images:handler:)) -> subscribed
[code.swift:line:99]- index 0 - progress 0.124667
[code.swift:line:99]- index 0 - progress 0.748000
[code.swift:line:99]- index 0 - progress 0.872666
[code.swift:line:99]- index 0 - progress 0.872666
[code.swift:line:99]- index 0 - progress 0.997333
[code.swift:line:99]- index 0 - progress 0.997333
[code.swift:line:99]- index 0 - progress 0.997333
[code.swift:line:99]- index 0 - progress 1.000000
[code.swift:line:99]- index 0 - progress 1.000000
2017-05-21 16:37:57.934: code.swift:102 (uploadImage(uid:token:type:images:handler:)) -> Event next(Status Code: 200, Data Length: 189)
[code.swift:line:99]- index 0 - progress 1.000000
2017-05-21 16:37:57.940: code.swift:102 (uploadImage(uid:token:type:images:handler:)) -> Event next(Status Code: 200, Data Length: 189)
2017-05-21 16:37:57.942: code.swift:102 (uploadImage(uid:token:type:images:handler:)) -> Event completed
[code.swift:line:115]- upload image complete
2017-05-21 16:37:57.942: code.swift:102 (uploadImage(uid:token:type:images:handler:)) -> isDisposed
```


why this code call ``` onNext``` twice?
when i repalce ```requestWithProgress``` with ```request```, 
 or add ```.skip(1)``` before ```.subscribe```,
 it work  as expected. 
anybody can answer my questionÔºü i will be grateful.
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1093?src=pr&el=h1) Report
> Merging [#1093](https://codecov.io/gh/Moya/Moya/pull/1093?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/caadf45aaa7e262e2d992224cd2f4decd0806980?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1093/graphs/tree.svg?token=CjZLHCNgNn&src=pr&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1093?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1093   +/-   ##
=======================================
  Coverage   73.79%   73.79%           
=======================================
  Files          22       22           
  Lines         729      729           
=======================================
  Hits          538      538           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1093?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1093?src=pr&el=footer). Last update [caadf45...0cf39eb](https://codecov.io/gh/Moya/Moya/pull/1093?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1092?src=pr&el=h1) Report
> Merging [#1092](https://codecov.io/gh/Moya/Moya/pull/1092?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/dfa3568fd7727c99feeebb8156a53a915844ee72?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1092/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1092?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1092   +/-   ##
=======================================
  Coverage   73.79%   73.79%           
=======================================
  Files          22       22           
  Lines         729      729           
=======================================
  Hits          538      538           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1092?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1092?src=pr&el=footer). Last update [dfa3568...f7ffdb6](https://codecov.io/gh/Moya/Moya/pull/1092?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  This PR is part of a campaign to fix a lot of typos on github using https://github.com/client9/misspell!
You can see the progress on https://github.com/fixTypos/fix_typos/ <!--
  0 Errors
  0 Warnings
  0 Messages
  1 Markdown
-->

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 79 | Unused parameter "target" in a closure should be replaced with _. 
MoyaProviderSpec.swift | 93 | Unused parameter "target" in a closure should be replaced with _. 
MoyaProviderSpec.swift | 10 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 401 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 526 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 532 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 617 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 623 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 638 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 707 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 711 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 9 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 446 lines 
MoyaProviderSpec.swift | 14 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 17 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 24 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 44 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 51 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 55 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 58 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 83 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 87 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 90 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 97 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 101 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 104 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 108 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 111 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 119 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 123 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 126 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 134 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 138 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 185 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 373 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 377 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 440 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 443 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 451 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 460 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 464 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 470 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 483 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 487 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 500 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 504 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 507 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 514 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 634 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 643 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 647 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 649 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 666 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 669 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 675 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 687 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 689 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 696 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 700 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 704 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 709 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 716 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 718 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 720 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 724 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 730 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 737 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 740 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 114 | Prefer `-> Void` over `-> ()`. 
MoyaProviderSpec.swift | 129 | Prefer `-> Void` over `-> ()`. 
MoyaProviderSpec.swift | 258 | Prefer `-> Void` over `-> ()`. 
MoyaProviderSpec.swift | 201 | Opening braces should be preceded by a single space and on the same line as the declaration. 
MoyaProviderSpec.swift | 672 | Opening braces should be preceded by a single space and on the same line as the declaration. 
MoyaProviderSpec.swift | 484 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 
MoyaProviderSpec.swift | 501 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 
MoyaProviderSpec.swift | 747 | File should contain 400 lines or less: currently contains 747 
ReactiveSwiftMoyaProviderTests.swift | 45 | Unused parameter "error" in a closure should be replaced with _. 
ReactiveSwiftMoyaProviderTests.swift | 12 | Force unwrapping should be avoided. 
ReactiveSwiftMoyaProviderTests.swift | 121 | Force unwrapping should be avoided. 
ReactiveSwiftMoyaProviderTests.swift | 213 | Force unwrapping should be avoided. 
ReactiveSwiftMoyaProviderTests.swift | 11 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 136 lines 
ReactiveSwiftMoyaProviderTests.swift | 243 | Limit vertical whitespace to a single empty line. Currently 2. 
ReactiveSwiftMoyaProviderTests.swift | 22 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 25 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 32 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 40 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 43 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 48 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 102 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 106 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 112 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 119 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 123 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 126 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 133 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 139 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 144 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 149 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 159 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 164 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 168 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 171 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 174 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 180 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 209 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 246 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 65 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 66 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 67 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 68 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 152 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 153 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 154 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 155 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 662 | Force casts should be avoided. 
MoyaProviderSpec.swift | 9 | Function should have complexity 10 or less: currently complexity equals 34 
MoyaProviderSpec.swift | 8 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 447 lines 
ReactiveSwiftMoyaProviderTests.swift | 135 | Force casts should be avoided. 
ReactiveSwiftMoyaProviderTests.swift | 130 | Force tries should be avoided. 
ReactiveSwiftMoyaProviderTests.swift | 135 | Force tries should be avoided. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1091?src=pr&el=h1) Report
> Merging [#1091](https://codecov.io/gh/Moya/Moya/pull/1091?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/bac7babad4d61dc3199a7e3273ca65cd51d530bf?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1091/graphs/tree.svg?width=650&height=150&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1091?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1091   +/-   ##
=======================================
  Coverage   73.79%   73.79%           
=======================================
  Files          22       22           
  Lines         729      729           
=======================================
  Hits          538      538           
  Misses        191      191
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1091?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Plugins/NetworkActivityPlugin.swift](https://codecov.io/gh/Moya/Moya/pull/1091?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvTmV0d29ya0FjdGl2aXR5UGx1Z2luLnN3aWZ0) | `100% <√∏> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1091?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1091?src=pr&el=footer). Last update [bac7bab...77e0c65](https://codecov.io/gh/Moya/Moya/pull/1091?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
   @sunshinejr thanks, I think I get it  Getting an "Invalid conversion from throwing function of type '`(_) throws -> ()`' to non-throwing function type '`Completion`' (aka '`(Result<Response, MoyaError>) -> ()`')" <img width="738" alt="screen shot 2017-05-15 at 4 39 57 pm" src="https://cloud.githubusercontent.com/assets/2657399/26055150/336126f4-398d-11e7-9ebd-449548210650.png">

as in above screenshot,
When i am trying to call service from controller

When i have added                 case .underlying(let nsError,let response):

this
 waiting for your reply Sorry got the solution, It was my mistake. @iOSUser110, how did you solve this problem?
  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
Version of Moya is 8.04
I have read the Endpoints document which makes me know how to set httpHearderFields,like this:
```swift
let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
    let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
    return defaultEndpoint.adding(newHTTPHeaderFields: ["APP_NAME": "MY_AWESOME_APP"])
}
let provider = MoyaProvider<GitHub>(endpointClosure: endpointClosure)
```
but,I also get another problem? When we create a provider, we need to  pass the endpointClosure to it. For me,the provider is a property  in the ViewController, I use a function to create the provider.

```swift
 var provider:RxMoyaProvider<HTTPService>!

  func setupProvider() {
        let endpointClosure = { (target: HTTPService) -> Endpoint<HTTPService> in
            let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
                return defaultEndpoint.adding(newHTTPHeaderFields: ["Accept":"application/json"])
            }
        provider = RxMoyaProvider<HTTPService>(endpointClosure: endpointClosure)
    }
```
Now,I need to set httpHearderFields for every request,  I don't want to write the same code  to create endpointClosure in every ViewController. How can I  add httpHeaderFields in automatic for every request?

 @alcarvalho and @pedrovereza ,thanks guys.   # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1086?src=pr&el=h1) Report
> Merging [#1086](https://codecov.io/gh/Moya/Moya/pull/1086?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/cdb063288dbf7376359b49362740acb0656075c6?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1086/graphs/tree.svg?token=CjZLHCNgNn&src=pr&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1086?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1086   +/-   ##
=======================================
  Coverage   73.79%   73.79%           
=======================================
  Files          22       22           
  Lines         729      729           
=======================================
  Hits          538      538           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1086?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1086?src=pr&el=footer). Last update [cdb0632...17af40d](https://codecov.io/gh/Moya/Moya/pull/1086?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
   # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1085?src=pr&el=h1) Report
> Merging [#1085](https://codecov.io/gh/Moya/Moya/pull/1085?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/9c299ec25fdcfc6e62f89aac32771258da6985b3?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1085/graphs/tree.svg?token=CjZLHCNgNn&width=650&src=pr&height=150)](https://codecov.io/gh/Moya/Moya/pull/1085?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1085   +/-   ##
=======================================
  Coverage   73.79%   73.79%           
=======================================
  Files          22       22           
  Lines         729      729           
=======================================
  Hits          538      538           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1085?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1085?src=pr&el=footer). Last update [9c299ec...60930cc](https://codecov.io/gh/Moya/Moya/pull/1085?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 Whohoo!!! üéâ  So what did I win? üòÅ    # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1084?src=pr&el=h1) Report
> Merging [#1084](https://codecov.io/gh/Moya/Moya/pull/1084?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/9c299ec25fdcfc6e62f89aac32771258da6985b3?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1084/graphs/tree.svg?token=CjZLHCNgNn&src=pr&height=150&width=650)](https://codecov.io/gh/Moya/Moya/pull/1084?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1084   +/-   ##
=======================================
  Coverage   73.79%   73.79%           
=======================================
  Files          22       22           
  Lines         729      729           
=======================================
  Hits          538      538           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1084?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1084?src=pr&el=footer). Last update [9c299ec...46d7c5a](https://codecov.io/gh/Moya/Moya/pull/1084?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  Version of Moya is 8.04

I can't set an Authorization header.
```swift
let requestClosure = { (endpoint: Endpoint<Services>, done: MoyaProvider.RequestResultClosure) in
                var request: URLRequest = endpoint.urlRequest!
                request.addValue("JWT " + self.token!, forHTTPHeaderField: "Authorization")
                done(.success(request))
            }
            let provider = MoyaProvider<Services>(requestClosure:requestClosure, plugins: [NetworkLoggerPlugin(verbose: true)])
```

 If I set something else, like this
```swift 
request.addValue("JWT " + self.token!, forHTTPHeaderField: "Autho")
```

backend found this header, but if I set header "Authorization" backend doesn't found this.

There is my Moya Services
```swift

enum Services {
    case login(username: String, password: String)
    case checkTicket(id: String)
}

extension Services: TargetType {
    var baseURL: URL { return URL(string: "http://192.168.0.101:8000")! }
    var path: String {
        switch self {
        case .login:
            return "/api/auth/login"
        case .checkTicket(let id):
            return "/api/tickets/\(id)"
        }
    }
    var method: Moya.Method {
        switch self {
        case .checkTicket:
            return .get
        case .login:
            return .post
        }
    }
    var parameters: [String: Any]? {
        switch self {
        case .checkTicket:
            return nil
        case .login(let username, let password):
            return ["username": username, "password": password]
        }
    }
    
    var parameterEncoding: ParameterEncoding {
        switch self {
        case .checkTicket:
            return URLEncoding.default
        case .login:
            return JSONEncoding.default
        }
    }
    var sampleData: Data {
        switch self {
        case .login:
            return "{\"token\": \"No\"}".data(using: .utf8)!
        case .checkTicket:
            return "{\"status\": \"active\"}".data(using: .utf8)!
        }
    }
    var task: Task {
        switch self {
        case .checkTicket, .login:
            return .request
        }
    }
    
}
```  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1082?src=pr&el=h1) Report
> Merging [#1082](https://codecov.io/gh/Moya/Moya/pull/1082?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/9c299ec25fdcfc6e62f89aac32771258da6985b3?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1082/graphs/tree.svg?src=pr&token=CjZLHCNgNn&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1082?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1082   +/-   ##
=======================================
  Coverage   73.79%   73.79%           
=======================================
  Files          22       22           
  Lines         729      729           
=======================================
  Hits          538      538           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1082?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1082?src=pr&el=footer). Last update [9c299ec...c82cd92](https://codecov.io/gh/Moya/Moya/pull/1082?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  As an aspiring contributor, I think a Vision document would be a great move! üòÉ   ```
{
  "id" : "101"
  "name" : "34"
  "desc" : "56"
  "FavouriteRecipe" : [
    {  "id" : "1" , "name": "recipe 1"},
    {  "id" : "2" , "name": "recipe2"},
  ]
}
```
How to deal with this kind of parameters , in MoyaProvider 
please provide sample. It very urgent. I searched a lot but not got the solution for this i want to construct a request with these parameters **When I tried to make Input JSON as** 

{
  "id" : "101"
  "name" : ‚ÄúTest‚Äù
  "desc" : ‚ÄúTest‚Äù
  "statusList‚Äù : [
    {  "id" : "1" , "status": ‚ÄúHigh‚Äù},
    {  "id" : "2" , "status": ‚Äúlow‚Äù},
    { "id" : "3" , "status": ‚Äúmedium‚Äù}
  ]
}


**I wrote Code on swift as** 
let dict1:[String,Any] =
         [
            "id":  ‚Äú1‚Äù
            "status":"High"
        ] 
        
let dict2:[String,Any] =
            [
                "id‚Äù:‚Äù2‚Äù,
                "status":"Low"
                ]

let dict3:[String,Any] =
            [
                "id‚Äù:‚Äù3‚Äù,
                "status":"Medium"
                ]


let inputParam =
 [
 "id" : "101"
  "name" : ‚ÄúTest‚Äù
  "desc" : ‚ÄúTest‚Äù
  "statusList‚Äù : [ dict1,dict2,dict3 ]
]



**On PHP side getting as below :** 
Array => 1<br /><pre>Array
(
    [statusList] => Array
        (
            [0] => Array
                (
                    [id] => ‚Äú1‚Äù
                )

            [1] => Array
                (
                    [status] =>  ‚ÄúHigh‚Äù
                )

            [2] => Array
                (
                    [id] => ‚Äú2‚Äù
                )

            [3] => Array
                (
                    [status] => ‚ÄúLow‚Äù
                )

            [4] => Array
                (
                    [id] =>   ‚Äú3‚Äù
                )

            [5] => Array
                (
                    [status] => ‚ÄúMedium‚Äù
                )

        )

    [id] => ‚Äú101 ‚Äù
    [name] => ‚ÄúTest ‚Äù
    [desc] => ‚Äú Test‚Äù
  
)


**BUt it should not treat dictionary element as array element , 
It should be like  as**

           [0] => Array
                (
                    [id] => ‚Äú1‚Äù
                    [status] =>  ‚ÄúHigh‚Äù
                )
            [1] => Array
                (
                    [id] => ‚Äú2‚Äù
                    [status] =>  ‚ÄúLow‚Äù
                )

            [2] => Array
                (
                     [id] => ‚Äú3‚Äù
                    [status] =>  ‚ÄúMedium‚Äù
                )
 I shared the code written in swift, And i have not written any other different thing for paramters , just used moya framework as demo shared by Moya @iOSUser110 this is Alamofire issue (not issue actually...) but it generates such body:

```
...
statusList[][id]=1&
statusList[][status]=High&
statusList[][id]=2&
statusList[][status]= Low&
statusList[][id]=3&
statusList[][status]= Medium
``` 
In other words: it composes an array without indexes, that's why PHP or whatever cannot decode it in right way. so what would be the workaround ?. 
(Workaround from app side) @alcarvalho ya, I am using URLEncoding  Using github.io website generator, or even jekyll can be a good solution for a brief and good website !

EDIT: [Jekyll with Github](https://help.github.com/articles/setting-up-your-github-pages-site-locally-with-jekyll/) Even without Jekyll. A good start could be to check the Github Pages, which can use easily the markdown doc in the repo.

Source: [Github Pages](https://pages.github.com)  +1 for 3. `docs/Community` or `docs/Projects` seems great :tada: Thanks @sunshinejr! üòÉ  +1 for 3 and for `docs/Community` üòÉ  Might be time to make a website?  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1077?src=pr&el=h1) Report
> Merging [#1077](https://codecov.io/gh/Moya/Moya/pull/1077?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/bb2f18f623f9c92c44f9ddf91a0c234cc492141c?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1077/graphs/tree.svg?width=650&token=CjZLHCNgNn&height=150&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1077?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1077   +/-   ##
=======================================
  Coverage   73.79%   73.79%           
=======================================
  Files          22       22           
  Lines         729      729           
=======================================
  Hits          538      538           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1077?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1077?src=pr&el=footer). Last update [bb2f18f...7cceeeb](https://codecov.io/gh/Moya/Moya/pull/1077?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1076?src=pr&el=h1) Report
> Merging [#1076](https://codecov.io/gh/Moya/Moya/pull/1076?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/5fd1ac2e54db91e1e30194eb8c74911a5df20ee2?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1076/graphs/tree.svg?width=650&height=150&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/1076?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1076   +/-   ##
=======================================
  Coverage   73.79%   73.79%           
=======================================
  Files          22       22           
  Lines         729      729           
=======================================
  Hits          538      538           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1076?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1076?src=pr&el=footer). Last update [5fd1ac2...9e8043b](https://codecov.io/gh/Moya/Moya/pull/1076?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
  I'm happy #1147 is planned to be added, too ‚Äì I think documentation is up-to-date, the only missing thing should be tests. I've got a question on the last bullet point of the initial post though:

> Check 8.0 -> 9.0 migration with an old project and check if the fix-its work as expected / there is need for a migration guide

First, do I understand it correctly, you were able to add Xcode fix-its to the code base of Moya? I didn't know we can do this. If so, I should probably add some fix-its to #1147 as well. And second, #1147 does include a `MigrationGuides.md` file which could be extended with other changes as well. Also it should be probably linked to within the `Readme.md` or at least in the release notes.

And one more thing: We should probably update or remove the `ArrayAsRootContainer.md` cause it doesn't work as it is now. It depends on an outdated Alamofire class structure, I'm not sure how the same is possible with the updated ones. @BasThomas Thanks for the pointers. I've tried to add fix-its but my approaches all failed.
See https://github.com/Moya/Moya/pull/1147#issuecomment-318890623 for more details.  I'm using Moya version 8.0.3.

I think Moya would benefit from changing the type of the associated value of `EndpointSampleResponse.networkError` to `Swift.Error`. Right now it's `NSError`, which makes stubbing more painful than it needs to be.

It's obviously possible to simply cast the error but if Moya truly needs an NSError internally it could do that step internally. It's not really a big thing, right now I have to do this:

```swift
EndpointSampleResponse.networkError(MyError.someError as NSError)
```

If `EndpointSampleResponse` would receive a `Swift.Error` directly I could avoid the `as NSError` cast and instead do this:

```swift
EndpointSampleResponse.networkError(MyError.someError)
```

Since `NSError` implements `Swift.Error` this would also allow passing `NSError` instances in addition to "normal" `Swift.Error` instance.  I really like using Moya in daily basis.
It's probably a good idea, to add Moya to "Swift Source Compatibility Test Suite".
https://swift.org/blog/swift-source-compatibility-test-suite
https://swift.org/source-compatibility/#current-list-of-projects
Alamofire, ObjectMapper are already in the list.  Sure, I will try to make a PR against apple's repo in a day or two. @BasThomas I have create a PR [Moya Swift compat](https://github.com/apple/swift-source-compat-suite/pull/35). But I am getting error in `./check Moya` step. Not able to get much information from the error logs also. I have added comment for asking some help from [Swift Compat](https://github.com/apple/swift-source-compat-suite) team.   We just merged it in on CocoaPods - https://github.com/CocoaPods/CocoaPods/pull/6745 - I can't really compete with GitHub on resources for this kind of project, so I wouldn't wait on peril  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->

Test the moya demo
i get this error "command failed due to signal: segmentation fault: 11"  when i use 
this code. It is Apple Error ? How to solve this error?
```swift
let provider: RxMoyaProvider<GitHub> = RxMoyaProvider<GitHub>(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure:  MoyaProvider.neverStub, manager: RxMoyaProvider<GitHub>.customAlmofireManager(), plugins: plugins)
```

xcode 8.3.2
swift 3.1  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1067?src=pr&el=h1) Report
> Merging [#1067](https://codecov.io/gh/Moya/Moya/pull/1067?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/0c95a70f7166e048850184dac6fb8f7942dc602d?src=pr&el=desc) will **increase** coverage by `0.1%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1067/graphs/tree.svg?src=pr&width=650&token=CjZLHCNgNn&height=150)](https://codecov.io/gh/Moya/Moya/pull/1067?src=pr&el=tree)

```diff
@@             Coverage Diff              @@
##           9.0.0-dev    #1067     +/-   ##
============================================
+ Coverage      73.43%   73.54%   +0.1%     
============================================
  Files             22       22             
  Lines            734      737      +3     
============================================
+ Hits             539      542      +3     
  Misses           195      195
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1067?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/TargetType.swift](https://codecov.io/gh/Moya/Moya/pull/1067?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1RhcmdldFR5cGUuc3dpZnQ=) | `100% <√∏> (√∏)` | :arrow_up: |
| [Sources/Moya/MoyaProvider+Defaults.swift](https://codecov.io/gh/Moya/Moya/pull/1067?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitEZWZhdWx0cy5zd2lmdA==) | `96.15% <100%> (+0.15%)` | :arrow_up: |
| [Sources/Moya/MultiTarget.swift](https://codecov.io/gh/Moya/Moya/pull/1067?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL011bHRpVGFyZ2V0LnN3aWZ0) | `100% <100%> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1067?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1067?src=pr&el=footer). Last update [0c95a70...23a8fc8](https://codecov.io/gh/Moya/Moya/pull/1067?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">PR is classed as Work in Progress</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Moya v8.0.3

I have a custom endpointClosure to add authentication paramters:
```swift
private let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
        let defaultEndpoint = RxMoyaProvider.defaultEndpointMapping(for: target)
        
        // Sign all non-authenticating requests
        switch target {
            case .LoginByEmail:
                return defaultEndpoint
            default:
                guard let currentSession = try? MyAuthenticationService.sharedInstance.session.value(), let id = currentSession?.id, let token = currentSession?.token else
                {
                    return defaultEndpoint
                }
                
                return defaultEndpoint.adding(newParameters: [
                    "u" : id,
                    "t" : token])
        }
    }
```

This works fine for all my existing requests. I've just added a new target for uploading images, which is an upload task as defined here:

```swift
var task : Task {
        switch self {
            case .UploadImage(let image):
                guard let image = UIImageJPEGRepresentation(image, 1.0) else { return .request }
                
                let formData: [MultipartFormData] = [MultipartFormData(provider: .data(image), name: "pic", fileName: "pic", mimeType: "image/jpeg")]
                
                return .upload(UploadType.multipart(formData))
            default:
                return .request
        }
    }
```

This doesn't work. When I sniff the packets, I noticed that the authentication parameters from endpointClosure are missing. Adding them manually as below works, but this seems very hacky as that's what the endpointClosure is supposed to do for me:

```swift
var parameters: [String: Any]? {
switch self
{
case .UploadImage:
                    guard let currentSession = try? MyAuthenticationService.sharedInstance.session.value(), let id = currentSession?.id, let token = currentSession?.token else
                    {
                        return [:]
                    }
                    
                    return [
                    "u" : id,
                    "t" : token,
                    "type_no" : 1]
}
```

In conclusion, the endpointClosure modifies my parameters successfully for .request tasks but not for .upload tasks  [NetClient](https://github.com/intelygenz/NetClient-iOS) has a subspec (NetClient/Moya) to make NetRequest compatible with your awesome abstraction layer, so I add it to the "Community Extensions" section of the Readme.md # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1065?src=pr&el=h1) Report
> Merging [#1065](https://codecov.io/gh/Moya/Moya/pull/1065?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/5fd1ac2e54db91e1e30194eb8c74911a5df20ee2?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1065/graphs/tree.svg?token=CjZLHCNgNn&src=pr&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1065?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1065   +/-   ##
=======================================
  Coverage   73.79%   73.79%           
=======================================
  Files          22       22           
  Lines         729      729           
=======================================
  Hits          538      538           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1065?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1065?src=pr&el=footer). Last update [5fd1ac2...46e876e](https://codecov.io/gh/Moya/Moya/pull/1065?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 @AndrewSB NetClient is another network abstraction layer, by default it uses URLSession behind but also has an implementation using Alamofire in a subspec. It has syntactic sugar, async/synch execution, interceptors... Maybe someone wants to use the power of the NetRequest builder pattern to build the request and after all launch the request using Moya, that's this pull request being.

I have pending improve the readme, we are starting the launch. Pull request would be greatly appreciated!

Thanks for your support. üòÉ  How to get the message from server in case of 400( or 4xx/5xx) status code.
IN the failure case , cant obtain the message and status code using moya ...for underlying case
  When the version will be available? Till then any temporary workaround for this ? hey, waiting for your reply..its an urgent ..cant remove the library support. Want to stuck to your library . Its very efficient. For now if you can give any workaround Hey thanks a lot, 
one doubt here , what is  "your branch" , here what is expected ?  Thanks a lot. Able to fix the issue using this solution  Similar to #634. 

I'm using Swift 2.3 and Moya 7.0.2, but I'm still seeing this error: 
```
Cannot use optional chaining on non-optional value of type NSURL
```

Here's the offending line: 
```
guard let stringURL = target.baseURL.URLByAppendingPathComponent(target.path)?.absoluteString  else {
```

In #634, it's stated that: "7.0.2 is a Swift 2.3 release (in which ```URLByAppendingPathComponent``` is optional"

So my question: Why am I seeing this error if (1) I have 7.0.2 installed and (2) I'm using Swift 2.3? 

Relevant portions of files: 

Podfile
```
platform :ios, '8.0'
use_frameworks!

target 'XXX' do
    pod 'Moya', '7.0.2'
end
```

Podfile.lock 
```
...
  - Moya (7.0.2):
    - Moya/Core (= 7.0.2)
  - Moya/Core (7.0.2):
    - Alamofire (~> 3.5)
    - Result (~> 2.0)
...
```

Can anyone help with this? Thanks! 

 @AndrewSB sorry I wasn't clear - I've updated my original issue to better explain what I'm seeing and what my question is.  @pedrovereza just tried, same issue  @pedrovereza @sunshinejr sorry for my inactivity. The errors ended up being swift/xcode version related. The fix ended up being using swift 2.3 with xcode 8.0 - nothing on your guys end. Thanks for your suggestions and time on this.   Hello,

I've got a question about certificate pinning with Moya.

Currently I'm handling certificate pinning through the `URLConnection` and `URLSession` delegate methods (e.g. `connection(NSURLConnection, willSendRequestFor: URLAuthenticationChallenge)`).
Using this delegate method I extract the received certificate's hash which I can then compare to existing hashes in my app.

I'm not that great with SSL and certificates, but I've checked how Moya does the pinning. But sadly it depends on having the certificate in the app's bundle (which I don't have).

How can I depend on the delegate methods in Moya?

---

I'm using Moya version 8.0.3 Hi @sunshinejr, no problem.

I had already worked my problem out by overriding the delegate's `taskDidReceiveChallenge` closure of the default Alamofire `SessionManager`. I wrapped the closure in a lazy var which makes it only execute once (as that is more logical for pinning in this case/context).
The above looks like:

```swift
class SomeNetworkingClass {
    /// Configures AlamoFire for our certificate pinning;
    /// subsequent calls will (and should) not execute this code again
    lazy var configureAlamofireForSSL: Void = {
        /* < Handle the certificate pinning here > */
    }()
}
```

Now calling `let _ = SomeNetworkingClass().configureAlamofireForSSL` sets up SSL for the default manager. After this I could just assign the `Sessionmanager.default` to the `MoyaProvider` and it works as expected.

---

I don't think there's an easier way of doing this, much less find a generic way to implement this in Moya. üòÑ 
  I love how Moya allows one to customize the parameters before the network request is being made per endpoint. Are there any best practices for doing something similar with the responses? I find myself typing this often:

```swift
return self.provider
        .request(.someTarget())
        .take(1)
        .filterSuccessfulStatusCodes()
        .retry(2)
        .mapJSON()
        .map { (data) -> [Entity]  in
          guard let json = data as? JSONDictionary else { return [] }
          guard let value = json["Value"] as? [JSONDictionary] else { return [] }
          let entities = Mapper<Entity>().mapArray(JSONArray: value) ?? []
          return entities
        }
        .do(onNext: { records in
          //update record in database
          _ = repository.save(entities)
        })
```
But the specifics of parsing the JSON and saving to the database might be a little different depending on the endpoint. Any suggestions for going about this as a general guideline? I did look through the closed issues and found this discussion:

https://github.com/Moya/Moya/issues/948

and this which is related

https://github.com/Moya/Moya/issues/950

I guess I am mainly looking for advice/best practices.

I am thinking for now it might be best to just create wrapper functions for each target to encapsulate the json parsing, as @scottrhoyt recommends in the first link.

So maybe something like:
```swift
class MyClient {
  let provider: Networking

  init(provider: Networking) {
    self.provider = provider
  }

  func getSomeTarget(parameters: SomeParams?) -> Observable< [Entity] > {
    return provider
        .request(.someTarget())
        .take(1)
        .filterSuccessfulStatusCodes()
        .retry(2)
        .mapJSON()
        .map { (data) -> [Entity]  in
          guard let json = data as? JSONDictionary else { return [] }
          guard let value = json["Value"] as? [JSONDictionary] else { return [] }
          let entities = Mapper<Entity>().mapArray(JSONArray: value) ?? []
          return entities
        }
        .do(onNext: { records in
          //update record in database
          _ = repository.save(entities)
        })
  }

  func getSomeOtherTarget() ...etc.
}
``` Hello @sunshinejr thank you for your reply. I ended up creating a wrapper and it has been working well so far. I did also end up borrowing some of the great ideas from the Kiosk implementation and modifying it for my project. Thank you :)  Hello I am not sure I am understanding your question completely but are you asking how to convert a dictionary to an array?

If so, for example:
```
let dictionary = [ "a" : "hello", "b": "how are you"]
let arrayOfValues = Array( dictionary.values.map { $0 })
```
That should work.

If I misunderstood can you please clarify? Maybe with an example of your data? O I think I understand. You will need to modify the request then. Looking at the example in the Moya docs for Request Mapping:
https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#request-mapping

```swift
let requestClosure = { (endpoint: Endpoint<GitHub>, done: MoyaProvider.RequestResultClosure) in
    var request = endpoint.urlRequest

    // Modify the request however you like.
    request.httpBody = Array( endpoint.parameters.values.map { $0 }) //convert to array here!
    done(.success(request))
}
let provider = MoyaProvider<GitHub>(requestClosure: requestClosure)
``` If not, you can follow this tutorial:
https://github.com/Moya/Moya/blob/master/docs/Examples/ArrayAsRootContainer.md

I haven't used array as a root container before but it sounds straightforward since you are customizing the request anyway.  I have seen an example of code where Provider can add headers to request with endpoint closure

```swift
let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
    let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)

    // Sign all non-authenticating requests
    switch target {
    case .authenticate:
        return defaultEndpoint
    default:
        return defaultEndpoint.adding(newHTTPHeaderFields: ["AUTHENTICATION_TOKEN": GlobalAppStorage.authToken])
    }
}
let provider = MoyaProvider<GitHub>(endpointClosure: endpointClosure)
```

However, it looks to me endpoint closure is repeated if we are creating provider in multiple places. I was wondering if there is any way to add headers to request in the same way we do add parameters, request type, endpoints etc. For example, in the GitHub struct, it would look like this,

```swift
extension GitHub: TargetType {
    var headers: [String: String] {
        switch self {
            case .repositories:
                return ["auth_header": "2312dasd"]
            case .users:
                return ["user_agent": "my_user_agent"]
        }
    }
}
```

In that way any module sending a request won't explicitly have to add an endpoint closure every time. I see this has already been raised in https://github.com/Moya/Moya/issues/1046. Should I just close this issue then?  I am using Moya version 8.0.3 and I want to log failing requests, their responses and the respective body data to crashlytics

When I log to console via the networkLoggingPlugin I get the following request readers:

```swift
$ curl -i \
	-X POST \
	-H "Content-Type: application/json" \
	-H "Accept-Encoding: gzip;q=1.0, compress;q=0.5" \
	-H "Accept-Language: en-US;q=1.0" \
	-H "User-Agent: Example/0.0.2 (com.abc.example; build:1; iOS 9.3.0) Alamofire/4.4.0" \
	-d "{\"data\":{\"phone_number\":\"+49123\"}}" \
	"https://www.example.com/api/v1/user"
```

In contrast when I want to extract the request headers from the response after a network request I only get those headers:

```swift
HTTP Error: POST https://www.example.com/api/v1/user {
   ["Content-Type": "application/json"]
 }
  {"data":{"phone_number":"+49123"}})
```

Am I something missing? Is there another way doing this? OK that works, but at the low level of my description method in my custom response object I don't (want to) have the provider available. Isn't it more correct that when I log the request I fire to the network it shows me all request headers that are fired with it?  It would be a pleasure for me ;-) One more question about my approach. Is it possible to solve this by reimplementing Endpoint.urlRequest and include the Alamofire `manager.session.configuration.httpAdditionalHeaders`  in the requests `allHTTPHeaderFields`. The problem here is that I have no access to the provider in that scope. Do you have another Idea?   
```swift
public protocol TargetType {
    var baseURL: URL { get }
    var path: String { get }
    var method: Moya.Method { get }
    var parameters: [String: Any]? { get }
    var sampleData: Data { get }
    var task: Task { get }
    var validate: Bool { get } // Alamofire validation (defaults to `false`)
}
```


```swift
    var parameters: [String: Any]? { get }
```

 Are you trying to send an array instead of a dictionary in a request. If so, please see:
https://github.com/Moya/Moya/issues/1060#issuecomment-296194926
and let us know if that helps.  Hello, i implemented callback queue propagation for reactive providers(which address https://github.com/Moya/Moya/issues/1032 https://github.com/Moya/Moya/issues/1048 https://github.com/Moya/Moya/pull/762). I have same complains, that should be resolved before merge.

## Queue vs Scheduler
I saw several suggestions to use Schedulers instead of queue for RxSwift(and whatever abstraction ReactiveSwift has), but I‚Äôm still believe this queue is not what rx provider responsible for, this is Alamofire threading stuff, users may be confused why they should pass scheduler instead of subscribe/observe on(and maybe this moment should be reflected at method comment).

‚Ä®‚Ä®We can‚Äôt use `SchedulerType`, case we need DispatchQueue, which unnecessary for abstract scheduler, so we have to constraint which scheduler type user can pass(so, instead of reuse his scheduler, user may be forced to create new just to pass queue).

RxSwift do several optimizations for Schedulers(and i‚Äôm believe ReactiveSwift too), for example it ‚Äúconverts‚Äù Concurrent queue to serial(creating new serial queue with old queue as target), which queue should we use in this case(and even, can we still access concurrent queue)? Not sure we can rely on internal queue in future "optimizations" üòÑ 

Everything previously said was my own thoughts, but the fact Schedulers configuration is internal(which means we can‚Äôt access it outside of module and 3 paragraphs above has no sense) indicates that Krunoslav Zaher don‚Äôt want us to use internal queue :)

## Comments
Maybe we should add reacher comments to method, explicitly indicating that we nor observe, nor subscribe on this queue, we just pass it to Alamofire as a callback queue. If user really want subscription(request method call) to run on queue - he should subscribe on caller side. ‚Ä®User may create provider with queue and forget about it, which leads to unexpected element generation queue. In current implementation there is no way to pass nil queue to Alamofire, if provider has default queue, and I don‚Äôt know is it okay.

## Other stuff
As far as I understand, I should update Readme(as at [this](https://github.com/Moya/Moya/pull/762) PR). Maybe I shouldn't use `??` operator? Seems it can affect compilation time, so maybe we should sacrifice readability in favour of compilation speed? <!--
  0 Errors
  1 Warning: Consider adding supporting doc...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 79 | Unused parameter "target" in a closure should be replaced with _. 
MoyaProviderSpec.swift | 93 | Unused parameter "target" in a closure should be replaced with _. 
MoyaProviderSpec.swift | 10 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 401 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 526 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 532 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 617 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 623 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 638 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 707 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 711 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 751 | Force unwrapping should be avoided. 
MoyaProviderSpec.swift | 9 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 497 lines 
MoyaProviderSpec.swift | 14 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 17 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 24 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 44 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 51 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 55 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 58 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 83 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 87 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 90 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 97 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 101 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 104 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 108 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 111 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 119 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 123 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 126 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 134 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 138 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 185 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 373 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 377 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 440 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 443 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 451 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 460 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 464 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 470 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 483 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 487 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 500 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 504 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 507 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 514 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 634 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 643 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 647 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 649 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 666 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 669 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 675 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 687 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 689 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 696 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 700 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 704 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 709 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 716 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 718 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 720 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 724 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 730 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 737 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 740 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 746 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 749 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 755 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 759 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 763 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 768 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 770 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 773 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 780 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 784 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 788 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 795 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 800 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 803 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 807 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 812 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 819 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 823 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 827 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 834 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 114 | Prefer `-> Void` over `-> ()`. 
MoyaProviderSpec.swift | 129 | Prefer `-> Void` over `-> ()`. 
MoyaProviderSpec.swift | 258 | Prefer `-> Void` over `-> ()`. 
MoyaProviderSpec.swift | 201 | Opening braces should be preceded by a single space and on the same line as the declaration. 
MoyaProviderSpec.swift | 672 | Opening braces should be preceded by a single space and on the same line as the declaration. 
MoyaProviderSpec.swift | 484 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 
MoyaProviderSpec.swift | 501 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 
MoyaProviderSpec.swift | 841 | File should contain 400 lines or less: currently contains 841 
ReactiveSwiftMoyaProviderTests.swift | 45 | Unused parameter "error" in a closure should be replaced with _. 
ReactiveSwiftMoyaProviderTests.swift | 12 | Force unwrapping should be avoided. 
ReactiveSwiftMoyaProviderTests.swift | 121 | Force unwrapping should be avoided. 
ReactiveSwiftMoyaProviderTests.swift | 213 | Force unwrapping should be avoided. 
ReactiveSwiftMoyaProviderTests.swift | 11 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 136 lines 
ReactiveSwiftMoyaProviderTests.swift | 243 | Limit vertical whitespace to a single empty line. Currently 2. 
ReactiveSwiftMoyaProviderTests.swift | 22 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 25 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 32 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 40 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 43 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 48 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 72 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 102 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 106 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 112 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 119 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 123 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 126 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 133 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 139 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 144 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 149 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 159 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 164 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 168 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 171 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 174 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 180 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 209 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 246 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 65 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 66 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 67 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 68 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 152 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 153 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 154 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 155 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxSwiftMoyaProviderTests.swift | 100 | Force unwrapping should be avoided. 
RxSwiftMoyaProviderTests.swift | 135 | Force unwrapping should be avoided. 
RxSwiftMoyaProviderTests.swift | 11 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 128 lines 
RxSwiftMoyaProviderTests.swift | 130 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 133 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 139 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 143 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 148 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 151 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 155 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 160 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 168 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 172 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 176 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 184 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 189 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 193 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 198 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 203 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 211 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 215 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 219 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 227 | Lines should not have trailing whitespace. 
RxSwiftMoyaProviderTests.swift | 108 | Colons should be next to the identifier when specifying a type and next to the key in dictionary literals. 
RxSwiftMoyaProviderTests.swift | 109 | Colons should be next to the identifier when specifying a type and next to the key in dictionary literals. 
TestHelpers.swift | 6 | Force unwrapping should be avoided. 
TestHelpers.swift | 16 | Force unwrapping should be avoided. 
TestHelpers.swift | 45 | Force unwrapping should be avoided. 
TestHelpers.swift | 47 | Force unwrapping should be avoided. 
TestHelpers.swift | 64 | Force unwrapping should be avoided. 
TestHelpers.swift | 94 | Force unwrapping should be avoided. 
TestHelpers.swift | 104 | Force unwrapping should be avoided. 
TestHelpers.swift | 153 | Force unwrapping should be avoided. 
TestHelpers.swift | 153 | Force unwrapping should be avoided. 
TestHelpers.swift | 148 | Limit vertical whitespace to a single empty line. Currently 2. 
TestHelpers.swift | 25 | Lines should not have trailing whitespace. 
TestHelpers.swift | 29 | Lines should not have trailing whitespace. 
TestHelpers.swift | 41 | Lines should not have trailing whitespace. 
TestHelpers.swift | 75 | Lines should not have trailing whitespace. 
TestHelpers.swift | 86 | Lines should not have trailing whitespace. 
TestHelpers.swift | 90 | Lines should not have trailing whitespace. 
TestHelpers.swift | 138 | Lines should not have trailing whitespace. 
TestHelpers.swift | 155 | Lines should not have trailing whitespace. 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 662 | Force casts should be avoided. 
MoyaProviderSpec.swift | 9 | Function should have complexity 10 or less: currently complexity equals 34 
MoyaProviderSpec.swift | 8 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 498 lines 
ReactiveSwiftMoyaProviderTests.swift | 135 | Force casts should be avoided. 
ReactiveSwiftMoyaProviderTests.swift | 130 | Force tries should be avoided. 
ReactiveSwiftMoyaProviderTests.swift | 135 | Force tries should be avoided. 
TestHelpers.swift | 149 | Variable name should start with a lowercase character: 'DefaultDownloadDestination' 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
 I'll fix lint issues later, when there will be no other reason to reject PR(case code can change during PR :)) > I think it would be smart to implement some more tests as well though. Are you familiar with testing in ReactiveSwift/RxSwift?

Yep, for some degree, but only with RxTest/RxBlocking(that means I can't write ReactiveSwift tests w/o future investigation). I'll cover this commit functionality(check callback queue) within the next few days As far as I remember, you can't get queue from a scheduler. In addition, you can't pass any Scheduler as a callback queue provider for Alamofire It's not private, it's internal. You can implement scheduler in whatever way you want: you should just adopt one protocol, which has nothing common with GCD. So, for instance, we need scheduler which stick with one thread, we can't get it's queue 'case it doesn't use any. There is sync and async versions for main scheduler(and again, we are talking about Schedulers, provided out of the box), but Alamofire wouldn't respect this distinction.
As I said earlier: we don't use this queue for any Rx-related work, we just pass to non-rx world. We don't even guarantee, that each element will be emitted on this scheduler(because we has dependency on Alamofire implementation). If user really want to use scheduler - he can just `observeOn` it any rx-chain he want, but he can't avoid dispatching to main queue for now. 
Anyway, I remember about tests and moving queue to MoyaProvider :) # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1055?src=pr&el=h1) Report
> Merging [#1055](https://codecov.io/gh/Moya/Moya/pull/1055?src=pr&el=desc) into [optional-response-thread-param](https://codecov.io/gh/Moya/Moya/commit/ed8365720a3e5cf960e47f838c9e9ef317ff9a28?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `71.42%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1055/graphs/tree.svg?width=650&src=pr&token=CjZLHCNgNn&height=150)](https://codecov.io/gh/Moya/Moya/pull/1055?src=pr&el=tree)

```diff
@@                       Coverage Diff                       @@
##           optional-response-thread-param    #1055   +/-   ##
===============================================================
  Coverage                           73.79%   73.79%           
===============================================================
  Files                                  22       22           
  Lines                                 729      729           
===============================================================
  Hits                                  538      538           
  Misses                                191      191
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1055?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1055?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `91.22% <100%> (+0.31%)` | :arrow_up: |
| [...urces/ReactiveMoya/ReactiveSwiftMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1055?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVTd2lmdE1veWFQcm92aWRlci5zd2lmdA==) | `51.72% <60%> (-0.82%)` | :arrow_down: |
| [Sources/RxMoya/RxMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1055?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhUHJvdmlkZXIuc3dpZnQ=) | `40.54% <60%> (-1.57%)` | :arrow_down: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1055?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1055?src=pr&el=footer). Last update [ed83657...e276294](https://codecov.io/gh/Moya/Moya/pull/1055?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 Hmm, any clue why tests failed? I can't even open log. By the way, i added tests for `MoyaProvider` `RxMoyaProvider` and moved queue to `MoyaProvider`. Deprecate approach doesn't work as i expected(swift can't choose proper overload) @AndrewSB Oh i see, i was afraid you just give up on this PR :) Ok, i'll update changelog @AndrewSB It's ok, I'm busy on weekdays too :) @AndrewSB Aaaaand... it's done :) @sunshinejr I took this name from original request method, but I'm agree, callbackQueue would be much better(I believe "queue" parameter name misleading even in request method) @BasThomas Yep, I think so. In method context `queue` is less confusing, but still does not provide any clue about its mission I prefer slightly more verbose `callbackQueue`  Moya (8.0.3)

Hello, I trying map the following object (and I can't):

`["response": {
    "groups":     (
    {
        "date": "2017-03-01T03:20:30.788Z",
        "latitude": "35.7020691",
        "longitude": "139.7753269",
        "msgs": 2,
        "name": "teste":
        "topic": "teste":
        "usernames":("john")
    }`

The question is ... How I can map that ? I need get "groups" into "response". I trying use mapObject and Map(defined function in  my helper)  but I can't use mapObject (let test = try response.mapObject(rootKey: "response")) because I get "Type String? does not conform to protocol 'ExpressibleByStringLiteral'"

Can anyone help me ?

Thanks  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1053?src=pr&el=h1) Report
> Merging [#1053](https://codecov.io/gh/Moya/Moya/pull/1053?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/616e38c833dd1bdfcd4424e9ba5230f78d13e8fb?src=pr&el=desc) will **increase** coverage by `0.14%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1053/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1053?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           master    #1053      +/-   ##
==========================================
+ Coverage   73.65%   73.79%   +0.14%     
==========================================
  Files          22       22              
  Lines         725      729       +4     
==========================================
+ Hits          534      538       +4     
  Misses        191      191
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1053?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider+Defaults.swift](https://codecov.io/gh/Moya/Moya/pull/1053?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitEZWZhdWx0cy5zd2lmdA==) | `96% <100%> (+0.76%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1053?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1053?src=pr&el=footer). Last update [616e38c...eabe9cb](https://codecov.io/gh/Moya/Moya/pull/1053?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Which version of Moya are you using? Could you provide the whole file? Which line produces `Use of undeclared type 'foo'`? Have you been able to reproduce in a completely new project?  Moya version 8.0.3
Xcode version 8.3.1
The Demo in Moya project can't run, and alert like this.
![image](https://cloud.githubusercontent.com/assets/8944018/24994539/ec12e2bc-205d-11e7-8f83-4b5b59188f05.png)

I also new a project and test, it is also have this problem. I can‚Äòt run other projects on my iPhone before and alert build success. When I try to use ‚Äôcarthage update‚Äò (but update failure) and build the Moya Framework. Then I run my project. Then it alert this(also in the moya demo) : 
![image](https://cloud.githubusercontent.com/assets/8944018/24998012/49120788-206b-11e7-83a6-a5ee4eda0b63.png)
 
  Hi, 
Is it possible to use gRPC with Moya?

https://github.com/grpc/grpc/tree/master/src/objective-c  Moya : 8.0.3
Language : Swift 3.1


### Let's imagine that you have a link that looks like that:

```swift
let urlString = "https://google.com/123/somepath?X-ABC-Asd=123"
```

### When I do my request using `Alamofire` :

```swift
Alamofire.upload(fileURL, to: URL(string: urlString)!, method: .put, headers: nil).response {
    response in
    print(response)
}
```

it all seems fine(don't look at status code):

![screen shot 2017-04-12 at 14 14 40](https://cloud.githubusercontent.com/assets/9297748/24957000/7984ebce-1f8a-11e7-8a6c-c62bc003f60b.png)

### but when I do the same request using Moya like that:

```swift
enum MyApi {
    case upload
}
extension MyApi : TargetType {
    var baseURL: URL {
        let urlString = "https://google.com/123/somepath?X-ABC-Asd=123"
        return URL(string: urlString)!        
    }

    var path: String {
        return ""
    }
    
    ...
}

provider.request(MyApi.upload)
```
The created request URL is different that in `Alamofire` request.

![screen shot 2017-04-12 at 14 20 49](https://cloud.githubusercontent.com/assets/9297748/24957215/4a202bea-1f8b-11e7-831f-776c84c5f555.png)


## The difference is that before `?` character moya inserts the `/` char. 

https://google.com/123/somepath?X-ABC-Asd=123
https://google.com/123/somepath/?X-ABC-Asd=123

Could you help me and tell me what I'm doing wrong?

<!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 @pedrovereza 
Thanks for your response.

I've created a sample repo with the test code. Just clone and run it.

https://github.com/k8mil/MoyaBaseURL

Below you can see, screen from Charles with 3 options:

### First
request was performed with Alamofire using 
`URL(string: "https://google.com/123/somepath?X-ABC-Asd=123")!`
### Second
request was performed using MoyaProvider with
`baseURL = "https://google.com/123/somepath?X-ABC-Asd=123"` 
### Third
request was performed using MoyaProvider with
`baseURL = "https://google.com` and `path = "/123/somepath?X-ABC-Asd=123"`

<img width="481" alt="screen shot 2017-04-13 at 22 19 42" src="https://cloud.githubusercontent.com/assets/9297748/25022746/5eb6b03a-2097-11e7-8a94-0e8b3710504b.png">


And only Alamofire produces that what I want to achieve :)

Important thing is that I'm using `Moya` in my project and the consuming my backend API with Moya is really great and works perfectly, but I have some case that I have to use the `URL`(which is not related with backedAPI) that I received from some service and I shouldn't modify that `URL`. Unfortunately, as you can see in the Second and Thrid example the URL is modified by removing/changing the `?` char.


 Thanks @pedrovereza !
I've tested it and it works fine.
So, now I wait till it will be merged with `master` üëç  :)  Hello, i am a little confused about [this](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/RxMoya/RxMoyaProvider.swift#L20) method(and it counterpart from ReactiveMoyaProvider). I know, I can later observe on any scheduler I want, but why I can't avoid unnecessary calls on main thread(which I can do with plain Moya api)? If it is not by design, I would like to make tiny contribution üò∏  @AndrewSB yeah, sorry, 2am is not best time to create issue descriptions üòÖ I'll try again:
As far as i know, by default Alamofire invokes all callbacks on Main queue, but you can customize this behavior via queue parameter. Moya [expose](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/Moya/MoyaProvider.swift#L85) this parameter, but RxMoyaProvider [don't](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/RxMoya/RxMoyaProvider.swift#L20). As a result, we can't avoid Main thread.

Only `self.request` [invocation](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/RxMoya/RxMoyaProvider.swift#L24) can be customized via subscribeOn, but [completion handler](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/RxMoya/RxMoyaProvider.swift#L25-L31) will be invoked on Main thread. To avoid future computation on main thread we can observe chain on another Scheduler, but we can't bypass main thread callback and unnecessary dispatches.

I look through https://github.com/Moya/Moya/pull/762 Are you sure that pass scheduler(instead of Queue) is the best idea? I believe this is not Rx-side work, and we should just pass queue to [this](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/Moya/MoyaProvider.swift#L85) method. I don't understand why you are propose to capture queue on provider creation (`RxMoyaProvider<GitHub>(queue: DispatchQueue.global(.utility))`) instead of pass it on each observable creation(this [method](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/RxMoya/RxMoyaProvider.swift#L20))
I propose:
- Add optional queue parameter to provider creation
- Add optional queue parameter to [this](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/RxMoya/RxMoyaProvider.swift#L20) method

And for [RxSwiftProgress](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/RxMoya/RxMoyaProvider.swift#L50) [ReactiveProvider](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift#L26) [ReactiveProvider with progress](https://github.com/Moya/Moya/blob/9.0.0-dev/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift#L76) Ok, I'll do it tomorrow, sorry for scheduling PR on weekends :)  Hi guys, 

I try to send `json`(username and password) on network requests. 
```json
{ 
  "username": "me",
  "password": "1234"
}
```
Following the documentation:
https://github.com/Moya/Moya/blob/circle-ci-xcode-8-3/docs/Examples/AuthPlugin.md

the `func prepare()` can be used to add `jwt` to requests.

The problem is that this function is not being called and therefore the parameters that are passed inside `json` do not work.

Any idea? Or, what is missing .. if I am doing something wrong. Or what I understand does not make sense? üòÖ

```swift
struct AuthUserPlugin: PluginType {
    
    let username: String
    let password: String
    
    func prepare(_ request: URLRequest, target: TargetType) -> URLRequest {
        var request = request
        let json = try? JSONSerialization.data(withJSONObject: ["username": username, "password": password], options: JSONSerialization.WritingOptions.prettyPrinted)
        request.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
        request.httpBody = json
        return request
    }
    
    // MARK: plugin
    
    func willSendRequest(_ request: RequestType, target: TargetType) {
        logger.debug("send request: \(request.request?.url?.absoluteString ?? String())")
    }
    
    func didReceiveResponse(_ result: Result<Moya.Response, Moya.Error>, target: TargetType) {
        switch result {
        case .success(let response):
            if 200..<400 ~= (response.statusCode)  {
                logger.debug("\n-->\nReceiving response: (\(response.statusCode )) de \(response.response?.url?.absoluteString ?? String()) \n Data --> \n \(response.data).\n")
            }
            
        case .failure(let error):
            logger.debug("\n-->\nConnection error: \(error)\n")
        }
    }
}
```
```swift
let provider = RxMoyaProvider<MyTarget>(plugins: [AuthUserPlugin(username: username, password: password)])
```
 @douglastaquary Was wondering what your workaround was. Thanks!  @rlam3 This implementation does not work. Do you have any idea how I can send these parameters in the body of the request as json with `Moya`? On my implementation the parameters are `nil`. :(

The function `prepare()` is not called. Any suggestion? @douglastaquary I've been trying to replicate this. Can you share any more information? I've set breakpoints on `prepare()` and it's called for me. @douglastaquary I didn't use AuthPlugin yet. However I would suggest that you use the pass parameters in the headers. There is a method where we can add the parameters into the header. My problem revolves more around how do I refresh an expired jwt token per request which I was hoping I could learn something from your implementation. hahaha. @rlam3 I think that know  what you're talking about.. My first implementation was like this. But also not work. : / This method where we can add the parameters into the header can to work also to pass json in body of request?
Are you have any code for show me? 
I solved the problem in the simplest and obvious way I think. I only implemented Moya's default code. After a long time trying to implement in other ways, I realized that this is the most simple and objective way. As we speak here in Brazil: Moya is Top! üéâ 

I updated the `Moya` version of `8.0.0-beta.3` to `8.0.3` and

```swift
enum MyAPI {
    case xAuth(username: String, password: String)
}

 var parameters: [String: Any]? {
        switch self {
        case .xAuth(let username, let password):
            return ["username": username as AnyObject,
                    "password": password as AnyObject]
        default:
            return nil
        }
    }

    var parameterEncoding: Moya.ParameterEncoding {
        switch self {
        case .xAuth:
            return JSONEncoding.default
        default:
            return URLEncoding.default
        }
    }

 let provider =  RxMoyaProvider<MyAPI>(plugins: [NetworkLoggerPlugin(verbose: true)])
```

The result is this `json` with `username` and `password` in the request body. üç∫ 

```json
{ 
  "username": "me",
  "password": "1234"
}
```
Very easy! üëè 
   I think it's better adding a `headers` property to TargetType protocol, it seems like the following:
```swift
var headers: [String : String]?
```

Say that there is an authentication token we need for case `isAuthenticationRequired`, we have to provide an endpoint when initialize `MoyaProvider`.

```swift
let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
    let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)

    switch target {
    case .isAuthenticationRequired:
        return defaultEndpoint.adding(newHTTPHeaderFields: ["AUTHENTICATION_TOKEN": GlobalAppStorage.authToken])
    default:
        return defaultEndpoint.adding
    }
}

let provider = MoyaProvider<GitHub>(endpointClosure: endpointClosure)
```

Having the `headers` property set, I would't have to write the endpoint, I just need to write the code in MyTarget:
```swift
var headers: [String : String]? = {
    switch self {
    case .isAuthenticationRequired:
        return  ["AUTHENTICATION_TOKEN" : GlobalAppStorage.authToken]
    default:
        return nil
    }
}
```

  Add a markdown link to the license file.  ## Subject

Enhance Moya.Response by using HTTPURLResponse

## Why 

* Moya use Alamofire
* Alamofire's responses are `HTTPURLResponse` 
* `HTTPURLResponse` give us the ability to access `allHttpHeaderFields`

## How

Modify the `Moya.Response` by avoiding downcast Alamofire's response

## Related issue

[#1040 - Moya.Response should use URLHTTPResponse class](https://github.com/Moya/Moya/issues/1040) Woops, sorry 
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Endpoint.swift | 113 | Prefer `!= nil` over `let _ =` 
Endpoint.swift | 114 | Prefer `!= nil` over `let _ =` 
MoyaProvider+Internal.swift | 238 | Prefer `!= nil` over `let _ =` 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 No *Breaking Change*, just me who did the work in a bad way (half in fact).

Seems to be good, i'll have a look in hour for update # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1044?src=pr&el=h1) Report
> Merging [#1044](https://codecov.io/gh/Moya/Moya/pull/1044?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/60c3b8368ff6fbc2b9d3fe47c50295c7d43efafe?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1044/graphs/tree.svg?width=650&src=pr&token=CjZLHCNgNn&height=150)](https://codecov.io/gh/Moya/Moya/pull/1044?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           9.0.0-dev    #1044   +/-   ##
==========================================
  Coverage      73.28%   73.28%           
==========================================
  Files             22       22           
  Lines            730      730           
==========================================
  Hits             535      535           
  Misses           195      195
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1044?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Plugins/NetworkLoggerPlugin.swift](https://codecov.io/gh/Moya/Moya/pull/1044?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvTmV0d29ya0xvZ2dlclBsdWdpbi5zd2lmdA==) | `93.33% <100%> (√∏)` | :arrow_up: |
| [Sources/Moya/Response.swift](https://codecov.io/gh/Moya/Moya/pull/1044?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1Jlc3BvbnNlLnN3aWZ0) | `95.65% <100%> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1044?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1044?src=pr&el=footer). Last update [60c3b83...e0071f2](https://codecov.io/gh/Moya/Moya/pull/1044?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). Thank you @ashfurrow , that's a honor to be part of Moya. 

üëç

Cheers From France   <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The <code>Cartfile</code> or <code>Cartfile.resolved</code> was updated, but there were no changes in the <code>podspec</code>. Did you forget updating the <code>podspec</code>?</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="false">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Endpoint.swift | 113 | Prefer `!= nil` over `let _ =` 
Endpoint.swift | 114 | Prefer `!= nil` over `let _ =` 
MoyaProvider+Internal.swift | 238 | Prefer `!= nil` over `let _ =` 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  <!--
Moya Version: 8.0.3
-->

```swift
public final class Response: CustomDebugStringConvertible, Equatable {
    public let statusCode: Int
    public let data: Data
    public let request: URLRequest?
    public let response: URLResponse?
}
```

should be

```swift
public final class Response: CustomDebugStringConvertible, Equatable {
    public let statusCode: Int
    public let data: Data
    public let request: URLRequest?
    public let response: HTTPURLResponse?
}
```

[Apple HTTPURLResponse class](https://developer.apple.com/reference/foundation/httpurlresponse) is quite more interesting than simple URLResponse. 

For example we have direct access of httpHeaderFields, which can't be accessed through URLResponse class. This issue force us to forcecast (`as!`) response as a HTTPURLResponse: bad practice


## EDIT - Related Pull Request

[PR #1044 - Enhance Moya.Response by using HTTPURLResponse](https://github.com/Moya/Moya/pull/1044) Ahoy, Ok i'll try to look at AF and if possible do the change üëç Thanks for your reply ... and is "downcasted" to a simple URLResponse ... 

https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider.swift#L151

The PR will be short i think üëç  Ahoy everyone

This `enhancement/issue` can be close no ?

üëã   To start, I posted [this on StackOverflow](http://stackoverflow.com/questions/43126192/generate-curl-output-from-moya-request)
I'm using Moya 7.0.4

I need to print the cURL for a network request. 

> Usually, in Alamofire 4, I would do something like this:
```swift
    let req = Alamofire.request(someURLRequestConvertible)
    debugPrint(req) // will print cURL
```

>My call site for Moya looks like this:
```swift
    MyMoyaProvider<MyEndPoints>.request(MyEndPoints.login(params)) { (result) in }
```

I've checked out the documentation for Moya, but I can't seem to get the results I'm looking for. I enabled the `NetworkLoggingPlugin` but still unsure how to print cURL for certain requests. Can someone help me find the proper way to print the Moya request's cURL to console?  @BasThomas Yep! Perfect üëåüèº  Hello, I'm using Moya version 8.0.3 in Swift 3 compiling on linux and I can't building because I have some error in Result libray dependency ... 

My Package.swift:
```swift
import PackageDescription

let package = Package(  
    name: "CryptoSwift",
    dependencies: [
        .Package(url:"https://github.com/Moya/Moya.git", majorVersion:8)
    ]
)
```

My error:
```swift
‚ûú  rocket-service git:(master) ‚úó swift build      
Cloning https://github.com/Moya/Moya.git
HEAD is now at 4ac60f0 Releasing version 8.0.3.
Resolved version: 8.0.3
Cloning https://github.com/Alamofire/Alamofire
HEAD is now at d1f0b86 Added release notes to the CHANGELOG and bumped the version to 4.4.0.
Resolved version: 4.4.0
Cloning https://github.com/ReactiveCocoa/ReactiveSwift
HEAD is now at 1556b84 1.1.1.
Resolved version: 1.1.1
Cloning https://github.com/antitypical/Result.git
HEAD is now at 2af7c14 3.2.1
Resolved version: 3.2.1
Cloning https://github.com/ReactiveX/RxSwift
HEAD is now at 068b4de Release 3.3.1
Resolved version: 3.3.1
Cloning https://github.com/antitypical/Result
HEAD is now at 2af7c14 3.2.1
Resolved version: 3.2.1
error: rename error: Directory not empty (39): /home/repositories/rocket-service/Packages/Result -> /home/repositories/rocket-service/Packages/Result-3.2.1
``` so sad =( i really was excited with this feature in my mind lol So.. I will use that on xcode, thanks !  Fixed headers 
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Endpoint.swift | 113 | Prefer `!= nil` over `let _ =` 
Endpoint.swift | 114 | Prefer `!= nil` over `let _ =` 
MoyaProvider+Internal.swift | 238 | Prefer `!= nil` over `let _ =` 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 Thanks guys! Love how you run open source projects ‚ù§Ô∏è  Hey there!

what is the best place to validate input given into a target as parameter, e.g. a phone number string where the country code is missing. I think about a pre-validation in per-target basis BEFORE the request hits the network. I want to write tests for that but I couldn't find a location where I can do do the validation.

My code looks something like that:

```swift
public enum Service {
    case validatePhoneNumber(number: String)
}

extension Service: TargetType {
    public var path: String {
        switch self {
        case .validatePhoneNumber:
            return "phone"
        }
    }

    public var method: Moya.Method {
        switch self {
        case .validatePhoneNumber:
            return .post
        }
    }

    public var parameters: [String: Any]? {
        switch self {
        case .validatePhoneNumber(let number):
            return ["phone_number": number]
    }
}
``` Oh nice idea!!!! I just could create a PhoneNumberType with a failing initializer. No need for a Library - in my case at least... I think that answers my question ;-)  ```swift

public enum Error: MoyaError {
    case serverError(Int, String)
}
```
this given me 2 error below
Raw type 'MoyaError' is not expressible by any literal

Type 'Error' does not conform to protocol 'RawRepresentable' Thx @pedrovereza if there is a way to extended the MoyaError with mine custom error  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->

Using `Moya` 8.0.1 and `RxSwift` 3.1.0

I'm trying to make sure that `Moya` requests run on a background thread, because currently my UI gets locked up while doing requests. I've been trying to use a `ConcurrentDispatchQueueScheduler`, but invariably the `Moya` requests switch back to the main thread. Example:

```swift
MyAPI.instance.getIndex()
    .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
    .observeOn(MainScheduler.asyncInstance)
    .flatMap { index in /* Do some UI stuff here */ }
    .subscribe(onNext: { uiResults in /* Do something with UI results */ })
```

My `getIndex` function is just a simple

```swift
func getIndex() {
    return self.provider.request(.getIndex)
}
```

Putting a breakpoint inside the `Observable.create` part of the `RxMoyaProvider.request` function always shows `com.apple.main-thread`. This is true even if I remove the `observeOn` from above. Also any subsequent `map`s or `flatMap`s all run on `com.apple.main-thread`. Normally I would expect these to run on the `ConcurrentDispatchQueueScheduler`. This happens if I am not using `Moya`.

Any way to not lock up my UI while using `Moya`?  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="false">Added or removed library files require the Carthage Xcode project to be updated.</td>
    </tr>
  </tbody>
</table>
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          3 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">PR is classed as Work in Progress</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Big PR</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Endpoint.swift | 113 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 
Endpoint.swift | 114 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 
MoyaProvider+Internal.swift | 166 | Variable name should be between 3 and 40 characters long: 'to' 
MoyaProvider+Internal.swift | 168 | Variable name should be between 3 and 40 characters long: 'to' 
MoyaProvider+Internal.swift | 170 | Variable name should be between 3 and 40 characters long: 'to' 
MoyaProvider+Internal.swift | 208 | Variable name should be between 3 and 40 characters long: 'to' 
MoyaProvider+Internal.swift | 238 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1031?src=pr&el=h1) Report
> Merging [#1031](https://codecov.io/gh/Moya/Moya/pull/1031?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/60c3b8368ff6fbc2b9d3fe47c50295c7d43efafe?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1031/graphs/tree.svg?src=pr&token=CjZLHCNgNn&width=650&height=150)](https://codecov.io/gh/Moya/Moya/pull/1031?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           9.0.0-dev    #1031   +/-   ##
==========================================
  Coverage      73.28%   73.28%           
==========================================
  Files             22       22           
  Lines            730      730           
==========================================
  Hits             535      535           
  Misses           195      195
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1031?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [...urces/ReactiveMoya/ReactiveSwiftMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1031?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVTd2lmdE1veWFQcm92aWRlci5zd2lmdA==) | `52.54% <√∏> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1031?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1031?src=pr&el=footer). Last update [60c3b83...316c9f6](https://codecov.io/gh/Moya/Moya/pull/1031?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  I am using the last version of Moya and Alamofire with Swift 3

I am having trouble when the method is "POST" and there is url encoding 

The url must be: 
`products?id_category=28`

but it is converted to be:
`products%3Fid_category=28`

which is not working and giving 400 error on the server

where can I find this conversion and stop it for the requests ?

Here is the code i used:

```Swift
enum MyService {
	case products(categorytId: Int)
}

extension MyService : TargetType {
    
    var base: String { return Constants.MyServiceURL }
    var baseURL: URL { return URL(string: base)! }
    
    public var task: Task {
        return .request
    }

    var path : String {
        switch self {
        // i tried with and without them, changing the parameters down below
        case .products(let id_category): 
            return "products?id_category=\(id_category)"
        }
    }

    var parameterEncoding: ParameterEncoding {
	    switch self {
	        case .products:
	        	//return MyURLEncoding.queryString
	            return URLEncoding.queryString
	        default:
	            return JSONEncoding.default 
	    }
    }

    var parameters : [String : Any]? {
        switch self {
        // here I tried to add them for Testing purpose, i tried with and without them
        case .products(let id_category):
            var params: [String: Any] = [:]
            params["id_category"] = id_category
            return params
        default:
            return nil
        }
    }

    // The method must be always post always
    var method : Moya.Method {
        return .post;
    }

    var sampleDate : Data {
            return Data()
        }
    }
 }
``` @pedrovereza i have updated the comment above. I think if the method is `POST`, the query parameters are not added to the `URL` even if the `URLEncoding.queryString` is returned in the `ParameterEncoding`. Right ? @pedrovereza I have tried exactly what in the example you have mentioned, The parameters are not added at all to the request.

```
["Moya_Logger: [28/03/2017 19:47:25] Request: http://myservice/products", "Moya_Logger: [28/03/2017 19:47:25]]
Request Headers: [ \"Content-Type\": \"application/x-www-form-urlencoded; charset=utf-8\"]"
"Moya_Logger: [28/03/2017 19:47:25] HTTP Request Method: POST"]
["Moya_Logger: [28/03/2017 19:47:25] Response: <NSHTTPURLResponse: 0x7a82a150> { URL: http://myservice/products } 
{ status code: 404, headers {\n    \"Cache-Control\" = \"no-cache\";\n    \"Content-Length\" = 216;\n    \"Content-Type\" = \"application/json; charset=utf-8\";\n    Date = \"Tue, 28 Mar 2017 16:47:18 GMT\";\n    Expires = \"-1\";\n    Pragma = \"no-cache\";\n    Server = \"Microsoft-IIS/8.5\";\n    \"X-AspNet-Version\" = \"4.0.30319\";\n    \"X-Powered-By\" = \"ASP.NET\";\n} }"]
Status Code: 404, Data Length: 216
```


 @iballan try this, I recently had the same issues and solved them by using the following (I forget where, but there was another issue raised in Moya where I cobbled together this answer, wish I could give that author credit):

```swift
var parameterEncoding : Moya.ParameterEncoding {
      
      switch self {
      case .feedback:
         return TokenURLEncoding.default
      default:
         return URLEncoding.default
      }
}

/// Used to append the Token to requests which require it.
/// Don't attempt to do this in the path variable, as our server can't handle % encoding..
struct TokenURLEncoding: Moya.ParameterEncoding {
   
   public static var `default`: TokenURLEncoding { return TokenURLEncoding() }
   
   
   /// Creates a URL request by encoding parameters and applying them onto an existing request.
   ///
   /// - parameter urlRequest: The request to have parameters applied.
   /// - parameter parameters: The parameters to apply.
   ///
   /// - throws: An `AFError.parameterEncodingFailed` error if encoding fails.
   ///
   /// - returns: The encoded request.
   public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
      
      var req = try urlRequest.asURLRequest()
      
      // first coerce a mutable URL out of the urlRequest
      // next, get the components of the request
      // finally, get our token
      guard let request = (req as NSURLRequest).mutableCopy() as? NSMutableURLRequest,
            let components = NSURLComponents(string: request.url!.absoluteString),
            let token = LinesSession().token else {

         // Handle the error
         return req
      }
      
      let json = try JSONSerialization.data(withJSONObject: parameters!,
                                            options: JSONSerialization.WritingOptions.prettyPrinted)

      let tokenQueryItem = NSURLQueryItem(name: "token", value: token)
      components.queryItems = [tokenQueryItem as URLQueryItem]
      
      req.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
      req.url = components.url
      req.httpBody = json

      return req
   }
}

 @avicks the query is not added at all still to the url. I think it has something to do with the method type "Post". btw, i put debug point inside the function you have written and used it. the break point is never reached 

I changed the request type to "Get", and the query was added correctly. but I need to change it to post to work correctly 

also i have tested code with Alamofire and it works:

```Swift
      let url = "\(Constants.MyService)products?id_category=30"
        Alamofire.request(url, method: .post)
            .responseData { response in
                print(response.request as Any)  // original URL request
                print(response.response as Any) // URL response
                print(response.result.value as Any)   // result of response serialization
        }
``` @iballan The query isn't added?  

I'm using that encoding I posted to append my query item to the URL, making a POST request, and getting success.  

Would you mind elaborating on the structure behind your call? @avicks 
@pedrovereza
the problem is instead of getting this as 
`URL: "http://myWebSErvice/products?id_category=30"`

I get this:  %3F
`URL: "http://myWebSErvice/products%3Fid_category=30"`

and when the "**?**" becomes "**%3F**" , the webservice throws error this  "`A potentially dangerous Request.Path value was detected from the client (?).`"

What i want is only to send the request with ? not with %3F @pedrovereza Thank you so much for your help.

However, It is still not working :( 
You may check my Question, i already used `URLEncoding.queryString`

I tried 2 ways:
**First:** setting the query manually:
```swift
   var path : String {
        switch self {
        case .products(let id_category): 
            return "products?id_category=\(id_category)"
        }
    }
```
_Fail_: because **?** was encoded into **%3F**. which caused webservice 400 error.

**Second:** As you mentioned `URLEncoding.queryString`
```swift
   var path : String {
        switch self {
        case .products: 
            return "products"
        }
    }
    var parameterEncoding: ParameterEncoding {
	    switch self {
	        case .products:
	        	//return MyURLEncoding.queryString
	            return URLEncoding.queryString
	        default:
	            return JSONEncoding.default 
	    }
    }

   var parameters : [String : Any]? {
        switch self {
        // here I tried to add them for Testing purpose, i tried with and without them
        case .products(let id_category):
            var params: [String: Any] = [:]
            params["id_category"] = id_category
            return params
        default:
            return nil
        }
    }
```

_Fail_: Not adding the parameter at all.


What made me think that it is **Moya**'s issue, when I use **Alamofire** as I mentioned above the URL is encoded correctly and did not change **?** to **%3F**.

Now in my code I used both Moya (because i already started with it and it is a really overhead work to roll back from it) and Alamofire (to get the POST requests' url query working correctly) üëé 

 Hi everybody, today is my first time to use Moya "it is really great library", in fact I got the same problem when i use path with  this received character "?" I decided to update in the Moya even is not recommended and I'm happy to share my solution with you.
the only thing I've done is to update inside this file MoyaProvider+Defaults.swift.

update this function : 

```swift
 private final class func url(for target: Target) -> URL {
        if target.path.isEmpty {
            return target.baseURL
        }

        return target.baseURL.appendingPathComponent(target.path)
    }
```
with this üëç 

```swift
private final class func url(for target: Target) -> URL {
        if target.path.isEmpty {
            return target.baseURL
        }
        
        let urlComponents = NSURLComponents(url: target.baseURL, resolvingAgainstBaseURL: true)!
        let charset = CharacterSet(charactersIn: "?")
        if target.path.rangeOfCharacter(from: charset) != nil {
            let index = target.path.characters.index(of: "?")
            if let index = index {
                let path = target.path.substring(to: target.path.characters.index(before: index))
                let query = target.path.substring(from: target.path.characters.index(after: index))
                urlComponents.path = path
                urlComponents.query = query
            }
        }
        else{
            urlComponents.path = target.path
        }
        
        return urlComponents.url!
    }

```
 I hope it will help :) I've tried the above modification but it doesn't work with my other url paths without "?". So with a slight modification this works for me now

```swift
private final class func url(for target: Target) -> URL {
        if target.path.isEmpty {
            return target.baseURL
        }

        let urlComponents = NSURLComponents(url: target.baseURL, resolvingAgainstBaseURL: true)!
        let index = target.path.characters.index(of: "?")
        if let index = index {
            let path = target.path.substring(to: index)
            let query = target.path.substring(from: target.path.characters.index(after: index))
            urlComponents.path = path
            urlComponents.query = query
            
            return urlComponents.url!
        } else {
            return target.baseURL.appendingPathComponent(target.path)
        }
    }
```
 hi @jx2359 I updated my code you can check agin it will work with the other url also hi @chivalrousbob, I tried your code again but I got an exception at the last line when the url has no parameters in the path. 

I forgot to add that in my previous comment I've also modified the line where "path" is generated. `target.path.substring(to: target.path.characters.index(before: index))` returns the path with the last character removed, and it results in a 404 response. I have same issues.  I am using Moya and RxSwift to build out my network stack...really porting it but I am a bit new to the Rx way of thinking and I have a general approach question. 

I am using Realm on the device and am planning on syncing up the data with our API. My plan is:

 User edits on device -> Data is saved on local database -> This update is put on a network queue of some sort (I haven't built this part yet but I am planning on using OperationQueue) and the appropriate Moya request is sent.

Ok, lets say we have the following sequence of events:

**1) User edits or adds item A**
---goes on queue (suppose we don't have network connectivity at this point..or slow)
**2) User edits or adds item A**
---goes on queue

Now....what I would like at this point is to cancel the first request and only send the last one since that has all of the necessary information. I would like to use RxSwift if possible.

Could you please help by offering some suggestions on how I would approach such a problem? Yup I think you are right. That is pretty much what I have been doing but I still have the issue of identifying which changes were made offline and save them somehow to send to the server once a connection has been established. 

Maybe, in your example above, on
```
saveDataToNetwork(newA)
```
if there is an error, I can either:

- Save the request itself to retry once a network has been established
or
- Save the primary key and type of Realm object and have some kind of background process that goes through the list of entities that need updating.

Do any of those approaches sound reasonable? Yup that is pretty much what I was thinking of doing. Thank you for all of your suggestions. It was very helpful.  I have an IOS app that needs to access a user's home-based server.  If the user is on their home network, the request should happen on their home network (e.g. 192.168.1.x.).  However, if the user is remote, the request should be sent to their static DNS/IP.  Some users use a VPN so I really need my app to connect to the primary and if it fails then fail over to the secondary.

The user enters both local/remote settings inside my app.  I was hoping that Moya/Alamofire could be configured to have a primary and secondary base URL so that if the primary fails the secondary is invoked. Thank you @pedrovereza.  That #980 does resemble something similar to what I'm trying to accomplish but it's only a portion of what I'm after - but I'll work through it and see if I can come up with a decent solution.

Ideally I'd like to give Moya 2 URL's - the first one would be primary and the other secondary/backup.  If the primary call fails, the secondary would be executed.  These URL's point to the exact same server so everything on the backend is identical - the URL's differ if the user is local/home versus remote. @pedrovereza Yep - that's exactly what I'm after - just trying to figure out how to do that Moya-style :-)  

There are many areas of my code where I invoke network calls so I'm trying to figure out a way to abstract the logic away from the code calling the API and have the RxMoyaProvider execute the primary/secondary call "behind the scenes".   For instance, here's a typical call:

```swift        
MyAPI.sharedInstance.provider.request(MyProvider.Programs)
            .subscribe(onNext: { (response) -> Void in
                self.parsePrograms(response: response)
                //   print(response)
            }, onError: { (error) -> Void in
                print(error)
            }).addDisposableTo(bag)
```

I suppose I could capture the error, alter the baseURL of the provider, and re-execute the request but I'd have to copy/paste that logic all over the place.  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Endpoint.swift | 113 | Prefer `!= nil` over `let _ =` 
Endpoint.swift | 114 | Prefer `!= nil` over `let _ =` 
MoyaProvider+Internal.swift | 238 | Prefer `!= nil` over `let _ =` 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1027?src=pr&el=h1) Report
> Merging [#1027](https://codecov.io/gh/Moya/Moya/pull/1027?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/d431add45fd9c62bb53b4fa9b7f9448dd8cb7980?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1027/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1027?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master    #1027   +/-   ##
=======================================
  Coverage   73.65%   73.65%           
=======================================
  Files          22       22           
  Lines         725      725           
=======================================
  Hits          534      534           
  Misses        191      191
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1027?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [...urces/ReactiveMoya/ReactiveSwiftMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1027?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVTd2lmdE1veWFQcm92aWRlci5zd2lmdA==) | `52.54% <√∏> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1027?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1027?src=pr&el=footer). Last update [d431add...56b9d53](https://codecov.io/gh/Moya/Moya/pull/1027?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift

```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->

i get no error onError(), when i close network
but i get debug with moya *Received empty network response for *
how handle this error , why not return this error
 ```swift
wildListViewModel.loading
    .subscribe(onNext: { [weak self] (items: ResultArray<Model>) in
        
        if let strongSelf = self {
            if items.code == ResultAPICode.success.rawValue {
                if let datas = items.data {
                }
            }
        }
    }
}, onError: { [weak self] (error: Error) in
    // when i close network, have no error return this
}, onCompleted: { [weak self] in
    //when i close network, have no error return this either
}, onDisposed: nil)
.addDisposableTo(disposeBag)
``` @BasThomas thank for you help yes, you are right, it is my mistake with my Reactive implementation . but i can get error again after my onError . I have some problem for   Reactive implementation, can you help me?
```swift
request(strongSelf.userId , strongSelf.pageSize, strongSelf.pageNo)
    .subscribe(onNext: { (items: ResultArray<Element>) in
        if items.code == ResultAPICode.success.rawValue {
            strongSelf.loading.onNext(items)
        }, onError: { (error) in
            self?.loading.onError(error) // there netError will return over agin , but can not sent this error to loading, 
        }, onCompleted: {
    }, onDisposed: nil)
.addDisposableTo(strongSelf.disposeBag)
``` I am not sure if this helps track it down but I just encountered this error as well. If I make too many simultaneous network requests they all fail. For example if I try to fetch a bunch of data at once:
```swift
provider.request(.target1).mapJSON(). map { data in 
...
}

provider.request(.target2).mapJSON(). map { data in 
...
}

provider.request(.target3).mapJSON(). map { data in 
...
}
```
This seems to not work for some reason. Not sure if it is related to your issue.  I use cocoapods install moya, after of 'pod install' ,compiler error:module file's minimum deployment targer is ios9.0 v9.0, but my iOS Deployment Target is 9.0  and Alamofire is 4.0.1 ```ruby
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, ‚Äô9.0‚Äô
use_frameworks!

target 'BeautifulApp' do
    pod 'Alamofire',    '~>4.0.0'
    pod 'Moya‚Äô,  	‚Äò~>8.0.0-beta.1'
end
``` After removing Alamofire Ôºåcan runÔºåthank youÔºÅ  if Use parameters with JSONEncoding it returns response with string included as \t\t\n\t\n\t\t\n\t\n\t\t\n\t\n\t\t\n\t\t\t ?

how to handle this ?  I'm trying to find cancel request method in Moya but seem it's not support. Let me know if i missing something from document. @BasThomas thanks, i got it
In my case, i call request_1, but this not response, i continue call request_2, so i want canceled request_1 (mean only 1 request available at the same time). Do we have any property or method to do that? @bestwnh i think this way not make sense in search function. Before i call request_2, i check is there any request at this time, if have, i'll canceled all. @bestwnh i got it, thanks. I ask to make sure did Moya support or not this feature because i see we have Manager(type: Alamofire.SessionManager) in MoyaProvider. i think the way of @bestwnh is good & easy for me now thanks all  if request fails then show the alert with option retry For Reactive/Rx Moya I have to use whole swift coding in Reactive. Right ?
Or can  I use  Reactive/Rx Moya in normal swift  ?    # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1020?src=pr&el=h1) Report
> Merging [#1020](https://codecov.io/gh/Moya/Moya/pull/1020?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/0dc516b9c27f300a3ba94ec90a418da89b8e226c?src=pr&el=desc) will **increase** coverage by `0.03%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/1020/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/1020?src=pr&el=tree)

```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1020      +/-   ##
=============================================
+ Coverage      73.25%   73.28%   +0.03%     
=============================================
  Files             22       22              
  Lines            729      730       +1     
=============================================
+ Hits             534      535       +1     
  Misses           195      195
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1020?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/RxMoya/RxMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/1020?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhUHJvdmlkZXIuc3dpZnQ=) | `43.58% <100%> (+1.48%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1020?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1020?src=pr&el=footer). Last update [0dc516b...7cd988d](https://codecov.io/gh/Moya/Moya/pull/1020?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Endpoint.swift | 113 | Prefer `!= nil` over `let _ =` 
Endpoint.swift | 114 | Prefer `!= nil` over `let _ =` 
MoyaProvider+Internal.swift | 238 | Prefer `!= nil` over `let _ =` 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Incoded -> Encoded. <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="false">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Hi,

In my project (EVReflection) I have a dependency to ReactiveSwift in a subspec. When publishing my project I now get a warning. (Fortunately I can still publish while ignoring the warnings)

The source of the problem can be found here:
https://github.com/Moya/Moya/blob/48dfad39608a1afeb06da248f0da31a0b3d7863b/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift#L9

When I do a 'pod trunk push' I get the following warnings:

```
Validating podspec
 -> EVReflection (4.5.1)
    - WARN  | [EVReflection/MoyaReactiveSwift,EVReflection/MoyaReactiveSwiftXML] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:9:32: warning: 'DateSchedulerProtocol' is deprecated: renamed to 'DateScheduler'
    - NOTE  | [EVReflection/MoyaReactiveSwift,EVReflection/MoyaReactiveSwiftXML] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:9:32: note: use 'DateScheduler' instead
    - WARN  | [EVReflection/MoyaReactiveSwift,EVReflection/MoyaReactiveSwiftXML] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:15:60: warning: 'DateSchedulerProtocol' is deprecated: renamed to 'DateScheduler'
    - NOTE  | [EVReflection/MoyaReactiveSwift,EVReflection/MoyaReactiveSwiftXML] xcodebuild:  Moya/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift:15:60: note: use 'DateScheduler' instead

Updating spec repo `master`
```

Here is the podfile that i use:
```
Pod::Spec.new do |s|
  s.name         = "EVReflection"
  s.version      = "4.5.1"
  s.summary      = "Reflection based (dictionary, JSON or XML) object mapping (including extensions for Alamofire and Moya with RxSwift or ReactiveSwift)"

  s.description  = <<-EOS
[Reflection](https://github.com/evermeer/EVReflection) based object mapping (dictionary, Json, XML, CKRecord)
including extensions for [Alamofire](https://github.com/Alamofire/Alamofire) and [Moya](https://github.com/Moya/Moya) for network abstraction. And on top of that extension for [RxSwift](https://github.com/ReactiveX/RxSwift/) and [ReactiveSwift]
EOS

  s.homepage     = "https://github.com/evermeer/EVReflection"
  s.license      = { :type => "MIT", :file => "License" }
  s.author             = { "Edwin Vermeer" => "edwin@evict.nl" }
  s.social_media_url   = "http://twitter.com/evermeer"

  s.ios.deployment_target = '8.0'
  s.osx.deployment_target = '10.10'
  s.watchos.deployment_target = '2.0'
  s.tvos.deployment_target = '9.0'

  s.source       = { :git => "https://github.com/evermeer/EVReflection.git", :tag => s.version }
  s.default_subspec = "Core"

# This is the core EVReflection library
  s.subspec "Core" do |ss|
    ss.source_files  = "Source/*.swift"
    ss.framework  = "Foundation"
  end

# Extending EVReflection with XMLDictionary functions.
  s.subspec "XML" do |ss|
    ss.source_files  = "Source/XML/*.swift"
    ss.dependency "EVReflection/Core"
    ss.dependency "XMLDictionary"
  end

# Extending EVReflection with mapping functions for CKRecord (CloudKit)
  s.subspec "CloudKit" do |ss|
    ss.source_files  = "Source/CloudKit/*.swift"
    ss.dependency "EVReflection/Core"
    ss.framework  = "CloudKit"
  end

# Adding easy Json to object mapping to Alamofire using EVReflection
  s.subspec "Alamofire" do |ss|
    ss.source_files  = "Source/Alamofire/*.swift"
    ss.dependency "EVReflection/Core"
    ss.dependency "Alamofire", "~> 4.2"
  end

# Adding easy XML to object mapping to Alamofire using XMLDictionary and EVReflection
  s.subspec "AlamofireXML" do |ss|
    ss.source_files  = "Source/Alamofire/XML/*.swift"
    ss.dependency "EVReflection/XML"
    ss.dependency "EVReflection/Alamofire"
  end

# Adding easy Json to object mapping to Moya using EVReflection
  s.subspec "Moya" do |ss|
    ss.source_files  = "Source/Alamofire/Moya/*.swift"
    ss.dependency "Moya", "~> 8.0"
    ss.dependency "EVReflection/Alamofire"
  end

# Adding easy XML to object mapping to Moya using XMLDictionary and EVReflection
  s.subspec "MoyaXML" do |ss|
    ss.source_files  = "Source/Alamofire/Moya/XML/*.swift"
    ss.dependency "EVReflection/AlamofireXML"
    ss.dependency "EVReflection/Moya"
  end

# Adding RxSwift functionality to the Moya extension
  s.subspec "MoyaRxSwift" do |ss|
    ss.source_files = "Source/Alamofire/Moya/RxSwift/*.swift"
    ss.dependency "Moya/RxSwift"
    ss.dependency "EVReflection/Moya"
  end

# Adding RxSwift functionality to the MoyaXML extension
  s.subspec "MoyaRxSwiftXML" do |ss|
    ss.source_files = "Source/Alamofire/Moya/RxSwift/XML/*.swift"
    ss.dependency "EVReflection/MoyaRxSwift"
    ss.dependency "EVReflection/MoyaXML"
  end

# Adding ReactiveSwift functionality to the Moya extension
  s.subspec "MoyaReactiveSwift" do |ss|
    ss.source_files = "Source/Alamofire/Moya/ReactiveSwift/*.swift"
    ss.dependency "Moya/ReactiveSwift"
    ss.dependency "EVReflection/Moya"
  end

# Adding ReactiveSwift functionality to the MoyaXML extension
  s.subspec "MoyaReactiveSwiftXML" do |ss|
    ss.source_files = "Source/Alamofire/Moya/ReactiveSwift/XML/*.swift"
    ss.dependency "EVReflection/MoyaReactiveSwift"
    ss.dependency "EVReflection/MoyaXML"
  end
end
```
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1017?src=pr&el=h1) Report
> Merging [#1017](https://codecov.io/gh/Moya/Moya/pull/1017?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/107b36257336ee109471b67c13f4f1ec38896a73?src=pr&el=desc) will **decrease** coverage by `0.4%`.
> The diff coverage is `50%`.


```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1017      +/-   ##
=============================================
- Coverage      73.65%   73.25%   -0.41%     
=============================================
  Files             22       22              
  Lines            725      729       +4     
=============================================
  Hits             534      534              
- Misses           191      195       +4
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1017?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/ReactiveMoya/SignalProducer+Response.swift](https://codecov.io/gh/Moya/Moya/compare/107b36257336ee109471b67c13f4f1ec38896a73...746f81a80866a3fa4e340b20771d340f29578fa1?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvU2lnbmFsUHJvZHVjZXIrUmVzcG9uc2Uuc3dpZnQ=) | `90% <0%> (√∏)` | :white_check_mark: |
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/compare/107b36257336ee109471b67c13f4f1ec38896a73...746f81a80866a3fa4e340b20771d340f29578fa1?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `84.74% <50%> (-6.17%)` | :x: |
| [Sources/Moya/MoyaError.swift](https://codecov.io/gh/Moya/Moya/compare/107b36257336ee109471b67c13f4f1ec38896a73...746f81a80866a3fa4e340b20771d340f29578fa1?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFFcnJvci5zd2lmdA==) | `31.81% <50%> (√∏)` | :white_check_mark: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/compare/107b36257336ee109471b67c13f4f1ec38896a73...746f81a80866a3fa4e340b20771d340f29578fa1?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.27% <66.66%> (√∏)` | :white_check_mark: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1017?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1017?src=pr&el=footer). Last update [107b362...746f81a](https://codecov.io/gh/Moya/Moya/compare/107b36257336ee109471b67c13f4f1ec38896a73...746f81a80866a3fa4e340b20771d340f29578fa1?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  I think it would be better to create new Provider, like RxSingleMoyaProvider to make this change non-breaking. In this way we will support both Observable and Single. And it will be easier to migrate to the Single. # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1016?src=pr&el=h1) Report
> Merging [#1016](https://codecov.io/gh/Moya/Moya/pull/1016?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/0dc516b9c27f300a3ba94ec90a418da89b8e226c?src=pr&el=desc) will **increase** coverage by `0.44%`.
> The diff coverage is `60%`.


```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1016      +/-   ##
=============================================
+ Coverage      73.25%   73.69%   +0.44%     
=============================================
  Files             22       22              
  Lines            729      726       -3     
=============================================
+ Hits             534      535       +1     
+ Misses           195      191       -4
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1016?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/ReactiveMoya/SignalProducer+Response.swift](https://codecov.io/gh/Moya/Moya/compare/0dc516b9c27f300a3ba94ec90a418da89b8e226c...26b9d47792032a589ef82cf2574c5f71b1c65ddf?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvU2lnbmFsUHJvZHVjZXIrUmVzcG9uc2Uuc3dpZnQ=) | `90% <0%> (√∏)` | :arrow_up: |
| [Sources/RxMoya/RxMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/compare/0dc516b9c27f300a3ba94ec90a418da89b8e226c...26b9d47792032a589ef82cf2574c5f71b1c65ddf?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhUHJvdmlkZXIuc3dpZnQ=) | `43.58% <100%> (+1.48%)` | :arrow_up: |
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/compare/0dc516b9c27f300a3ba94ec90a418da89b8e226c...26b9d47792032a589ef82cf2574c5f71b1c65ddf?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `90.9% <50%> (+6.16%)` | :arrow_up: |
| [Sources/Moya/MoyaError.swift](https://codecov.io/gh/Moya/Moya/compare/0dc516b9c27f300a3ba94ec90a418da89b8e226c...26b9d47792032a589ef82cf2574c5f71b1c65ddf?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFFcnJvci5zd2lmdA==) | `31.81% <50%> (√∏)` | :arrow_up: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/compare/0dc516b9c27f300a3ba94ec90a418da89b8e226c...26b9d47792032a589ef82cf2574c5f71b1c65ddf?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.27% <66.66%> (√∏)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1016?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1016?src=pr&el=footer). Last update [0dc516b...26b9d47](https://codecov.io/gh/Moya/Moya/compare/0dc516b9c27f300a3ba94ec90a418da89b8e226c...26b9d47792032a589ef82cf2574c5f71b1c65ddf?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1015?src=pr&el=h1) Report
> Merging [#1015](https://codecov.io/gh/Moya/Moya/pull/1015?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/23be21483154bfed6b2a851cee8c6eb0ea66212f?src=pr&el=desc) will **increase** coverage by `0.4%`.
> The diff coverage is `50%`.


```diff
@@            Coverage Diff            @@
##           master    #1015     +/-   ##
=========================================
+ Coverage   73.25%   73.65%   +0.4%     
=========================================
  Files          22       22             
  Lines         729      725      -4     
=========================================
  Hits          534      534             
+ Misses        195      191      -4
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1015?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/ReactiveMoya/SignalProducer+Response.swift](https://codecov.io/gh/Moya/Moya/compare/23be21483154bfed6b2a851cee8c6eb0ea66212f...14881b06d7d30a3b79555d26c3c8e409ca804a30?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvU2lnbmFsUHJvZHVjZXIrUmVzcG9uc2Uuc3dpZnQ=) | `90% <0%> (√∏)` | :white_check_mark: |
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/compare/23be21483154bfed6b2a851cee8c6eb0ea66212f...14881b06d7d30a3b79555d26c3c8e409ca804a30?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `90.9% <50%> (+6.16%)` | :white_check_mark: |
| [Sources/Moya/MoyaError.swift](https://codecov.io/gh/Moya/Moya/compare/23be21483154bfed6b2a851cee8c6eb0ea66212f...14881b06d7d30a3b79555d26c3c8e409ca804a30?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFFcnJvci5zd2lmdA==) | `31.81% <50%> (√∏)` | :white_check_mark: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/compare/23be21483154bfed6b2a851cee8c6eb0ea66212f...14881b06d7d30a3b79555d26c3c8e409ca804a30?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.27% <66.66%> (√∏)` | :white_check_mark: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1015?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1015?src=pr&el=footer). Last update [23be214...14881b0](https://codecov.io/gh/Moya/Moya/compare/23be21483154bfed6b2a851cee8c6eb0ea66212f...14881b06d7d30a3b79555d26c3c8e409ca804a30?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1013?src=pr&el=h1) Report
> Merging [#1013](https://codecov.io/gh/Moya/Moya/pull/1013?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/a3f0c526ddaf9c10b8044e5121f6272e06e31c27?src=pr&el=desc) will **increase** coverage by `0.44%`.
> The diff coverage is `55.55%`.


```diff
@@              Coverage Diff              @@
##           9.0.0-dev    #1013      +/-   ##
=============================================
+ Coverage      73.21%   73.65%   +0.44%     
=============================================
  Files             22       22              
  Lines            728      725       -3     
=============================================
+ Hits             533      534       +1     
+ Misses           195      191       -4
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1013?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/ReactiveMoya/SignalProducer+Response.swift](https://codecov.io/gh/Moya/Moya/compare/a3f0c526ddaf9c10b8044e5121f6272e06e31c27...3011754e59339a41c04e27d37b65638e1be94064?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvU2lnbmFsUHJvZHVjZXIrUmVzcG9uc2Uuc3dpZnQ=) | `90% <0%> (√∏)` | :white_check_mark: |
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/compare/a3f0c526ddaf9c10b8044e5121f6272e06e31c27...3011754e59339a41c04e27d37b65638e1be94064?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `90.9% <50%> (+6.16%)` | :white_check_mark: |
| [Sources/Moya/MoyaError.swift](https://codecov.io/gh/Moya/Moya/compare/a3f0c526ddaf9c10b8044e5121f6272e06e31c27...3011754e59339a41c04e27d37b65638e1be94064?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFFcnJvci5zd2lmdA==) | `31.81% <50%> (√∏)` | :white_check_mark: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/compare/a3f0c526ddaf9c10b8044e5121f6272e06e31c27...3011754e59339a41c04e27d37b65638e1be94064?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.27% <75%> (+0.17%)` | :white_check_mark: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1013?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1013?src=pr&el=footer). Last update [a3f0c52...3011754](https://codecov.io/gh/Moya/Moya/compare/a3f0c526ddaf9c10b8044e5121f6272e06e31c27...3011754e59339a41c04e27d37b65638e1be94064?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The <code>podspec</code> was updated, but there were no changes in either the <code>Cartfile</code> nor <code>Cartfile.resolved</code>. Did you forget updating <code>Cartfile</code> or <code>Cartfile.resolved</code>?</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Why UploadType has only `file` and `multipart` without `data` options ?

<!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependency manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
  Since RxSwift released version 3.3 which adds support for Single observable, it would be nice if Moya supports this concept.

So, RxMoyaProvider should be able to return Single<> Instead of Observable<>, because ideologically it is more correct, because we emit only one response. It would probably be a breaking change since `request(_ token: Target)` would now return a `Single<Response>` (instead of `Observable<Response>`).
Otherwise, I think `Single` is pretty much the same as a regular `Observable`.  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1010?src=pr&el=h1) Report
> Merging [#1010](https://codecov.io/gh/Moya/Moya/pull/1010?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/e27a381f999cbc0e314b9b1c4e49d47d6d6140aa?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.


```diff
@@           Coverage Diff           @@
##           master    #1010   +/-   ##
=======================================
  Coverage   73.65%   73.65%           
=======================================
  Files          22       22           
  Lines         725      725           
=======================================
  Hits          534      534           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1010?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1010?src=pr&el=footer). Last update [e27a381...cdb0f3f](https://codecov.io/gh/Moya/Moya/compare/e27a381f999cbc0e314b9b1c4e49d47d6d6140aa...cdb0f3febe7c2bd3496ea26094aa6e5473fb5519?src=pr&el=footer&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  When should I dispose the RxMoyaProvider?

If I add that to `self.disposeBag`, I guess that will hold until the viewController dismissing.

So if I make many requests in the viewController, that will be very terrible... ```Swift
Timer.every(5.0.seconds) {
    _ = RxMoyaProvider<MyAPI>().request(.heartbeat).subscribe()
}
```

Is this right? I don't care the response or error. I just want to send a request periodically. Wouldn't you do something like this....

```swift
class SomeViewController: UIViewController {
    
  let provider = RxMoyaProvider<MyAPI>()
  let disposeBag = DisposeBag()
  
  override func viewDidLoad() {
      
    Timer.every(5.0.seconds)
       .flatMap({ _ in return provider.request(.heartbeat)})
       .switchLatest()
       .subscribe(onNext: { _ in 
          print("thump")
       })
       .disposed(by: disposeBag)
       
  }
}
```

EDIT: 
I realize I gave an answer but didn't really explain as Andrew did. This is probably more of a RxSwift question than a Moya question. You would treat the request as any other rx signal as Andrew mentioned. My example is showing that you probably want to extract the provider out and hold reference onto it instead of creating a new provider every time you want to make a request. In the example above the disposeBag is attached to the view controller... When the view controller goes out of scope, the disposeBag will be disposed, and so will any subscriptions attached to it. @AndrewSB Thank you much. I think I made a conceptual mistake. The request is retain by subscription instead of provider.
And I think the `Finite sequence` does not need to `addDisposeBag`, they will auto dispose while receiving `.completed` or `.error` message.

I have no problem now, thanks you all.  I want to know if I storage a RxMoyaProvider and share it with multiple requests, is there any problem? (example: Can I start multiple requests with the same provider at the same time?)

In other words, if I have very intensive requests, should I init and deinit Provider for each request? Do this reduce performance?  Use `NSNull()` to fill that entry in your dictionary. To provide a default value of an optional of `[String: Any]`, you could use an empty dictionary `[:]` instead of `NSNull`.

On 12 Mar 2017, 4:27 PM +0800, Philip Engberg <notifications@github.com>, wrote:
>
> Thanks @vzsg (https://github.com/vzsg). But I'm curious as to why you need to use some old NSObject subclass in a Swift dictionary, when we have optionals?
>
>
> Also, what is the easiest way of constructing the parameters dictionary then? Let's say I have an object
>
> struct LineupPlayer { let id: Int let user : _User? }
>
>
> doing the following
>
> extension LineupPlayer : ParameterRepresentation { var representation: [String : Any] { return ["id": id, "user": user?.representation ?? NSNull()] }
>
>
> results in a compile error Generic parameter 'T' could not be inferred, since the nil-coalescing operator tries to operate on two different types.
>
>
> How would you recommend to do this?
>
>
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub (https://github.com/Moya/Moya/issues/1007#issuecomment-285930025), or mute the thread (https://github.com/notifications/unsubscribe-auth/AAEG8NlI1Fm4caHS0IJX5UTbZzpr285kks5rk6yLgaJpZM4MaS-O).
>
>
>

 Why don't you do it as the following? Also, what is the type of `representation`? Is it the same as `LineupPlayer` representation?

```swift
/// What is the expected type of user?.representation

extension LineupPlayer : ParameterRepresentation {
    var representation: [String : Any] {
        return ["id": id, "user": user?.representation as? [String: Any] ?? [:]]
    }
}
``` Alright, understood. It compiles, but there's an error? or a warning? 

If it's a warning I don't think that is an issue since that is what you're doing, coercing `[String: Any]` to `Any` and using `NSNull` as a default, which is a different type from `[String: Any]`.  Any ETA on the 8.0.3 release? We're currently using the Xcode beta because the 3.1 compiler is a whole-lot faster then the 3.0 one.  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1005?src=pr&el=h1) Report
> Merging [#1005](https://codecov.io/gh/Moya/Moya/pull/1005?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/bd0365f88c6a52857e32146af6d419483c92795a?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.


```diff
@@           Coverage Diff           @@
##           master    #1005   +/-   ##
=======================================
  Coverage   73.65%   73.65%           
=======================================
  Files          22       22           
  Lines         725      725           
=======================================
  Hits          534      534           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1005?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1005?src=pr&el=footer). Last update [bd0365f...1fac330](https://codecov.io/gh/Moya/Moya/compare/bd0365f88c6a52857e32146af6d419483c92795a...1fac330ba27f9d0a86268dd7772d3a6dfeb8d0a4?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  Hi I've been using Moya with RxSwift but I need to add some http headers to the request and I've been looking through the rxswift documentation but I can't find this. Can anyone help me with this issue please? 

 @gperdomor thanks! I'll look into it  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/1002?src=pr&el=h1) Report
> Merging [#1002](https://codecov.io/gh/Moya/Moya/pull/1002?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/ca5c9fed3a6ad4bb8be9a5d882bb202782910ac1?src=pr&el=desc) will **increase** coverage by `0.03%`.
> The diff coverage is `100%`.


```diff
@@            Coverage Diff             @@
##           master    #1002      +/-   ##
==========================================
+ Coverage   73.61%   73.65%   +0.03%     
==========================================
  Files          22       22              
  Lines         724      725       +1     
==========================================
+ Hits          533      534       +1     
  Misses        191      191
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/1002?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/compare/ca5c9fed3a6ad4bb8be9a5d882bb202782910ac1...d2070ee47a189b822dde00bc6f186e72da944d9a?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.27% <100%> (+0.17%)` | :white_check_mark: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/1002?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/1002?src=pr&el=footer). Last update [ca5c9fe...d2070ee](https://codecov.io/gh/Moya/Moya/compare/ca5c9fed3a6ad4bb8be9a5d882bb202782910ac1...d2070ee47a189b822dde00bc6f186e72da944d9a?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  Hello. I was looking at stubbing Moya requests and I had great difficulty in figuring out how to do it. It would be great if the documentation could give examples on how to do so.
 @dannymout For absolute beginners who haven't read all the docs yet, I would expect to see documentation about stubs in the [Basic](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md) section. This is especially important as the Basic doc talks about sampleData and how great Moya helps you doing unit testing.

Thanks for making Moya! What if i try to use provider like this ?

`let provider = MoyaProvider<Target>(endpointClosure: defaultEndpointClosure, stubClosure: MoyaProvider.immediatelyStub)` As someone currently trying to figure this out, I agree that it should be in the Basics section.

Also, while the Provider docs make it clear how to "stub" the requests, it doesn't make it clear what that the requests are stubbed *with*. `sampleData` is not mentioned anywhere on the page except as part of the default endpoint closure. It'd be nice to explicitly state the connection to prevent confusion. It'd also make that page show up in searches for `sampleData`.

Thanks!  I wanna consume this URLs:
"https://api.github.com/search/repositories?q=language:Swift&sort=stars&page={param}"
"https://api.github.com/repos/{param}/{param}/pulls"
In the first URL the language and classification parameters ("Swift", "stars") are constant, so I set the values directly in the path, should i try to define the values in the parameters attribute? And try to send  "Swift" and "stars" as constants values? I can mantain the structure in the second URL?

Currently the request URL is changed to: "https://api.github.com/search/repositories%3Fq=language:Swift&sort=stars&page=1". After i call the provider.


```swift
import Moya
import Alamofire
import Foundation

enum GithubAPI{
    case repository(page: Int)
    case pullRequest(repository: Repository)
}
extension GithubAPI: TargetType{
    /// The method used for parameter encoding.
    
    var baseURL: URL { return
        URL(string: "https://api.github.com/")!
    }

    /// The path to be appended to `baseURL` to form the full `URL`.
    public var path: String {
        switch self {
        case .repository(let page): return "search/repositories?q=language:Swift&sort=stars&page=\(page)"
        case .pullRequest(let repository): return "repos/\(repository.owner.name)/\(repository.name)/pulls"
        }
        
    }
    
    var method: Moya.Method{
        switch self{ case .repository, .pullRequest : return .get}
    }
    
    // I tried use JSONEncoding too
    public var parameterEncoding: Moya.ParameterEncoding{ return URLEncoding.default}
    
    
    public var parameters: [String: Any]?{
        switch self{
        case .repository : return nil
        case .pullRequest : return  nil
        }
    }
    
    public var task: Task{ return .request}
    public var sampleData: Data{
        switch self{
        default : return Data()
        }
    
    }
```

 So, i resolved using the endPoint constructor
```swift
let urlSolver = { (target: GithubAPI) -> Endpoint<GithubAPI> in
    let url = target.baseURL.absoluteString.appending(target.path)
    return Endpoint(url:  url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
}

let rxProvider = RxMoyaProvider<GithubAPI>(endpointClosure: urlSolver)
```  How can I use the sampleData defined in TargetTypes for unit testing (XCTests)?
I tried specifying an endpoint closure, but it still goes to the actual end point and returns that response instead of the sampleData.

Any guidance would be greatly appreciated. Aha! That was the missing part from my code. It would be great if this is reflected in the docs, especially here:
https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md  What RSS capabilities does Moya have? Right now I'm using https://github.com/AdeptusAstartes/AlamofireRSSParser but I'd prefer Moya because of the ReactiveSwift support. If downloading and parsing RSS feeds isn't a feature, is it on the roadmap?
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>

    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Big PR</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Endpoint.swift | 17 | Limit vertical whitespace to a single empty line. Currently 2. 
Endpoint.swift | 31 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 32 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 33 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 34 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 35 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya.swift | 28 | Limit vertical whitespace to a single empty line. Currently 2. 
Moya.swift | 59 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya.swift | 60 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya.swift | 61 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya.swift | 62 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya.swift | 63 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya.swift | 55 | Shorthand syntactic sugar should be used, i.e. [Int] instead of Array<Int> 
Moya.swift | 5 | Prefer `-> Void` over `-> ()`. 
Moya.swift | 97 | Prefer `-> Void` over `-> ()`. 
NetworkActivityPlugin.swift | 12 | Prefer `-> Void` over `-> ()`. 
Moya+Internal.swift | 102 | Prefer `-> Void` over `-> ()`. 
Moya+Internal.swift | 198 | Prefer `-> Void` over `-> ()`. 
Moya+ReactiveCocoa.swift | 12 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya+ReactiveCocoa.swift | 13 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya+ReactiveCocoa.swift | 14 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya+ReactiveCocoa.swift | 15 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya+ReactiveCocoa.swift | 16 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya+RxSwift.swift | 11 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya+RxSwift.swift | 12 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya+RxSwift.swift | 13 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya+RxSwift.swift | 14 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Moya+RxSwift.swift | 15 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  A deploy isn't contingent on pushing to master - just the tag + commits, so
amending the script to put you in a place to send a private seems a good
first step?

On Mar 4, 2017 12:49 PM, "Scott Hoyt" <notifications@github.com> wrote:

> Well, I suppose on the other hand, as long as we can't force push, then we
> won't be able to do anything absolutely irreversible. It just might be a
> major pain to do so...
>
> ‚Äî
> You are receiving this because you are on a team that was mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Moya/Moya/issues/994#issuecomment-284124706>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAC_jswdyUaejOlcBq5KHtllS9FD6AfVks5riN9AgaJpZM4MPIc3>
> .
>
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/993?src=pr&el=h1) Report
> Merging [#993](https://codecov.io/gh/Moya/Moya/pull/993?src=pr&el=desc) into [9.0.0-dev](https://codecov.io/gh/Moya/Moya/commit/c07085d92c82356bd47c098742c305f9cc4bf662?src=pr&el=desc) will **decrease** coverage by `-0.41%`.
> The diff coverage is `50%`.


```diff
@@              Coverage Diff              @@
##           9.0.0-dev     #993      +/-   ##
=============================================
- Coverage      73.61%   73.21%   -0.41%     
=============================================
  Files             22       22              
  Lines            724      728       +4     
=============================================
  Hits             533      533              
- Misses           191      195       +4
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/993?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/ReactiveMoya/SignalProducer+Response.swift](https://codecov.io/gh/Moya/Moya/compare/c07085d92c82356bd47c098742c305f9cc4bf662...249e436ab1c32f212a195afbe411fe5234aba81f?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvU2lnbmFsUHJvZHVjZXIrUmVzcG9uc2Uuc3dpZnQ=) | `90% <0%> (√∏)` | :white_check_mark: |
| [Sources/Moya/MoyaError.swift](https://codecov.io/gh/Moya/Moya/compare/c07085d92c82356bd47c098742c305f9cc4bf662...249e436ab1c32f212a195afbe411fe5234aba81f?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFFcnJvci5zd2lmdA==) | `31.81% <50%> (√∏)` | :white_check_mark: |
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/compare/c07085d92c82356bd47c098742c305f9cc4bf662...249e436ab1c32f212a195afbe411fe5234aba81f?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `84.74% <50%> (-6.17%)` | :x: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/compare/c07085d92c82356bd47c098742c305f9cc4bf662...249e436ab1c32f212a195afbe411fe5234aba81f?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.1% <66.66%> (√∏)` | :white_check_mark: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/993?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/993?src=pr&el=footer). Last update [c07085d...249e436](https://codecov.io/gh/Moya/Moya/compare/c07085d92c82356bd47c098742c305f9cc4bf662...249e436ab1c32f212a195afbe411fe5234aba81f?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). Thanks, guys. How come it had not been there for 8 versions xD   I'm building an IOS app using Swift 3 and Moya 8.0.1.  My app needs to connect via HTTPS to a user's own home automation controller (99% of the time the controller has a self signed certificate).  Moya works great when I'm on my own home network and connecting to my automation controller via http and port 80.  However, if I switch it to HTTPS I receive the following error:

underlying(Error Domain=NSURLErrorDomain Code=-1200 "An SSL error has occurred and a secure connection to the server cannot be made." UserInfo={_kCFStreamErrorCodeKey=-9806, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, NSUnderlyingError=0x61800004bfa0 {Error Domain=kCFErrorDomainCFNetwork Code=-1200 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, _kCFNetworkCFStreamSSLErrorOriginalValue=-9806, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9806}}, NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made.
 Yes, according to my Info.plist file I should be bypassing ATS completely:

```
<dict>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>NSAllowsLocalNetworking</key>
		<true/>
		<key>NSAllowsArbitraryLoads</key>
		<true/>
        </dict>
       ....... more here
``` @pedrovereza  - No luck... I'm still getting the exact same error message.  

```swift
provider = RxMoyaProvider<MyCustomProvider>(endpointClosure: endpointClosure, manager: DefaultAlamofireManager.sharedInstance, plugins: [NetworkLoggerPlugin(verbose:true)])

class DefaultAlamofireManager: Alamofire.SessionManager {
    static let sharedInstance: DefaultAlamofireManager = {
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders
        configuration.timeoutIntervalForRequest = 20 // as seconds, you can set your request timeout
        configuration.timeoutIntervalForResource = 20 // as seconds, you can set your resource timeout
        configuration.requestCachePolicy = .useProtocolCachePolicy
        
        return DefaultAlamofireManager(configuration: configuration, serverTrustPolicyManager: CustomServerTrustPoliceManager())
    }()
}

class CustomServerTrustPoliceManager : ServerTrustPolicyManager {
    override func serverTrustPolicy(forHost host: String) -> ServerTrustPolicy? {
        return .disableEvaluation
    }
    public init() {
        super.init(policies: [:])
    }
}
``` @pedrovereza - Thanks.  I already had that in my Info.plist but I'm still getting the same error...  If I hit the same https rest service from a browser I get the typical "this is not a trusted SSL certificate" warning message.  Even the error message coming from Moya states:  "Would you like to connect to the server anyway".  Here's the full error logging message again:

> (Error Domain=NSURLErrorDomain Code=-1200 "An SSL error has occurred and a secure connection to the server cannot be made." UserInfo={_kCFStreamErrorCodeKey=-9806, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, NSUnderlyingError=0x60800005bd50 {Error Domain=kCFErrorDomainCFNetwork Code=-1200 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, _kCFNetworkCFStreamSSLErrorOriginalValue=-9806, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9806}}, NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made.


 Bump...  Nobody on stackoverflow or alamofire have a solution...  Is there a framework that supports self signed SSL certs?  I need something ASAP @pedrovereza - you are awesome!  Thank you for the reference project...  I merged parts of your project with mine and it's now working.  The only thing that looked different than any of my previous attempts was your CustomServerTrustPolicyManager class implementation (specifically the override func serverTrustPolicy and having it always return .disableEvaluation).  Thanks again!  
Using Moya (8.0.0-beta.6)
class Endpoint   import Alamofire  here showing
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/990?src=pr&el=h1) Report
> Merging [#990](https://codecov.io/gh/Moya/Moya/pull/990?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/5a37dc06f45d0aa27230ca265b44132c73c1db68?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.


```diff
@@           Coverage Diff           @@
##           master     #990   +/-   ##
=======================================
  Coverage   73.61%   73.61%           
=======================================
  Files          22       22           
  Lines         724      724           
=======================================
  Hits          533      533           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/990?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/990?src=pr&el=footer). Last update [5a37dc0...66cea45](https://codecov.io/gh/Moya/Moya/compare/5a37dc06f45d0aa27230ca265b44132c73c1db68...66cea458aeddfc412e93f2dd3b88f63ec8cd763d?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/989?src=pr&el=h1) Report
> Merging [#989](https://codecov.io/gh/Moya/Moya/pull/989?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/c07085d92c82356bd47c098742c305f9cc4bf662?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.


```diff
@@           Coverage Diff           @@
##           master     #989   +/-   ##
=======================================
  Coverage   73.61%   73.61%           
=======================================
  Files          22       22           
  Lines         724      724           
=======================================
  Hits          533      533           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/989?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/989?src=pr&el=footer). Last update [c07085d...67c5068](https://codecov.io/gh/Moya/Moya/compare/c07085d92c82356bd47c098742c305f9cc4bf662...67c5068d1801e6c657321c0614ebacff6598488e?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  @dannymout in Xcode console log  Hi, Using Moya v8.0.2

What would be the best to collect statistics regard request and response timing?
Is there a way to get to the underline Alamofire response and access the [timeline property](https://github.com/Alamofire/Alamofire#statistical-metrics)?

Thanks!
  I tried to solve this problem.
https://github.com/Moya/Moya/issues/975

This change does not affect to current behavior, so I pull request to master branch.

## solved problem
when use Alamofire validation, we cannot get response in failure result.

## how to solved
check the Target is using "validate" in convertResponseToResult() <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="false">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 @scottrhoyt  Thanks for comments!

You are right, if someone handling responseValidationFailed, my change will be a breaking change..
> It is technically a breaking change, though. If someone wrote code that looks for the a AFError. responseValidationFailed embedded in a MoyaError.underyling, their code will break with this update. Worse, it would probably be silent--no compiler error.

I think my approach is not best solution ( just patch solution ).
It's may be better to solve #975 next major version.  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/984?src=pr&el=h1) Report
> Merging [#984](https://codecov.io/gh/Moya/Moya/pull/984?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/f5e405a2f15576c616779f6e889431e3a9a8f466?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.


```diff
@@           Coverage Diff           @@
##           master     #984   +/-   ##
=======================================
  Coverage   73.61%   73.61%           
=======================================
  Files          22       22           
  Lines         724      724           
=======================================
  Hits          533      533           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/984?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/984?src=pr&el=footer). Last update [f5e405a...5d93b9f](https://codecov.io/gh/Moya/Moya/compare/f5e405a2f15576c616779f6e889431e3a9a8f466...5d93b9fdff7993865d0b0739c54d0a15fb70dd19?src=pr&el=footer&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).   <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->

Moya i am Using
```
PODS:
  - Alamofire (4.3.0)
  - Moya (8.0.2):
    - Moya/Core (= 8.0.2)
  - Moya/Core (8.0.2):
    - Alamofire (~> 4.1)
    - Result (~> 3.0)
  - Result (3.1.0)
```

---

I try to subclass MoyaProvider like [ReactiveSwiftMoyaProvider.swift](https://github.com/Moya/Moya/blob/master/Sources/ReactiveMoya/ReactiveSwiftMoyaProvider.swift) , so that I can set a global http header for all my requests

## BaseProvider.swift

```swift
import UIKit
import Moya

open class BaseProvider<Target>: MoyaProvider<Target> where Target: TargetType {
    override open func endpoint(_ token: Target) -> Endpoint<Target> {
        let endpoint = endpointClosure(token)
        return endpoint.adding(newHTTPHeaderFields: ["golbalHeader":"h"])
    }
}
```

## Router.swift

```swift
import UIKit
import Moya

enum LessonRouter: String,TargetType{
    case lessonList = ""
    
    var baseURL: URL {
        return URL(string:"")!
    }
        
    var path: String{
        switch self {
        case .lessonList:
            return self.rawValue
        }
    }

    var method: Moya.Method {
        return .get
    }
    
    var parameters: [String: Any]? {
        return nil
    }
    
    var parameterEncoding: ParameterEncoding {
        return URLEncoding.methodDependent
    }
    
    var sampleData: Data {
        return Data()
    }
    
    var task: Task {
        return .request
    }
    
    var validate: Bool {
        return false
    }
    
}
```

## Finally In my ViewController

```swift
import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
//        let lessonProvider = BaseProvider<LessonRouter>()
    }
}

```
if I uncomment that line, I got following error

```
... 
... a lot useless msg here
... 

1.	While emitting SIL for 'viewDidLoad' at /Users/pi/workSpace/MoyaDemo/MoyaDemo/ViewController.swift:13:14
2.	While emitting reabstraction thunk in SIL function @_TTRXFo_ix_oGC4Moya8Endpointx__XFo_dO8MoyaDemo12LessonRouter_oGS0_S2___

```

What the hell with my code here, or just anyone poisoning my Xcode !!!
Help plz  ~

# :( I just create a whole new project to reproduce this issue, [here it is](https://github.com/iShawnWang/MoyaDemo), feel free to run to see this problem Hi @iShawnWang !

Try to override public init and it should work üòâ  The additional Repositories no longer seen to exist, but everything is included in Moya/Moya # [Codecov](https://codecov.io/gh/Moya/Moya/pull/981?src=pr&el=h1) Report
> Merging [#981](https://codecov.io/gh/Moya/Moya/pull/981?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/fd2a33236166bb1b1f95686c4a4671c8e0e302ff?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.


```diff
@@           Coverage Diff           @@
##           master     #981   +/-   ##
=======================================
  Coverage   73.61%   73.61%           
=======================================
  Files          22       22           
  Lines         724      724           
=======================================
  Hits          533      533           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/981?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/981?src=pr&el=footer). Last update [fd2a332...722a78b](https://codecov.io/gh/Moya/Moya/compare/fd2a33236166bb1b1f95686c4a4671c8e0e302ff...722a78b1a3a05f2bf1d48902dd675a26e4bfd9f3?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  Moya version: 8.0.2

There is my code:
```swift
MooProvider<MooApi>(token: accessToken)
      .request(.libraryBooks)
      .filterSuccessfulStatusAndRedirectCodes()
      .mapObject(type: JSONDocumentManyObjects<LibraryItem>.self)
      .subscribe { event in
        switch event {
        case .next(let element):
          print("next: \(element.url)")
        case .error(let error):
          print("error: \(error)")
        case .completed:
          print("completed")
        }
      }
      .addDisposableTo(disposeBag)
```

In the `JSONDocumentManyObjects`, the object has the next api url. So I need to use that to request again, and with the same JSON parser, the same request, the same flow until I can't find the next url.

Should I use a `Variable` with an url value? But how can the url match my API case? 

Thanks for your help. Hi, @scottrhoyt thanks for your answer. Change my TargetType to a struct is much better.
I will try this method, thanks!  Related to #612, it fixed an issue where `reversedPrint` is printing an array of `items` which will ignore the separator and terminator that has been set. Without this, pretty print (e.g. with JSON pretty print) is broken. 

* Variadic argument needs to be enumerated and its element printed
* Renamed seperator to separator Also as shown in the [Danger](http://danger.systems/), I'm not sure whether it's a good idea to update the changelog every time there's a change. 

Because the `CHANGELOG.md` is updated for each  tagged version, not on every pull request. So, I don't know what to do here. # [Codecov](https://codecov.io/gh/Moya/Moya/pull/979?src=pr&el=h1) Report
> Merging [#979](https://codecov.io/gh/Moya/Moya/pull/979?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/807b24f1191760e98d97ddd16f6c374ff7b0b3c3?src=pr&el=desc) will **decrease** coverage by `-0.11%`.
> The diff coverage is `25%`.


```diff
@@            Coverage Diff             @@
##           master     #979      +/-   ##
==========================================
- Coverage   73.72%   73.61%   -0.11%     
==========================================
  Files          22       22              
  Lines         723      724       +1     
==========================================
  Hits          533      533              
- Misses        190      191       +1
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/979?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Plugins/NetworkLoggerPlugin.swift](https://codecov.io/gh/Moya/Moya/compare/807b24f1191760e98d97ddd16f6c374ff7b0b3c3...8991a15a6ce3aba6c1867f31c1ce5e5fe9c3e640?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvTmV0d29ya0xvZ2dlclBsdWdpbi5zd2lmdA==) | `93.33% <25%> (-1.59%)` | :x: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/979?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/979?src=pr&el=footer). Last update [807b24f...8991a15](https://codecov.io/gh/Moya/Moya/compare/807b24f1191760e98d97ddd16f6c374ff7b0b3c3...8991a15a6ce3aba6c1867f31c1ce5e5fe9c3e640?src=pr&el=footer&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). @scottrhoyt Thanks for clarification. I updated the changelog.  Hi...

I wanna build some kind of Rest SDK for a iOS app which need to communicate with various servers (all the servers expose the same endpoints)... In the login form, you need to type the homeserver, so the baseURL needs that parameter, how can i do that? @scottrhoyt mmmm, i will try the first approach (because i don't know the servers urls), but i don't like the idea of passing the parameter over more than 50 endpoints xD. I will try also with a singleton class to store the url
 I wanna build a Rest Client (matrix.org) for matrix protocol (matrix.org), so i can have my own matrix server and you have another matrix server, so we can install my app but i wanna stablish connection with my server and you with yours... So, in the login page, the users needs typing their url servers...

Other use case can be a GitlabCE client for example, one app, which connect to multiple gitlab servers, but the app don't know that servers DynamicTarget not conform TargetType protocol because of `let baseUrl: URL` @scottrhoyt My bad, init was missing xD... Apparently it works, would you consider adding this functionality to the framework natively? Singleton works too, but protocol approach seems to be better, but having a `SubTarget` Protocol implies that we need to update that protocols if Moya changes the `TargetType`protocol @scottrhoyt thanks... I will keep the issue open for a few days to see if anyone come up with other solution :D @scottrhoyt it's possible override the sampleData of a Target to implement this only in a test target? Mmmm... this seems overkilling xD... I need implement a TargetType for each endpoint?... Can you provide a link to one of your tests?.

BTW, i tried the protocol extension before asking but no works I think using `OHHTTPStubs`is a better way, the only thing i need to do is a stub call, before each request:

```swift
stub(condition: isHost("domain.com")) { _ in
    let obj = fixtureJSON("FIXTURE KEY") 
    return OHHTTPStubsResponse(jsonObject: obj, statusCode: 200, headers: nil)
}
``` I have a `Session` target with three endpoints, `login`, `tokenRefresh` and `logout`, how can i mix this session target with the test target to test a success and error response for each endpoint, how they work together? i don't see that  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/977?src=pr&el=h1) Report
> Merging [#977](https://codecov.io/gh/Moya/Moya/pull/977?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/15be7c7c75055c4abe13ac92fcd07db4fd738399?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.


```diff
@@           Coverage Diff           @@
##           master     #977   +/-   ##
=======================================
  Coverage   73.72%   73.72%           
=======================================
  Files          22       22           
  Lines         723      723           
=======================================
  Hits          533      533           
  Misses        190      190
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/977?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/977?src=pr&el=footer). Last update [15be7c7...180e379](https://codecov.io/gh/Moya/Moya/compare/15be7c7c75055c4abe13ac92fcd07db4fd738399...180e3790ef7c9876ef5780a45933ca1f7c18580d?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  Our server not return the "Cache-Control ", so I want to use manually `URLCache` to cache the request, but I can not get the `URLRequest` with Moya.  I am using Moya 8.0.2 configured with OAuth2 authentication handling with Alamofire RequestRetrier as suggested in the [docs](https://github.com/Moya/Moya/blob/master/docs/Examples/Advanced.md), outlined in [this](https://github.com/Alamofire/Alamofire/issues/1097) Alamofire issue and implemented by [p2/OAuth2](https://github.com/p2/OAuth2/wiki/Alamofire-4). 

To make it working in Moya, I implemented the `validate` getter in my `Target` returning `true` for the requests that need validation.

Everything works like a charm, the installed Alamofire RequestRetrier intercepts the 401 Unauthorized responses, fires the OAuth flow and then resumes the original request signing it. My problem is that this configuration, in particular that Moya issues the `validate()` request to Alamofire without the possibility of configuring it, shades the response body from the server for non-2xx status codes. For example when issuing a request to a non-existing resource, the automatic validation that I need for the authorization makes failing also this request, returning a `underlying(Alamofire.AFError.responseValidationFailed(Alamofire.AFError.ResponseValidationFailureReason.unacceptableStatusCode(404)))` error but I have no access to the original response from the server.

Are there any ways to selectively validate the Alamofire responses or otherwise make the non-401 HTTP errors succeed the request? @scottrhoyt thank you for the suggestions. Based on your suggestion in (2.) I actually debugged how Moya processes the response and found that the response data actually arrives from Alamofire to the level of Moya and it is Moya that shades the data. More exactly the [second case in the switch](https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaProvider.swift#L153-L155) in `convertResponseToResult` simple ignores the `data` in Alamofire response before converting it to an error result. Could this be the place where we could add the data to the result? Conclusion, in 9.0 will be possible get the response from the error? I need that :D  In my project, the all request have the same parametersÔºàeg: key and consIdÔºâ, I want to put those parameters in var parameters: [String: Any]?, but abort the request and push some alert view when the key and consId is empty. @pedrovereza  I am doing this at the moment, tks.  How to setup nested parameters in Moya?

This is my parameters in moya:

return ["notification": ["title": "asdfasdfasdf", "body": "jlgjkl", "badge": "3"], "to": "receiverTokenHere"]

And this will be the return body in my logs, the format is different already:

notification%5Bbody%5D=asdfasdf&notification%5Btitle%5D=Albert%20send%20you%20message&notification%5Bbadge%5D=3&to=receiverTokenHere"]

I want to be formatted like this: 

{ "notification": {
    "title": "asdfasdfasdf",
    "body": "jlgjkl",
    "badge": "3"
  },
  "to" : "receiverTokenHere"
}

Thanks... hey @pedrovereza , my parameters will never be like this also?

return ["notification": ["title": "asdfasdfasdf", "body": "jlgjkl", "badge": "3"], "to": "receiverTokenHere"]

Im already changed it to JSONEncoding.default but still gets this on log:

notification%5Bbody%5D=asdfasdf&notification%5Btitle%5D=Albert%20send%20you%20message&notification%5Bbadge%5D=3&to=receiverTokenHere"] hey @pedrovereza, yeah you are right... I forgot to call the parameter encoding that's why it is happen... its working now. thanks  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/971?src=pr&el=h1) Report
> Merging [#971](https://codecov.io/gh/Moya/Moya/pull/971?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/26c4fd37915f25e4f6f5cbef3179f60b7e46ff80?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.


```diff
@@           Coverage Diff           @@
##           master     #971   +/-   ##
=======================================
  Coverage   73.72%   73.72%           
=======================================
  Files          22       22           
  Lines         723      723           
=======================================
  Hits          533      533           
  Misses        190      190
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/971?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/971?src=pr&el=footer). Last update [26c4fd3...c4a6f34](https://codecov.io/gh/Moya/Moya/compare/26c4fd37915f25e4f6f5cbef3179f60b7e46ff80...c4a6f342ee47a04a93d99a531dae3fd786d2f6ce?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  I am using Moya 7.0.0 in Xcode 7.3.1 with swift 2.2. I know very little about swift 3 and corresponding equivalent syntax of swift 3 in swift 2.2. The documentation that I found for Moya is in swift 3. It is a general problem with many excellent libraries that have migrated to swift 3 that it is hard to find documentation for swift 2.2. I have been too lazy to do the migration as I have many pending projects that I have written using swift 2.2 that have grown considerably in size. 

What is the advisable strategy here? It may come across as a very layman question but any suggestion/advice will help me forward fast. Thanks in advance.

 All documentation should still be available at corresponding tag: https://github.com/Moya/Moya/tree/7.0.4 I was not busy labelling @BasThomas üòâ  Yeah, I just realized this when reading your PR. And I was just about to write it, so this time you beat me to it. Thanks a lot guys! Long live open source and open source lovers!! :) Guys, which objectmapper to use for swift 2.2? I am using swiftyjson to parse my json response. Every library seem to have been updated to swift 3. Guess its time to stop being lazy and move on to swift 3 :(

Thought it might be related to this thread as didn't want open a new one.  Would you mind telling us how you did solve it ? üòè
I'm having the exact same issue when sending the request but haven't found a way to fix it yet.. üòî

Thanks in advance! üòâ Found it right after asking.. üòÖ

So for those of you who're looking for the answer, I solve it by using `NSURLComponents` like that :

`let urlComponents = NSURLComponents(string: "http://you/base/url/route")!`
`urlComponents.path = "/your/path"`
`urlComponents.query = "your/query"`

Do not add the question mark ('?') inside your query, it'll be added automatically !
And then you just build your url this way : 

`let url = urlComponents.url!`

Enjoy ! üëçüèª Thanks for sharing! Your approach is much more neat and simple ! 
Never saw this mentioned anywhere, kind of awkward, not known enough maybe..  fix #959  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="false">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Endpoint.swift | 113 | Prefer `!= nil` over `let _ =` 
Endpoint.swift | 114 | Prefer `!= nil` over `let _ =` 
MoyaProvider+Internal.swift | 238 | Prefer `!= nil` over `let _ =` 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 If there are no objections to this PR, I can fix the issues Danger raised `DownloadDestination` is a closure whose responsibility belongs to the Target. It's scope should be closed to within the Target.

`destinationURL` should be a property of `Response` because it is likely that that path is required at response time not at request time. Something like this:

``` swift
/// Downloads a URL file and returns its local path
func download(_ url: URL) -> Observable<URL> {
  return provider.request(.download(url))
    .map { (response: Response) -> URL in
      guard let url = response.destinationURL else {
        throw NSError(code: .noData)
      }
      return url    
  }
}
```
(We're using RxSwift, btw)

This could be accomplished by using `DownloadDestination` if we pass the closure as a stored value of the Target enum, but I think it would be outside the correct scope and would just look wrong. That may make sense for some cases where you'd like to have the file stored in a specific location known beforehand, but I don't know if it would be the general case. Nevertheless, it would cause the URL construction to be outside of the `TargetType` responsibilities, which I believe to be incorrect.  Also, what would happen if one passes an invalid URL or a path without `write` access? Would the request fail *after* download?

Keeping `DownloadDestination` as part of the `TargetType` and returning the `destinationURL` with the `Response` wouldn't keep you from creating a `TargetType` case that could receive the path in which to store the file, so these aren't exclusive.

Speaking of our case, our app downloads a few things from S3 and throws it all in the Documents directory, so it falls under the use case I gave you. As I said, I don't know if this is the general case, but I believe it is one that makes the solution I proposed to be reasonable. We're using the `download` task to mimic Apple's On-Demand Resources (we had a bad experience using it), so our app knows which files to download. It is not user-defined. This is our `DownloadDestination` closure:
``` swift
fileprivate func downloadDestination(_ temporaryURL: URL, _ response: HTTPURLResponse) -> (URL, DownloadRequest.DownloadOptions) {
    let directoryURLs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
    var path = temporaryURL
    
    if !directoryURLs.isEmpty {
        path = directoryURLs[0].appendingPathComponent(response.suggestedFilename!)
    }
    
    return (path, .removePreviousFile)
}
```
As you can see, we keep the downloaded file name and replace the file if it already exists. We could figure out the name by deconstructing the given URL, if we were required to give the `destinationURL` beforehand, but it is unnecessary in our case. You are right. When you mentioned the verification to see if the file already exists, it sounded familiar because I knew we already did something like that and, in fact, we do. Except it's on another part of the code.

So I've reached an impasse, because we build the `destinationURL` to check if the file exists, but, in the other hand, our downloader doesn't have that check, because we assume that if the method is called, it must download the file whether or not it exists.

I guess we could refactor our service layer to include this verification and the URL build. @fjcaetano I am currently running into this exact scenario within our application. I need a destination URL, or some mechanism, to retrieve the Data instance from the downloaded request. Currently, the Moya.Response object for a download operation returns nil for Response.data. I believe this is because the extension does not set the Data value on response complete:

```swift
// In Moya+Alamofire.swift
extension DownloadRequest: Requestable {
    internal func response(queue: DispatchQueue?, completionHandler: @escaping RequestableCompletion) -> Self {
        return response(queue: queue) { handler  in
            // *** Return nil data here even though the handler has a reference to the destination URL
            completionHandler(handler.response, handler.request, nil, handler.error)
        }
    }
}
```
I am not sure when this PR will be approved, but it is certainly something that our application can use. Thanks again for tackling this! @xliangTrackVia doesn't scott's suggestion, of providing the destinationURL with the enum, solve it for you? # [Codecov](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=h1) Report
> Merging [#968](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/80a55f5715c733e8d5fe9360ed498cedb4dbd08b?src=pr&el=desc) will **increase** coverage by `0.1%`.
> The diff coverage is `100%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/968/graphs/tree.svg?height=150&width=650&token=CjZLHCNgNn&src=pr)](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=tree)

```diff
@@            Coverage Diff            @@
##           master     #968     +/-   ##
=========================================
+ Coverage   73.65%   73.75%   +0.1%     
=========================================
  Files          22       22             
  Lines         725      724      -1     
=========================================
  Hits          534      534             
+ Misses        191      190      -1
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Endpoint.swift](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL0VuZHBvaW50LnN3aWZ0) | `94% <√∏> (√∏)` | :arrow_up: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.1% <100%> (-0.18%)` | :arrow_down: |
| [Sources/Moya/Response.swift](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1Jlc3BvbnNlLnN3aWZ0) | `95.74% <100%> (+0.09%)` | :arrow_up: |
| [Sources/Moya/Moya+Alamofire.swift](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWErQWxhbW9maXJlLnN3aWZ0) | `82.6% <100%> (√∏)` | :arrow_up: |
| [Sources/Moya/MoyaProvider+Defaults.swift](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitEZWZhdWx0cy5zd2lmdA==) | `95.23% <100%> (√∏)` | :arrow_up: |
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `90.9% <100%> (√∏)` | :arrow_up: |
| [Sources/Moya/Plugins/NetworkLoggerPlugin.swift](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvTmV0d29ya0xvZ2dlclBsdWdpbi5zd2lmdA==) | `94.91% <0%> (+1.58%)` | :arrow_up: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=footer). Last update [80a55f5...32a90b2](https://codecov.io/gh/Moya/Moya/pull/968?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  Looks like the length of the diff is causing my comments to be misplaced.  I linked it in the pull request. Here it is again https://github.com/petester42/framework-generate feedback is welcome.  One thing I found missing that is a nice to have is that the Test Scheme is not set in the Library's Scheme as a Test Target. `‚åò + U` will build the library and run the tests with the Library selected if it is set. Otherwise the test scheme will need to be selected for `‚åò + U` to work.

I also think code coverage is turned off (not sure this is tracked). Adding the test command to the target is easy. I thought I had added that already. I'll check.  Ok so the following should be addressed:
- `‚åò + U` for the targets
- Code coverage is now enabled again
- Carthage framework copy script is now part of the source control. <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="false">Added or removed library files require the Carthage Xcode project to be updated.</td>
    </tr>
  </tbody>
</table>
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Big PR</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 I don't really know what to do about the danger errors. Any ideas since I don't think my change has those errors.  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/967?src=pr&el=h1) Report
> Merging [#967](https://codecov.io/gh/Moya/Moya/pull/967?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/2394d53396dae50ed00a9fc7c99181c0702c68da?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/967/graphs/tree.svg?height=150&width=650&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/967?src=pr&el=tree)

```diff
@@           Coverage Diff           @@
##           master     #967   +/-   ##
=======================================
  Coverage   73.65%   73.65%           
=======================================
  Files          22       22           
  Lines         725      725           
=======================================
  Hits          534      534           
  Misses        191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/967?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/967?src=pr&el=footer). Last update [2394d53...b0b2339](https://codecov.io/gh/Moya/Moya/pull/967?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). @scottrhoyt

> - Will this work with both Carthage and Cocoapods? And have both been tested?

Yes this works with both. Cocoapods doesn't use the xcode project so no problem there. I've used this same thing for other projects and Carthage works too. Just tested it to make sure and it works.

> - Does this method work with Carthage prebuilt binaries incase we want to introduce that for Moya?

Yup. Just tried it and it works too.

> - Are there any other downsides to this?

For a maintainer I don't see any downside. Might be a little odd for people who aren't familiar with it.

> - This won't be breaking for anyone will it?

I don't see why it would.

@AndrewSB
> ‚åò + U for the targets
Code coverage is now enabled again
Carthage framework copy script is now part of the source control.

All this has been taken care of already. considering the scope of your changes, I think it's fine to accept that the Danger rules may not be fine for this run üëç  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/966?src=pr&el=h1) Report
> Merging [#966](https://codecov.io/gh/Moya/Moya/pull/966?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/5678a4c66ad779b15173315b0c2e300d0e3d9ba9?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `0%`.


```diff
@@           Coverage Diff           @@
##           master     #966   +/-   ##
=======================================
  Coverage   73.72%   73.72%           
=======================================
  Files          22       22           
  Lines         723      723           
=======================================
  Hits          533      533           
  Misses        190      190
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/966?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/MoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/compare/5678a4c66ad779b15173315b0c2e300d0e3d9ba9...9b41e6bb41b7724981f596fdf57d3205d91244ca?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFBdmFpbGFiaWxpdHkuc3dpZnQ=) | `0% <√∏> (√∏)` | :white_check_mark: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/966?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/966?src=pr&el=footer). Last update [5678a4c...9b41e6b](https://codecov.io/gh/Moya/Moya/compare/5678a4c66ad779b15173315b0c2e300d0e3d9ba9...9b41e6bb41b7724981f596fdf57d3205d91244ca?src=pr&el=footer&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  Hello

I use Moya/RxSwift 2.0.8 and I'm trying to use plugins to implement authorization token in HTTP headers

For example API:

```swift
import Moya

enum Api {
    case getRequest
}

extension Api: AuthorizedTargetType {
    /// The target's base `URL`.
    var baseURL: URL { return URL(string: "http://url.com")! }
    
    /// The path to be appended to `baseURL` to form the full `URL`.
    var path: String {
        switch self {
        case .getRequest:
            return "/api/v1/services/book"
        }
    }
    
    /// The HTTP method used in the request.
    var method: Moya.Method {
        switch self {
        case .getRequest:
            return .get
        }
    }
    
    /// The parameters to be incoded in the request.
    var parameters: [String: Any]? {
        switch self {
        case .getRequest:
            return nil
        }
    }
    
    /// The method used for parameter encoding.
    var parameterEncoding: ParameterEncoding {
        return URLEncoding.default
    }
    
    /// Provides stub data for use in testing.
    var sampleData: Data {
        switch self {
        case .getRequest:
            return "{\"records\": [{\"id\": 3,\"price\": 5000,\"service\": {\"id\": 2,\"title\": \"–ü—Ä–µ–¥–ø—É—Å–∫–æ–≤—ã–µ –ø–æ–¥–æ–≥—Ä–µ–≤–∞—Ç–µ–ª–∏\"},\"created\": \"2017-02-13T11:26:19.125243Z\",\"modified\": \"2017-02-13T12:25:01.328032Z\",\"discount\": 0.2,\"date\": \"2017-02-13\",\"user\": 2}],\"total\": 5000,\"discount_total\": 1000}".utf8Encoded
        }
    }
    
    /// The type of HTTP task to be performed.
    var task: Task {
        switch self {
        default:
            return .request
        }
    }
    
    /// Whether or not to perform Alamofire validation. Defaults to `false`.
    var validate: Bool {
        return false
    }
    
    var needsAuth: Bool {
        switch self {
        case .getRequest:
            return true
        default:
            return true
        }
    }
}


// MARK: - Helpers
private extension String {
    var urlEscaped: String {
        return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
    }
    
    var utf8Encoded: Data {
        return self.data(using: .utf8)!
    }
}
```

With Plugin:

```swift
import Moya

struct AuthPlugin: PluginType {
    let token: String?
    
    func prepare(_ request: URLRequest, target: TargetType) -> URLRequest {
        guard let token = token,
            let target = target as? AuthorizedTargetType,
            target.needsAuth
            else {
                return request
        }
        
        var request = request
        request.addValue("Token " + token, forHTTPHeaderField: "Authorization")
        return request
    }
}

protocol AuthorizedTargetType: TargetType {
    var needsAuth: Bool { get }
}
```

And working code

```swift
    let provider = RxMoyaProvider<Api>(
        plugins: [
            AuthPlugin(token: "eb1b505e863token6274bdfbe23925d223"),
            NetworkLoggerPlugin(verbose: true)])

    provider.request(.getRequest)
            .debug()
            .filterSuccessfulStatusCodes()
            .subscribe(onNext: { (response) in
                print(response)
            }, onDisposed: {
            })
```

In log we can see this situation:
```
["Moya_Logger: [13/02/2017 18:40:06] Request: http://url.com/api/v1/services/book"]
["Moya_Logger: [13/02/2017 18:40:06] Request Headers: [\"Authorization\": \"Token eb1b505e8634d19a2ece786274bdfbe23925d223\"]"]
["Moya_Logger: [13/02/2017 18:40:06] HTTP Request Method: GET"]
["Moya_Logger: [13/02/2017 18:40:07] Response: <NSHTTPURLResponse: 0x78e81ad0> { URL: http://url.com/api/v1/services/book/ } { status code: 401, headers {\n    Allow = \"GET, OPTIONS\";\n    Connection = \"keep-alive\";\n    \"Content-Type\" = \"application/json\";\n    Date = \"Mon, 13 Feb 2017 15:48:35 GMT\";\n    Server = \"nginx/1.9.9\";\n    \"Transfer-Encoding\" = Identity;\n    Vary = Accept;\n    \"Www-Authenticate\" = Token;\n    \"X-Frame-Options\" = SAMEORIGIN;\n} }"]
["{\"detail\":\"–£—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–µ –±—ã–ª–∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã.\"}"]
```

But token is not present in the headers

```
Hypertext Transfer Protocol
    GET /api/v1/services/book/ HTTP/1.1\r\n
    Host: url.com\r\n
    Connection: keep-alive\r\n
    Accept: */*\r\n
    Accept-Encoding: gzip;q=1.0, compress;q=0.5\r\n
    User-Agent: moyaTest/1.0 (test.moyaTest; build:1; iOS 10.2.0) Alamofire/4.3.0\r\n
    Accept-Language: ru-RU;q=1.0, en-RU;q=0.9\r\n
    \r\n
    [Full request URI: http://url.com/api/v1/services/book/]
    [HTTP request 2/2]
    [Prev request in frame: 94914]
    [Response in frame: 94930]
```

But POST requests are working properly.
 @scottrhoyt 
This is all libraries in test project:

```
  - Alamofire (4.3.0)
  - Moya (8.0.2):
    - Moya/Core (= 8.0.2)
  - Moya-ObjectMapper/Core (2.3.1):
    - Moya (~> 8.0)
    - ObjectMapper (~> 2.2)
  - Moya-ObjectMapper/RxSwift (2.3.1):
    - Moya-ObjectMapper/Core
    - Moya/RxSwift
    - RxSwift (~> 3.1)
  - Moya/Core (8.0.2):
    - Alamofire (~> 4.1)
    - Result (~> 3.0)
  - Moya/RxSwift (8.0.2):
    - Moya/Core
    - RxSwift (~> 3.0)
  - ObjectMapper (2.2.2)
  - Result (3.1.0)
  - RxSwift (3.2.0)
```

I shown wireshark dump of my request and server nothing to do with that.

What is the difference between endpoint and request closures? I put all code with Moya in topic @scottrhoyt. Sure. That link to git repo with my test project

https://github.com/ftp27/testMoya Hello @pedrovereza. I installed Charles and run the project. I have got this request headers:

```
GET /api/v1/services/book/ HTTP/1.1
Host	tcars.indev-group.eu
Accept	*/*
Accept-Encoding	gzip;q=1.0, compress;q=0.5
Accept-Language	ru-RU;q=1.0, en-RU;q=0.9
Connection	keep-alive
User-Agent	moyaTest/1.0 (eu.indevgroup.moyaTest; build:1; iOS 10.2.0) Alamofire/4.3.0
```

May be with something wrong with my Pods? 

I cleared all pods and installed them again, but it doesn't help

```
rm -rf "${HOME}/Library/Caches/CocoaPods"
rm -rf "`pwd`/Pods/"
pod update
``` @pedrovereza Wow

```
GET /api/v1/services/book/ HTTP/1.1
Host	tcars.indev-group.eu
User-Agent	moyaTest/1.0 (eu.indevgroup.moyaTest; build:1; iOS 10.2.0) Alamofire/4.3.0
Accept	*/*
Accept-Encoding	gzip;q=1.0, compress;q=0.5
Accept-Language	ru-RU;q=1.0, en-RU;q=0.9
Connection	keep-alive
TestHeader	Token eb1b505e8634d19a2ece786274bdfbe23925d223
```

With code

```swift
        var request = request
        request.addValue("Token " + token, forHTTPHeaderField: "Authorization")
        request.addValue("Token " + token, forHTTPHeaderField: "TestHeader")
        return request
``` Very weired. Http headers look right with httpbin.
```
GET /get HTTP/1.1
Host	httpbin.org
User-Agent	moyaTest/1.0 (eu.indevgroup.moyaTest; build:1; iOS 10.2.0) Alamofire/4.3.0
Authorization	Token eb1b505e8634d19a2ece786274bdfbe23925d223
Accept	*/*
Accept-Encoding	gzip;q=1.0, compress;q=0.5
Accept-Language	ru-RU;q=1.0, en-RU;q=0.9
Connection	keep-alive
TestHeader	Token eb1b505e8634d19a2ece786274bdfbe23925d223
```
 Some time ago I stated to catch 301 codes in Charles to URL with closing '/'. I changed path and GET request  was starting to send with Authorization header. Thanks to all for the help  ```swift
extension ApiService:TargetType{
    
    /// The type of HTTP task to be performed.
    public var task: Task {
    }

    /// Provides stub data for use in testing.
    public var sampleData: Data {
        switch self {
        case .upload:
            return "".data(using: String.Encoding.utf8)!
        }
    }

    /// The method used for parameter encoding.
    public var parameterEncoding: ParameterEncoding {
        return URLEncoding.default
    }

    public var baseURL: URL { return URL(string: "https://upload.giphy.com")! }
    public var path: String {
        switch self {
        case .upload:
            return "/v1/gifs"
        }
    }
    public var method: Moya.Method {
        switch self {
        case .upload:
            return .post
        }
    }
    public var parameters: [String: Any]? {
        switch self {
        case .upload:
            return ["api_key": "dc6zaTOxFJmzC", "username": "Moya"]
        default:
            return nil
        }
    }
}
``` I said is a task of this method, I think you just need to return, the request should be ok @974929538 You need to say what kind of `task` your request is. In most cases you can just use:

```swift
public var task: Task {
    return .request
}
``` Thank you very much A very awkward questionüòÖ Has been resolved But I met a new problem again Forgive me, I am a little shrimp only half a year work experience My question is when I will "responsetor" into "Moya. Response" throw an error
```swift
extension Observable{
    private func resultFormJson<T:Mapable>(jsondata:JSON,classType:T.Type) -> T?{
        return T(json:jsondata)
    }
    func mapResponseToArray<T:Mapable>(type:T.Type) -> Observable<[T]>{
        return map{ responsetor in
            
            guard let response = responsetor as? Moya.Response else{
                
                throw VendingMachineError.ConversionError //Problems thrown in here
            }
            
            let json = JSON.init(data: response.data)
            
            if let code = json["resultcode"].int{
                if code == 200 {
                    var objects = [T]()
                    let arr = json["result"].array
                    if let array = arr{
                        for object in array{
                            if let obj = self.resultFormJson(jsondata: object, classType: type){
                                objects.append(obj)
                            }
                        }
                        return objects
                    }else{
                        throw VendingMachineError.ParseError
                    }
                }else{
                    throw VendingMachineError.insufficientFunds(coinsNeeded: code)
                }
            }else{
                throw VendingMachineError.ParseError
            }
        }
    }
}
``` ```swift
import Foundation
import RxSwift
import Moya


class TestVM {
    let apiProvider = RxMoyaProvider<ApiService>()
    let backDate = Variable<[FoodTestModel]>([])
    let request = Variable<String>("")
    let disposeBag = DisposeBag()
    
    
    
    
    init(){
        
        let request = self.request.asObservable().map{ city in
            
           return self.apiProvider.request(.upload(cityname: city))
            
        }.shareReplay(1)
            
         let response = request.mapResponseToArray(type: FoodTestModel.self).shareReplay(1)
        
        
        response
            .asObservable()
            .subscribe(onNext: { result in
                
                self.backDate.value = result
                
            }, onError: {error in
                
                print(error)
                
            }).addDisposableTo(disposeBag)
    }
    
}
``` ```swift
class ViewController: UIViewController {
    
    var testvm:TestVM?

    override func viewWillAppear(_ animated: Bool) {
        testvm = TestVM()
        testvm?.request.value = "London"
    }
    override func viewDidLoad() {
        super.viewDidLoad()
        self.bulidVm()
//        let apiProvider = RxMoyaProvider<ApiService>()
//        apiProvider
//            .request(.upload(cityname: "London"))
//            .subscribe{event in
//                switch event{
//                case .next(let data):
//                    let json = JSON.init(data: data.data)
//                    print(json)
//                case .error(let error):
//                    print(error)
//                default:
//                    break
//                }
//        }.addDisposableTo(disposeBag)
        
    }
    
    func bulidVm(){
        
        self.testvm?.backDate.asObservable().subscribe(onNext: { result in
            
            print(result)
            
        }).addDisposableTo(disposeBag)
    }
```  For some reason, I need to use both `MoyaProvider` and `RxMoyaProvider` in project

I try to use a class function to initialize `MoyaProvider` and `RxMoyaProvider` with default plugins

```swift
fileprivate let defaultPlugins = [PluginOne(), PluginTwo()]

extension MoyaProvider {
    // Return `Self` here because the generic thing
    // Also because I want to return `RxMoyaProvider` when using RxMoyaProvider
    class func withDefaultPlugins() -> Self {
        return Self.init(plugins: defaultPlugins)
    }
}
```

But the complier raise an exception `Constructing an object of class type 'Self' with a metatype value must use a 'required' initializer`

So I add make it `required`, get some trouble with `ReactiveSwiftMoyaProvider`, and I figure out a kind of dirty way to solve it. 

The only problem is initialize like this, will get some trouble(ambiguous use of `init`)

```swift
ReactiveSwiftMoyaProvider(endpointClosure: endpointClosure,
                          requestClosure: requestClosure,
                          stubClosure: stubClosure,
                          manager: manager,
                          plugins: plugins,
                          trackInflights: trackInflights)
```

Do you guys have some idea about this? <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The <code>Cartfile</code> or <code>Cartfile.resolved</code> was updated, but there were no changes in the <code>podspec</code>. Did you forget updating the <code>podspec</code>?</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 @pedrovereza 

I've try this way in the beginning. But when you code like this:

```swift
let rxProvider = RxMoyaProvider<MyService>.withDefaultPlugins()
```

`rxProvider`'s type is `MoyaProvider<MyService>`, not `RxMoyaProvider<MyService>`, so I use `Self` as the type return in `withDefaultPlugins` method @pedrofjfmartins 

Yes, I need `withDefaultPlugin` available for both `MoyaProvider` and `RxMoyaProvider` @sunshinejr 

Unfortunately, I just delete my fork few week ago, cause I thought this PR won't be accept. It seems like I can't commit for this PR anymore. So maybe you need to open a new PR, just close this one.

ü§îActually I think there is really not need to subclass `MoyaProvider`. Instead of make init required, maybe just make `MoyaProvider` final.

Then let `MoyaProvider` conform to `ReactiveCompatible` and `ReactiveExtensionsProvider`, then we could change our code like this:

```swift
let provider = MoyaProvider<GitHubAPI>()

// RxSwift
provider.rx.request(target)

// ReactiveCocoa
provider.reactive.request(target)
```

For me, I think this is a better design. It will be more consistent, cause if someone use `rx` or `reactive` in code, it means it will get a `Observerble`. And make Reactive more like an ability, which is more Swifty and POP. Also the performance will be better.  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/962?src=pr&el=h1) Report
> Merging [#962](https://codecov.io/gh/Moya/Moya/pull/962?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/e0924cddf49de4ebd6376ee4fe59fcaaaa7d832b?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.


```diff
@@           Coverage Diff           @@
##           master     #962   +/-   ##
=======================================
  Coverage   73.72%   73.72%           
=======================================
  Files          22       22           
  Lines         723      723           
=======================================
  Hits          533      533           
  Misses        190      190
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/962?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/962?src=pr&el=footer). Last update [e0924cd...bd5f218](https://codecov.io/gh/Moya/Moya/compare/e0924cddf49de4ebd6376ee4fe59fcaaaa7d832b...bd5f2189eb236947bc3189cef08f916e8f280251?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  This creates a much cleaner completion block by using the Result method `dematerialize()` in the same do-try-catch block as the response mapping. Adds a `mapNSArray()` extension to Response in GitHubAPI.swift to support this and as an example. Also an example of how to create a error message from an error with default.

See #950 for more discussion.

   # [Codecov](https://codecov.io/gh/Moya/Moya/pull/960?src=pr&el=h1) Report
> Merging [#960](https://codecov.io/gh/Moya/Moya/pull/960?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/e0924cddf49de4ebd6376ee4fe59fcaaaa7d832b?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.


```diff
@@           Coverage Diff           @@
##           master     #960   +/-   ##
=======================================
  Coverage   73.72%   73.72%           
=======================================
  Files          22       22           
  Lines         723      723           
=======================================
  Hits          533      533           
  Misses        190      190
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/960?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/960?src=pr&el=footer). Last update [e0924cd...c22653c](https://codecov.io/gh/Moya/Moya/compare/e0924cddf49de4ebd6376ee4fe59fcaaaa7d832b...c22653c1a46de38222f0f3c180056ceef072561a?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  I believe that Moya's Response should have a property called `destinationURL` much like Alamofire's response.

I'm trying to migrate a piece of code from `Alamofire.download` to the `.download` task and I've noticed that the response object does not have the destination path to where the downloaded file has been moved to.

I'm not sure if `temporaryURL` should also exist in the Response, but I believe it's a no-brainer. @scottrhoyt, typically, when downloading some data and saving it in a device, it is important to know the path in which that data was stored. That's where `destinationURL` is necessary.

I solved it trivially, but I believe the solution is something that must be discussed. For starter, Alamofire has two typical response types: `DownloadResponse` and `DataResponse`. Naturally, `destinationURL` is a property of the former. So, if we add `destinationURL` to the single response type in Moya, that property will be available even when it doesn't make sense to have it. So should it really be in the `Response` class? I think it does for simplicity of access and solution.

Secondly, how would one stub such request? Should it even be stubbed? Once again, my approach to this was to add another parameter to the response cases of `EndpointSampleResponse` representing an optional URL which is interpreted as a possible mocked destination URL:
``` swift
/// Used for stubbing responses.
public enum EndpointSampleResponse {

    /// The network returned a response, including status code, data, and destination URL of downloaded data.
    case networkResponse(Int, Data, URL?)

    /// The network returned response which can be fully customized.
    case response(HTTPURLResponse, Data, URL?)

    /// The network failed to send the request, or failed to retrieve a response (eg a timeout).
    case networkError(NSError)
}
```

I'll submit a PR right now, but I'd love to get some opinions about these.  Hi,

I am new to Moya and Swift. Using Swift 3 and Moya  8.0.2
With the instruction in Basic.md, I tried to load some file from bundle as the the **sampleData** in TargetType
like this
```swift
var sampleData: Data {
        switch self {
            case .showAccounts:
                guard let path = Bundle.main.path(forResource: "myjson", ofType: "json"),
                    let data = Data(base64Encoded: path) else {
                        return Data()
                }
                return data
            .....
        }
```
but it always return nil data from **Data(base64Encoded: path)**
However, I change to code like follow, then it will return encoded data
```swift
var sampleData: Data {
        switch self {
            case .showAccounts:
                let path = Bundle.main.path(forResource: "myjson", ofType: "json")
                let url = URL(fileURLWithPath: path!)
                let data = try! Data(contentsOf: url)
                return data
            .....
        }
```
Am I using the **Data(base64Encoded: path)** in a wrong way?
Thank you
<!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 Thanks ! @scottrhoyt . The helper function in the PR is what I need !
However, I look at the code at https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md
that says
```swift
case .showAccounts:
            // Provided you have a file named accounts.json in your bundle.
            guard let path = Bundle.main.path(forResource: "accounts", ofType: "json"),
                let data = Data(base64Encoded: path) else {
                    return Data()
            }
            return data
        }
```
Will it return the **Data** of the file ?
Since it pass a path (e.g. \xxx\xxx\xxx\accounts.json) into **Data(base64Encoded: )**,
which the input should be some `Base-64 encoded String` or `Base-64, UTF-8 encoded Data` Many thanks @scottrhoyt  ;)  Hi!
I have some troubles with Moya and I hope you can help me with it. Me environment is 

```
PODS:
  - Alamofire (4.3.0)
  - ModelMapper (6.0.0)
  - Moya (8.0.2):
```

my API wrapper looks like 

```swift
import Moya

let apiBaseEndpoint = "http://localhost:3000/api"
let apiVersion = "v1"
let apiEndpoint = "\(apiBaseEndpoint)/\(apiVersion)"

enum MyService {
    case authGetOTP(msisdn: String)
    case authValidateOTP(msisdn: String, code: String)
}

extension MyService:TargetType {
    var baseURL: URL { return URL(string: apiEndpoint)! }
    
    var path: String {
        switch self {
        case .authGetOTP(_):
            return "/authentication/get_otp"
        case .authValidateOTP(_, _):
            return "/authentication/validate_otp"
        }
    }
    
    var method: Moya.Method {
        switch self {
        case .authGetOTP, .authValidateOTP:
            return .post
        }
    }
    
    public var parameters: [String: Any]? {
        switch self {
        case .authGetOTP(let msisdn):
            return ["msisdn": msisdn]
        case .authValidateOTP(let msisdn, let code):
            return ["msisdn": msisdn, "code": code]
        }
    }
    
    var parameterEncoding: ParameterEncoding {
        switch self {
        case .authGetOTP, .authValidateOTP:
            return JSONEncoding.default
        }
    }
    
    var sampleData: Data { return Data() }
    
    var task: Task {
        switch self {
        default:
            return .request
        }
    }
}


// MARK: - Helpers
private extension String {
    var urlEscaped: String {
        return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
    }
    
    var utf8Encoded: Data {
        return self.data(using: .utf8)!
    }
}
```

looks standard, huh? But on my requests with this wrapper

```swift
        let provider = MoyaProvider<MyService>()
        provider.request(.authGetOTP(msisdn: "+1234567890")) { result in
            NSLog("get OTP")
        }

        provider.request(.authValidateOTP(msisdn: "+ 1234567890", code: "123456")) { result in
            NSLog("validate OTP")
        }
```

I see extra data in requests:

```
  Parameters: {"msisdn"=>"+ 1234567890", "code"=>"123456", "authentication"=>{"msisdn"=>"+1234567890", "code"=>"123456"}}
  Parameters: {"msisdn"=>"+ 1234567890", "authentication"=>{"msisdn"=>"+79268891632"}}
```

I mean **"authentication"=>{"msisdn"=>"+1234567890", "code"=>"123456"}**

What I'm doing wrong? @scottrhoyt no, I didn't. But I've enabled verbose logging with
```
let provider = MoyaProvider<CosmoZoo>(plugins: [NetworkLoggerPlugin(verbose: true)])
```

and I see no extra-data in requests

```
["Moya_Logger: [09/02/2017 23:55:22] Request: http://localhost:3000/api/v1/authentication/get_otp"]
["Moya_Logger: [09/02/2017 23:55:22] Request Headers: [\"Content-Type\": \"application/json\"]"]
["Moya_Logger: [09/02/2017 23:55:22] HTTP Request Method: POST"]
["Moya_Logger: [09/02/2017 23:55:22] Request Body: {\"msisdn\":\"+79268891632\"}"]
["Moya_Logger: [09/02/2017 23:55:22] Request: http://localhost:3000/api/v1/authentication/validate_otp"]
["Moya_Logger: [09/02/2017 23:55:22] Request Headers: [\"Content-Type\": \"application/json\"]"]
["Moya_Logger: [09/02/2017 23:55:22] HTTP Request Method: POST"]
["Moya_Logger: [09/02/2017 23:55:22] Request Body: {\"msisdn\":\"+79268891632\",\"code\":\"123456\"}"]
["Moya_Logger: [09/02/2017 23:55:22] Response: <NSHTTPURLResponse: 0x618000029340> { URL: http://localhost:3000/api/v1/authentication/get_otp } { status code: 200, headers {\n    \"Cache-Control\" = \"max-age=0, private, must-revalidate\";\n    \"Content-Type\" = \"application/json; charset=utf-8\";\n    Etag = \"W/\\\"a29ee2b15c494311c52521766e44af56\\\"\";\n    \"Transfer-Encoding\" = Identity;\n    \"X-Content-Type-Options\" = nosniff;\n    \"X-Frame-Options\" = SAMEORIGIN;\n    \"X-Request-Id\" = \"e7be499e-de9d-45e4-be0a-0e6e15e87776\";\n    \"X-Runtime\" = \"0.006129\";\n    \"X-XSS-Protection\" = \"1; mode=block\";\n} }"]
["{\"status\":\"ok\"}"]
2017-02-09 23:55:22.716 pets[36820:2364194] get OTP
["Moya_Logger: [09/02/2017 23:55:22] Response: <NSHTTPURLResponse: 0x600000436f60> { URL: http://localhost:3000/api/v1/authentication/validate_otp } { status code: 200, headers {\n    \"Cache-Control\" = \"max-age=0, private, must-revalidate\";\n    \"Content-Type\" = \"application/json; charset=utf-8\";\n    Etag = \"W/\\\"a1805b363176810b2a252dad4cd073da\\\"\";\n    \"Transfer-Encoding\" = Identity;\n    \"X-Content-Type-Options\" = nosniff;\n    \"X-Frame-Options\" = SAMEORIGIN;\n    \"X-Request-Id\" = \"ac98af24-0f3b-40b1-b6fb-8881b1f315a3\";\n    \"X-Runtime\" = \"0.010393\";\n    \"X-XSS-Protection\" = \"1; mode=block\";\n} }"]
["{\"status\":\"authenticated\"}"]
2017-02-09 23:55:22.718 pets[36820:2364194] validate OTP
```

Looks strange
 @scottrhoyt I think it isn't server issue, because on 

```
curl -X "POST" "http://localhost:3000/api/v1/authentication/get_otp?msisdn=%2B79268891632"
```

I see no extra data

```
Parameters: {"msisdn"=>"+79268891632"}
``` huh, you're right - the problem was in parameterEncoding type :) thanks a lot! 

But, is it correct for JSONEncoding to add data? As I see in Alamofire documentation 

```
let parameters: Parameters = [
    "foo": [1,2,3],
    "bar": [
        "baz": "qux"
    ]
]

// Both calls are equivalent
Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: JSONEncoding.default)
Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: JSONEncoding(options: []))

// HTTP body: {"foo": [1, 2, 3], "bar": {"baz": "qux"}}
```

there are no extra-data in request nothing special on backend, I just rendering params from mobile app for testing. There it is if you know ruby syntax:

```
 def get_otp
    Rails.logger.info("--- msisdn: #{params[:msisdn]}")
    render json: {status: 'ok'}
  end
```

but I'll try to perform requests with alamofire but you're right - I send

```
curl -X "POST" "http://localhost:3000/api/v1/authentication/get_otp" \
     -H "Content-Type: application/json; charset=utf-8" \
     -d $'{
  "msisdn": "+79268891532"
}'
```

and see in logs

```
Started POST "/api/v1/authentication/get_otp" for 127.0.0.1 at 2017-02-10 01:01:23 +0300
Processing by Api::V1::AuthenticationController#get_otp as HTML
  Parameters: {"msisdn"=>"+79268891532", "authentication"=>{"msisdn"=>"+79268891532"}}
--- msisdn: +79268891532
Completed 200 OK in 0ms (Views: 0.1ms | ActiveRecord: 0.0ms)
```

I'll do extra-check on backend! Thanks a lot!  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/954?src=pr&el=h1) Report
> Merging [#954](https://codecov.io/gh/Moya/Moya/pull/954?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/0dfc0b6d0cfefeef2ecb4b81ce41c1e77380035f?src=pr&el=desc) will **not impact** coverage.


```diff
@@           Coverage Diff           @@
##           master     #954   +/-   ##
=======================================
  Coverage   73.72%   73.72%           
=======================================
  Files          22       22           
  Lines         723      723           
=======================================
  Hits          533      533           
  Misses        190      190
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/954?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/954?src=pr&el=footer). Last update [0dfc0b6...1429112](https://codecov.io/gh/Moya/Moya/compare/0dfc0b6d0cfefeef2ecb4b81ce41c1e77380035f...1429112d5631d6011830e8fde918f0da98c876d3?src=pr&el=footer&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). Why not both?  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
This is my TargetType
```swift
*your code goes here*
//
//  BeeHttp.swift
//  BeeAPP
//
//  Created by steam on 2017/2/5.
//  Copyright ¬© 2017Âπ¥ steam. All rights reserved.
//

import Foundation
import Moya


enum RequestApi{
    case login
}

extension RequestApi : TargetType {
     public var baseURL : URL{
        return URL(string: "http://localhost/bee")! //Êú¨Âú∞
//        return URL(string: "https://api.steambean.me/bee")! //ËÖæËÆØ‰∫ë
    }
    
    var path : String {
        switch self {
        case .login:
            return "/user/login"
        }
    }
    
    var method: Moya.Method{
        switch self {
            
        case .login:
            return .post
            
        }
    }
    
    var parameters: [String : Any]? {
            //add parame to request
            return ["name":111]
        
    }
    
    var parameterEncoding: ParameterEncoding{
        return URLEncoding.default
    }
    
    var sampleData: Data{
        switch self {
        case .login:
            //add json to httpbody ?
            return "{\"name\":2321}".utf8Encoded

        }
    }
    
    var task: Task{
        switch self {
        case.login :
            return .request
            
        }
    }
    
    
}

// MARK: - Helpers
private extension String {
    var urlEscaped: String {
        return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
    }
    
    var utf8Encoded: Data {
        return self.data(using: .utf8)!
    }
}
```
**## Question:There is no json in request httpbody,but parame seted in URL is in request httpbody„ÄÇAs follow :** 
```
POST /bee/user/login HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Connection: keep-alive
Accept: */*
User-Agent: BeeAPP/1.0 (com.steam.grad-project.BeeAPP; build:1; iOS 10.2.0) Alamofire/4.3.0
Accept-Language: en;q=1.0
Content-Length: 8
Accept-Encoding: gzip;q=1.0, compress;q=0.5

name=111
```  As of Jan 4 commit, MoyaAvailability.swift marks Moya.Error as unavaliable, but also tries to use Moya.Error in the same file:

```swift
@available(*, unavailable, renamed: "MoyaError", message: "Moya.Error has been renamed to MoyaError in version 8.0.0")
public typealias Error = MoyaError

...
    func didReceiveResponse(result: Result<Moya.Response, Moya.Error>, target: TargetType) { fatalError() }
```

Generates a compiler error. Ah - it's only a compiler error in Swift 3.1. Swift 3.0 seems to only apply the @unavailable outside the file. Since Swift 3.1 is supposed to be backwards compatible with Swift 3.0, I think the Swift dev team will be interested by this: @DougGregor @jckarter This sounds like a bug fix to me, but I'll raise it with the core team. There was a fix that attempted to emulate the 3.0 behavior and emit warnings in this case:

https://github.com/apple/swift/commit/9489f10ce1feb60e9fb0a32857a273a22420253b

It's recent enough that it may not have made it into 8.3 beta 1. Do you still see the error in 8.3 beta 2, or in a Swift 3.1 snapshot toolchain from swift.org? The Swift 3.0 compatibility fix @jckarter referred to was first introduced in Xcode 8.3 beta 2. @DougGregor This is still happening on Xcode 8.3 Beta 2 and with the latest 3.1 Toolchain (2017-02-07). Should this meanwhile be fixed in Moya (and renamed to MoyaError)? The availability fixits should still appear. Let us know if they don't. The only change should have been to tighten up the checking of availability on typealiases. I am trying to convert my Project from Swift 2.3 to Swift 3 in Xcode 8.3 beta 2. What should be done here to fix this issue. If I try to rename Error to MoyaError, Xcode cribs that I file is locked to changes. Still new to Swift and this migration is getting little painful. Any help is appreciated.

Thanks.  This is point of question or discussion, not a bug. If this isn't the correct spot for it, please close.

I'm interested in Moya, but my initial reaction is that the enum based configuration could quickly get out of hand for larger applications, at which point all the different aspects of a request being handled in very different spots of the file seems potentially awkward.

I have seen https://github.com/devxoul/MoyaSugar which tries to help with this some, but still has the configuration spread out over several different enum methods. Also now we're adding another layer on top of Moya.

Does anyone have experience on using this in larger applications? Is it as awkward as it seems? I should have thought to look there. ü§¶‚Äç‚ôÇÔ∏è Thanks @pedrovereza. I'll close this in a bit if I don't have follow-up thoughts. Interesting. So I guess worst case scenario you make a handful of APIs and redefine the base path, etc, in each. Which really could be a shared function somewhere. Not too bad. Yeah I like the idea @scottrhoyt. Looks like it didn't make the cut though. I'm considering if I can use protocol extensions for now. Solid. Exactly what I was thinking.  Moya encapsulates everything necessary to make a call, but on the return requires clients to parse and cast `Result<Moya.Response, MoyaError>` objects, which inevitably clutters the completion block and leaks network concerns into the client. From #948 as @scottrhoyt characterized (without endorsing) it, the goal is "Provide better completion handler usability for MoyaProvider when both the return type and method of deserialization are known".  

This can be accomplished adding the following (queue, progress parameters removed for clarity) generic function to MoyaProvider: 

```swift
/// Generic request-making method.
@discardableResult
open func request<T>(_ target: Target, parser: @escaping (Moya.Response) throws -> T, completion: @escaping (Result<T, MoyaError>) -> Void) -> Cancellable {
    return request(target, queue: queue, progress: progress) { (result) in
        do {
            let response = try result.dematerialize()
            let value = try parser(response)
            completion(Result(value: value))
        } catch let error as MoyaError {
            completion(Result(error: error))
        } catch {
            completion(Result(error: MoyaError.underlying(error)))
        }
    }
}
``` 
It's straightforward, it calls the parser on the response and returns the value (or any error) to the completion. The generic function enforces that the type returned by the parser matches the parameter of the completion. (Side note, this is a great example of why to avoid optional sentinels: `T` can be an optional where `nil` is valid value, so only `throws` indicates an error.) 

So the call site becomes: 
```swift
func downloadRepositories(_ username: String) {
    GitHubProvider.request(.userRepositories(username), parser: Parsers.parseNSArray) { result in
        switch result {
        case let .success(json):
            self.repos = json
            self.tableView.reloadData()
        case let .failure(error):
            guard let error = error as? CustomStringConvertible else {
                break
            }
            self.showAlert("GitHub Fetch", message: error.description)
        }
    }
}
```
It may seem like a small distinction, moving the parser from something invoked in the completion to something passed to the request method; the call site still needs to know how the response will be parsed. The main benefit is it declutters the completion blocks, removing any knowledge or handling of response objects. A similar approach would work with the reactive versions. It also seems more in line with the goals of encapsulation to handle these things upstream.

<!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 
The idea is to take Moya the last mile, so clients don't have to do parsing in their completion blocks at the call site. I think @pedrovereza 's comment that's what nearly all the extensions do reflects that. In this generic solution, since there's no way through Swift's type system to have enums vend closures returning different types, the call site still needs to know which parser to use. Putting the parser in the function signature removes one concern from the completion.

(This is obviously less of a concern for the reactive variations that use lenses throughout their entire structure. Of course it could be moved up for them as well.)

As @scottrhoyt said allowing extensions to standardize their own interfaces would be a benefit and allow better integration. Because of generics this needs to be done carefully, as the generic function parameters `func request(TargetType, (Response) -> T, completion (T) -> Void)`don't hold up when passed a generic function--legitimately, because all type information is gone. Typing the completion block only sometimes fixes this. 

Actually, browsing through the extensions it seems like all of them work by requiring T to conform to some protocol `-able` for the library, usually `init(_ json: JSON)`? Assuming the compiler could be instructed what the type is, it would be possible to have a protocol  `init(from response: Moya.Response) throws` and put the requirement in the generic function constraint. 

 However, maybe it's my experience parsing terrible JSON but I would be against creating the expectation that JSON parsing can be accomplished automatically from endpoint-magic-object. There's a gap between endpointJSON and model, that clients need to be explicitly and consciously bridge. The place to do that is the TargetType, but that was a dead end for enums. 

In the case of completion blocks it makes sense that the knowledge of how to get the response into the app domain should have been made as part of the call. Baking _the option_ to provide a parser of choice -- an option, because this would be able to live alongside the existing method and immediately use into it -- would make Moya more end-to-end by covering the final distance. 
 You know, I'm going to follow the "Contributing" guidelines in the readme.md, assume positive intent, and give @AndrewSB as well as the people who reacted with "laugh" the benefit of the doubt. I love XKCD, and assume people are taking the moment to laugh at this classic. 

But I would invite you to think about how it could come across to post that comic in this context. I've put a lot of thought and a lot of time on this proposal because I think it would improve Moya, a project I've watched for a long time now, that I think is ingenious and greatly respect. 

I'm happy to continue to respond to any substantive comments about the idea of adding the MoyaProvider generic function. 
 Sure, comic about a guy making a proposal was just an off note to drop in this context, no big deal.  

While the generic function is being mulled, since I did browse through the extensions I noticed that no one is using the `Result` method `dematerialize() throws -> T`. The switch statement usually makes more sense, but when the success case immediately starts a do-try-catch block it could be much cleaner. 

I'm looking at this also in the example in the Demo `ViewController `   ` func downloadRepositories(_ username: String)` [here](https://github.com/Moya/Moya/blob/master/Demo/Demo/ViewController.swift#L29). Reacting to this in particular was part of what I was trying to improve with this and the earlier #948 proposal.   

It current looks like:
```swift 
    func downloadRepositories(_ username: String) {
         GitHubProvider.request(.userRepositories(username)) { result in
            switch result {
            case let .success(response):
                do {
                    if let json = try response.mapJSON() as? NSArray {
                        // Presumably, you'd parse the JSON into a model object. This is just a demo, so we'll keep it as-is.
                        self.repos = json
                    } else {
                        self.showAlert("GitHub Fetch", message: "Unable to fetch from GitHub")
                    }
                } catch {
                    self.showAlert("GitHub Fetch", message: "Unable to fetch from GitHub")
                }
                self.tableView.reloadData()
            case let .failure(error):
                guard let error = error as? CustomStringConvertible else {
                    break
                }
                self.showAlert("GitHub Fetch", message: error.description)
            }
        }
}
```
With `dematerialize()` it can come to: 

```swift 
    func downloadRepositories(_ username: String) {
        GitHubProvider.request(.userRepositories(username)) { result in
            do {
                let response = try result.dematerialize()
                let value = try response.mapNSArray() 
                self.repos = value
                self.tableView.reloadData()
            } catch {
                let printableError = error as? CustomStringConvertible
                let errorMessage = printableError?.description ?? "Unable to fetch from GitHub"
                self.showAlert("GitHub Fetch", message: errorMessage)
            }
        }
    }
```
As nice as do-try-catch setup as I've seen (not an end in itself, but still) and the smooth handling of error message with fallback it makes possible is a nice bonus.   

But the `mapNSArray()` function as an extension of `Response` doesn't currently exist. There could be a guard statement in the do block, but you would have to throw from the do block, and now what error type do you use, etc. 

I'm thinking it should be in the Demo GitHub file.  All it does is cast the response from mapping to Any. (Although it's just file organization at this point, as I mentioned in #948 and above I think the knowledge of how to parse the response is deeply tied to the endpoint/TargetType anyway.) Another option would be to name the function `mapGitHubRepos()` to emphasize the view controller is passing all responsibility for how to parse this endpoint, and also because there are different ways to parse to the same type.  

It would also accomplish much of what I was trying to without touching the core project, so could shelve the generic function for now until there are reasons to do the parsing before returning result to the completion. If the information about what parser to use has to live at the call site anyway, getting it done in one line this way is just as compact.

Thoughts? (words preferred ;)  @justinmakaila What you said here really resonates with my own opinion (that Moya should not get in the response deserialization game), but I also don't exactly agree with what you said.  What @michaelsand is proposing here is *not* a parser library or system, just another take on *how* to integrate a parsing layer at the call site.

This is usually the type of feature that I don't like adding, but in this case the more I look at it the more I like it!

It might be unfortunate that the title includes "method of deserialization is known" because that makes it sound like Moya is getting involved, but actually it's just saying that you could plug *any* parser into this; the parsers (that you write as part of your network layer) take a `Moya.Response` (if the result is `.success`) and hand the result (or a new error) to your completion block.

The reason I like this proposal is that it adds the type information - and *only* the type information - to the call site, and the type is inferred by the compiler based on the mapping function, so there's no additional noise.  And mapping from `Result<Moya.Response>` to `Result<T>` feels very natural to me.  Put another way, it is a way to inform Moya how it can get out of the way of our application.  We begin the request cycle by handing it an enum value, we end by receiving our expected object or an error.

And we get "opt-in/opt-out" for free here since this method signature would not collide with the existing `request` method.  In the Ello app we look at the HTTP result directly to get the status code out, so we could still use this method to map to a `(statusCode, JSON)` tuple, and I think our code would benefit from it!  Since our JSON is in a consistent format, we could actually parse it into a really useful object, which would move a lot of the heavy lifting out of `ElloProvider` and into a testable/pluggable `ElloJSONParser` type.

I'm on board with this change.  It is backwards compatible, it feels very "functional programming"-esque, and I don't see it as opinionated as @justinmakaila seems to.  To me, this is a natural place to provide an HTTP response parser.

I would love to see a dissenting opinion that shows how we can get this same benefit from our current setup. Thanks! Great counter point!  Extending `Moya.Response` achieves similar code separation; it isn't as *purely* functional perhaps, but that's splitting hairs.  I would be hard pressed to call one more "Swifty".  `map(a) -> b` is  instead`a.map() -> b`.

And, unless I'm mistaken, @michaelsand might also be agreeing with this strategy; I was re-reading the conversation here, and in his last comment he points out that extending `Moya.Response` accomplishes the same goal (I missed that the first time around).

On the other hand, I had a different use-case in mind.  In our app, we have *only one place* where we call Moya, and that's from `ElloProvider`.  We do authentication token checking and refreshing before we send the request out.  So in our case, the "parser" that I would provide is higher-level; it would only return a generic `SwiftyJSON` object (and it would introspect that JSON - we use a `linked` key and put all the related objects in there into local key-value storage - typical JSON API pattern).  In your example, this corresponds with `let response = try mapAPIResponse()`, and so the response body would look something like this:

```swift
public func authenticate(type: AuthType, username: String, password: String) {
    let endpoint: API = .auth(type, username: username, password: password)
    provider.request(endpoint, parser: mapAPIResponse, completion: { result in
        do {
            let apiResponse = try result.dematerialize()
            let authResponse = try mapAuthenticationResponse(apiResponse)  # MyAPIResponse instance
        }
...
```

I do still like this; it "closes the loop" between your domain's API endpoints, and how your data is returned from the server.  But is it necessary?  No, I think @justinmakaila demonstrated that we can accomplish this by having the parser as part of the body; and *either way* (whether it's in the function, or in the body) you'd have to repeat this parser code as many times as you have Moya call sites.
 @AndrewSB no big deal, thanks for mentioning that. 

@colinta 
I really like the formulation "it is a way to inform Moya how it can get out of the way of our application."

@justinmakaila Somewhat out of order: 
> FWIW, my perspective is that of a ReactiveMoya user. 

Yes, it is apparent Reactive/RX doesn't get as much out of this, since if going from A to Z and Moya gets you from A to Y, it would make sense immediately apply a lens for Y to Z--in a functional reactive app it just seems more natural. It's the traditional completion block approach (I'm going to keep calling them completion blocks) that makes having to do parsing at the call site a violation of separation of concerns, and currently users are on their own, why it's noted there are so many extensions for it. Of course if parity is needed it's completely possible.   

>One implementation suggestion is to provide serialization closures,

As far as providing Moya a function that takes a response that Moya then invokes, if that closure still needs¬†to know about parsing logic and about view-controller completion logic, it's just moving code around. There is a way around this, in the (brief)  #948 I outlined a technique with enum that accomplishes what I set out to do, let the TargetType switch to pick the parser, but at a cost that the completion closure must be added as an associated type. It puts this complex requirements on users and the syntax looks bad also. 

> As OP mentioned, wouldn't it be possible to just extend the Response type to provide custom mapping functions to transform to custom types?

> Taking on @colinta's challenge for a dissenting opinion

This is an even fully-formed than my example. If this is the way we land, we should definitely put a more elegant demo in there, with a parser defined in the demo project, probably in `GitHub.swift`. 
 
I have reservations about telling people this much in an extension. There's that `MyAPIResponse` class tucked in there. `AuthenticateError` is free-floating. It calls other functions in the extension.    And actually my expectation is the parser could have some settings, like debugging options. Of course a response extension could have/refer those as well (today I learned extensions can add `static var` but if it's a `static var` might as well put it on some other static settings object.)

Still,  moving the parser to a parameter would allow the block to `swich` on result if it wanted to. It would emphasize the parsing is something that is not this class's responsibility, emphasizing that Moya can handle it end-to-end. 

 @colinta  Yeah I'm in the awkward position of not being sold on the necessity of my own proposal, since well-formed extensions on `Response` get the job done. Regardless some of the Demo examples could be a lot cleaner, especially `downloadRepositories`  

I should mention my reason for being enthusiastic about this:  I implemented this generic pass-parser approach for handling completions and it was a lifesaver. This was when I worked at an agency, a client was gonna be the next facebook so the app had a lot of API calls. This was before Moya existed, and I had each call made in its own function, a network wrapper. But on the completion, all of the network calls went through one generic completion block, which really was a lifesaver when their dysfunctional API kept breaking and we needed to start logging/scrutinizing everything. 

Anyway, after that when Moya I saw that this handled most of the other steps more elegantly, and with the addition of generic completion blocks could wrap the entire networking layer end-to-end.  

But yeah, there are other ways to accomplish that goal. So it feels like a glaring omission to drop the raw response into the call site, probably a view controller--but generics are trouble, and this is coming down to really accomplishing that much. 

@scottrhoyt Yeah limitations generics in Swift is the way to describe it. I ended up going down the rabbit hole of covariance. Not fun. The rabbit can't even live in a rabbit hole-- it has to live in a generic burrow. 

@justinmakaila That wrapped provider looks good for another layer of safety. I feel like the integration with TargetType is so close, and was looking at solutions with hashable identifier; will keep investigating. 

I'm going to go ahead and submit the pull request to clean up those completion blocks in the Demo, adding a `extension Response` for mapping to NSArray. If this is recognized as a best practice might as well put it in a demo. 

I'm also going to put some of the various loose threads into a pod for an extension, including some extensions on MoyaProvider that might be useful depending on what trade-offs best meet various use-cases. 

Thanks for the great feedback everyone-- not the end, but still.     Moya is unparalleled at encapsulating the call to APIs. I've been following Moya for a while and thinking about how to make it even more end-to-end: If its completion could take a specific type, or `Result<T, MoyaError>` of a type, instead of `Result<Moya.Response, MoyaError>`. `Moya.Response` is a good object, the issue is it requires clients to immediately parse it, which is inelegant, and probably a violation of separation of concerns if done in a view controller, for example. 

Of course, Moya shouldn‚Äôt prescribe a method of parsing‚Äîthat‚Äôs not where this is going. But how to parse an endpoint's response, what the expected response is, is API knowledge. API knowledge that lives with the target endpoint information, alongside its path, parameters, etc. The `TargetType`. That is where the parsers should live. 

The issue is types-- There‚Äôs not a way for a target to return a variable type‚Äîa generic T or associated would mean each instance of `TargetType` and `MoyaProvider<TagetType<T>>` could only take or return that T, which defeats the purpose.

The solution that I‚Äôve come up with, which is _nonbreaking_, is to create protocol that inherits from `TargetType`, `TargetTypeWithCompletion`. This protocol inherits all the requirements of `TargetType`, and adds a single method, `complete(with response: Moya.Response)`. 

There is no return-- every enum case would have to have an associated type for its completion block. This is best implemented with typealiases, so `typealias StringResultClosure = (Result<String, MoyaError>) -> Void` and then `.zen(StringResultClosure)` . My research hasn‚Äôt found any way around this associated completion. There is logic to it, because what comes back varies with the specific endpoint. 

This is the entirety of the addition: 
```swift
/// Inherits from TargetType and contains its own completion method.
public protocol TargetTypeWithCompletion : TargetType {
    func complete(with response: Result<Moya.Response, MoyaError>)
}


public extension MoyaProvider where Target : TargetTypeWithCompletion {

    @discardableResult
    public func requestWithCompletion(for target: Target, queue: DispatchQueue? = nil) -> Cancellable {
        return self.request(target, queue: queue) { (response) in
            target.complete(with: response)
        }
    }
}
```
And the usage goes from:

```swift
GitHubProvider.request(.userRepositories(username)) { result in
    switch result {
    case let .success(response):
        do {
            if let json = try response.mapJSON() as? NSArray {
                // Presumably, you'd parse the JSON into a model object. This is just a demo, so we'll keep it as-is.
                self.repos = json
            } else {
                self.showAlert("GitHub Fetch", message: "Unable to fetch from GitHub")
            }
        } catch {
            self.showAlert("GitHub Fetch", message: "Unable to fetch from GitHub")
        }
        self.tableView.reloadData()
    case let .failure(error):
        guard let error = error as? CustomStringConvertible else {
            break
        }
        self.showAlert("GitHub Fetch", message: error.description)
    }
}
```
To this:

```swift
GitHubProvider.requestWithCompletion(for: .userRepositories(username, { result in
    switch result {
    case let .success(repos):
        self.repos = repos
        self.tableView.reloadData()
    case let .failure(error):
        guard let error = error as? CustomStringConvertible else {
            break
        }
        self.showAlert("GitHub Fetch", message: error.description)
    }
}))
```
The paring code has ended up in the GitHub `TargetType`, which you can see at [on this branch](https://github.com/michaelsand/Moya/blob/f_targetTypeWithCompletion/Demo/Shared/GitHubAPI.swift) The parsing does not need to be in the `TargetType`-- the target type's `complete(with response:)` should switch on self and each case can call whatever parser it wants before calling its associated completion.   

(There's also an issue that I couldn't add `TargetTypeWithCompletion` to `TargetType.swift` because the compiler kept confusing the signature's `Result` with Alamofire's `Result` and complained.)

I've been following Moya for a while but haven't messed with workings of it before, so no idea if this could cause issues-- so curious what other people think.  
 
<!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 How it would work with ReactiveSwift and RxSwift was a question, and while it seems like a classic case for lenses, looking more closely I wasn't able to come up with a way to implement them for this enum-associated-type-completion approach. 

I agree looking again the API is more complex than it should be. The wrapper solution of course occurred to me also, but it's unsatisfying, little more then inviting people to make wrapper layer to go the last mile. Notably, they're not connected to enum cases in any way except that they use them--definitely better than nothing, but not up to the rest of Moya standard for organization. 

However, taking another look now a better solution occurred to me: I had been resisting using `Any` -- really resisting, because I thought it would defeat the purpose. In addition, as said before, a generic function return of `T` can't return a specific type, since that would break the API contract (although if the only use of `T` is for the return type it technically should be allowed, but the compiler has enough problems with generics already I'm not complaining). 

But there's nothing to prevent a generic function from immediately casting `anAny as? T` which gets exactly the same safety, and a lot better API.

The parse function in `TargetTypeWithParser `, stripped to essentials: 
```swift
//In Target : TargetTypeWithParser
public func parse(_ response: Moya.Response) throws -> Any  {
    switch self {
    case .zen(_):
        return GitHub.parseString(from: response)
    case .userProfile(_, _):
        return GitHub.parseDictionary(from: response)
    case .userRepositories(_, _):
        return GitHub.parseNSArray(from: response)
    }
}
```
And in `extension MoyaProvider where Target: TargetTypeWithParser`:

```swift
func parseAndComplete<T>(with target: Target, from response: Moya.Response, completion: (Result<T, MoyaError>) -> Void) {
    do {
        guard let parsed = try target.parse(response) as? T else {
            throw MoyaError.stringMapping(response) //Error approximate for demonstration
        }
        completion(Result(value: parsed))
    } catch let error as MoyaError {
        completion(Result(error: error))
    } catch {
        completion(Result(error: MoyaError.underlying(error)))
    }
}
``` 

It should be trivial to use the same parser create an equivalent method/s for a lens for a `SignalProvider<Moya.Response, MoyaError>` to `SignalProvider<T, MoyaError>`, or have a typed signal response, etc.  Actually I realize one drawback is you could call the MoyaProvider function with a completion block that took a result of any type-- the compiler wouldn't enforce the type. I don't like that it's possible to use the API incorrectly, but you would get the string mapping error above on casting, and maybe an AssertionFailure() for development there would be worthwhile. 

It's possible this could be addressed with a Swft equivalent of Objective C class object but more research is required. Regardless, this still additive change would bring better completion blocks.  
 It does appear with `enum` the only way to get the compile-time type safety is to include the completion block in the associated type, which I think is worth it but as you noted among other issues is incompatible with the reactive versions. I'll look into the best way to position it outside the core project. 

I investigated the equivalent of Objective C `class` object, which is bridged to Swift as `AnyClass.Type`, and so would be used as `Any.Type`. Unfortunately this didn't work (image to include playground output):

<img width="771" alt="screen shot 2017-02-03 at 12 44 35 pm" src="https://cloud.githubusercontent.com/assets/6426698/22602645/0d495362-ea12-11e6-960c-30cf184e4a4b.png">

Even though it has got `String.Type` by the time it's passed to the generic function, the compiler apparently can't match that to the closure parameter of `String`. (The same happened when passing a matching instance returned from `Any`.) Something maybe worth taking up within Swift itself.

So in @scottrhoyt 's formulation 1, 2,  it seems 1 is at a dead end. For 2, I actually have a lighter approach that uses generic functions that meets that goal exactly. It leaves out the `TargetType` entirely -- which you I think would consider a plus -- so I'll open a new issue for that. Cheers. 
  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/947?src=pr&el=h1) Report
> Merging [#947](https://codecov.io/gh/Moya/Moya/pull/947?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/2858dac91c990842a35c187c5fee6f36155fad07?src=pr&el=desc) will **not impact** coverage.


```diff
@@           Coverage Diff           @@
##           master     #947   +/-   ##
=======================================
  Coverage   73.72%   73.72%           
=======================================
  Files          22       22           
  Lines         723      723           
=======================================
  Hits          533      533           
  Misses        190      190
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/947?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/947?src=pr&el=footer). Last update [2858dac...a82967f](https://codecov.io/gh/Moya/Moya/compare/2858dac91c990842a35c187c5fee6f36155fad07...a82967fc12f818db80d69d46002c0bc0a80478f4?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  I guess we don't rely on functionality from `4.1`, or `4.2` of `Alamofire`. Or `3.1` for `RxSwift`. Else I'd suggest making the dependencies: `"Alamofire", "~> 4.2"` and `"RxSwift", "~> 3.1"` 
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Endpoint.swift | 30 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 31 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 32 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 33 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 34 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider.swift | 58 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider.swift | 59 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider.swift | 60 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider.swift | 61 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider.swift | 62 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProvider.swift | 12 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProvider.swift | 13 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProvider.swift | 14 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProvider.swift | 15 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProvider.swift | 16 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxMoyaProvider.swift | 11 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxMoyaProvider.swift | 12 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxMoyaProvider.swift | 13 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxMoyaProvider.swift | 14 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxMoyaProvider.swift | 15 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  I have the following podfile:
  pod 'Alamofire', '\~> 4.3'
  pod 'RxSwift', '\~> 3.2'
  pod 'RxCocoa', '\~> 3.2'
  pod 'Moya/RxSwift', '8.0.1'

When I run pod update I get:
[!] Unable to satisfy the following requirements:
- `Alamofire (~> 4.3)` required by `Podfile`
- `Alamofire (~> 4.2.0)` required by `Moya/Core (8.0.1)`
- `RxSwift (~> 3.2)` required by `Podfile`
- `RxSwift (~> 3.2)` required by `Podfile`
- `RxSwift (~> 3.1)` required by `RxCocoa (3.2.0)`
- `RxSwift (~> 3.1.0)` required by `Moya/RxSwift (8.0.1)` Thank you guys for the quick reaction! It resolved issue with Moya, but I still have the same issue with Moya-ObjectMapper. Opened an issue there https://github.com/ivanbruel/Moya-ObjectMapper/issues/45  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/941?src=pr&el=h1) Report
> Merging [#941](https://codecov.io/gh/Moya/Moya/pull/941?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/7de7f79fd56eb41d6213fe71ddca54dfa1cf56e7?src=pr&el=desc) will **not impact** coverage.


```diff
@@           Coverage Diff           @@
##           master     #941   +/-   ##
=======================================
  Coverage   73.72%   73.72%           
=======================================
  Files          22       22           
  Lines         723      723           
=======================================
  Hits          533      533           
  Misses        190      190
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/941?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/941?src=pr&el=footer). Last update [7de7f79...1fa474c](https://codecov.io/gh/Moya/Moya/compare/7de7f79fd56eb41d6213fe71ddca54dfa1cf56e7...1fa474c715d80e401c22ce6102863f55bc479404?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).  Hello all,

I'm currently trying to upload a multipart request with progress but the progress of the particular request will sometimes freeze and never complete. This will occur if I try to make many such requests (at least 2-3) in a sequence, the second or third will start reporting the percent but will randomly stop before reaching the end. The request will work appropriately as long as I don't use `requestWithProgress`. This works correctly when not using rx. 

I've tried testing using the following code and the "print" command will stop running, no errors catched, and the `filterCompleted()` never passing:

```swift
rxProvider.requestWithProgress(target)
        .do(onNext: { response in
          print(response.progress)
        })
        .filterCompleted()
        /// Do some other stuff
        .addDisposableTo(disposeBag)
```

Configuration:
Moya (8.0.1)
RxSwift (3.1.0)
COCOAPODS: 1.1.1 I've continued testing it, the problem is in the current provider wrapper. `requestWithProgress` doesn't always behave reliably. 

```swift
func requestWithProgress(_ token: Target, progressHandler: @escaping (Double)->Void) -> Observable<Response> {
    let response: Observable<Response> = Observable.create { [weak self] observer in
      let cancellableToken = self?.request(target, queue: nil, progress: { (progressResponse: ProgressResponse) in
        progressHandler(progressResponse.progress)
      }, completion: { result in
        switch result {
        case let .success(response):
          observer.onNext(response)
          observer.onCompleted()
        case let .failure(error):
          observer.onError(error)
        }
      })
      return Disposables.create {
        cancellableToken.cancel()
      }
    }
    return response
  }
```

Although this is a less than ideal implementation due to the callback instead of remaining in the rx world, it will work correctly when reporting the progress and will not hang. I recommend rechecking the logic in the `scan` and `progress` block under the original implementation as I suspect the problem lies there. Can confirm we are also seeing problems with this. The progress callback seems to hang as @migue1s has reported and I've also noticed that a subsequent .do(onNext after a filterCompleted in the chain is called twice sometimes.

I am using a similar fix for RxMoya for the time being based on @migue1s solution above. Thanks!

```swift
extension RxMoyaProvider where Target : TargetType {
    
    public func requestWithProgressFixed(_ target: Target, progressHandler: @escaping (Double)->Void) -> Observable<Response> {
        
        let response: Observable<Response> = Observable.create {
            [weak self] observer in
            
            let cancellableToken = self?.request(target, queue: nil, progress: { (progressResponse: ProgressResponse) in
                progressHandler(progressResponse.progress)
            }, completion: {
                result in
                
                switch result {
                case let .success(response):
                    observer.onNext(response)
                    observer.onCompleted()
                case let .failure(error):
                    observer.onError(error)
                }
            })
            return Disposables.create {
                cancellableToken?.cancel()
            }
        }
        return response
    }
}
```
 It's easy to reproduce with AWS S3 + ELB!
we have multiple stages of server, it's working with Nginx all the time, but hanging sometimes with AWS ELB, progress is not reliable ! it should be the latest version, i cant tell double onNext event happen or not, i have use RxSwift, however it's easy to reproduce hanging issue, onNext event freeze sometimes,  but onCompleted is work.



ÂæûÊàëÁöÑ iPhone ÂÇ≥ÈÄÅ

> ≈Åukasz Mr√≥z <notifications@github.com> Êñº 2017Âπ¥8Êúà17Êó• ‰∏ãÂçà4:44 ÂØ´ÈÅìÔºö
> 
> Hey @PatrickSCLin, do you still encounter double onNext event? What version of Moya do you use? Is it with RxSwift?
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 
 sorry, I was testing with project of company, you can try to set AWS S3 + ELB in Tokyo region, it's easy to reproduce  This PR adds the required `parameterEncoding` property in the Basic Example in the documentation.

 # [Codecov](https://codecov.io/gh/Moya/Moya/pull/939?src=pr&el=h1) Report
> Merging [#939](https://codecov.io/gh/Moya/Moya/pull/939?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/9c36262c223b0867d00f56d86ef53e394a190e84?src=pr&el=desc) will **not impact** coverage.


```diff
@@           Coverage Diff           @@
##           master     #939   +/-   ##
=======================================
  Coverage   73.72%   73.72%           
=======================================
  Files          22       22           
  Lines         723      723           
=======================================
  Hits          533      533           
  Misses        190      190
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/939?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/939?src=pr&el=footer). Last update [9c36262...35672e8](https://codecov.io/gh/Moya/Moya/compare/9c36262c223b0867d00f56d86ef53e394a190e84...35672e89ffcce8b9b2b9f5a0a5ee44ca1de1287f?src=pr&el=footer&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). 
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Endpoint.swift | 30 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 31 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 32 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 33 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
Endpoint.swift | 34 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider.swift | 58 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider.swift | 59 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider.swift | 60 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider.swift | 61 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
MoyaProvider.swift | 62 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProvider.swift | 12 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProvider.swift | 13 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProvider.swift | 14 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProvider.swift | 15 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProvider.swift | 16 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxMoyaProvider.swift | 11 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxMoyaProvider.swift | 12 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxMoyaProvider.swift | 13 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxMoyaProvider.swift | 14 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxMoyaProvider.swift | 15 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  <!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->

I'm in the process of building an app for a friend's website, and figured I might learn to use Moya while I'm at it. The website is using a bit non-standard way of building request links: 
```http://mobileapi.blah.info/1/?action=index&page=1```
I've followed the [basic setup](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md) to configure the provider:
```swift
var baseURL: URL { return URL(string: "https://mobileapi.blah.info/1/?action=")! }

var path: String {
  switch self {
    case .index:
      return "index"
  }
}
// ...

var parameters: [String: Any]? {
  switch self {
    case .index(let page):
      return ["page": page]
  }
}
// ...
```

With above setup, Moya builds a request like this: 
```https://mobileapi.blah.info/1/index?action=&page=1```
and returns 404.

I've also tried passing ```https://mobileapi.blah.info/1/``` as ```baseURL```, while passing ```"?action=index"``` as ```path```, but that didn't work either. If someone could point the newb in the right direction, I'd be much obliged. I think the issue is that path is added to the URL, and since it's a path and not a parameter it wont be put in the parameters, i.e. after `?`.

This is a slightly hacky way of handling it, but you'll have to handle everything in parameters.

And @scottrhoyt beat me to the punch. Worked like a charm. Many thanks, gentlemen!  I am trying to port my old network code to RxSwift Moya. Moya is very verbose but certain scenarios are not described in the documentation. Only network stack I have found with Github search is eidolon‚Äôs stack. I think in the long run I may dissect its network part but I will really appreciate if you can write an example for reactive Moya. Since almost all networking app needs some kind authorization, re-authorization, storing and retrieving tokens, Following points can be covered in the example.

- Authorization (JWT, oath etc.) plugin with Keychain,UserDefaults etc.
- Retry Authorization.
- Refresh Authorization with retry
- Get stuff with retry

Thanks again for creating this library and open sourcing eidolon it really helps me a lot.
  As our `TargetType` protocol requirements are increasing. That results in large `ServiceType` classes or non protocol adapting extensions . I think it would be great enhancement if we split the `TargetType` protocol into multiple protocols using protocol inheritance. Still requiring to provide full specifications but allowing to split into multiple files with new protocol requirements. Although already it is possible to split specification fulfilment with non protocol adapting extensions of `ServiceType` I think this way is much neat.  

I created example [here](https://github.com/madnik/Moya/blob/split-targettype-protocol/Sources/Moya/TargetType.swift) at my fork. If the contributors agree with the proposal I can update demo and docs and create PR.

```swift
/// The protocol used to define the full specifications necessary for a `MoyaProvider`.
public protocol TargetType: TargetURLType, TargetHTTPMethodType, TargetParametersType, TargetSampleDataType, TargetTaskType, TargetValidationType {}

/// The protocol used to define the 'baseURL' and 'path' specifications.
public protocol TargetURLType {

  /// The target's base `URL`.
  var baseURL: URL { get }

  /// The path to be appended to `baseURL` to form the full `URL`.
  var path: String { get }
}

/// The protocol used to define the HTTP request method specifications.
public protocol TargetHTTPMethodType {

  /// The HTTP method used in the request.
  var method: Moya.Method { get }
}

/// The protocol used to define the parameter and encoding specifications.
public protocol TargetParametersType {

  /// The parameters to be incoded in the request.
  var parameters: [String: Any]? { get }

  /// The method used for parameter encoding.
  var parameterEncoding: ParameterEncoding { get }
}

/// The protocol used to define the sample data specifications.
public protocol TargetSampleDataType {

  /// Provides stub data for use in testing.
  var sampleData: Data { get }
}

/// The protocol used to define the HTTP task type specifications.
public protocol TargetTaskType {

  /// The type of HTTP task to be performed.
  var task: Task { get }
}

/// The protocol used to define the Alamofire validation requirements.
public protocol TargetValidationType {

  /// Whether or not to perform Alamofire validation. Defaults to `false`.
  var validate: Bool { get }
}


public extension TargetValidationType {
    var validate: Bool {
        return false
    }
}
``` 
Please review and feedback. Usage examples.

```swift
extension GitHubUserContent: TargetType {}

extension GitHubUserContent: TargetURLType {

  public var baseURL: URL { return URL(string: "https://raw.githubusercontent.com")! }
  public var path: String {
    switch self {
    case .downloadMoyaWebContent(let contentPath):
      return "/Moya/Moya/master/web/\(contentPath)"
    }
  }
}

extension GitHubUserContent: TargetHTTPMethodType, TargetParametersType {

  public var method: Moya.Method {
    switch self {
    case .downloadMoyaWebContent:
      return .get
    }
  }
  public var parameters: [String: Any]? {
    switch self {
    case .downloadMoyaWebContent:
      return nil
    }
  }
  public var parameterEncoding: ParameterEncoding {
    return URLEncoding.default
  }
}

extension GitHubUserContent: TargetSampleDataType {

  public var sampleData: Data {
    switch self {
    case .downloadMoyaWebContent:
      return animatedBirdData() as Data
    }
  }
}

extension GitHubUserContent: TargetValidationType {

  public var task: Task {
    switch self {
    case .downloadMoyaWebContent:
      return .download(.request(DefaultDownloadDestination))
    }
  }
}
```
  This idea is really good! But there are some required properties like `baseURL`, `path`, `parameters` and `method` that must be included on all targets.

Parameters like `sampleData`, `task` and `parameterEncoding`, as @scottrhoyt pointed,  we should provide defaults if the Target doesn't implement them. That will make Moya much more flexible and easy to learn. @scottrhoyt 's answer make sense to me. 
> decomposition of TargetType would only be truly valuable if the separate protocols were useful for something other than being inherited by TargetType.


Yes. I agree with that. I will rethink about this. 
@leoneparise I think proposed approach still make those properties required. But I agree that specifications becomes loose as @scottrhoyt  pointed out. That something we need to address if we decompose. 
Thanks for the arguments with facts contributors.  I felt this would be useful when I was trying to use `struct`s instead of an enum for `TargetType`. For sharing implementations of few methods like `baseUrl` between the structs, I was planning to create a hierarchy of structs using inheritance, where parent struct will conform the `TargetURLType` protocol.

However, this approach felt too rigid. Because, the way the TargetType gets broken directly impacts on what can and can't be shared. I needed a flexible approach.
I took a protocol oriented approach by creating intermediate empty `protocol`s and adding extension functions to them.

```swift
protocol GithubUrl { }

extension GithubUrl {
    var baseURL: URL { return URL(string: "https://raw.githubusercontent.com")! }
}

struct EventsApi: TargetType, GithubUrl {
    var path: String { return "events" }
}
```

Ultimately, the decomposition didn't feel like the right approach for this usecase.  Moya: 8.0.0

```bash
>> carthage update --platform iOS

A shell task ({PROJECT_DIR}/Carthage/Checkouts/Moya/Demo/Demo.xcworkspace -scheme MoyaTests-Mac -configuration Release CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean -showBuildSettings) failed with exit code 66:
xcodebuild: error: Scheme MoyaTests-Mac is not currently configured for the clean action.
```

Carthage tries to build MoyaTests-Mac even if I add '--platform iOS'.
I think Demo should be built by Carthage. Maybe some schemes are shared when they shouldn't be.  It seems 8.0.1 fixed the problem. No more error occurs.  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/931?src=pr) is 73.72% (diff: 100%)
> Merging [#931](https://codecov.io/gh/Moya/Moya/pull/931?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #931   diff @@
==========================================
  Files            22         22          
  Lines           723        723          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            533        533          
  Misses          190        190          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [805e981...c2aca8e](https://codecov.io/gh/Moya/Moya/compare/805e98152aff1f0e0bb8bbfc2ec7e49bdd3600a0...c2aca8ea200e8ce06e74031b946092bafde53525?src=pr)  We already have a `ProgressResponse`

```swift
public struct ProgressResponse {
    public let response: Response?
    public let progressObject: Progress?

    public init(progress: Progress? = nil, response: Response? = nil) {
        self.progressObject = progress
        self.response = response
    }

    public var progress: Double {
        return progressObject?.fractionCompleted ?? 1.0
    }

    public var completed: Bool {
        return progress == 1.0 && response != nil
    }
}
```

a method called `requestWithProgress` for both reactive extensions and two Observable operators to filter progress and response.

```swift
extension ObservableType where E == ProgressResponse {
    /**
     Filter completed progress response and maps to actual response
     - returns: response associated with ProgressResponse object
     */
    public func filterCompleted() -> Observable<Response> {
        return self
            .filter { $0.completed }
            .flatMap { progress -> Observable<Response> in
                // Just a formatlity to satisfy the compiler (completed progresses have responses).
                switch progress.response {
                case .some(let response): return .just(response)
                case .none: return .empty()
                }
            }
    }

    /**
     Filter progress events of current ProgressResponse
     - returns: observable of progress events
     */
    public func filterProgress() -> Observable<Double> {
        return self.filter { !$0.completed }.map { $0.progress }
    }
}
```

I don't think this PR will add anything that our current implementation is not handling. No problem @scottrhoyt! Yeah, we can change the method names like `progress` and `response` to be more readable. But, in my head, this PR only adds complexity. A progress closure inside a observable? I can't agree with that.

Currently it is possible to track progress with method `requestWithProgress`. I'm closing this one.  One thing is crystal clear: you cannot _synchronously_ return something that will arrive in the future. (Not to mention that using side-effects to sneak out values from RX is malpractice by itself.)

The `setupRx` function should be rewritten to take callbacks or return an Observable, and your bridging code should make use of the resolve/reject blocks you get from the framework. [This seems to be related.](https://blog.getexponent.com/react-native-meets-async-functions-3e6f81111173#.qummm3qs6)  Using Moya 8.0

I would like to be able to set timeouts for request based on `TargetType` because some of my calls need much longer timeouts than others. I'm using Moya to communicate with custom hardware were certain calls should fail quickly while others are known to take their time (like firmware update over Wifi).

I'm using a `ReactiveCocoaMoyaProvider` like this: `ReactiveCocoaMoyaProvider(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, plugins: plugins)`

With a `requestClosure` like this:

```swift
fileprivate static let requestClosure: ((Moya.Endpoint<StoveTarget>, @escaping Moya.MoyaProvider.RequestResultClosure) -> Void) = { (endpoint, done) -> Void in
    guard var urlRequest = endpoint.urlRequest else { return }
    urlRequest.cachePolicy = .reloadIgnoringLocalAndRemoteCacheData
    urlRequest.timeoutInterval = Config.TimeOuts.pollIntervalHTTP / 2.0
    let result: Result<URLRequest, Moya.Error> = .success(urlRequest)
    done(result)
}
```

Unfortunately i have only the URL but no target to determine the timeout in this closure. Would it be possible to support this? Thanks a lot for the hint. I must have overlooked that feature. I've created a plugin that modifies the timeouts according to the target, works like a charm. Thanks again!  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/925?src=pr) is 73.72% (diff: 100%)
> Merging [#925](https://codecov.io/gh/Moya/Moya/pull/925?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #925   diff @@
==========================================
  Files            22         22          
  Lines           723        723          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            533        533          
  Misses          190        190          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [54d09b8...2079f38](https://codecov.io/gh/Moya/Moya/compare/54d09b89705d4d80b7a5422d08ccf9d1fb06099e...2079f389f3809a8c644e246ad2a01151575daded?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/924?src=pr) is 73.72% (diff: 100%)
> Merging [#924](https://codecov.io/gh/Moya/Moya/pull/924?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #924   diff @@
==========================================
  Files            22         22          
  Lines           723        723          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            533        533          
  Misses          190        190          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [54d09b8...ac6d0ce](https://codecov.io/gh/Moya/Moya/compare/54d09b89705d4d80b7a5422d08ccf9d1fb06099e...ac6d0cecf01c0d08ed83af3b2450594854415b00?src=pr)  A couple areas of the repo have changed directory structure since this file was last updated. This PR simply fixes links that were broken due to this. ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/923?src=pr) is 73.72% (diff: 100%)
> Merging [#923](https://codecov.io/gh/Moya/Moya/pull/923?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #923   diff @@
==========================================
  Files            22         22          
  Lines           723        723          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            533        533          
  Misses          190        190          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [2f96939...5454ed2](https://codecov.io/gh/Moya/Moya/compare/2f96939ab28be8fa66da8ee9db088ed6b1512fd4...5454ed2a76e8f3166276ab542401b2a1eb750b1f?src=pr)  For iPhones using the name might not always work. If the simulator has a watch tied to it the OS and the name will not be unique. You can have more than one. I'm guessing this works for iPhone 6s because the watches are now tied to an iPhone 7 simulator in circle. 

Let's just keep that in mind if something breaks in the future. 
  Moya 8.0.0

This is probably a stupid question but I can't find anything anywhere about this issue. Please note that I'm relatively new to Swift. 

I have Moya concepts / RxSwift all working without any issue outside of this use case.

I'm using a singleton class to manage a target for simplicity reasons and keeping consistency with another app.

Something very basic.
```swift
class KodiManager {

    private static let sharedInstance: KodiManager = KodiManager()

    static func getInstance() -> KodiManager {
        return sharedInstance
    }

   .... Lots of irrelevant code about the issue....

    public func kodiHostHaveAddon(host: String, port: Int, login: String, password: String, addonId: String) ->  Observable<Bool> {
        let provider = RxMoyaProvider<KodiProvider>(
                endpointClosure: getEndpointForKodiHost(host: host, port: port, login: login, password: password),
                manager: alamoManager)

        return provider.request(.addonsGetDetails(addonId))
                .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))
                .filterSuccessfulStatusCodes()
                .map(to: AddonDetailsResponse.self)
                .flatMap {
                    (response: AddonDetailsResponse) -> Observable<Bool> in
                    if (response.addon?.addonId?.isEmpty ?? true) {
                        return Observable.just(false)
                    }
                    return Observable.just(addonId.lowercased() == response.addon?.addonId?.lowercased())
                }
    }
}
```

If I call this
``` swift
KodiManager.getInstance().kodiHostHaveAddon(host: kodiHost.ip, port: kodiHost.httpPort, login: "", password: "", addonId: "xxxxx").subscribe()
```

Then the request is never fired.

If I store the provider as a local variable of the singleton then it works (See below). But of course it is problematic when calling 3 times the same function at the same time in a .zip for example.

```swift
class KodiManager {

    private var kodiAddonProvider: RxMoyaProvider<KodiProvider>? = nil

    public func kodiHostHaveAddon(host: String, port: Int, login: String, password: String, addonId: String) ->  Observable<Bool> {
       kodiAddonProvider = RxMoyaProvider<KodiProvider>(
                endpointClosure: getEndpointForKodiHost(host: host, port: port, login: login, password: password),
                manager: alamoManager)

        return kodiAddonProvider.request(.addonsGetDetails(addonId))
                .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))
                .filterSuccessfulStatusCodes()
                .map(to: AddonDetailsResponse.self)
                .flatMap {
                    (response: AddonDetailsResponse) -> Observable<Bool> in
                    if (response.addon?.addonId?.isEmpty ?? true) {
                        return Observable.just(false)
                    }
                    return Observable.just(addonId.lowercased() == response.addon?.addonId?.lowercased())
                }
    }
}
```

This does not happens if I return a simple Observable from the singleton.

I'm pretty sure this is something known, I read things about escaping but can't find how / where it would apply in that case.

Any help would be highly appreciated. @scottrhoyt Thanks for confirming I'm not mad :)

About storing the provider, this is what I do for the normal behavior of this singleton, then use a subject to push updates and things to listeners, classic Rx things.
But this is when already connected to a known host. 

This function and another are made for discovering of the hosts and testing. So it's more temporary things I'd like to avoid to increase complexity of client to avoid requesting a provider then calling the function. 

Not sure #905 would fix the issue, it sounds like I would at least receive the error but I'll try as soon as I can.
Is there a workaround to force the provider to not be deallocated ? 

I use cocoapods, if you have a quick hint at how to migrate to master with it :) Thanks will test all that tomorrow. Ok so tested and yes Master does behave more normally for that use case.

I have not tested long time provider retention but at least for the time between the return of the func and the call it now always correctly fire the request and return a result.

Thanks for the help and the working solution :)

Is there an estimate about a public release date ?  I use latest Moya beta version, and i have a problem with uploading pdf. I've got valid pdf Data (I know coz i can open it in webview). I'm trying upload, but server didn't accepting it. While uploading images all well. 

```swift
return .upload(.multipart([MultipartFormData(provider: .data(document.file!), name: "doc", fileName: "doc.pdf", mimeType: "application/pdf")]))
```
where document.file is swift Data with pdf Does your server expect a multipart upload or a simple POST where the body is the PDF data? (Your code does the multipart version.)

 Are you getting any useful or technical messages in the server's response? Yes, server should expect multipart, as i said images uploading working fine.
I getting status code 400 with message no file here, maybe i should use some other method? 
Thank you for response thank you but no, already doing same It's strange that your server is not accepting a PDF but it's accepting images. Can you do the same test with Alamofire directly? Ok, sorry, it was my fault, wrong field name. Thank you all for response, everything work.  xcode 8 swift 3
version of Moya we are using --  pod 'Moya', '~> 8.0.0-beta.2'

```swift
public var multipartBody: [MultipartFormData]? {
        switch self {
case .ChangeAvatar(_, _, let profileImage):
            let image_name = "\(NSDate().timeIntervalSince1970)_avatar.jpg"
            guard let data = UIImageJPEGRepresentation(profileImage, 1.0) else { return nil }
            return [MultipartFormData(provider: .data(data), name: "profile_image[0]", fileName: "\(image_name)", mimeType:"image/jpeg")]
}
```

Image not getting uploaded to server as MultipartFormData block not executing.

 For Version 8.0, uploads are done with `task` parameter. `multipartBody` was deprecated. Any example please ? Working Thanks  I want to cancel the download request.
```swift
func download() -> Observable<ProgressResponse> {
    let req = FileDownloadProvider.requestWithProgress(.downloadFile(fromURL: fileURL, saveAs: audioID + ".mp3"))
    req.cancel()// Value of type 'Observable<ProgressResponse>' has no member 'cancel'
}
```
<!--
Please let us know what version of Moya you are using, so we can better pinpoint and/or solve your issue.

Please wrap code blocks in backticks, like so:

```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file and version to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 Yes. The task is cancelled when observable is disposed.    Added EVReflection Moya extension to Community Extensions  This is based on #830. I have updated only the docs to provide a usecase for why this is required.
I strongly think that this will enable end-users to extend Moya's functionality in different ways which are not possible right now. 

Would love to have feedback on whether this makes sense.
I am not sure where exactly this documentation belongs. Fundamentally, this feature provides a MoyaProvider that can be used with different targets. Hence, I added it to `MultiTarget`.

I would like to start working on the implementation as soon as this requirement is validated. <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">PR is classed as Work in Progress</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/910?src=pr) is 73.72% (diff: 100%)
> Merging [#910](https://codecov.io/gh/Moya/Moya/pull/910?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #910   diff @@
==========================================
  Files            22         22          
  Lines           723        723          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            533        533          
  Misses          190        190          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [9c0a41a...d4830f3](https://codecov.io/gh/Moya/Moya/compare/9c0a41abec87c9a8a73ce5ef90c71c332df5e627...d4830f37e2a15a9e55eb357f34faac3f5d678ae0?src=pr) My opinion is that if the end-user prefers strong types over grouping, he should have that choice.

Earlier, I was expecting `MultiMoyaProvider` implementation to get complicated, hence I wanted this to be included in the core.
However, I tried to implement this and it has turned out to be very simple. Thus, with respect to implementation, I am fine with building it as an extension.

```swift 
class MultiMoyaProvider: MoyaProvider<MultiTarget> { }
```

The key deliverable here is the documentation. My only concern now is whether an extension which contains only documentation makes sense.  I am not entirely sure if that is an issue but please feel free to prove me wrong.

What I am trying to achieve is to make a `POST` request to an API. The first thing is that I have to provide the `TOKEN` for the `API`, encodend in the url like:  

`http://awesomeapi.com?token=mytoken`

Unfortunately the `API` I am calling, is made in a way so that it accepts the token only if it's a URL encoded parameter.

Next thing is I have to send a parameters in a `JSON` body like :
```json
{
    param1: value,
    param2: value
}
```
So in general I have to make a `POST` request and provide both URL encoded parameters and body parameters.

While researching about an answer I came into [Issue 431](https://github.com/Moya/Moya/issues/431), where the author is trying to achieve the same, but I can not see a straightforward answer to his [question](https://github.com/Moya/Moya/issues/431#issuecomment-197482365). 

Reading the docs make me think that having parameters in the request body and as URL encoded is of course possible in separate requests, but having them combined in one is not or at least not documented yet. Am I right about that ?  If not, can you provide an example of how can this be done ?  You can change the used ParameterEncoding. An idea could be to create a ParameterEncoding like:

```swift
public struct TokenEncoding: ParameterEncoding {
    public let token: String
    private let urlEncoding = URLEncoding(destination: .methodDependent)

    init(token: String) {
        self.token = token
    }

    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        // use URLEncoding to encoding parameters
        // use something like URLEncoding's implementation to add token to URL.
        // URLEncoding can be found here: https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L70
    }
}
```

This does require that token stays the same I guess. Another way could have it pull out token from passed parameters and then treat the token parameter in a special way. Mind you all of this code has not been tested in any way. @pedrovereza I just came to a similar issue again, so I consider re-openning the issue again, since I am uncertain if it's possible to make for example `POST` or `PUT` request to `api/resource/:id` and   pass a `json` body out of the box, without any additional implementation, as it was suggested above.  Yes. Thanks for the help .   While I think it could be nice that you don't automatically build Rx and ReactiveSwift extensions out-of-the-box with Carthage, then I believe the issues can be mitigated in other ways. 

One way could be caching `Carthage/Build` and/or `Carthage/Checkout`. 

But another way entirely could be to run it with `carthage boostrap --no-build`, which would postpone building to when the project is being compiled. I'm not entirely sure how well this option works with Moya, since I haven't personally tried it too much. I did some tests with it earlier today, but failed to get it to compile on CI.  With #563 it changes how Moya is used with Carthage. It seems that the importing conflicts are resolved, but the current wording can also be confusing, since it seems to suggest you only link either `RxMoya` or `ReactiveMoya` if you use either of these.

Granted I can have misunderstood how Moya should be used with Carthage. ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/907?src=pr) is 73.72% (diff: 100%)
> Merging [#907](https://codecov.io/gh/Moya/Moya/pull/907?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #907   diff @@
==========================================
  Files            22         22          
  Lines           723        723          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            533        533          
  Misses          190        190          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [b29f032...7a3654e](https://codecov.io/gh/Moya/Moya/compare/b29f0329aa81c9af43302afa4d943b4b7312ca0b...7a3654e5ac6cd16f855dd89810ffb105451181af?src=pr) That would require having `ReactiveMoya` and `RxMoya` being located at those location and not in `Moya/Moya`.  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/906?src=pr) is 73.72% (diff: 100%)
> Merging [#906](https://codecov.io/gh/Moya/Moya/pull/906?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #906   diff @@
==========================================
  Files            22         22          
  Lines           723        723          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            533        533          
  Misses          190        190          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [b29f032...dd471de](https://codecov.io/gh/Moya/Moya/compare/b29f0329aa81c9af43302afa4d943b4b7312ca0b...dd471defb34a90fb4a29e478134c22a3c2a9837a?src=pr)  Added a check to ensure that the provider is not deallocated, if it is then it sends OnError event. Some discussion on the problem http://stackoverflow.com/questions/41433337/observable-returned-from-function-never-sends-onnext/41474121#41474121 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/905?src=pr) is 73.72% (diff: 50.00%)
> Merging [#905](https://codecov.io/gh/Moya/Moya/pull/905?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #905   diff @@
==========================================
  Files            22         22          
  Lines           723        723          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            533        533          
  Misses          190        190          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [b29f032...07edb84](https://codecov.io/gh/Moya/Moya/compare/b29f0329aa81c9af43302afa4d943b4b7312ca0b...07edb849e35cb21f0863bd0bedb89fcbbe7613d0?src=pr) Sure, how?  ## Version
Moya 8.0.0, Swift 3

The API I'm using with Moya has URLs in most of the JSON responses. What I mean is, let's say I had `getProfile(username: String)`. The API returns the data, and the response provides more API links to get more information like the user's followers, since putting them in the same response would probably make the size of the request much larger. I don't want to add more functions for each of these URLs, but instead I want to make a Moya request using a URL. I know it's a bit confusing, should I just do this with Alamofire?
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/903?src=pr) is 73.72% (diff: 100%)
> Merging [#903](https://codecov.io/gh/Moya/Moya/pull/903?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #903   diff @@
==========================================
  Files            22         22          
  Lines           723        723          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            533        533          
  Misses          190        190          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [917997f...f4263be](https://codecov.io/gh/Moya/Moya/compare/917997fef2f631f554b76a5cfdb864ea5533f99f...f4263be926ad6d1900d62c9ae54d209d8c9d4182?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/902?src=pr) is 73.72% (diff: 100%)
> Merging [#902](https://codecov.io/gh/Moya/Moya/pull/902?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #902   diff @@
==========================================
  Files            22         22          
  Lines           723        723          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            533        533          
  Misses          190        190          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [6e96aec...4bc09fe](https://codecov.io/gh/Moya/Moya/compare/6e96aec5bb68bb7871df93780958302f328cc0fd...4bc09feb6f19fe8b27a783b0fcf8a59d06a23f37?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/901?src=pr) is 73.72% (diff: 100%)


> No coverage report found for **master** at fa59869.

> Powered by [Codecov](https://codecov.io?src=pr). Last update [fa59869...3804439](https://codecov.io/gh/Moya/Moya/compare/fa59869b76a9366b8356aecd22affeffb2c143f9...3804439532b1cc94032cf1beff5bccb4ca673504?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/900?src=pr) is 75.39% (diff: 100%)
> Merging [#900](https://codecov.io/gh/Moya/Moya/pull/900?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **1.67%**

```diff
@@             master       #900   diff @@
==========================================
  Files            22         20     -2   
  Lines           723        699    -24   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits            533        527     -6   
+ Misses          190        172    -18   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [86886b4...3cd09cb](https://codecov.io/gh/Moya/Moya/compare/86886b45a0fb14571aa2fd7f608bbc4fb622fe02...3cd09cb878b39971bce2c5b398e7052bdea08f7a?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/899?src=pr) is 75.39% (diff: 100%)
> Merging [#899](https://codecov.io/gh/Moya/Moya/pull/899?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #899   diff @@
==========================================
  Files            20         20          
  Lines           699        699          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            527        527          
  Misses          172        172          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [17e9d44...4c154a0](https://codecov.io/gh/Moya/Moya/compare/17e9d44d537b1630c908fa518f46a78b4677884d...4c154a049247022a4650336164ce862f3c531eb8?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/898?src=pr) is 73.91% (diff: 0.00%)
> Merging [#898](https://codecov.io/gh/Moya/Moya/pull/898?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **1.48%**

```diff
@@             master       #898   diff @@
==========================================
  Files            20         20          
  Lines           699        713    +14   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            527        527          
- Misses          172        186    +14   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [17e9d44...d60dc75](https://codecov.io/gh/Moya/Moya/compare/17e9d44d537b1630c908fa518f46a78b4677884d...d60dc75b1ff16d6cfa921c405b609c9bdda462b2?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/897?src=pr) is 76.25% (diff: 100%)
> Merging [#897](https://codecov.io/gh/Moya/Moya/pull/897?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.85%**

```diff
@@             master       #897   diff @@
==========================================
  Files            20         20          
  Lines           699        699          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits            527        533     +6   
+ Misses          172        166     -6   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [17e9d44...89b6c2d](https://codecov.io/gh/Moya/Moya/compare/17e9d44d537b1630c908fa518f46a78b4677884d...89b6c2dc7b766315a46d775263c160903c127158?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/896?src=pr) is 75.39% (diff: 100%)
> Merging [#896](https://codecov.io/gh/Moya/Moya/pull/896?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #896   diff @@
==========================================
  Files            20         20          
  Lines           699        699          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            527        527          
  Misses          172        172          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [106d429...2cbd82b](https://codecov.io/gh/Moya/Moya/compare/106d429dca34564d4e9195396d03e8fff4fbbc19...2cbd82b67fc88b1ba4c426c61132d25b7d4724a3?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/895?src=pr) is 75.39% (diff: 100%)
> Merging [#895](https://codecov.io/gh/Moya/Moya/pull/895?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #895   diff @@
==========================================
  Files            20         20          
  Lines           699        699          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            527        527          
  Misses          172        172          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [106d429...3c034c9](https://codecov.io/gh/Moya/Moya/compare/106d429dca34564d4e9195396d03e8fff4fbbc19...3c034c988a44bc54242e312adbf857bd0e73b516?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/893?src=pr) is 75.39% (diff: 100%)
> Merging [#893](https://codecov.io/gh/Moya/Moya/pull/893?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.42%**

```diff
@@             master       #893   diff @@
==========================================
  Files            19         20     +1   
  Lines           687        699    +12   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits            515        527    +12   
  Misses          172        172          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [37abb66...d42efa7](https://codecov.io/gh/Moya/Moya/compare/37abb66ef342ee30bdad6e5907f7a7a912effc1b...d42efa7b70d19f75fbb7074828c690ff06bd1f2a?src=pr) This looks great. But how would one handle the access token when it is expired in the request? Would there be a way for us to set a specific url to refresh the token?   When create MoyaProvider, I can pass endpointClosure and requestClosure to its initializer.

So the problem is what if I want to change the endponitClosure later.

I have to create a MoyaProvider again, pass the new endpointClosure to its initializer.

Is there a better idea?  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=h1) Report
> Merging [#891](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/2394d53396dae50ed00a9fc7c99181c0702c68da?src=pr&el=desc) will **decrease** coverage by `0.18%`.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/891/graphs/tree.svg?width=650&height=150&src=pr&token=CjZLHCNgNn)](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           master     #891      +/-   ##
==========================================
- Coverage   73.65%   73.46%   -0.19%     
==========================================
  Files          22       19       -3     
  Lines         725      701      -24     
==========================================
- Hits          534      515      -19     
+ Misses        191      186       -5
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Endpoint.swift](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL0VuZHBvaW50LnN3aWZ0) | `82% <0%> (-12%)` | :arrow_down: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.1% <0%> (-0.18%)` | :arrow_down: |
| [Sources/Moya/MultiTarget.swift](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL011bHRpVGFyZ2V0LnN3aWZ0) | `100% <0%> (√∏)` | :arrow_up: |
| [Sources/Moya/MoyaProvider+Defaults.swift](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitEZWZhdWx0cy5zd2lmdA==) | `95.23% <0%> (√∏)` | :arrow_up: |
| [Sources/Moya/Response.swift](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1Jlc3BvbnNlLnN3aWZ0) | `95.65% <0%> (√∏)` | :arrow_up: |
| [...ources/ReactiveMoya/ReactiveMoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVNb3lhQXZhaWxhYmlsaXR5LnN3aWZ0) | | |
| [Sources/Moya/MoyaError.swift](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFFcnJvci5zd2lmdA==) | | |
| [Sources/Moya/Plugins/AccessTokenPlugin.swift](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvQWNjZXNzVG9rZW5QbHVnaW4uc3dpZnQ=) | | |
| [Sources/Moya/MoyaAvailability.swift](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFBdmFpbGFiaWxpdHkuc3dpZnQ=) | | |
| [Sources/Moya/Error.swift](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL0Vycm9yLnN3aWZ0) | `31.81% <0%> (√∏)` | |
| ... and [1 more](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=tree-more) | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=footer). Last update [2394d53...0d692aa](https://codecov.io/gh/Moya/Moya/pull/891?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Big PR</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/890?src=pr) is 74.33% (diff: 0.00%)
> Merging [#890](https://codecov.io/gh/Moya/Moya/pull/890?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **1.06%**

```diff
@@             master       #890   diff @@
==========================================
  Files            20         22     +2   
  Lines           699        709    +10   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            527        527          
- Misses          172        182    +10   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [106d429...b948531](https://codecov.io/gh/Moya/Moya/compare/106d429dca34564d4e9195396d03e8fff4fbbc19...b948531ec283a509d87fa64bd47c107bba833a9a?src=pr) <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/889?src=pr) is 73.46% (diff: 100%)
> Merging [#889](https://codecov.io/gh/Moya/Moya/pull/889?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #889   diff @@
==========================================
  Files            19         19          
  Lines           701        701          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            515        515          
  Misses          186        186          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [3472baa...30387b4](https://codecov.io/gh/Moya/Moya/compare/3472baa1001009e01334b4f9337702776c25043c...30387b484ed05d45e871fa8ef4e64517f5c29247?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/886?src=pr) is 75.00% (diff: 100%)
> Merging [#886](https://codecov.io/gh/Moya/Moya/pull/886?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #886   diff @@
==========================================
  Files            19         19          
  Lines           688        688          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            516        516          
  Misses          172        172          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [c1fb3fa...e0023f9](https://codecov.io/gh/Moya/Moya/compare/c1fb3fabdd3de99dc360517299fa7d8cbd215124...e0023f93660cbdcd3540bd3b854586ae4942c404?src=pr) <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Big PR</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The <code>Cartfile</code> or <code>Cartfile.resolved</code> was updated, but there were no changes in the <code>podspec</code>. Did you forget updating the <code>podspec</code>?</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/885?src=pr) is 73.46% (diff: 100%)
> Merging [#885](https://codecov.io/gh/Moya/Moya/pull/885?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #885   diff @@
==========================================
  Files            19         19          
  Lines           701        701          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            515        515          
  Misses          186        186          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [55c4d5d...fadcdca](https://codecov.io/gh/Moya/Moya/compare/55c4d5d65ee6b55b75b85bb7d0903e8907583183...fadcdcaaa0d50e41223edb27648ca1275c052156?src=pr) <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Big PR</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  With this pull request Moya.Error conforms to LocalizedError thus providing more meaningful error descriptions. Also removed unused Moya.Error enumeration case.

Before
print(imageMappingError.localizedDescription): The operation couldn‚Äôt be completed. (Moya.Error error 0.)
print(underlyingError.localizedDescription): The operation couldn‚Äôt be completed. (Moya.Error error 5.)

After
print(imageMappingError.localizedDescription): Failed to map data to an Image
print(underlyingError.localizedDescription): Response status code was unacceptable: 404. <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 Thanks for the encouraging feedback. Didn't notice the tests before CircleCI complained. Working on the requested improvements. ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/884?src=pr) is 73.46% (diff: 0.00%)
> Merging [#884](https://codecov.io/gh/Moya/Moya/pull/884?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **1.53%**

```diff
@@             master       #884   diff @@
==========================================
  Files            19         19          
  Lines           688        701    +13   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits            516        515     -1   
- Misses          172        186    +14   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [c1fb3fa...4ba25d5](https://codecov.io/gh/Moya/Moya/compare/c1fb3fabdd3de99dc360517299fa7d8cbd215124...4ba25d5f40c161bb91d688d5a01e1bbeb0fab339?src=pr) codecov/patch coverage looks intimidating and i'm slightly tempted to write a test or two just to bump it up but doubt if the tests would provide any real value here. In my opinion we can close the issue and consider it completed. The following is bikeshedding and of little importance. 

Having the following behaviours for Moya.Error and enforcing them using unit tests wouldn't be completely nonsense.

* Moya.Error enumaration cases should return non-nil errorDescription.
* Enumeration cases that have associated error, for example .underlying(Swift.Error), should include associatedError.errorDescription in the returned errorDescription.

As for test implementation I would like it to guide the programmer to the relevant test cases either by 1) failing tests and / or by 2) compiler error when a new error enumeration case is added. If these requirements are not met the test cases go unnoticed too easily.

1) I couldn't think of easy way to test future enumeration cases as Swift doesn't have convenient way to enumerate enums. I don't want to add `static let allValues = [.imageMapping, ...]` only for tests.
2) Compiler error could be archived by using switch statement, something along lines:

```swift
describe("error description") {
    it("should return description") {
        expectNonNilErrorDescriptionFor(error: .imageMapping(response))
        ...
        expectNonNilErrorDescriptionFor(error: .underlying(NSError.init()))
    }
}

fileprivate func expectNonNilErrorDescriptionFor(error: Moya.Error) {
    switch error {
    case .imageMapping,
         .jsonMapping,
         ....
         .requestMapping:
        expect(error.errorDescription).to(beNil())
    }
}
```

Above implementation is not satisfying as it fills goals only partially. The implementation does guide programmer to relevant file by triggering compiler error and requires adding a new case to the switch but there's no guarantee that the programmer would remember to add a new call to `expectNonNilErrorDescriptionFor` in `it("should return description")`.

Summa summarum: couldn't figure out meaningful test cases with elegant and future-proof implementation that didn't require further modifying Moya.Error enum.  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/883?src=pr) is 74.96% (diff: 80.00%)
> Merging [#883](https://codecov.io/gh/Moya/Moya/pull/883?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **1.49%**

```diff
@@             master       #883   diff @@
==========================================
  Files            19         19          
  Lines           701        687    -14   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            515        515          
+ Misses          186        172    -14   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [ea1406d...8a37df2](https://codecov.io/gh/Moya/Moya/compare/ea1406d1547fc1721d36fb12c197411bdb5d5127...8a37df2d8760ff883a74f650e949f4b457ec0b60?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/882?src=pr) is 75.00% (diff: 100%)
> Merging [#882](https://codecov.io/gh/Moya/Moya/pull/882?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.07%**

```diff
@@             master       #882   diff @@
==========================================
  Files            19         19          
  Lines           690        688     -2   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits            518        516     -2   
  Misses          172        172          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [66b863c...f83d925](https://codecov.io/gh/Moya/Moya/compare/66b863c047f84a41296a8953b0d7fcbe42fe9074...f83d925ccbfb1ff11df2e02b2634f97668b44ab9?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/881?src=pr) is 73.63% (diff: 66.66%)
> Merging [#881](https://codecov.io/gh/Moya/Moya/pull/881?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.08%**

```diff
@@             master       #881   diff @@
==========================================
  Files            22         22          
  Lines           723        732     +9   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits            533        539     +6   
- Misses          190        193     +3   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [b29f032...5775dd9](https://codecov.io/gh/Moya/Moya/compare/b29f0329aa81c9af43302afa4d943b4b7312ca0b...5775dd9a946fc168d54c04ded8fc8276be982593?src=pr) Hey @scottrhoyt, I'm also using a stubbed files approach and also wouldn't like to have these json files in the main bundle to be distributed with the app. Did you manage to add them to the test target without having to change the whole project membership?  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/880?src=pr) is 75.07% (diff: 100%)
> Merging [#880](https://codecov.io/gh/Moya/Moya/pull/880?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #880   diff @@
==========================================
  Files            19         19          
  Lines           690        690          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            518        518          
  Misses          172        172          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [d4cc57c...d98e098](https://codecov.io/gh/Moya/Moya/compare/d4cc57cb9561a326d5231c6a3850d9981836ca27...d98e098b589f67d4afdd7417a8cff851e30b44fc?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/879?src=pr) is 75.07% (diff: 100%)
> Merging [#879](https://codecov.io/gh/Moya/Moya/pull/879?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #879   diff @@
==========================================
  Files            19         19          
  Lines           690        690          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            518        518          
  Misses          172        172          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [d4cc57c...e242a7a](https://codecov.io/gh/Moya/Moya/compare/d4cc57cb9561a326d5231c6a3850d9981836ca27...e242a7a3dd5583229c7609d8f2eadf730451fafb?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/878?src=pr) is 83.27% (diff: 100%)
> Merging [#878](https://codecov.io/gh/Moya/Moya/pull/878?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **8.20%**

```diff
@@             master       #878   diff @@
==========================================
  Files            19         34     +15   
  Lines           690       2769   +2079   
  Methods           0          0           
  Messages          0          0           
  Branches          0          0           
==========================================
+ Hits            518       2306   +1788   
- Misses          172        463    +291   
  Partials          0          0           
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [6282a21...416cb23](https://codecov.io/gh/Moya/Moya/compare/6282a21c47bca97890437b96584215bf7cf70e7a...416cb23a5d87d708298144346704cfd04c7beb35?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/877?src=pr) is 75.07% (diff: 100%)
> Merging [#877](https://codecov.io/gh/Moya/Moya/pull/877?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #877   diff @@
==========================================
  Files            19         19          
  Lines           690        690          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            518        518          
  Misses          172        172          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [6282a21...b3cc8c4](https://codecov.io/gh/Moya/Moya/compare/6282a21c47bca97890437b96584215bf7cf70e7a...b3cc8c478132c9b6d6244dd57508d82735f19b92?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/876?src=pr) is 75.00% (diff: 100%)
> Merging [#876](https://codecov.io/gh/Moya/Moya/pull/876?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #876   diff @@
==========================================
  Files            19         19          
  Lines           688        688          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            516        516          
  Misses          172        172          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [c1fb3fa...01b8df8](https://codecov.io/gh/Moya/Moya/compare/c1fb3fabdd3de99dc360517299fa7d8cbd215124...01b8df8a1eb879697bcc58b26eb38e1f1872f52a?src=pr)  I want to fetch accessToken from server  in requestClosure, on fetched change the request header.
but it not support 
 I'm using 8.0.0-beta.5 Can you tell me how to use requestClosure? Thanks  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/874?src=pr) is 75.07% (diff: 100%)
> Merging [#874](https://codecov.io/gh/Moya/Moya/pull/874?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **1.38%**

```diff
@@             master       #874   diff @@
==========================================
  Files            37         19     -18   
  Lines          3122        690   -2432   
  Methods           0          0           
  Messages          0          0           
  Branches          0          0           
==========================================
- Hits           2387        518   -1869   
+ Misses          735        172    -563   
  Partials          0          0           
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [1e9a9d1...e4a5d11](https://codecov.io/gh/Moya/Moya/compare/1e9a9d16eb61b90910357b770e5e11e080950d97...e4a5d11cfda621dad503ff748fbfc378e805f7ca?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/873?src=pr) is 83.76% (diff: 100%)
> Merging [#873](https://codecov.io/gh/Moya/Moya/pull/873?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.40%**

```diff
@@             master       #873   diff @@
==========================================
  Files            34         35     +1   
  Lines          2783       2827    +44   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits           2320       2368    +48   
+ Misses          463        459     -4   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [98886f2...cf7d461](https://codecov.io/gh/Moya/Moya/compare/98886f2e3d477962ce082954aa4da2d0ede8c8b5...cf7d4616b0d51ab388e6baa9ec383b74dbcc7289?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/872?src=pr) is 83.39% (diff: 100%)
> Merging [#872](https://codecov.io/gh/Moya/Moya/pull/872?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.03%**

```diff
@@             master       #872   diff @@
==========================================
  Files            34         34          
  Lines          2783       2789     +6   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits           2320       2326     +6   
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [98886f2...ef8b86e](https://codecov.io/gh/Moya/Moya/compare/98886f2e3d477962ce082954aa4da2d0ede8c8b5...ef8b86e6da9829515128f707b98a63e7aad476f3?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/871?src=pr) is 76.45% (diff: 96.55%)
> Merging [#871](https://codecov.io/gh/Moya/Moya/pull/871?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **7.30%**

```diff
@@             master       #871   diff @@
==========================================
  Files            35         37     +2   
  Lines          2827       3122   +295   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits           2368       2387    +19   
- Misses          459        735   +276   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [40054e5...0290934](https://codecov.io/gh/Moya/Moya/compare/40054e5f528b696613481c2d24b2fce75f65157b...0290934a816c08874b97a2f6b2333630a3d5200a?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/869?src=pr) is 83.36% (diff: 100%)
> Merging [#869](https://codecov.io/gh/Moya/Moya/pull/869?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #869   diff @@
==========================================
  Files            34         34          
  Lines          2783       2783          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2320       2320          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [f90a124...ec63660](https://codecov.io/gh/Moya/Moya/compare/f90a124428a02c0c0f66cd1d993d951731769853...ec63660ca5cc25646120888d61df866a72ca2cd2?src=pr)  I'm using Moya 8.0.0-beta.6 with Swift 3.

I keep getting an error saying `Type 'foo' does not conform to protocol 'TargetType'`. It says that some things are missing, but I have them all. Last time, I had this problem, fixing it required changing the order of the variables. What is going on

![](http://i.imgur.com/KFDHj7S.png)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/867?src=pr) is 83.36% (diff: 100%)
> Merging [#867](https://codecov.io/gh/Moya/Moya/pull/867?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #867   diff @@
==========================================
  Files            34         34          
  Lines          2783       2783          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2320       2320          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [416c19f...89e69da](https://codecov.io/gh/Moya/Moya/compare/416c19f852a4af3d6d0aab7bdc82fa004acf696a...89e69da63a228bd96d34423d57e2367a6fbbde97?src=pr) <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  I have large sample response for each endpoint in my app. However, I am afraid that if I directly paste the response inside each switch case my code will start looking ugly. I was wondering what are the other was to do this:

Please find below part of my switch statement with sample response for the smallest case.

```swift
 var sampleData: Data {
    switch self {
    case .movieDetails(_):
      return "{\"adult\": false,\"backdrop_path\": \"/wSJPjqp2AZWQ6REaqkMuXsCIs64.jpg\",\"belongs_to_collection\": null,\"budget\": 63000000,\"genres\": [{\"id\": 18,\"name\": \"Drama\"}],\"homepage\": \"http://www.foxmovies.com/movies/fight-club\",\"id\": 550,\"imdb_id\": \"tt0137523\",\"original_language\": \"en\",\"original_title\": \"Fight Club\",\"overview\": \"A ticking-time-bomb insomniac and a slippery soap salesman channel primal male aggression into a shocking new form of therapy. Their concept catches on, with underground \"fight clubs\" forming in every town, until an eccentric gets in the way and ignites an out-of-control spiral toward oblivion.\",\"popularity\": 6.868575,\"poster_path\": \"/adw6Lq9FiC9zjYEpOqfq03ituwp.jpg\",\"production_companies\": [{\"name\": \"Regency Enterprises\",\"id\": 508},{\"name\": \"Fox 2000 Pictures\",\"id\": 711},{\"name\": \"Taurus Film\",\"id\": 20555},{\"name\": \"Linson Films\",\"id\": 54050},{\"name\": \"Atman Entertainment\",\"id\": 54051},{\"name\": \"Knickerbocker Films\",\"id\": 54052}],\"production_countries\": [{\"iso_3166_1\": \"DE\",\"name\": \"Germany\"},{\"iso_3166_1\": \"US\",\"name\": \"United States of America\"}],\"release_date\": \"1999-10-14\",\"revenue\": 100853753,\"runtime\": 139,\"spoken_languages\": [{\"iso_639_1\": \"en\",\"name\": \"English\"}],\"status\": \"Released\",\"tagline\": \"How much can you know about yourself if you've never been in a fight?\",\"title\": \"Fight Club\",\"video\": false,\"vote_average\": 8.1,\"vote_count\": 5863}".data(using: String.Encoding.utf8)!
    case .similarMovies(_):
```
 Thanks @scottrhoyt @ashfurrow . This is indeed a great idea. @ashfurrow your implementation is really elegant. Planning to implement it in the same way

  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/865?src=pr) is 83.36% (diff: 33.33%)
> Merging [#865](https://codecov.io/gh/Moya/Moya/pull/865?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #865   diff @@
==========================================
  Files            34         34          
  Lines          2783       2783          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2320       2320          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [95058c1...5016fe5](https://codecov.io/gh/Moya/Moya/compare/95058c1eed1663a36e420b687d88f63b438b09c0...5016fe522018422c797ec65b6e8761cabb9568d5?src=pr)  Considering that if I want to use JSONEncoding, not the default one (URLEncoding).

So I have to define an endpointClosure like the following code dose:

```swift
let endpointClosure = {
    (target: MyTarget) -> Endpoint<MyTarget> in
            
    let urlString = target.baseURL.appendingPathComponent(gistRouter.path).absoluteString
            
    let sampleResponseClosure: Endpoint.SampleResponseClosure = {
       .networkResponse(200, target.sampleData)
     }
            
    return Endpoint<MyTarget>(
      url: urlString,
      sampleResponseClosure: sampleResponseClosure,
      method: gistRouter.method,
      parameters: gistRouter.parameters,
      parameterEncoding: gistRouter.parameterEncoding
    )
}
```

That's annoying!

Here's the suggestion:

1: add the following code  to TargetType
```swift
var parameterEncoding: Moya.ParameterEncoding { get }
```


2: 
```swift
public extension TargetType {
    var parameterEncoding: Moya.ParameterEncoding {
        return URLEncoding.default
    }
}
```

3: In the Moya+Defaults.swift file
```swift
public final class func defaultEndpointMapping(for target: Target) -> Endpoint<Target> {
    let url = target.baseURL.appendingPathComponent(target.path).absoluteString
    return Endpoint(url: url, sampleResponseClosure: { .networkResponse(200, target.sampleData) }, method: target.method, parameters: target.parameters, parameterEncoding: target.parameterEncoding)
}
```

With the above code implemented, I won't have to define endpointClosure if absolutely necessary. 8.0.0-beta.6  I have a question. I want to make sure I understand the purpose of `sampleData`. So, is this where examples of the JSON data you'd receive from the API go? If this is the case, I'm having an issue. The documentation for the API I'm using provides examples. I'm trying to use these examples, so I copied and pasted them and put the quotes around the text, but something with the quotes somewhere is messing up making Swift think it's a comment, I need to be able to put this into a string. Here is what's happening: 

![screenshot](http://i.imgur.com/1P8cI9W.png) 
### Some of it is being picked up as a string, and some of it as a comment. All I did was put quotes around it.  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/861?src=pr) is 75.25% (diff: 100%)


> No coverage report found for **master** at c1fb3fa.

> Powered by [Codecov](https://codecov.io?src=pr). Last update [c1fb3fa...07797f1](https://codecov.io/gh/Moya/Moya/compare/c1fb3fabdd3de99dc360517299fa7d8cbd215124...07797f1460e87d2df8afae80b2e52ca8af20db38?src=pr) <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="false">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 I think `SingleURLTarget` is useless. but the `TargetType` default extension is a good change. How about providing a way to customize target's url? I had implemented similarly in https://github.com/devxoul/MoyaSugar/pull/6 to send a request with URL path.

What we have to do is just adding a `defaultURL` to let users return the default urls when overriding `url` property. There's no need to create another protocols. It's similar to 'convention over configuration'.

```swift
enum MyTarget {
  case url(URL)

  var url: URL {
    switch self {
    case .url(let url):
      return url

    default:
      return self.defaultURL // we have to provide default url implementation
    }
  }
}
```
 You can already do this by using the baseUrl and path properties. Just set the baseUrl to be the URL and the path to be nothing for the URL case.  Since we're collecting opinions, I'll share mine.  This is not to say I feel strongly one way or the other about this, so just take this as me throwing another idea into the hat.

TL;DR: I think some defaults could be helpful (`method`, `parameters` in particular), but honestly I prefer the current more verbose style, because it leaves nothing up to the imagination.  i.e. for a new developer, that had no experience with Moya, looking at the `TargetType` implementation, having everything explicit is great.  We're really just talking about removing `default: return .get` from the bottom of a switch statement.

-------------

It looks like `SingleURLTarget` would make it easy to send a request to a server/endpoint that is *not* enumerated in a `TargetType`.  I do think you have a valid argument about Moya being a network abstraction layer, but I actually *don't* see it going so far as to replace the functionality of Alamofire - and Alamofire is still a dependency of Moya, so we're already using it no matter what.  The first example you gave above could be accomplished with Alamofire easily, and is exactly what Alamofire is built for.

Real world example: In the Ello app we often get image URLs from the Ello API, and we use Alamofire to download those to prime the image cache.  Building a Moya `TargetType` for this purpose feels heavy handed - we're wrapping a wrapper at that point.  Then again "reaching through" Moya to use Alamofire is, I think, what people are trying to avoid.  To me, it's the right tool for the job.  I see Moya as an *API Abstraction* layer.  We hope, in the future, to pull out the `ElloAPI` Moya code, so that if developers want to access our API they can easily do so using Moya.  Or, if nothing else, it provides a concise programmatic reference to our API!

If anyone here is using Moya to abstract an API *but also* wants to use it for *all* network requests, then I think you have a different view of what Moya is designed for than I do, and so we'll certainly disagree on this feature/direction.

The thing that I'm most concerned on is the default `sampleData`.  I think that having a default value for this would make it *way too easy* to skip this feature (and it's already easy enough).  Since support for testing is so high on the list of Moya's original features, it pains me to push it any further down the priority list. I think you make a good point with the `SimpleApi` example.  You're right, it's safe to assume that the requests would be sent with no parameters via a GET request.  I thought I said as much in my first comment - that having those defaults makes sense to me, *even though* I prefer the verbosity.  Maybe my wording was unclear, but that's what I was going for.

I think it's glib to argue that *any* use of Alamofire, or some other network/request framework than Moya, is some egregious misuse of the Moya paradigm.  Abstractions are always leaky, and the use cases you are touting (I'm referring specifically to the `SingleURLTarget` idea) are exactly where Moya leaks.  You're proposing that we expand Moya's surface area to cover these requests, and I'm arguing against it.  But it wouldn't burn my house down if we added this feature.

As for the sampleData, it's a concern, but I'm not planting my flag here.  I don't care one way or the other if people use Moya or not, but you can't force good habits, I certainly agree with you there.  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/860?src=pr) is 83.27% (diff: 100%)
> Merging [#860](https://codecov.io/gh/Moya/Moya/pull/860?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #860   diff @@
==========================================
  Files            34         34          
  Lines          2769       2769          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2306       2306          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [967d169...a80f945](https://codecov.io/gh/Moya/Moya/compare/967d169f52f7a3f8e75991d54c257af82528c98f...a80f945292f73724ab6f0cb306a92b02579af5fc?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/859?src=pr) is 83.36% (diff: 100%)
> Merging [#859](https://codecov.io/gh/Moya/Moya/pull/859?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.08%**

```diff
@@             master       #859   diff @@
==========================================
  Files            34         34          
  Lines          2769       2783    +14   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits           2306       2320    +14   
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [967d169...f7b7300](https://codecov.io/gh/Moya/Moya/compare/967d169f52f7a3f8e75991d54c257af82528c98f...f7b73005820daf773466e59aaf8fb6727bcaecf5?src=pr) 
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Moya+Internal.swift | 111 | Prefer `-> Void` over `-> ()`. 
Moya+Internal.swift | 210 | Prefer `-> Void` over `-> ()`. 
Moya.swift | 5 | Prefer `-> Void` over `-> ()`. 
Moya.swift | 96 | Prefer `-> Void` over `-> ()`. 
NetworkActivityPlugin.swift | 12 | Prefer `-> Void` over `-> ()`. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  I've been trying to find out how to reload my uiviewcontroller similar to how tableviewcontroller/collectionviewcontroller requires me to reload the view after the rxmoya request finishes and sets the array of object back into an optional var. 

```swift
var myArray: ArrayMappable?

func setupRx(){
// provider.request ..... 
// self.myArray = object_of_subscribed
// self.tableview.reloaddata() OR self.collectionview.reloaddata()
}

viewdidload{
setupRx()
}

```

But on a normal uiviewcontroller, what would be that similar statement? Thanks!   
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Moya+Internal.swift | 111 | Prefer `-> Void` over `-> ()`. 
Moya+Internal.swift | 210 | Prefer `-> Void` over `-> ()`. 
Moya.swift | 5 | Prefer `-> Void` over `-> ()`. 
Moya.swift | 96 | Prefer `-> Void` over `-> ()`. 
NetworkActivityPlugin.swift | 12 | Prefer `-> Void` over `-> ()`. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/856?src=pr) is 83.27% (diff: 100%)
> Merging [#856](https://codecov.io/gh/Moya/Moya/pull/856?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #856   diff @@
==========================================
  Files            34         34          
  Lines          2769       2769          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2306       2306          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [967d169...faa5ff7](https://codecov.io/gh/Moya/Moya/compare/967d169f52f7a3f8e75991d54c257af82528c98f...faa5ff7cbd935cf8c4a404158efce308e9a58a45?src=pr)  Right now Moya url-encoding commas at %2C.
  Moya: 8.0.0-beta.5
Swift: 3.0
Xcode: 8.1

Hi, everyone

I am using the endpointClosure as follows for my GET requests, but I am getting a 401 response.

```swift
let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
        let defaultEndpoint = MoyaProvider<MyTarget>.defaultEndpointMapping(target)
        switch target{
        case .event:
        return defaultEndpoint.adding(newHTTPHeaderFields: ["Authorization": "Token token=\(access_token)"])
        default:
            return defaultEndpoint
        }
    }
```

When using the DHC Restless extension I add the header like this and works:
![screen shot 2016-12-21 at 9 46 46 pm](https://cloud.githubusercontent.com/assets/291768/21411397/01aa5258-c7c7-11e6-9292-76b487ab514c.png)

Can someone say what I am doing wrong or a workaround?

My Target:
```swift

enum ServiceAPI{
    case event(dateID: Int)
}

extension ServiceAPI: TargetType{
    var baseURL: URL {return URL(string: "http://myapi.com/api")!}
    
    var path: String{
        switch self{
        case .event(let dateID):
            return "/dates/\(dateID)"
        }
    }
    
     var method: Moya.Method{
        switch self{
        case .event:
                return .get
        }
    }
    
     var parameters: [String : Any]?{
        switch self{            
        case .event:
            return nil
        }
    }
    
     var task: Task {
        switch self {
        default:
            return .request
        }
    }
    
     var sampleData: Data {
        return "Hi".utf8Encoded
    }
}

private extension String {
      
    var utf8Encoded: Data {
        return self.data(using: .utf8)!
    }
}
```



Really thanks! 
 So I've found a workaround for this issue. I added an empty string after the authorization parameter and it worked!

```swift
let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
        let defaultEndpoint = MoyaProvider<MyTarget>.defaultEndpointMapping(target)
        switch target{
        case .event:
        return defaultEndpoint.adding(newHTTPHeaderFields: ["authorization ": "Token token=\(access_token)"])
        default:
            return defaultEndpoint
        }
    }
```

If there is a better way to do it let me know!
Thanks. The workaround that I posted before is actually working. I contacted the API's developer and said about this issue but he told me that it's working normally on Postman and on the Android client so I don't know what exacly caused it. You can close the issue and thanks! I've encountered this issue using AccessTokenAuthorizable, by removing it and using endpointClosure with "Authorization " string instead of "Authorization" it worked  Hi 

Need help in writing test cases for my project which uses `RxMoyaProvider` and Object mapper. Currently the calls to the n/w or using stub behaviour works fine in my code. However when I tried to do unit test cases test cases are failing and even there is no call to endpoint closure. This I obesrved with debug statement in endpoint closure. 
Below is the code snippet for the test case

```swift
// initialises the oauthclient which holds variable of moyaProvider and is initialized with stub behavier
 let  ccApiOAuthClient = CCApiOAuthClient(apiKey: CC_CLIENT_API_KEY, apiSecreteToken: CC_CLIENT_SECRET_TOKEN, stubCloser: MoyaProvider.immediatelyStub, response: (200, CCStubbedResponse.stubbedResponseFromJSON(filename: "authResponse")))
        

        let expect = expectation(description: "subscribeNext called")
        
        
// rx_getAuthToken is the function defined in the oAthClient which in turn send the request
        
              _ = ccApiOAuthClient.rx_getAuthToken(username: "XYZ", password: "XYZ")
            .observeOn(MainScheduler.instance)
            .do(onNext: { oAuth2ResponseObject in
                print(oAuth2ResponseObject)
                XCTAssert(true)
               // expect.fulfill()
            })
        
        waitForExpectations(timeout: 2) { error in
            if let error = error {
                XCTFail("waitForExpectationsWithTimeout errored: \(error)")
            }
        }
```
Do next is never executed. Advice me .
Thanks in Advance
Shivayogi Can some one help me on how to test without Nimble?
 @scottrhoyt 
Thank you for the reply. I have solved the issue myself. It was a mistake on using do operator. After replacing with subscribe it is working fine.   @BasThomas Oh I must have missed that. Yup that would be best I think.  Looking for pagination documentation. Was wondering if there was an example of how to use moya when doing some sort of feed pagination. Thanks!  @BasThomas Thanks for the pointer!

Is there a proper way to use collection view / table view with moya? 

I've been trying to map my provider.request. I'm firing my request inside viewDidLoad then mapping  and subscribing to object and setting it back into var feedObjects: [FeedObject] via self.feedObject

```swift

...viewDidLoad

provider.request(.myRequest)
.map...
.subscribe{ (event) in
switch event{
case .next(let object):
    self.feedObjects = let object.feeds
}
case .error(let error):
    print("\(error.localizedDescription...)")
default
    break // <<< It keeps breaking out
}


...numberOfItemsInSection

return self.feedObjects.count // <<< Always finds nil... even though the request works...

``` @AndrewSB Thanks for the pointer, but I'm confused as to why my numberOfItemsInSection is reading nil when it is mapped correctly.... Or does it mean that when I use RxSwift I'm not able to use the standard collectionview function/libraries?   version : 8.0.0-beta.5
swift 3.0

In common way I used the `soapMessage` which is a `String` with XML tags, create the data from it and pass into `request.httpBody` like that: 
```swift
var request = URLRequest(url: url)
request.addValue("text/xml; charset=utf-8", forHTTPHeaderField: "Content-Type")
request.addValue(soapMessage, forHTTPHeaderField: "Content-Length")
request.httpMethod = httpMethod
request.httpBody = soapMessage.data(using: .utf8, allowLossyConversion: false)

URLSession.shared.dataTask(with: request) {
    [weak self] (data, response, error) in
    if error == nil {
        var result: String?
        if let data = data {
            result = String(data: data, encoding: .utf8)
        }
        completion(result)
    } else {
        self?.log.error(error!.localizedDescription)
        completion(nil)
    }
}.resume()
```

If I want to use the `Moya` and `TargetType` the `parameters` is a `Dictionary` type and a `sampleData` is not called after doing this:

```swift
let provider = MoyaProvider<Endpoint>()

provider.request(.authenticateManager(login: "login", password: "123123")) {
  result in
  print(result)
}
```

My `Endpoint`  class:

```swift
enum Endpoint {
    case login(login: String, password: String)
}

extension Endpoint: TargetType {

    var task: Task {
        return .request
    }
    var validate: Bool {
        return false
    }

    var baseURL: URL {
        var rl : URL;
        return URL(string: "https://someurl.com")!
    }

    var method: Moya.Method {
        return .post
    }

    var path: String {
        return "/somepath.asmx"
    }

    var parameters: [String: Any]? {
        return nil
    }

    var sampleData: Data {
        switch self {
        case .login(let login, let password):
            return SoapMessageCreator()
            .login(userName: login, password: password).data(using: .utf8)!
        }
    }
}
```

**So my question is where should I put the `Data` from my soapMessage(with XML tags) `String` ? Or where can I set the `httpBody` ?**

Thanks!
 Ok, thanks for that complete answer!   How to handle errors after filterSuccessfulStatusCodes?

```swift

provider.request(.token(_,_))
.filterSuccessfulStatusCodes()
.mapObject(type: MyObjectMap.self)
.subscribe(onNext:{ object in

   // do something with mapped object 

})
```

what if my whole request fails? How can I handle the request and log the error? Thanks!  Use `.subscribe(onError: { error in ... })`. But it's not a good solution. Once the observable receives an error it unsubscribes. @leoneparise so when it unsubscribes, i handle the error out of the chain? 

@jonlambert I'm looking for: when it fails during filtersuccessfulstatus code it would stop and error out and stop mapping continuing the chain.   ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/847?src=pr) is 83.27% (diff: 100%)
> Merging [#847](https://codecov.io/gh/Moya/Moya/pull/847?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #847   diff @@
==========================================
  Files            34         34          
  Lines          2769       2769          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2306       2306          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [3fdc051...61e62a0](https://codecov.io/gh/Moya/Moya/compare/3fdc0515b211b54c241a4995618919bef9290a8c...61e62a0e3bbac516e9f06d5e79729e7c1ef741a7?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/846?src=pr) is 83.27% (diff: 100%)
> Merging [#846](https://codecov.io/gh/Moya/Moya/pull/846?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #846   diff @@
==========================================
  Files            34         34          
  Lines          2769       2769          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2306       2306          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [3fdc051...6ff66c5](https://codecov.io/gh/Moya/Moya/compare/3fdc0515b211b54c241a4995618919bef9290a8c...6ff66c556175716c29af09d54df2586e804d136d?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/845?src=pr) is 83.27% (diff: 100%)
> Merging [#845](https://codecov.io/gh/Moya/Moya/pull/845?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #845   diff @@
==========================================
  Files            34         34          
  Lines          2769       2769          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2306       2306          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [3fdc051...b6a7392](https://codecov.io/gh/Moya/Moya/compare/3fdc0515b211b54c241a4995618919bef9290a8c...b6a73924af09ef40f72d17279d9e777f0e2344fb?src=pr)  @jonlambert I had similar issue. tried curl command with same result.

there's been 2 issues:

1. adding -d {} to the curl command because of empty dictionary in the parameters rather than nil which makes the request post instead of get
2. adding -H "Accept-Encoding: gzip;q=1.0, compress;q=0.5" in the headers

I changed the code that @justinmakaila provided a little bit and it worked for me:

```swift
        let endpointClosure = { (target: GitHub) -> Endpoint<GitHub> in
            let defaultEndpoint = MoyaProvider.defaultEndpointMapping(for: target)
            return defaultEndpoint.adding(newHTTPHeaderFields: ["Accept-Encoding": "application/json"])
        }
        provider = RxMoyaProvider<GitHub>(
                endpointClosure:  endpointClosure,
                requestClosure: MoyaProvider.defaultRequestMapping,
                stubClosure: MoyaProvider.neverStub,
                manager: RxMoyaProvider<GitHub>.defaultAlamofireManager(),
                plugins: [NetworkLoggerPlugin(cURL: true)],
                trackInflights: true
        )

```

Also if your request is get then make sure to return nil for the parameters like this:
```swift
public var parameters: [String : Any]? { return nil }
```
obviously you can add switch case for different entries  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/843?src=pr) is 83.27% (diff: 100%)
> Merging [#843](https://codecov.io/gh/Moya/Moya/pull/843?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #843   diff @@
==========================================
  Files            34         34          
  Lines          2769       2769          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2306       2306          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [3fdc051...1937e05](https://codecov.io/gh/Moya/Moya/compare/3fdc0515b211b54c241a4995618919bef9290a8c...1937e05ab207d37631cf6b4ddf6408848b0b56f2?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/842?src=pr) is 83.27% (diff: 100%)
> Merging [#842](https://codecov.io/gh/Moya/Moya/pull/842?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #842   diff @@
==========================================
  Files            34         34          
  Lines          2769       2769          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2306       2306          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [3fdc051...9a82f70](https://codecov.io/gh/Moya/Moya/compare/3fdc0515b211b54c241a4995618919bef9290a8c...9a82f70bec609570d8b5dfa954fbf6f650ba46b5?src=pr) 
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Moya+Internal.swift | 111 | Prefer `-> Void` over `-> ()`. 
Moya+Internal.swift | 210 | Prefer `-> Void` over `-> ()`. 
Moya.swift | 5 | Prefer `-> Void` over `-> ()`. 
Moya.swift | 96 | Prefer `-> Void` over `-> ()`. 
NetworkActivityPlugin.swift | 12 | Prefer `-> Void` over `-> ()`. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/841?src=pr) is 83.36% (diff: 100%)
> Merging [#841](https://codecov.io/gh/Moya/Moya/pull/841?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #841   diff @@
==========================================
  Files            34         34          
  Lines          2783       2783          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2320       2320          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [f90a124...2ef4ee8](https://codecov.io/gh/Moya/Moya/compare/f90a124428a02c0c0f66cd1d993d951731769853...2ef4ee86226b8c873bf262f893955ee19c114fa4?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/840?src=pr) is 83.27% (diff: 100%)
> Merging [#840](https://codecov.io/gh/Moya/Moya/pull/840?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.01%**

```diff
@@             master       #840   diff @@
==========================================
  Files            34         34          
  Lines          2771       2769     -2   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits           2308       2306     -2   
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [67b02ae...19fadbc](https://codecov.io/gh/Moya/Moya/compare/67b02ae7f608711ca2d00c08fc6706951085c6af...19fadbcf1f4331bb1d7590ef76e374f633607dbd?src=pr)  ËØ∑ÈóÆÂ¶Ç‰ΩïÂú®ÊéßÂà∂Âô®deinitÊó∂ÂèñÊ∂à ÂΩìÂâçÊéßÂà∂Âô®ÁöÑÊâÄÊúâËØ∑Ê±Ç ÂèëÁé∞Âú®Á¶ªÂºÄÊéßÂà∂Âô®‰πãÂêé Êï∞ÊçÆÊâçËøîÂõûÔºåËøôÊó∂ self = nil ÊâÄÊúâÊÉ≥ÈóÆÈóÆdeinit ÊòØÂê¶ÊúâÂèñÊ∂àÁöÑÊñπÊ≥ïÔºü How do I cancel the current controller in controller deinit all requests
 Áî®‰∫ÜRXÁöÑËØù ‰∏çÁî®ÁÆ° no problem, can close this question @BasThomas  @xiangyu-sun  what do you mean please?Can you say more details? how to use it when i pop viewcontroller  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/838?src=pr) is 83.29% (diff: 100%)
> Merging [#838](https://codecov.io/gh/Moya/Moya/pull/838?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #838   diff @@
==========================================
  Files            34         34          
  Lines          2771       2771          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2308       2308          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [67b02ae...8c7bed4](https://codecov.io/gh/Moya/Moya/compare/67b02ae7f608711ca2d00c08fc6706951085c6af...8c7bed4737439dedcdc65d7a4e357c97d572010d?src=pr)  <!-- Please wrap code blocks in backticks, like so:
```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
Hi,

I have a project where URL for a server is not known during compile time, only first server in chain is known, other servers URLs are given as a response from the first one. Also every server has its alternative URL in case of failure, so they must be switched on demand.

Here is how I tried to solve this, my provider:
```swift    
private lazy var provider: RxMoyaProvider<DataRequests> = {
        return RxMoyaProvider<DataRequests>(endpointClosure: {(target: DataRequests) -> Endpoint<DataRequests> in
            let server = URL(string: self.currentServer == .primary ? self.server.primary : self.server.secondary)!
            let url = server.appendingPathComponent(target.path).absoluteString
            return Endpoint(url: url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
        }, manager: self.connectionManager)
    }()
```
and here is my request:
```swift
    public func dataModel() -> Observable<VeraDataModel>{
        return requestDataModel()
            .catchError{_ in
                self.currentServer = self.currentServer.changeActiveServer()    //change server and try again
                return self.requestDataModel()
        }
    }
    
    private func requestDataModel() -> Observable<VeraDataModel>{
        return self.provider
            .request(DataRequests.dataModel)
            .debug()
            .mapObject(VeraDataModel.self)
    }
``` 
So first requirement is solved by creating a new class instance (containing code I mentioned) every time I got an information about new server. 

The second one is more tricky. As far sa I understand Rx (and its async nature) since this line:
```swift
self.currentServer = self.currentServer.changeActiveServer()    //change server and try again
```
is introducing side effects it will be a problem when multiple dataModel() calls will occur (race condition)

Does anybody have simmilar problems?  I'm trying to add Moya into my project but it's fail with error below. I think there is a problem from Moya Demo project.

> ...
> *** Building scheme "Moya" in Demo.xcworkspace
> ** CLEAN FAILED **
> The following build commands failed:
> 	Check dependencies
> (1 failure)
> ** BUILD FAILED **
> The following build commands failed:
> 	Check dependencies
> (1 failure)
> A shell task (/usr/bin/xcrun xcodebuild -workspace ~/Carthage/Checkouts/Moya/Demo/Demo.xcworkspace -scheme Moya -configuration Release -sdk iphoneos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:

I'm using Xcode 8.0, Carthage 0.18.1

Here is my Cartfile's configuration:
> github "Alamofire/Alamofire"
> github "SwiftyJSON/SwiftyJSON"
> github "realm/realm-cocoa"
> github "Hearst-DD/ObjectMapper"
> github "Moya/Moya"

Using command line:
> carthage build --platform iOS
> carthage update --platform iOS

Thanks! Sure! Here is it.
> github "Alamofire/Alamofire" "4.2.0"
> github "Moya/Moya" "3.0.0"
> github "Hearst-DD/ObjectMapper" "2.2.1"
> github "SwiftyJSON/SwiftyJSON" "3.1.3"
> github "realm/realm-cocoa" "v2.1.1"


 **UPDATE: 12/12**
I remove others framework and keep Moya only:
> github "Moya/Moya"

After running Carthage turns out another error:

> $ carthage update --platform iOS
> *** Fetching Moya
> *** Fetching RxSwift
> *** Fetching Alamofire
> *** Fetching Result
> *** Checking out Alamofire at "3.5.1"
> *** Checking out Result at "2.1.3"
> *** Checking out ReactiveCocoa at "v4.2.2"
> *** Checking out RxSwift at "2.6.1"
> *** Checking out Moya at "7.0.4"
> *** xcodebuild output can be found in /var/folders/1n/81b947wj2_12d0s_xnps_ptw0000gn/T/carthage-xcodebuild.hgN728.log
> *** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
> A shell task (/usr/bin/xcrun xcodebuild -project /Users/nah/Data/Projects/My/Carthage/Checkouts/Moya/Demo/Pods/Pods.xcodeproj CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES -list) failed with exit code 74:
> xcodebuild: error: Unable to read project 'Pods.xcodeproj' from folder '/Users/nah/Data/Projects/My/Carthage/Checkouts/Moya/Demo/Pods'.
> 	Reason: Project /Users/nah/Data/Projects/My/Carthage/Checkouts/Moya/Demo/Pods/Pods.xcodeproj cannot be opened because it is missing its project.pbxproj file.
 It doesn't work. Let me will try other way to use Moya first. Hope this bug will be fixed soon. :D 

> $ carthage update --platform iOS
> *** Fetching Moya
> *** Fetching RxSwift
> *** Fetching Alamofire
> *** Fetching Result
> *** Checking out Alamofire at "4.2.0"
> *** Checking out Result at "3.1.0"
> *** Checking out ReactiveSwift at "1.0.0-alpha.3"
> *** Downloading RxSwift.framework binary at "Graham"
> *** Checking out Moya at "8.0.0-beta.5"
> *** xcodebuild output can be found in /var/folders/1n/81b947wj2_12d0s_xnps_ptw0000gn/T/carthage-xcodebuild.MApVEr.log
> *** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
> A shell task (/usr/bin/xcrun xcodebuild -project /Users/nah/Data/Projects/My/Carthage/Checkouts/Moya/Demo/Pods/Pods.xcodeproj CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES -list) failed with exit code 74:
> xcodebuild: error: Unable to read project 'Pods.xcodeproj' from folder '/Users/nah/Data/Projects/My/Carthage/Checkouts/Moya/Demo/Pods'.
> 	Reason: Project /Users/nah/Data/Projects/My/Carthage/Checkouts/Moya/Demo/Pods/Pods.xcodeproj cannot be opened because it is missing its project.pbxproj file.

Cartfile
> github "Moya/Moya" >= 8.0

Cartfile.resolved
> github "Alamofire/Alamofire" "4.2.0"
> github "antitypical/Result" "3.1.0"
> github "ReactiveX/RxSwift" "3.0.1"
> github "ReactiveCocoa/ReactiveSwift" "1.0.0-alpha.3"
> github "Moya/Moya" "8.0.0-beta.5" One more question, why do we need to import Demo project into Carthage configuration? As I see the error log, XCode can not build it while `Pod.xcodeproj` is missing. Still get the problem. I remove cache by this command line
$ rm -rf ~/Library/Caches/org.carthage.CarthageKit
 @AndrewSB I'm using `XCode 8.0`, `Carthage 0.18.1`, `Swift 3.0`.   AndrewSB: After doing few steps, the problem is gone now. Hope this could help other users. :)
1. Update XCode to 8.2 (8C38)
2. Remove Carthage cache:  `$ rm -rf ~/Library/Caches/org.carthage.CarthageKit`
3. From project folder, remove `Carthage/Build` and `Carthage/Checkouts`
4. Add `github "Moya/Moya" >= 8.0`
5. Rebuild carthage: `$ carthage update --platform iOS`

Cartfile:
> github "Moya/Moya" >= 8.0
> github "Alamofire/Alamofire"
> github "SwiftyJSON/SwiftyJSON"
> github "realm/realm-cocoa"
> github "Hearst-DD/ObjectMapper"

Console log: 

> *** Fetching ObjectMapper
> *** Fetching realm-cocoa
> *** Fetching SwiftyJSON
> *** Fetching Alamofire
> *** Fetching Moya
> *** Fetching RxSwift
> *** Fetching Result
> *** Checking out Alamofire at "4.2.0"
> *** Checking out ObjectMapper at "2.2.2"
> *** Downloading realm-cocoa.framework binary at "v2.1.1"
> *** Checking out Result at "3.1.0"
> *** Checking out ReactiveSwift at "1.0.0-alpha.3"
> *** Downloading RxSwift.framework binary at "Graham"
> *** Checking out Moya at "8.0.0-beta.5"
> *** Downloading SwiftyJSON.framework binary at "3.1.3"
> *** xcodebuild output can be found in /var/folders/1n/81b947wj2_12d0s_xnps_ptw0000gn/T/carthage-xcodebuild.BfYI4k.log
> *** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
> *** Building scheme "ObjectMapper-iOS" in ObjectMapper.xcworkspace
> *** Building scheme "Result-iOS" in Result.xcodeproj
> *** Building scheme "ReactiveSwift-iOS" in ReactiveSwift.xcworkspace
> --- xcodebuild: WARNING: Unable to open project file '/Users/nah/Data/Projects/Aries/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/nah/Data/Projects/Aries/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
> --- xcodebuild: WARNING: Unable to open project file '/Users/nah/Data/Projects/Aries/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.playground' in workspace '/Users/nah/Data/Projects/Aries/Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcworkspace'.
> *** Building scheme "ReactiveMoya iOS" in Moya.xcodeproj
> *** Building scheme "Moya iOS" in Moya.xcodeproj
> *** Building scheme "RxMoya iOS" in Moya.xcodeproj  I hava a question , how to design a API can use for offset page, I need a variable to store current page number ,but enum cannot define stories variable, Anyone has idea? @ashfurrow But I must change page number value every time when i used it, Any better idea? May be use struct to do this ,I'll try @xnxin why do you want to store page number in networking layer? This property is more related to data model and can be different in a number of viewcontrollers that all use the same API endpoint. OKÔºånow I solve this problem.
first, I define a offsetModel mapping from server data,
```swift
final class OffsetModel<T: Mappable> {
    var total: Int = 0
    var pageSize: Int = 0
    var pageNum: Int = 0
    var startRow: Int = 0
    var endRow: Int = 0
    var pages: Int = 0
    
    var elements: [T] = [T]()
}
```
and I define a endPoint to add offset parameters,
like this 
```swift
let pageSize = 20

extension XXXProvider {
    
    static func offsetEndpointClosure(_ target: Target, page: Int, pageSize: Int = pageSize) -> Endpoint<Target> {
        
        let url = target.baseURL.appendingPathComponent(target.path).absoluteString
        var params:[String: Any] = target.parameters ?? [:]
        params["startPage"] = page
        params["pageNum"] = pageSize
        
        return Endpoint(url: url,
                        sampleResponseClosure: { .networkResponse(200, target.sampleData) },
                        method:target.method,
                        parameters:params).adding(newHTTPHeaderFields: target.headers)
    }
}
```
finally, define a class to accept a target and modelType to automatic mapping,
like this
```swift
class PaginationViewModel<Target, T> where Target: XXXTargetType, T: Mappable {
    
    //MARK: -
    //MARK: outlet && variables
    let refreshTrigger = PublishSubject<Void>()
    let loadmoreTrigger = PublishSubject<Void>()
    
    let hasMore = Variable<Bool>(false)
    let loading = Variable<Bool>(false)
    let elements = Variable<[T]>([])
    let currentPage = Variable<Int?>(nil)
    let offsetModel = Variable<OffsetModel<T>?>(nil)
    
    let error = PublishSubject<Swift.Error>()
    
    fileprivate let disposeBag = DisposeBag()
    //MARK: -
    //MARK: life cycle
    
    init(_ target: Target) {
        
        let refreshProvider = loading.asObservable()
            .sample(refreshTrigger)
            .flatMapLatest { loading
                -> Observable<XXXProvider<Target>> in
                
                guard loading == false else {
                    return Observable.empty()
                }
                
                let provider = XXXProvider<Target>(endpointClosure: { target in
                    return XXXProvider<Target>.offsetEndpointClosure(target, page: 1)
                })
                return Observable.just(provider)
        }
        
        let loadmoreProvider = Observable
            .combineLatest(loading.asObservable(),
                           hasMore.asObservable(),
                           currentPage.asObservable()) { $0 }
            .sample(loadmoreTrigger)
            .flatMapLatest { (loading, hasMore, currentPage)
                -> Observable<XXXProvider<Target>> in

                if let page = currentPage, !loading && hasMore {
                    
                    let provider = XXXProvider<Target>(endpointClosure: { target in
                        return XXXProvider<Target>.offsetEndpointClosure(target, page: page)
                    })
                    return Observable.just(provider)
                }
                return Observable.empty()
        }
        
        let provider = Observable
            .of(refreshProvider, loadmoreProvider)
            .merge()
            .shareReplay(1)
        
        let response = provider
            .flatMapLatest { provider -> Observable<Response> in
                
                
                return provider.request(target)
                    .do(onError: { [weak self] error in
                        self?.error.onNext(error)
                    }).catchError { _ in Observable.empty() }
            }.shareReplay(1)
        
        Observable
            .of(
                provider.map { _ in true },
                response.map { _ in false },
                error.map { _ in false }
            )
            .merge()
            .bindTo(loading)
            .addDisposableTo(disposeBag)
        
        Observable
            .combineLatest(provider, response, elements.asObservable())
            { endPoint, response, elements -> [T] in
                
                do {
                    let ofModel:OffsetModel<T> = try response.mapObject()
                    return ofModel.pageNum == 1 ? ofModel.elements : elements + ofModel.elements
                } catch {
                    throw APPError.jsonDecoded
                }
            }
            .debug()
            .sample(response)
            .bindTo(elements)
            .addDisposableTo(disposeBag)
        
        response
            .withLatestFrom(provider) {
                do {
                    let ofModel:OffsetModel<T> = try $0.0.mapObject()
                    return ofModel.pageNum
                } catch {
                    throw APPError.jsonDecoded
                }
            }
            .debug()
            .bindTo(currentPage)
            .addDisposableTo(disposeBag)
        
        response
            .map {
                do {
                    return try $0.mapObject()
                } catch {
                    throw APPError.jsonDecoded
                }
            }.bindTo(offsetModel)
            .addDisposableTo(disposeBag)
        
        response
            .map {
                do {
                    let of:OffsetModel<T> = try $0.mapObject()
                    return of.pageNum * of.pageSize < of.total
                } catch {
                    throw APPError.jsonDecoded
                }
            }
            .bindTo(hasMore)
            .addDisposableTo(disposeBag)
    }
}
```

usge:
```swift
var viewModel: PaginationViewModel<XXXAPI, CommentModel> = PaginationViewModel(.comments(merchantID: "54"))
```
bind for view
```swift
     rx.sentMessage(#selector(UIViewController.viewWillAppear(_:)))
            .map { _ in () }
            .bindTo(viewModel.refreshTrigger)
            .addDisposableTo(disposeBag)

        
        viewModel.elements.asDriver()
            .debug()
            .drive(tableView.rx.items(cellIdentifier: "CommentViewCell")){ _, model, cell in
                guard let cell = cell as? CommentViewCell else {
                    return
                }
                
                cell.nameLabel.text = model.name
                cell.timeStampLabel.text = model.createTime?.string(format: "yyyy-MM-dd")
                cell.commentLabel.text = model.content
                cell.avatarImageView.image = #imageLiteral(resourceName: "logo")
                cell.startView.rating = NSDecimalNumber(decimal: model.grage).floatValue
                
                guard let avatarURL = model.avatarImageURL else {
                    return
                }
                cell.avatarImageView.sd_setImage(with: avatarURL, placeholderImage: #imageLiteral(resourceName: "logo"))
            }
            .addDisposableTo(disposeBag)
        
        viewModel.loading.asDriver()
            .drive(activityIndicator.rx.isAnimating)
            .addDisposableTo(disposeBag)
```
If there has any better idea ,plz tell me, thanks.  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">PR is classed as Work in Progress</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/833?src=pr) is 83.29% (diff: 100%)
> Merging [#833](https://codecov.io/gh/Moya/Moya/pull/833?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #833   diff @@
==========================================
  Files            34         34          
  Lines          2771       2771          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2308       2308          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [8b1dc46...0ba42ad](https://codecov.io/gh/Moya/Moya/compare/8b1dc4625ac6c2f8de45a0c73f63e3181a6f7b8a...0ba42ad6dd0f5b7acb66947b00a8e80d69f37a33?src=pr) Awesome!   ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/832?src=pr) is 83.29% (diff: 100%)
> Merging [#832](https://codecov.io/gh/Moya/Moya/pull/832?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #832   diff @@
==========================================
  Files            34         34          
  Lines          2771       2771          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2308       2308          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [8b1dc46...6d886cb](https://codecov.io/gh/Moya/Moya/compare/8b1dc4625ac6c2f8de45a0c73f63e3181a6f7b8a...6d886cb0e3abbc037a0642ac7c8c69ee46881670?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/831?src=pr) is 83.29% (diff: 100%)
> Merging [#831](https://codecov.io/gh/Moya/Moya/pull/831?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #831   diff @@
==========================================
  Files            34         34          
  Lines          2771       2771          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2308       2308          
  Misses          463        463          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [8b1dc46...2da7c37](https://codecov.io/gh/Moya/Moya/compare/8b1dc4625ac6c2f8de45a0c73f63e3181a6f7b8a...2da7c37ab932dffe8e38b79d5c74b000eb439763?src=pr)  Yes, I am interested in getting this added to Moya. Let me summarize the points.

Current implementation of `MoyaProvider` has a template variable `<Target>` at the class level. Because of this, one instance of `MoyaProvider` can work with only one type of target. 

Using `MultiTarget`, we have created a wrapper so that a single instance can be used for different inner `TargetType`s. This works when there are no associated types involved in enums.

In order to extend Moya's functionality, it is sometimes necessary to use associated types by extending the `TargetType` protocol. One use case is to abstract deserialization, so that MoyaProvider can return an `Observable<ModelType>`, where `ModelType` is the associatedtype. This has been discussed in https://github.com/Moya/Moya/issues/823#issuecomment-265458718.

The idea is to build a `MoyaProvider` variant which does not have any template variable at the class level, but instead at the `request` method level. 

```func request<T: TargetType>(request: T, completion: Moya.Completion)```

This would allow basic usage and also allow Moya consumers to add extensions like:

```func requestDecoded<T: DecodableTargetType>(request: T, completion: (_ result: Result<T.ResultType, Moya.Error>) -> ())```
or simply
```func requestDecoded<T: DecodableTargetType>(request: T) -> Observable<T.ResultType>```

I don't have access to reopen the issue. @AndrewSB Can you do this? Yes, I would love to implement this. Amending the docs is a good idea. I'll first update one of the examples doc assuming that this MoyaProvider exists. 

In the above example, `DecodableTargetType` extends `TargetType`.
```swift
protocol DecodableTargetType: Moya.TargetType {
    associatedType ResultType: SomeJSONDecodableProtocolConformance
}
```

Perhaps a specific example would help.
```swift
enum UserApi : DecodableTargetType {
    case get(id: Int)
    case update(id: Int, name: String)
    ...

    var baseURL: URL { ... }
    var path: String { switch self ... }
    var method: Moya.Method { ... }
    
    typealias ResultType = UserModel
}
```

To invoke the api
```swift
let user = provider.request(UserApi.get(id: 1)) 
// The type for user is Observable<UserModel>

let user: Observable<SomethingElse> = provider.request(UserApi.get(id: 1))
// This doesn't compile. Thus, you get a compile time check for ensuring the right type
```

Thus, the generic parameter `UserApi` is implicitly derived from the Api instance provided. The return type is also implicitly derived from the Api instance provided. The beauty of this is that the return type changes (implicitly) based on the argument that you pass to the function.

In case of `provider.request(.me).map(UserModel.init)`, this will fail at runtime if an incorrect model is passed.

I hope this makes it clear. The content for the updated doc would also be on these lines.  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/829?src=pr) is 83.27% (diff: 100%)


> No coverage report found for **master** at 8ed8920.

> Powered by [Codecov](https://codecov.io?src=pr). Last update [8ed8920...9f2e46f](https://codecov.io/gh/Moya/Moya/compare/8ed8920c4a1e5d1f294c38654189fb57243521bf...9f2e46f981e80a7b9677ca5b549f859c25485c23?src=pr)  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">No Changelog entries made</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues\n\n#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Moya.swift | 182 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 54 lines 
Moya.swift | 41 | Limit vertical whitespace to a single empty line. Currently 2. 
Moya.swift | 417 | Limit vertical whitespace to a single empty line. Currently 2. 
Moya.swift | 530 | File should contain 400 lines or less: currently contains 530 
Moya.swift | 530 | Files should have a single trailing newline. 
Moya.swift | 237 | Else and catch should be on the same line, one space after the previous declaration. 
Moya.swift | 402 | Else and catch should be on the same line, one space after the previous declaration. 
Moya.swift | 182 | Function should have complexity 10 or less: currently complexity equals 11 
Moya.swift | 149 | Shorthand syntactic sugar should be used, i.e. [Int] instead of Array<Int> 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/827?src=pr) is 83.27% (diff: 93.18%)
> Merging [#827](https://codecov.io/gh/Moya/Moya/pull/827?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.04%**

```diff
@@             master       #827   diff @@
==========================================
  Files            34         34          
  Lines          2782       2775     -7   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits           2318       2311     -7   
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [e55bcec...1c441c3](https://codecov.io/gh/Moya/Moya/compare/e55bcece7c3c0bcb37b4f09f95f595f274bf7a88...1c441c3322081bf321e8868d9c73d0df0208ea97?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/826?src=pr) is 83.27% (diff: 100%)
> Merging [#826](https://codecov.io/gh/Moya/Moya/pull/826?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #826   diff @@
==========================================
  Files            34         34          
  Lines          2775       2775          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2311       2311          
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [483cbd1...c263075](https://codecov.io/gh/Moya/Moya/compare/483cbd1b4312c73be1c8721e5ed53dcb0972f945...c263075238afdb0a5cbdac0115be3f30eec0e215?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/825?src=pr) is 83.27% (diff: 95.23%)
> Merging [#825](https://codecov.io/gh/Moya/Moya/pull/825?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #825   diff @@
==========================================
  Files            34         34          
  Lines          2775       2775          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2311       2311          
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [6637718...3b1ac3b](https://codecov.io/gh/Moya/Moya/compare/663771871d07de6fe0bc3e5c4c5348c347691242...3b1ac3b2a622fb2bf297a7fd00bf2e7ed6fc3dc8?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/824?src=pr) is 83.29% (diff: 90.32%)
> Merging [#824](https://codecov.io/gh/Moya/Moya/pull/824?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.01%**

```diff
@@             master       #824   diff @@
==========================================
  Files            34         34          
  Lines          2775       2771     -4   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits           2311       2308     -3   
+ Misses          464        463     -1   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [483cbd1...73ddbc8](https://codecov.io/gh/Moya/Moya/compare/483cbd1b4312c73be1c8721e5ed53dcb0972f945...73ddbc846e982a7b12503246216a27d4ca702304?src=pr)  Alamofire layer: Generic Input -> Network call -> Generic Output
> Generic = XML/Json or any format

With Moya, we are abstracting the serialization of request parameters. Thus, it looks like:
Api specific params -> Generic Input -> Network call -> Generic Output

Deserialization of output is still **outside Moya**. An example from Artsy's code:
```swift
// This belongs to AppViewController.swift
let auctionEndpoint: ArtsyAPI = ArtsyAPI.auctionInfo(auctionID: auctionID)

        return provider.request(auctionEndpoint)
            .filterSuccessfulStatusCodes()
            .mapJSON()
            .mapTo(object: Sale.self)
            .logError()
            .retry()
            .throttle(1, scheduler: MainScheduler.instance)
```

Thus, AppViewController is now aware that the request uses `JSON` & it is deciding the type `Sale` in which the `JSON` should be parsed into. 

Ideally, this logic should belong to the network abstraction layer i.e. inside Moya. 
So basically, I want `request(auctionEndpoint)` function to return an `Observable<Sale>`.

What would be a good way to achieve this? 
 Thanks a lot.

Perhaps deserialization is difficult to integrate because of the enum structure. It seems doable if we use protocols with associated types for Request & Response. 

For example:
```swift
protocol Api {
    associatedtype Result
    associatedtype Request

    static func parameters(request: Request) -> [String: Any]?
    static func parse(data: Data) -> Result?
}

extension Api {
    static func call(request: Request) -> Result? {
        let params = parameters(request: request)
        // Invoke api get result
        return parse(data: Data())
    }
}

extension Api where Result: ModelProtocol {
    internal static func parse(data: Data) -> Result? {
        return Result.init(data: data)
    }
}
```

With this, Api can be declared using a struct

```swift
struct AuctionInfo: Api {
    typealias Request = Int
    typealias Result = Auction
}
```

Are there any plans to add support for deserialization? Structs conforming to `TargetType`, should work in my case.

If I go ahead with this, will I need to create a different provider instance for every type of api call OR could there be a better approach?
 Thanks @AndrewSB, I will mostly go ahead with creating a Networking layer. 

However, I strongly feel that a network abstraction library is incomplete without any support for deserialization. We can take inspiration from other platforms. For example, [Retrofit](https://square.github.io/retrofit/) for Java/Android really makes networking seamless. Regarding dependency with JSON parsing, wouldn't it be possible to create a new `Parser` protocol in Moya for parsing `data` to any object? 
Consumers can then create these parsers using any JSON/XML parsing library. These parsers could be registered when creating `MoyaProvider`. This way, deserialization can be implemented without Moya having to depend on any JSON library.

`DecodableTargetType` approach is great. It will definitely hide the `JSON` format from API consumer. But user will still need to cast it to the correct model type, right?
```swift
enum MyApi: DecodableTargetType {
    ...
    func decode() -> Observable<SomeJSONDecodableProtocolConformance> {
        ...
    }
}

provider.request(.me).decode() // returns Observable<SomeJSONDecodableProtocolConformance>
        .mapTo(User.self)      // <- Can this be eliminated?
```
Am I missing something here? I think it cannot be eliminated without using `associatedType`. If we change `ModelType` to an `associatedType`, the decode function can return the desired `Observable<ModelType>`.

```swift
protocol DecodableTargetType: Moya.TargetType {
    associatedType ModelType: SomeJSONDecodableProtocolConformance
}

enum MyAPI: DecodableTargetType {
  ...
    typealias ModelType = String

    func decoded(response: Response) -> Observable<ModelType> { // This works
      // parse things and return the correct modelType
    }

  ...
}
```

However, this takes us back to the initial discussion with @scottrhoyt. One `DecodableTargetType` conformance can return only specific type of Model. We could go ahead by creating a struct for every network api.

But then, the next problem is that a different `MoyaProvider` instance is required for different api calls. This is undesirable as any setup (like custom endpoint closure, etc.) would be required for every api invocation. 

**Can we build a `MoyaProvider` variant which does not have a generic `<Target>` parameter?**

From what I understood, the `Target` generic parameter is used to have static checks in `request(target: Target)`. We should be able to move the class level generic parameter to the `request` function. This would allow using the same MoyaProvider for different types that conform to `TargetType`.

 @justinmakaila @AndrewSB Thank you for your inputs. I will be going ahead with creating a wrapper over MoyaProvider.  My ios deployment target is 9.0 for all targets and project.
I deleted derivedData, clean, clean build folder etc, but im getting this issue:
![captura de pantalla 2016-12-02 a las 11 59 35](https://cloud.githubusercontent.com/assets/1838117/20831749/d46e879a-b886-11e6-87c1-3754767583b8.png)

```ruby
source 'https://github.com/CocoaPods/Specs.git'
use_frameworks!
platform :ios, '9.0'

target 'App' do
    pod 'Alamofire', '4.0'
    pod 'TPKeyboardAvoiding'
    pod 'SVProgressHUD'
    pod 'ObjectMapper', '~> 2.1'
    pod 'Fabric'
    pod 'Toaster'
    pod 'Crashlytics'
    pod 'RESideMenu'
    pod 'RealmSwift'
    pod 'RxSwift'
    pod 'RxBlocking'
    pod 'RxCocoa'
    pod 'AsyncImageView'
    pod 'Moya', '8.0.0-beta.5'
    pod 'Moya/RxSwift'
    pod 'UICollectionViewLeftAlignedLayout'
    pod 'UIFloatLabelTextField'
    pod 'Firebase'
    pod 'Firebase/Messaging'
    pod 'OAuthSwift' , :git => 'https://github.com/OAuthSwift/OAuthSwift', :branch => 'master'
    pod 'KeychainAccess'
    pod 'SwrveSDK'
    pod 'NYTPhotoViewer'
    pod 'RxDataSources'
    
    target 'NextVisitTests' do
        pod 'Quick', git: 'https://github.com/Quick/Quick.git', branch: 'master'
        pod 'Nimble'
        pod 'RxBlocking'
        pod 'OHHTTPStubs' # Default subspecs, including support for NSURLSession & JSON etc
        pod 'OHHTTPStubs/Swift' # Adds the Swiftier API wrapper too
    end

   target 'AcceptanceTests' do
      pod 'Quick', git: 'https://github.com/Quick/Quick.git', branch: 'master'
      pod 'Nimble'
      pod 'KIF', '~> 3.0', :configurations => ['Debug']
   end
end

 post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['SWIFT_VERSION'] = '3.0'
        end
    end
  end
``` thx!   #716 fix downdload issue,but rx way still not fix.
`FileServices.swift`
```swift
import Foundation
import Moya

let endpointClosure = {
    (target: FileService) -> Endpoint<FileService> in
    let url = URL(string: target.path)?.absoluteString
    return Endpoint(URL: url!, sampleResponseClosure: { .networkResponse(200, target.sampleData) }, method: target.method, parameters: target.parameters)
}

private func JSONResponseDataFormatter(_ data: Data) -> Data {
    do {
        let dataAsJSON = try JSONSerialization.jsonObject(with: data)
        let prettyData =  try JSONSerialization.data(withJSONObject: dataAsJSON, options: .prettyPrinted)
        return prettyData
    } catch {
        return data // fallback to original data if it can't be serialized.
    }
}

let FileDownloadProvider = RxMoyaProvider<FileService>(endpointClosure: endpointClosure, plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])
//let FileDownloadProvider = MoyaProvider<FileService>(endpointClosure: endpointClosure, plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])

enum FileService {
    case download(url: String)
}

extension FileService:TargetType{

    var baseURL : URL{
            return URL(string:"http://no.use.but.cant.empty")!
    }
    
    
    var path:String{
        switch self {
        case .download(let url):
            return url
        }
        
    }

    var method: Moya.Method {
        switch self {
        case .download:
            return .get

        }

    }

    
    var parameters: [String:Any]?{
        switch self {
        case .download:
            return nil
        }
    }
    
    var sampleData:Data{
        switch self {
            default:
            return "default data".utf8EncodedData
        }
    }
    
    var task:Task{
        switch self {
        case .download:
            return .download(DownloadType.request(DefaultDownloadDestination))

        }
    }
    
}


private let DefaultDownloadDestination: DownloadDestination = { temporaryURL, response in
    
    let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
    let fileURL = documentsURL.appendingPathComponent(response.suggestedFilename!)
    return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
    
}

// MARK: - Helpers
private extension String {
    var urlEscapedString: String {
        return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
    }
    
    var utf8EncodedData: Data {
        return self.data(using: .utf8)!
    }
}

```

call code snappet
```swift
                play.rx.tap
                    .throttle(3, latest: false, scheduler: MainScheduler.instance)
                    .debug("debug", trimOutput:false)
                    .flatMap{ (Void) -> Observable<ProgressResponse> in
                        return FileDownloadProvider.requestWithProgress(.download(url: "https://raw.githubusercontent.com/Moya/Moya/master/web/logo_github.png"))
        
                    }
                    .subscribe{
                        resp in
                        print("resp \(resp)")
                    }.addDisposableTo(bag)
        
//        play.rx.tap
//            .throttle(3, latest: false, scheduler: MainScheduler.instance)
//            .debug("debug", trimOutput:false)
//            .subscribe {
//                resp in
//                    switch resp {
//                case .next:
//                FileDownloadProvider.request(.download(url: "https://raw.githubusercontent.com/Moya/Moya/master/web/logo_github.png"), queue: DispatchQueue.main, progress: { resp in
//                    print ("progress \(resp.progress)")
//                }, completion: { result in
//                    print(result)
//                })
//                default:
//                print(resp)
//                
//                }
//            }.addDisposableTo(bag)

``` @AndrewSB I'm a beginner from android, still  not very familiar with ios stuff  I know how. I've done it for other projects. It's fairly simple. There are couple things not really mentioned but this article covers mostly how to do this http://promisekit.org/news/2016/08/Multiplatform-Single-Scheme-Xcode-Projects/.  Ya sure I could do it. I was creating a script that would automatically do this but I haven't finished it. I could do it manually, it wouldn't take too long.  How would this work with bundleID collisions with say a watchOS extension. This more for frameworks than actual applications. It's not really useful for application targets  frameworks still have bundleID's though. 

Reason I am asking is because I do this already for other frameworks and had issues when we wanted to use the framework compiled in this way in an Application as well as a Watch extension bundled with that Application. It's more a question maybe we weren't loading/linking the framework correctly across watch/extension/app. I have no idea about watchOS stuff.  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/817?src=pr) is 83.05% (diff: 100%)
> Merging [#817](https://codecov.io/gh/Moya/Moya/pull/817?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #817   diff @@
==========================================
  Files            34         34          
  Lines          2738       2738          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2274       2274          
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [8288667...2a81b2a](https://codecov.io/gh/Moya/Moya/compare/8288667d2ef326d96bbcaaf04ea8538e146c2697...2a81b2ae6e3b8f6f1a58e8102f85e49e85d411bb?src=pr)  <!-- Please wrap code blocks in backticks, like so:  -->
Heres what i am using
```swift
open class LfArrayStringTransform : TransformType {
    public typealias Object = String
    public typealias JSON = [[String]]
    
    public init() {}
    
    open func transformFromJSON(_ value : Any?) -> String?{
    /* This Prints
Optional({
    email =     (
        "The email has already been taken."
    );
    "mobile_number" =     (
        "The mobile number has already been taken."
    );
})
*/   
 print(value)

        do{
            let jsonData = try JSONSerialization.data(withJSONObject: value, options: []) as? [AnyHashable : Any]
            print(jsonData) // this is nil
        }catch{
        }
/*Goes in there (obvious it was , silly me)*/
        if let someValue = value as? Any{
            
        }
        /* Not Going in Here */
        if let arrayValue = value as? [[String]]{
            return arrayValue.flatMap({ (value) -> String in
               return value.joined(separator: ", ")
            }).joined(separator: ", ")
        }
        return nil
    }
    
    open func transformToJSON(_ value: String?) -> [[String]]? {
        return nil
    }
}
```

I want to transform the json data that i am receiving myself. But the object that i am receiving or which is printed does not have a standard structure. 
Am I missing something here?

<!--
The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 Hey @ashfurrow do you mind helping me out on this? Nope, That I cannot parse it since it does not seem like json to me ```json
{
  "message": "422 Unprocessable Entity",
  "errors": {
    "otp_code": [
      "The selected otp code is invalid."
    ]
}
```

This is what i get in Postman and here's my mapping code
```swift
struct ResponseErrorModel : Mappable{
    var message: String?
    var statusCode : Int?
    var errors : String?

    mutating func mapping(map: Map) {
        message <- map["message"]
        statusCode <- map["status_code"]
        errors <- (map["errors"], LfArrayStringTransform())
    }
    
    init?(map: Map) {
    }
    
    init(){}
}

``` As I have commented out before that the value I get while transformation prints something like this

```
Optional({
    email =     (
        "The email has already been taken."
    );
    "mobile_number" =     (
        "The mobile number has already been taken."
    );
})
```

```swift

open class LfArrayStringTransform : TransformType {
    public typealias Object = String
    public typealias JSON = [[String]]
    
    public init() {}
    
    open func transformFromJSON(_ value : Any?) -> String?{
    /* This Prints
Optional({
    email =     (
        "The email has already been taken."
    );
    "mobile_number" =     (
        "The mobile number has already been taken."
    );
})
*/   
 print(value)

        do{
            let jsonData = try JSONSerialization.data(withJSONObject: value, options: []) as? [AnyHashable : Any]
            print(jsonData) // this is nil
        }catch{
        }
/*Goes in there (obvious it was , silly me)*/
        if let someValue = value as? Any{
            
        }
        /* Not Going in Here */
        if let arrayValue = value as? [[String]]{
            return arrayValue.flatMap({ (value) -> String in
               return value.joined(separator: ", ")
            }).joined(separator: ", ")
        }
        return nil
    }
    
    open func transformToJSON(_ value: String?) -> [[String]]? {
        return nil
    }
}

``` Yup. After doing custom transformation, as i wrote down above. The value I am getting in the parameter i.e. of **Any?** type prints this. So how do i transform this value into a dictionary or json. JSONSerialization fails ```json
{
  "message": "422 Unprocessable Entity",
  "errors": {
    "email": [
      "The email has already been taken."
    ],
    "mobile_number" : [
      "The mobile number has already been taken."
    ]
}
```
This is the actual value for the request in postman. (The same request I am doing in my app ) Just go for the semantics here. True but then considering the actual json, it shouldnt fail, should it? (The Casting I mean) Yeah I just tried that and it indeed failed. So do i have to convert the string json first into data??
Because i did that as well
```swift
open func transformFromJSON(_ value : Any?) -> String?{
        print(String(describing: value))
        let stringData = String(data: value as! Data, encoding: String.Encoding.utf8)
        print(stringData)
return nil
    }
```

But it gives me runtime exception Hey @BasThomas  Thanks a lot, I did all of that you said before And I realised a lot later the problem is not with Moya so I apologise for that.
BTW I solved it by casting it to a dictionary [AnyHashable : Any] directly.
Thank you so much for your time. Much Appreciated.  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="false">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Moya.swift | 54 | Shorthand syntactic sugar should be used, i.e. [Int] instead of Array<Int> 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/814?src=pr) is 83.05% (diff: 100%)
> Merging [#814](https://codecov.io/gh/Moya/Moya/pull/814?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #814   diff @@
==========================================
  Files            34         34          
  Lines          2738       2738          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2274       2274          
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [d01c87c...6f1ca3a](https://codecov.io/gh/Moya/Moya/compare/d01c87c926345c7def8197054555ea6b94d7fd72...6f1ca3a2c571d585ca41cb22813a5997a1f54ea4?src=pr)  
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Moya.swift | 54 | Shorthand syntactic sugar should be used, i.e. [Int] instead of Array<Int> 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/813?src=pr) is 83.32% (diff: 96.36%)
> Merging [#813](https://codecov.io/gh/Moya/Moya/pull/813?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.26%**

```diff
@@             master       #813   diff @@
==========================================
  Files            34         34          
  Lines          2738       2782    +44   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits           2274       2318    +44   
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [86166e4...20ae1a3](https://codecov.io/gh/Moya/Moya/compare/86166e40affc52b7977e6fe6963676dcc5867d64...20ae1a3e0302af84c9bba649fdef3db9a36eddf9?src=pr)  In `README.md`

> Carthage users can point to this repository and use whichever generated framework they'd like, Moya, RxMoya, or ReactiveMoya. The full Moya framework is bundled in each of those frameworks; importing more than one framework in a single file will result in ambiguous lookups at compile time.

This appears to be true for basic usage. However, I get undefined symbol errors for `Response` if I don't also include `Moya` with `RxMoya`. I run into this whenever I want to create custom Rx operators for `Observable<Response>`. I have not run into any ambiguous lookups yet.

------

In `docs/RxSwift.md`

> In the error cases, the error's domain is MoyaErrorDomain. The code is one of MoyaErrorCode's rawValues, where appropriate. Wherever possible, underlying errors are provided and the original response data is included in the NSError's userInfo dictionary using the "data" key.

The domain of the `NSError` that I see is `Moya.Error`. Also, it doesn't appear that the `userInfo` dictionary contains any items, and I can't see where in the code this would be the case. Maybe there is some magic happening under the hood when bridging `Error` to `NSError`?

In any case, when I need to process the response in error cases, I don't bridge to `NSError` and instead:

```swift
if 
   let error = error as? Moya.Error,
   let data = error.response?.data
{
   // Do something with the data
}
```
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/810?src=pr) is 83.05% (diff: 100%)
> Merging [#810](https://codecov.io/gh/Moya/Moya/pull/810?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #810   diff @@
==========================================
  Files            34         34          
  Lines          2738       2738          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2274       2274          
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [1a49afc...483d255](https://codecov.io/gh/Moya/Moya/compare/1a49afcc4c022b93a512ecdffb6867f584c6c243...483d2554d61211e2f56adefeb75a9835d200fa3f?src=pr)  My app can make many network requests & I am scheduling the RxMoyaProvider on a Concurrent scheduler. I run into this error a lot. When this error is hit, there are usually ~200 threads running CFNetworking. My app does not open an files, so I think this is due to the file descriptor on CFNetworking. I found [this](https://forums.developer.apple.com/message/118647#118647) with a search but it does not help since I can see this even if requests don't fail. 
Any idea on how I can debug this? 

2016-11-29 19:11:26.652880 MyApp[30635:2458222] [] __nwlog_err_simulate_crash_libsystem libsystem simulate crash unavailable "libsystem_network.dylib: nw_route_get_ifindex :: socket(PF_ROUTE, SOCK_RAW, PF_ROUTE) failed: [24] **Too many open files**"
2016-11-29 19:11:26.653620 MyApp[30635:2458222] [] nw_route_get_ifindex socket(PF_ROUTE, SOCK_RAW, PF_ROUTE) failed: [24] Too many open files, dumping backtrace:
        [x86_64] libnetcore-856.20.4
    0   libsystem_network.dylib             0x00000001121e9682 __nw_create_backtrace_string + 123
    1   libsystem_network.dylib             0x00000001121de7d1 nw_route_get_ifindex + 774
    2   libsystem_network.dylib             0x00000001121f615e nw_path_simulator_get_path_result + 196
    3   libsystem_network.dylib             0x00000001121f5eb0 nw_path_create_evaluator_for_endpoint + 289
    4   libnetwork.dylib                    0x0000000113079de1 nw_endpoint_handler_start + 415
    5   libdispatch.dylib                   0x0000000111f66980 _dispatch_call_block_and_release + 12
    6   libdispatch.dylib                   0x0000000111f900cd _dispatch_client_callout + 8
    7   libdispatch.dylib                   0x0000000111f6de6b _dispatch_queue_serial_drain + 236
    8   libdispatch.dylib                   0x0000000111f6eb9f _dispatch_queue_invoke + 1073
    9   libdispatch.dylib                   0x0000000111f713b7 _dispatch_root_queue_drain + 720
    10  libdispatch.dylib                   0x0000000111f7108b _dispatch_worker_thread3 + 123
    11  libsystem_pthread.dylib             0x000000011233f736 _pthread_wqthread + 1299
    12  libsystem_pthread.dylib             0x000000011233f211 start_wqthread + 13 Found the issue. I had created a wrapper that creates the provider with specific endpoint closures. Instead of updating the same provider, it was creating a new one every time. This was creating a new socket for every request.  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/808?src=pr) is 83.05% (diff: 100%)
> Merging [#808](https://codecov.io/gh/Moya/Moya/pull/808?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #808   diff @@
==========================================
  Files            34         34          
  Lines          2738       2738          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2274       2274          
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [1a49afc...11680fc](https://codecov.io/gh/Moya/Moya/compare/1a49afcc4c022b93a512ecdffb6867f584c6c243...11680fccd9681942a5062beec9820d31e71741cb?src=pr) 
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
Moya.swift | 54 | Shorthand syntactic sugar should be used, i.e. [Int] instead of Array<Int> 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/807?src=pr) is 83.05% (diff: 100%)
> Merging [#807](https://codecov.io/gh/Moya/Moya/pull/807?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #807   diff @@
==========================================
  Files            34         34          
  Lines          2738       2738          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2274       2274          
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [7c576e5...a962d08](https://codecov.io/gh/Moya/Moya/compare/7c576e5bd4c898cd0eac528af4c7abc5ab2cc7d0...a962d08bbc4117c5e8c84da80c96827b6b58ad5a?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/806?src=pr) is 83.05% (diff: 50.00%)
> Merging [#806](https://codecov.io/gh/Moya/Moya/pull/806?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #806   diff @@
==========================================
  Files            34         34          
  Lines          2738       2738          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2274       2274          
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [e6abf6b...ab8c2d5](https://codecov.io/gh/Moya/Moya/compare/e6abf6ba70c6b9c4e871db60b6c155874b47239a...ab8c2d5017f1b6dbfd7a16cf125ed3093f7f6157?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/805?src=pr) is 83.05% (diff: 100%)
> Merging [#805](https://codecov.io/gh/Moya/Moya/pull/805?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #805   diff @@
==========================================
  Files            34         34          
  Lines          2738       2738          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2274       2274          
  Misses          464        464          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [02af5c0...3545429](https://codecov.io/gh/Moya/Moya/compare/02af5c0fb5d60bf50a96aa617f691532c62822ac...3545429fe7952ad22ff28fcc73e8930b8aa64577?src=pr)  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/804?src=pr) is 85.94% (diff: 100%)
> Merging [#804](https://codecov.io/gh/Moya/Moya/pull/804?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **2.89%**

```diff
@@             master       #804   diff @@
==========================================
  Files            34         30     -4   
  Lines          2738       2618   -120   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits           2274       2250    -24   
+ Misses          464        368    -96   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [02af5c0...a253046](https://codecov.io/gh/Moya/Moya/compare/02af5c0fb5d60bf50a96aa617f691532c62822ac...a253046eed56a4d64fe9cb1616c5c9431dafb2b8?src=pr)  What is the proper way to set up unit testing with quick/nimble for moya?

I've been looking for tutorials and documentation on this matter but have not found anything in this repository. 

Would love to see more documentation on this matter if possible. Thanks!  @sunshinejr Thanks! I took a look at this previously. 

But I'm still a bit confused... For example... I see the XAuth.json and I see .XAuth in API enum but I only see 1 test being done in APISpec... 

I don't see it being tested for authentication.... Or maybe I'm looking at the wrong place? 

  example , if .zen has both GET and POST how to write?
```swift
public var path: String {
        switch self {
        case .zen:
            return "/zen"
        }
    }
public var method: Moya.Method {
        switch self {
        case .zen   
          return       //return what ?
        }
    }
```


 OKÔºåit seems a good idea ~  Migrating from Swift 2 to swift 3 produced breaking changes in moya. 

How do we handle parameter encodings now in swift 3? 

It used to be a switch case sort of away to handle them... is this still present? 

Thanks! @sunshinejr 

Is the following way not the accepted way to initialize the endpoint anymore? 

```swift
        let endpoint: Endpoint<API> = Endpoint<API>(
            URL: target.baseURL.appendingPathComponent(target.path).absoluteString,
            sampleResponseClosure: {.networkResponse(200, target.sampleData)},
            method: target.method,
            parameters: target.parameters,
            parameterEncoding: target.parameterEncoding
        )
        
```  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/799?src=pr) is 83.05% (diff: 100%)
> Merging [#799](https://codecov.io/gh/Moya/Moya/pull/799?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.05%**

```diff
@@             master       #799   diff @@
==========================================
  Files            34         34          
  Lines          2735       2738     +3   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits           2273       2274     +1   
- Misses          462        464     +2   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [925a549...7801b33](https://codecov.io/gh/Moya/Moya/compare/925a549ca76417e437e6aa3e327687edb3d9c164...7801b3306e875d595304ae9c7e5991b4191e3b04?src=pr)  <!-- Please wrap code blocks in backticks, like so:
```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
 I use Swift3, and need to support iOS8.0 Thanks!  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/797?src=pr) is 83.10% (diff: 100%)
> Merging [#797](https://codecov.io/gh/Moya/Moya/pull/797?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #797   diff @@
==========================================
  Files            34         34          
  Lines          2735       2735          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2273       2273          
  Misses          462        462          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [925a549...e029609](https://codecov.io/gh/Moya/Moya/compare/925a549ca76417e437e6aa3e327687edb3d9c164...e0296094d142a0bd78fa8a62368db04a27d47809?src=pr) I see Alamofire latest version is 4.2.0. Why this use 4.1.0.  Update the version to support ios 8.0.  Hi, 

I am using Moya to handle HTTP operations and normally I have an `refreshToken()`. I am checking token if expired or not when a request is about happen but the problem is there can be a scenarios that more than one requests. If they are chained with nested types it is not a problem however, it is not likely all the time. 

To be more clear lets say I have `request1()` and `request2()` and assume that they execute separate operations and can be triggered anytime(for instance one is called in a `viewDidLoad()`, other one is called in another `viewDidLoad()`). when this happens and if the token is expired, my refresh request fails. (`statusCode: 400`) So, my question is, how can I make provider to wait `refresh()` operation get done?I mean by provider is other endpoints. I want them to wait `refresh()` endpoint if it is on.

I will be very appreciated if you suggest a way that will make this easier. 
 @AndrewSB Hi, sorry for the really really late response. I just had to focus on the school, so I suspended the project. As the school is over for now, I just started work on my project. 

I examined your answer and the reference, but I am not feeling safe with the idea of using RxSwift right now. Because I do not have experience with it and it will cost me more time. I just used `GCD` in seperate function which is responsible for refreshing token so, it seems OK for now. 

But for further work about the service you are providing, I really want to see a feature that handles this kind of operations by itself. And as a user of `Moya` I want to help as much as I can. 

Thanks! Just one question for now @AndrewSB . I know it is not preferred but it there a way to make all the requests made with Moya synchronous. Because my way seems to not working correctly? It still has the bug. Any other simple but 'saves the day' solution will work also.  Hey guys!

I just recently started using Moya in conjunction with ReactiveSwift and am currently struggeling with building a small API wrapper for my service to encapsulate some more logic under the hood involving CoreData.

I'm currently using the following:
```swift
class APIProvider {
    static let provider = ReactiveCocoaMoyaProvider<MyService>()
    
    static func login(token: String) -> Signal<Response, Moya.Error> {
        return Signal { sink in
            provider.request(token: .login(token: token)).filterSuccessfulStatusCodes().start { event in
                switch event {
                case let .failed(error):
                    sink.send(error: error)
                case let .value(response):
                    // Process the response here, write to CoreData
                    sink.send(value: response)
                default:
                    //TODO: manage error here
                    break
                }
            }
        }
    }
}
```

I'm then calling this function from my view controller like this:
`_ = APIProvider.login(token: mySecretToken)`

However it seems like the request is only successfully being processed if I add an additional 
`.observe { _ in }` to the end of the call in my view controller ...

I attached the NetworkLogger as a plugin and get the following output:
```
[["Moya_Logger: [26/11/2016 14:52:54] Response: Received empty network response for login(....
```

I'm aware that I clearly didn't get something about the whole Signal and SignalProducer thing. Does someone have an idea how I could resolve this issue or what general best practices are for use with Moya?

Thanks! how to slove the empty network ?  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/789?src=pr) is 83.34% (diff: 100%)
> Merging [#789](https://codecov.io/gh/Moya/Moya/pull/789?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #789   diff @@
==========================================
  Files            34         34          
  Lines          2738       2738          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2282       2282          
  Misses          456        456          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [7d8489f...5b120fd](https://codecov.io/gh/Moya/Moya/compare/7d8489f77e124d5f3a379a4d8e6a355a4f3df263...5b120fd4f25d6e1f12c3eab86b0b48f13fa6bd04?src=pr)  What exactly is this used for?
```swift
  var task: Task {
        switch self {
            case .zen, .showUser, .createUser, .showAccounts:
                return .request
        }
    }
``` Thanks! This was helpful. But I guess most requests should by default be .request right?  @BasThomas Thanks!   
### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MultiTarget.swift | 5 | Lines should not have trailing whitespace. 
MultiTarget.swift | 9 | Lines should not have trailing whitespace. 
MultiTarget.swift | 13 | Lines should not have trailing whitespace. 
MultiTarget.swift | 17 | Lines should not have trailing whitespace. 
MultiTarget.swift | 21 | Lines should not have trailing whitespace. 
MultiTarget.swift | 25 | Lines should not have trailing whitespace. 
MultiTarget.swift | 29 | Lines should not have trailing whitespace. 
MultiTarget.swift | 33 | Lines should not have trailing whitespace. 
MultiTarget.swift | 37 | Lines should not have trailing whitespace. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/787?src=pr) is 83.34% (diff: 100%)
> Merging [#787](https://codecov.io/gh/Moya/Moya/pull/787?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #787   diff @@
==========================================
  Files            34         34          
  Lines          2738       2738          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2282       2282          
  Misses          456        456          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [1958731...a81b2c9](https://codecov.io/gh/Moya/Moya/compare/1958731285d232d410e925389a6a198d86bb2ac7...a81b2c966482a443a7531c6597b8f3f9896a3fa5?src=pr)  
![631c073a-5872-44a2-9ea4-c5532f8c56ae](https://cloud.githubusercontent.com/assets/8953791/20477253/bc3ff796-b00f-11e6-8b8e-ac24f5337b92.png)
how solve it ? 
 #782 I get it , i hope soon ,thanks   There was a [similar issue](https://github.com/Moya/Moya/issues/334) on this by it does not answer my question.

OData protocol can return the 'nextLink' for multipage responses. [Here](http://www.odata.org/getting-started/basic-tutorial/) is the documentation for it.

Ideally I think it should be handled with the request. Keep sending the next request until nextLink is nil.
The solution below works but is the right thing to do?

```swift
private let provider = RxMoyaProvider<T>(endpointClosure: ApiUtility.getEndpointClosure())

    func requestPaged<E: Mappable>(_ token: T, withEntity: String) -> Observable<[E]> {
        var items:[E] = []
        
        return requestHelper(token, withEntity:withEntity, scheduler: QueueConstants.ReadQueue())
        .mapObject(PagedResponse<E>.self)
            .flatMap { pagedResponse -> Observable<[E]> in
                items += pagedResponse.items
                
                guard let nextLink = pagedResponse.nextLink else {
                    self.provider = RxMoyaProvider<T>(endpointClosure: ApiUtility.getEndpointClosure(url: nil))
                    return Observable.of(items)
                }
                
                self.provider = RxMoyaProvider<T>(endpointClosure: ApiUtility.getEndpointClosure(url: nextLink))
                return self.requestPaged(token, withEntity: withEntity)
        }
    }
```  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/784?src=pr) is 83.14% (diff: 92.98%)

> Merging [#784](https://codecov.io/gh/Moya/Moya/pull/784?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **2.79%**

``` diff
@@             master       #784   diff @@
==========================================
  Files            30         34     +4   
  Lines          2618       2706    +88   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2250       2250          
- Misses          368        456    +88   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [c12f6b1...d8dd82e](https://codecov.io/gh/Moya/Moya/compare/c12f6b1f97b8daeb465a1d30843b2487c988c6f7...d8dd82ebcceb1159acd699dd1dcfd96efefbb2af?src=pr)
  ```swift
let endpointClosure = { (target: API) -> Endpoint<API> in
    var endpoint = Endpoint<API>(
        URL: url(route: target),
        sampleResponseClosure: {.networkResponse(200, target.sampleData)},
        method: target.method,
        parameters: target.parameters,
        httpHeaderFields: ["Content-Type": "application/json;charset=UTF-8"]
    )
    if target.method == .post || target.method == .put {
        endpoint = endpoint.adding(parameterEncoding: JSONEncoding.default)
    }
    if let token = DefaultConfig.token {
        endpoint = endpoint.adding(httpHeaderFields: ["Authorization": token])
    }
    return endpoint
}


let provider = MoyaProvider<API>(plugins: [NetworkLoggerPlugin(verbose:true, responseDataFormatter: JSONResponseDataFormatter)])
```
above I set sent parameters as `application/json;charset=UTF-8`, if I sent parameters with date, `parameter["date"] = Date()`, error bottom:
```
Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'Invalid type in JSON write (__NSDate)'.
```
Someone can help me?
 You can't put a Date into the parameter dictionary directly. JSONSerialization only handles primitive types, so you have to convert your Date into a String or an Int first.

(Sidenote: without your explicit conversion, it would be pretty ambiguous how to represent a date.)
  Alamofie 4.1.0 has Updated the iOS Example app deployment target to iOS 8.0; Why Moya does not support iOS8Ôºü https://github.com/Moya/Moya/pull/608#issuecomment-247292895 @sunshinejr had said `Because both Alamofire and RxSwift have iOS 9.0 as a minimum deployment target.`, But now Alamofire and RxSwift Support iOS 8.0 again; iOS 8 is still 9% of the market share!
 üëçSo cool!!!  You are so great!  Cheers!
 COOL
  I need to download many small files from different urls,they dont share a same baseURL,what should I do using moya?

thanks


 I believe you can just pass the baseURL in as a parameter to your target

FileFetchTarget.swift:

```swift
public enum FileFetchTarget {
    case getFile(baseURL: String, filePath: String)
}

extension FileFetchTarget: TargetType {
    public var baseURL: URL {
        switch self {
        case .getFile(let baseURL, _):
            return URL(string: baseURL)!
        }
    }

    public var path: String {
        switch self {
        case .getFile(_, let filePath):
            return filePath
        }
    }

    ...

}
```

Calling it in project:
```swift
let fileFetchProvider = MoyaProvider<FileFetchTarget>()
fileFetchProvider.request(.getFile(baseURL: "https://store.foo.com", filePath: "/tiny.zip")) { result in
    process(result)
}
``` no, it says ```Error Domain=NSCocoaErrorDomain Code=262 "The file couldn‚Äôt be opened because the specified URL type isn‚Äôt supported."```
I print the url, it append a "/" 

```swift
enum DownloadService {
    case download(baseURL: String,path: String)
}

extension DownloadService:TargetType{

    var baseURL : URL{
        switch self {
        case .download(let baseURL,_):
            return URL(string:baseURL)!

        }
        
    }
    
    
    var path:String{
        switch self {
        case .download(_,let path):
            return path
        }
        
    }

    var method: Moya.Method {
        switch self {
        case .download:
            return .get

        }

    }

    
    var parameters: [String:Any]?{
        switch self {
        case .download:
            return nil
        }
    }
    
    var sampleData:Data{
        switch self {
            default:
            return "default data".utf8EncodedData
        }
    }
    
    var task:Task{
        switch self {
        case .download:
            return .download(DownloadType.request(DefaultDownloadDestination))

        }
    }
    
}


private let DefaultDownloadDestination: DownloadDestination = { temporaryURL, response in
     print("url = \(response.url)") //I pass baseURL with "http://aaa.bbb.ccc",path with empty string "" but here it prints "http://aaa.bbb.ccc/"
      return   (URL(string: NSHomeDirectory()+"/Documents/"+response.url!.absoluteString.md5())!, [.removePreviousFile])
    

}

// MARK: - Helpers
private extension String {
    var urlEscapedString: String {
        return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
    }
    
    var utf8EncodedData: Data {
        return self.data(using: .utf8)!
    }
}

``` the reson `Error Domain=NSCocoaErrorDomain Code=262 "The file couldn‚Äôt be opened because the specified URL type isn‚Äôt supported."` is someting wrong with `DefaultDownloadDestination ` , I use an `endpointClosure` to correct the urlÔºåand it works! but I don't know if it's a common   way.@bchrobot @BasThomas 

```swift


import Foundation
import Moya

let endpointClosure = {
    (target: FileService) -> Endpoint<FileService> in
    let url = URL(string: target.path)?.absoluteString
    return Endpoint(URL: url!, sampleResponseClosure: { .networkResponse(200, target.sampleData) }, method: target.method, parameters: target.parameters)
}

private func JSONResponseDataFormatter(_ data: Data) -> Data {
    do {
        let dataAsJSON = try JSONSerialization.jsonObject(with: data)
        let prettyData =  try JSONSerialization.data(withJSONObject: dataAsJSON, options: .prettyPrinted)
        return prettyData
    } catch {
        return data // fallback to original data if it can't be serialized.
    }
}

let FileDownloadProvider = RxMoyaProvider<FileService>(endpointClosure: endpointClosure, plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])

enum FileService {
    case download(url: String)
}

extension FileService:TargetType{

    var baseURL : URL{
            return URL(string:"http://no.use.but.cant.empty")!
    }
    
    
    var path:String{
        switch self {
        case .download(let url):
            return url
        }
        
    }

    var method: Moya.Method {
        switch self {
        case .download:
            return .get

        }

    }

    
    var parameters: [String:Any]?{
        switch self {
        case .download:
            return nil
        }
    }
    
    var sampleData:Data{
        switch self {
            default:
            return "default data".utf8EncodedData
        }
    }
    
    var task:Task{
        switch self {
        case .download:
            return .download(DownloadType.request(DefaultDownloadDestination))

        }
    }
    
}


private let DefaultDownloadDestination: DownloadDestination = { temporaryURL, response in
    
    let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
    let fileURL = documentsURL.appendingPathComponent(response.suggestedFilename!)
    return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
    
}

// MARK: - Helpers
private extension String {
    var urlEscapedString: String {
        return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
    }
    
    var utf8EncodedData: Data {
        return self.data(using: .utf8)!
    }
}

``` if your urls have  `path` component in them, just try split the whole url into two parts, like this: 
split `http://www.abc.com/apath/bpath/cpath` with a=> `http://www.abc.com/apath/bpath/` and b=> `cpath`,and `a` put in baseUrl,`b` put in path
```swift
...
extension FileService:TargetType{

    var baseURL : URL{
        switch self {
        case .download(let url):
            var newUrl = url.characters.split(separator: "/").map{String($0)}
            newUrl.removeLast()
            return URL(string: newUrl.joined(separator: "/"))!
        default:
            return URL(string:"http://other.com")!
    }
    
    
    var path:String{
        switch self {
        case.download(let url):
            let newUrl = url.characters.split(separator: "/")
            return "\(String(newUrl.last!))"
        
    }
...
```  Any chance for instructions on how to add Moya to a project manually? I would love the fully spelled out idiot/newbie version if you don't mind? 

Thanks in advance. I know this is not the place to complain about this but it is exactly the difficulty with installing and/or using CocoaPods/Carthage themselves that got me asking about manual install (Moya specifically is was not the problem). But it sounds like this is not viable option as it stands unfortunately.   ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/779?src=pr) is 83.10% (diff: 66.66%)
> Merging [#779](https://codecov.io/gh/Moya/Moya/pull/779?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.23%**

```diff
@@             master       #779   diff @@
==========================================
  Files            34         34          
  Lines          2738       2735     -3   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits           2282       2273     -9   
- Misses          456        462     +6   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [1958731...8f31c28](https://codecov.io/gh/Moya/Moya/compare/1958731285d232d410e925389a6a198d86bb2ac7...8f31c283186d6b47e912a5effc05106f8c30bfbf?src=pr) <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>

    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
MultiTarget.swift | 5 | Lines should not have trailing whitespace. 
MultiTarget.swift | 9 | Lines should not have trailing whitespace. 
MultiTarget.swift | 13 | Lines should not have trailing whitespace. 
MultiTarget.swift | 17 | Lines should not have trailing whitespace. 
MultiTarget.swift | 21 | Lines should not have trailing whitespace. 
MultiTarget.swift | 25 | Lines should not have trailing whitespace. 
MultiTarget.swift | 29 | Lines should not have trailing whitespace. 
MultiTarget.swift | 33 | Lines should not have trailing whitespace. 
MultiTarget.swift | 37 | Lines should not have trailing whitespace. 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Convenience method for pulling a single String value from a JSON response <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          :white_check_mark: Jolly good show.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">PR is classed as Work in Progress</td>
    </tr>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</del></td>
      </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/778?src=pr) is 86.11% (diff: 93.33%)

> Merging [#778](https://codecov.io/gh/Moya/Moya/pull/778?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.16%**

``` diff
@@             master       #778   diff @@
==========================================
  Files            30         30          
  Lines          2618       2650    +32   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits           2250       2282    +32   
  Misses          368        368          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [c666c6b...e6e039c](https://codecov.io/gh/Moya/Moya/compare/c666c6b04bdb54832c4c0a75ce780d7fb9889627...e6e039c26da89f7eb0cea8e86dfef32f037eb383?src=pr)
 :smile: Thank you ü§ó  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          :white_check_mark: Good on 'ya.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 110 | Lines should not have trailing whitespace. |
| Response.swift | 23 | Lines should not have trailing whitespace. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/777?src=pr) is 85.69% (diff: 70.83%)

> Merging [#777](https://codecov.io/gh/Moya/Moya/pull/777?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.24%**

``` diff
@@             master       #777   diff @@
==========================================
  Files            30         30          
  Lines          2618       2615     -3   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits           2250       2241     -9   
- Misses          368        374     +6   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [f624f2c...79af1ed](https://codecov.io/gh/Moya/Moya/compare/f624f2cc00a549e12c9c459c33bde9a441d56774...79af1edcf664e4a95df8185aae56f85040a0e05a?src=pr)
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/776?src=pr) is 85.69% (diff: 73.91%)

> Merging [#776](https://codecov.io/gh/Moya/Moya/pull/776?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.24%**

``` diff
@@             master       #776   diff @@
==========================================
  Files            30         30          
  Lines          2618       2615     -3   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits           2250       2241     -9   
- Misses          368        374     +6   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [f624f2c...96efdfe](https://codecov.io/gh/Moya/Moya/compare/f624f2cc00a549e12c9c459c33bde9a441d56774...96efdfe3313d6bb7f29f25656231bb650bec0dc2?src=pr)
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          :white_check_mark: Yay.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/775?src=pr) is 85.69% (diff: 67.56%)

> Merging [#775](https://codecov.io/gh/Moya/Moya/pull/775?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.24%**

``` diff
@@             master       #775   diff @@
==========================================
  Files            30         30          
  Lines          2618       2615     -3   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits           2250       2241     -9   
- Misses          368        374     +6   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [f624f2c...d77c261](https://codecov.io/gh/Moya/Moya/compare/f624f2cc00a549e12c9c459c33bde9a441d56774...d77c26110429f428493ba87e7894db0305d57769?src=pr)
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/772?src=pr) is 85.94% (diff: 100%)

> Merging [#772](https://codecov.io/gh/Moya/Moya/pull/772?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #772   diff @@
==========================================
  Files            30         30          
  Lines          2618       2618          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2250       2250          
  Misses          368        368          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [1b1f221...b8c5363](https://codecov.io/gh/Moya/Moya/compare/1b1f2217bd95dbfccc7315591a93f472f862c74d...b8c53630766a6128f9a93022ce4a2696844ec27c?src=pr)
   ### SwiftLint found issues

#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 17 | Limit vertical whitespace to a single empty line. Currently 2. |
| Moya.swift | 28 | Limit vertical whitespace to a single empty line. Currently 2. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/771?src=pr) is 85.94% (diff: 100%)

> Merging [#771](https://codecov.io/gh/Moya/Moya/pull/771?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #771   diff @@
==========================================
  Files            30         30          
  Lines          2618       2618          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2250       2250          
  Misses          368        368          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [1b1f221...8f4ea9b](https://codecov.io/gh/Moya/Moya/compare/1b1f2217bd95dbfccc7315591a93f472f862c74d...8f4ea9b92221a9ca0f57adab52911c065287a0fc?src=pr)
  I've created a network layer using Moya, however for one of my requests I'm passing a etag in the `If-None-Match` header and even though this correspond to the returning `Etag` it still return a JSON array, even though I've tested it in Postman where it does not return anything. I guess this is due to the fact that cache-control is turned off? How can I achieve this?

```swift
    let endpointClosure = { (target: API) -> Endpoint<API> in
       
        let endpoint = Endpoint<API>(URL: url(target), sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
        
        
        switch target {
        case .auth(let fbAccessToken):
            return endpoint.adding(newHttpHeaderFields: [
                "x-access-token": "\(fbAccessToken)"
                ])
        case .games(let accessToken, let etag):
                
            return endpoint.adding(newHttpHeaderFields: [
                "x-access-token": "\(accessToken)",
                "If-None-Match": "\(etag)"
                ])
        }   
    }
``` Correct me if I'm wrong, but isn't this the way that etags are supposed to work? The networking layer should, if it gets a `304` from the server, just return the cached version of it. Which seems like what you're saying it is doing? So Postman will give you a `304` because it's saying there's no update, and Alamofire is seeing the 304 and just returning the cached value. Seems like the intended functionality unless I am misunderstanding you, or how etags work ;) Your correct however at the moment if i pass a etag in the `If-None-Match` i get an array back even though when i check the response the etag is exactly the same i passed in `If-None-Match`. If these are the same it is suppose to give 304 error, but its not.  I'm trying to upload an image to my server using MultipartFormData. I've tried my endpoint with Postman and it was successful, however when using Moya for it I'm always receiving a 502 (Bad Gateway) error. 

```Swift
enum UserService {
    case uploadAvatar(image: UIImage)
}

extension UserService: MoyaService {
    
    public var task: Task {
        switch self {
        default:
            return .request
        }
    }
    
    var path: String {
        switch self {
        case .uploadAvatar(_):
            return "/user/upload/avatar"
        }
    }
    
    var method: Moya.Method {
        switch self {
        case .uploadAvatar(_):
            return .POST
        }
    }
    
    var parameters: [String: Any]? {
        switch self {
        default:
            return nil
        }
    }
    
    var parameterEncoding: ParameterEncoding {
        switch self {
        default:
            return JSONEncoding.default
        }
    }
    
    var sampleData: Data {
        switch self {
        default:
            return "{\"status\":{ \"code\": 200, \"message\": \"success\" }, \"data\": 21.5}".UTF8EncodedData
        }
    }
    
    var multipartBody: [MultipartFormData]? {
        switch self {
        case .uploadAvatar(let image):
            let data = UIImagePNGRepresentation(image)
            return [MultipartFormData(provider: .data(data!), name: "image", fileName: "avatar.png", mimeType:"image/png")]
        default:
            return nil
        }
    }
}
```
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/768?src=pr) is 85.94% (diff: 100%)

> Merging [#768](https://codecov.io/gh/Moya/Moya/pull/768?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #768   diff @@
==========================================
  Files            30         30          
  Lines          2618       2618          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2250       2250          
  Misses          368        368          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [217dd25...ba71a1f](https://codecov.io/gh/Moya/Moya/compare/217dd258fc83473de1e27901df295e8c68d67c13...ba71a1f98e3c2620a88f0c4bc9f378e0103eba5b?src=pr)
  Sometimes, users will want to use alamofire's automatic validation on some requests. For exemple, when they want to take advantage of the new `RequestRetrier`.
This functionality will allow to optionally configure `Alamofire` validation on some requests (you can see an example in the documentation).
This also solves the `RequestRetrier` issue mentioned in #700 and opened as a separate issue here: #766.

The `Alamofire` validation configuration has been set to `false` by default so that `Moya` users don't have to change their current configuration.
And if `Alamofire` validation configuration is not set up, the behaviour remains the same. <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          :white_check_mark: Yay.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 17 | Limit vertical whitespace to a single empty line. Currently 2. |
| Moya.swift | 28 | Limit vertical whitespace to a single empty line. Currently 2. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/767?src=pr) is 85.94% (diff: 60.00%)

> Merging [#767](https://codecov.io/gh/Moya/Moya/pull/767?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.07%**

``` diff
@@             master       #767   diff @@
==========================================
  Files            30         30          
  Lines          2611       2618     +7   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits           2246       2250     +4   
- Misses          365        368     +3   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [dffad98...bee6f15](https://codecov.io/gh/Moya/Moya/compare/dffad98a12e0f01105b1ad51afd87d774f3b9f48...bee6f150960b9c5d3b2daaec4e54d33a11c885bc?src=pr)
 Yes, since this enhancement is only needed in specific cases, maybe it should not belong to the Basic Usage documentation.

Looking at the TargetType protocol, it will be pretty self-explanatory. What do you propose? Do we put a sample code in the issues instead?
 Yeah, you're right, I'm adding in a few hours the new option in the demo app, and in a new file Advanced.md.
Should I also add the change in the Changolog.md?
 Hi, can you explain me what I can do to satisfy codecov/patch and codecov/project?
  In the case of the requestRetrier, that is because the requestRetrier delegate method is **only** called when there is an **Alamofire error** in the response. (you can see it here https://github.com/Alamofire/Alamofire/blob/master/Source/SessionDelegate.swift#L434)
When you directly use Alamofire, this error would appear if you call `validate()` on a DataRequest.

BUT when using Moya, you can't call `validate()` on a DataRequest (since it is hidden), and thus Alamofire does not consider there is an error, and the requestRetrier `should` process is not launched.

You can test that your requestRetrier would still work with Moya by calling validate() on the DataRequest here:
https://github.com/Moya/Moya/blob/master/Source/Moya%2BInternal.swift#L187
would be
`let alamoRequest = manager.request(request as URLRequestConvertible).validate()`
Using this **hot fix**, your requestAdapter and requestRetrier work as before (as when you were using Alamofire directly).

But the real improvement would be for Moya to allow us in the switch/case configuration (in the `TargetType` protocol) to pass true or false, if we want or not the Alamofire `validate()` appended. I thought it was a good idea, because the first author of issue #700 spoke about cache policy problems specifically.
The `requestRetrier` issue was introduced later by _DanteCore_, but his question and my answer (and PR) don't help the initial author.
  I need the request object build by moya for testing purposes.  the latest Moya version to use with Swift 3 is  `'8.0.0-beta.4'`, this is now reflected in the `Readme` ### SwiftLint found issues

#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 17 | Limit vertical whitespace to a single empty line. Currently 2. |
| Moya.swift | 28 | Limit vertical whitespace to a single empty line. Currently 2. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  I am trying to use Moya's extension for RxSwift, installing it through Cocoapods.

My Podfile looks as follows: 
```ruby

target 'RxMoyaExample' do
  use_frameworks!

  pod 'Moya', '8.0.0-beta.2'
  pod 'Moya/RxSwift'
  pod 'RxSwift'
  pod 'RxCocoa'

end
```

Running `pod install` works fine and fetches all required dependencies. However, once I open the workspace the project won't build anymore. I am getting 2 compiler errors in `Moya+RxSwift.swift` (lines 31 and 57):
`Use of unresolved identifier AnonymousDisposable`.

Any ideas how to fix this? I'm also happy to provide more info about my setup if needed! Thanks so much for the immediate help, using `pod 'Moya', '8.0.0-beta.4'` indeed fixed the issue! üôè
 pretty sure I already did (unless I missed something?!)

<img width="1006" alt="screen shot 2016-11-09 at 22 57 41" src="https://cloud.githubusercontent.com/assets/4058327/20167389/1c991328-a6d0-11e6-8cd6-3180a1aab09b.png">
 I'm having the exact same issue with beta.6  # [Codecov](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=h1) Report
> Merging [#762](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=desc) into [master](https://codecov.io/gh/Moya/Moya/commit/c09c7d13047f9c22ea92a54d0004267008df973f?src=pr&el=desc) will **decrease** coverage by `0.71%`.
> The diff coverage is `74.46%`.

[![Impacted file tree graph](https://codecov.io/gh/Moya/Moya/pull/762/graphs/tree.svg?token=CjZLHCNgNn&width=650&height=150&src=pr)](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=tree)

```diff
@@            Coverage Diff             @@
##           master     #762      +/-   ##
==========================================
- Coverage   77.11%   76.39%   -0.72%     
==========================================
  Files          22       22              
  Lines         721      733      +12     
==========================================
+ Hits          556      560       +4     
- Misses        165      173       +8
```


| [Impacted Files](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=tree) | Coverage Œî | |
|---|---|---|
| [Sources/Moya/Moya+Alamofire.swift](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWErQWxhbW9maXJlLnN3aWZ0) | `82.6% <100%> (√∏)` | :arrow_up: |
| [Sources/RxMoya/RxMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=tree#diff-U291cmNlcy9SeE1veWEvUnhNb3lhUHJvdmlkZXIuc3dpZnQ=) | `94.44% <100%> (-0.16%)` | :arrow_down: |
| [Sources/Moya/MoyaProvider+Internal.swift](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlcitJbnRlcm5hbC5zd2lmdA==) | `62.27% <55.55%> (-1.41%)` | :arrow_down: |
| [...urces/ReactiveMoya/ReactiveSwiftMoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=tree#diff-U291cmNlcy9SZWFjdGl2ZU1veWEvUmVhY3RpdmVTd2lmdE1veWFQcm92aWRlci5zd2lmdA==) | `51.72% <71.42%> (-0.82%)` | :arrow_down: |
| [Sources/Moya/MoyaProvider.swift](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL01veWFQcm92aWRlci5zd2lmdA==) | `88.7% <84.61%> (-2.2%)` | :arrow_down: |
| [Sources/Moya/Plugins/NetworkLoggerPlugin.swift](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=tree#diff-U291cmNlcy9Nb3lhL1BsdWdpbnMvTmV0d29ya0xvZ2dlclBsdWdpbi5zd2lmdA==) | `93.33% <0%> (-0.11%)` | :arrow_down: |

------

[Continue to review full report at Codecov](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Œî = absolute <relative> (impact)`, `√∏ = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=footer). Last update [c09c7d1...641f7c8](https://codecov.io/gh/Moya/Moya/pull/762?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 <!--
  0 Errors
  1 Warning: The <code>Cartfile</code> or <...
  0 Messages
  1 Markdown
-->
<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">The <code>Cartfile</code> or <code>Cartfile.resolved</code> was updated, but there were no changes in the <code>podspec</code>. Did you forget updating the <code>podspec</code>?</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Warnings

File | Line | Reason |
| --- | ----- | ----- |
ViewController.swift | 114 | Unused parameter "action" in a closure should be replaced with _. 
ViewController.swift | 10 | Lines should not have trailing whitespace. 
ViewController.swift | 14 | Lines should not have trailing whitespace. 
ViewController.swift | 24 | Lines should not have trailing whitespace. 
ViewController.swift | 49 | Lines should not have trailing whitespace. 
ViewController.swift | 53 | Lines should not have trailing whitespace. 
ViewController.swift | 61 | Lines should not have trailing whitespace. 
ViewController.swift | 68 | Lines should not have trailing whitespace. 
ViewController.swift | 70 | Lines should not have trailing whitespace. 
ViewController.swift | 76 | Lines should not have trailing whitespace. 
ViewController.swift | 85 | Lines should not have trailing whitespace. 
ViewController.swift | 90 | Lines should not have trailing whitespace. 
ViewController.swift | 101 | Lines should not have trailing whitespace. 
ViewController.swift | 109 | Lines should not have trailing whitespace. 
ViewController.swift | 133 | Lines should not have trailing whitespace. 
ViewController.swift | 116 | Unused parameter "action" in a closure should be replaced with _. 
ViewController.swift | 9 | Lines should not have trailing whitespace. 
ViewController.swift | 12 | Lines should not have trailing whitespace. 
ViewController.swift | 16 | Lines should not have trailing whitespace. 
ViewController.swift | 19 | Lines should not have trailing whitespace. 
ViewController.swift | 26 | Lines should not have trailing whitespace. 
ViewController.swift | 28 | Lines should not have trailing whitespace. 
ViewController.swift | 43 | Lines should not have trailing whitespace. 
ViewController.swift | 51 | Lines should not have trailing whitespace. 
ViewController.swift | 55 | Lines should not have trailing whitespace. 
ViewController.swift | 63 | Lines should not have trailing whitespace. 
ViewController.swift | 70 | Lines should not have trailing whitespace. 
ViewController.swift | 72 | Lines should not have trailing whitespace. 
ViewController.swift | 78 | Lines should not have trailing whitespace. 
ViewController.swift | 87 | Lines should not have trailing whitespace. 
ViewController.swift | 92 | Lines should not have trailing whitespace. 
ViewController.swift | 103 | Lines should not have trailing whitespace. 
ViewController.swift | 105 | Lines should not have trailing whitespace. 
ViewController.swift | 107 | Lines should not have trailing whitespace. 
ViewController.swift | 111 | Lines should not have trailing whitespace. 
ViewController.swift | 114 | Lines should not have trailing whitespace. 
ViewController.swift | 127 | Lines should not have trailing whitespace. 
ViewController.swift | 131 | Lines should not have trailing whitespace. 
ViewController.swift | 135 | Lines should not have trailing whitespace. 
ViewController.swift | 137 | Lines should not have trailing whitespace. 
ViewController.swift | 141 | Lines should not have trailing whitespace. 
MoyaProvider.swift | 96 | Function should have 5 parameters or less: it currently has 6 
ReactiveSwiftMoyaProvider.swift | 49 | Function should have 5 parameters or less: it currently has 6 
MoyaProviderSpec.swift | 463 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 745 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 748 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 754 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 758 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 762 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 767 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 772 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 779 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 783 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 787 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 794 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 799 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 802 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 806 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 811 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 818 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 822 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 826 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 833 | Lines should not have trailing whitespace. 
MoyaProviderSpec.swift | 483 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 
MoyaProviderSpec.swift | 500 | Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function. 
MoyaProviderSpec.swift | 840 | File should contain 400 lines or less: currently contains 840 
ReactiveSwiftMoyaProviderTests.swift | 72 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 159 | Lines should not have trailing whitespace. 
ReactiveSwiftMoyaProviderTests.swift | 65 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 66 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 67 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 68 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 152 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 153 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 154 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
ReactiveSwiftMoyaProviderTests.swift | 155 | Function parameters should be aligned vertically if they're in multiple lines in a declaration. 
RxSwiftMoyaProviderTests.swift | 166 | Prefer `!= nil` over `let _ =` 
TestHelpers.swift | 148 | Limit vertical whitespace to a single empty line. Currently 2. 
#### Errors

File | Line | Reason |
| --- | ----- | ----- |
MoyaProviderSpec.swift | 8 | Type body should span 350 lines or less excluding comments and whitespace: currently spans 498 lines 
TestHelpers.swift | 149 | Variable name should start with a lowercase character: 'DefaultDownloadDestination' 


<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">Danger</a>
</p>
  ### SwiftLint found issues

#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 17 | Limit vertical whitespace to a single empty line. Currently 2. |
| Moya.swift | 28 | Limit vertical whitespace to a single empty line. Currently 2. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/761?src=pr) is 86.02% (diff: 100%)

> Merging [#761](https://codecov.io/gh/Moya/Moya/pull/761?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #761   diff @@
==========================================
  Files            30         30          
  Lines          2611       2611          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2246       2246          
  Misses          365        365          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [166de54...bc679b7](https://codecov.io/gh/Moya/Moya/compare/166de54e0eb1e784ae76fdf820b7b7a6903ccbcc...bc679b79e7d6db02739bbe7892d00873bb49e4ab?src=pr)
  when I use github "Moya/Moya" , it's become  github "Moya/Moya" "3.0.0"  in the file Cartfile.resolved.why not 8.0.0-beta.4.
   `public var task: Moya.Task { get }` is now required, this adds it to the setup documentation. @AndrewSB Your example seems more clear to me, I can update. I think adding other Task types may be too complex for `Basic.md`, but I don't have a strong preference either way.
 ### SwiftLint found issues

#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 17 | Limit vertical whitespace to a single empty line. Currently 2. |
| Moya.swift | 28 | Limit vertical whitespace to a single empty line. Currently 2. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/758?src=pr) is 86.02% (diff: 100%)

> Merging [#758](https://codecov.io/gh/Moya/Moya/pull/758?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #758   diff @@
==========================================
  Files            30         30          
  Lines          2611       2611          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2246       2246          
  Misses          365        365          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [1b1edcf...3060956](https://codecov.io/gh/Moya/Moya/compare/1b1edcf782bdf9eea0fa0c55c18275904d35d1e6...3060956bbefaebc3a4e42ede9e46fbb639039c9e?src=pr)
  I have encountered below error when I updated Moya in Carthage.
I have found same issues and tried all suggestion. These didn't work for me.
Please help me!

```
The following build commands failed:
	CompileSwift normal arm64 /Volumes/Data/MyProject/Carthage/Checkouts/Moya/Source/Error.swift
	CompileSwift normal arm64 /Volumes/Data/MyProject/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift
	CompileSwift normal arm64 /Volumes/Data/MyProject/Carthage/Checkouts/Moya/Source/Image.swift
	CompileSwift normal arm64 /Volumes/Data/MyProject/Carthage/Checkouts/Moya/Source/Plugins/NetworkActivityPlugin.swift
	CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
(5 failures)
``` Carthage Version: 0.18.1
xcrun swift -version: Apple Swift version 3.0.1 (swiftlang-800.0.58.6 clang-800.0.42.1)
Xcode: Xcode 8.1 8B62

I also have an issue when resolving Moya dependencies in the following line
`RxCococa*** Building scheme "RxCocoa-iOS" in Rx.xcworkspace`

after I tried to rebuild the frameworks with `carthage update --platform iOS --no-use-binaries` (for the new Swift 3.0.1). Should this be posted in RxSwift or might this be resolved by updating the Cartfile in Moya?
The specific error in xcodebuilt output is `duplicate symbol __TMRbBp` in `...KVOObservable.o` and `...UIButton+Rx.o` which might be related to [this issue](https://github.com/ReactiveX/RxSwift/issues/970)
 I've got the same error of "RxCocoa Building error". 
 Hello, Andrew.
Thanks for your advice.
But it doesn't work for me also. I updated RxSwift from master repo again and also update Moya.
But same error occurred.
I don't know this is because RxSwift or Moya.
Thanks.
 @AndrewSB   I just tested a new project which has a Cartfile with only `github "ReactiveX/RxSwift" ~> 3.0`. Everything works fine.  And I tested a new project with only `github "Moya/Moya" "8.0.0-beta.2"`. I got this error:

```
The following build commands failed:
    Ld /Users/Alan/Library/Developer/Xcode/DerivedData/Rx-fruannoazmfefrheaohcpygimphr/Build/Intermediates/Rx.build/Release-iphoneos/RxCocoa-iOS.build/Objects-normal/arm64/RxCocoa normal arm64
    Ld /Users/Alan/Library/Developer/Xcode/DerivedData/Rx-fruannoazmfefrheaohcpygimphr/Build/Intermediates/Rx.build/Release-iphoneos/RxCocoa-iOS.build/Objects-normal/armv7/RxCocoa normal armv7
    CreateUniversalBinary /Users/Alan/Library/Developer/Xcode/DerivedData/Rx-fruannoazmfefrheaohcpygimphr/Build/Products/Release-iphoneos/RxCocoa.framework/RxCocoa normal armv7\ arm64
    GenerateDSYMFile /Users/Alan/Library/Developer/Xcode/DerivedData/Rx-fruannoazmfefrheaohcpygimphr/Build/Products/Release-iphoneos/RxCocoa.framework.dSYM /Users/Alan/Library/Developer/Xcode/DerivedData/Rx-fruannoazmfefrheaohcpygimphr/Build/Products/Release-iphoneos/RxCocoa.framework/RxCocoa
```
 Cleared derived data. Still got this error.
 I have deleted whole derived data.
Also checkout Moya from master.
Still get same error.
  Is it possible in Moya to have a request having both POST & GET parameters ?
For example, in my current API, GET API parameters are used for expanding the response.

POST: `{{base_url}}/user/authWithFacebook?expand=roles,facebook_friends,devices,accesses`

But I don't see how I can manage these kind of things actually, as if we define the request as POST request, all parameters will be sent as POST parameters.
 @ashfurrow I didn't test yet because back-end developers of this API made it possible to have expand parameter as `POST` parameter.

I never used Custom `ParameterEncoding`, but by reading your example, it's fit perfectly what I needed, I see how I could implement that.

You can close the issue, thanks for the tips !
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/753?src=pr) is 86.02% (diff: 100%)

> No coverage report found for **master** at 56ae5b2.
> 
> Powered by [Codecov](https://codecov.io?src=pr). Last update [56ae5b2...8a103ae](https://codecov.io/gh/Moya/Moya/compare/56ae5b26e3fda77912b0512bb577ef16d0cd4627...8a103ae967b289262fbe9c6eb96973d6782b67d7?src=pr)
  Moya saves a lot of time for me by supporting mocks like this:

```swift
    public var sampleData: Data {
        switch self {
        case .Lookup(let di):
           // return some sample data

```

Love it.

How could I now extend the testing mechanism, in Moya-fashion, to support:

- Empty responses / network timeouts / network errors
- 4xx/5xx responses, which according to the docs: "If the server responds with a 4xx or 5xx error, that will be sent as a ".success"-ful response."
- Empty 200 responses (I think already can do it)

Right now, I'm facing the problem that the App will crash when internet goes away during a long-running request and before devising a fix, I'd like to find a way to mock it. @ashfurrow , thank you very much, that solves it for me.

Regarding the documentation, it's actually clear once read carefully. 

My nitpick would be to link the section about `sampleData` (in https://github.com/Moya/Moya/blob/master/docs/Targets.md) to https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint, and to _highlight_ the note about unit tests there for easier readability. 

Moya is super powerful. Thank you all.
 @BasThomas no time at the moment, still busy in project work. Should be able to help in 1~2 weeks.
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/749?src=pr) is 86.02% (diff: 100%)

> No coverage report found for **master** at a9796d5.
> 
> Powered by [Codecov](https://codecov.io?src=pr). Last update [a9796d5...e716c97](https://codecov.io/gh/Moya/Moya/compare/a9796d56f02b1d0e28e874c4398548cb2e6affad...e716c97021c63f2f78d6fc14cdd9e47395f3ef0b?src=pr)
  I need to perform the following steps in order for my service to work:
1. GET csrf_token
2. Set csrf_token + jwt into http header
3. Return the response 

Is there a specific way where my endpoint enclosure is able to do a `GET` request using the same provider? Or would I need to invoke another provider within the endpoint enclosure to invoke another request to do my GET request?

``` swift
let endpointClosure = { (target: GameAppMoyaAPI) -> Endpoint<GameAppMoyaAPI> in

        let endpoint: Endpoint<GameAppMoyaAPI> = Endpoint<GameAppMoyaAPI>(
            URL: target.baseURL.URLByAppendingPathComponent(target.path).absoluteString,
            sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
            method: target.method,
            parameters: target.parameters,
            parameterEncoding: target.encoding
        )

        switch target {
        case .AuthenticateUser:
            return endpoint
        default:

            // 1. Check if token is expired from Locksmith
            // 2. If expired, GET new access_token with refresh_token
            // 3. Write new access_token back into Locksmith
            // 4. Else, add token from Locksmith to Header

            let dict = Locksmith.loadDataForUserAccount()

            // FIXME: This is temporarily in
            let access_token = dict!["jwt_token"] as! String

            // Need to add csrf_token to header for POST
            if target.method == .POST{

                // Would I be invoking another provider here?

                let csrf = ???


                return endpoint.endpointByAddingHTTPHeaderFields(
                [
                  "Authorization": "Bearer \(access_token)", 
                  "X-CSRFToken": csrf
                ])

            }

            return endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Bearer \(access_token)"])

        }
    }


let provider = RxMoyaProvider<MyMoyaAPI>(endpointClosure:endpointClosure)

provider.request(.PostRequest(parameter:some_parameter))
.subscribe{
...
}


```

Thanks!
 Update:

I created the following way to get my app to work, but do not know if this is best practice or proper design. Would love suggestions and feedback

``` swift
// moyaapi.swift

public enum MoyaAPI {

    case GetCSRF()    
    case AuthenticateUser(email:String, password:String) // 
    case RefreshAccessToken(expiredToken: String, refreshToken:String)

}

etc ...
```

``` swift
// customAPIClosure.swift


class MoyaAPIClosures{

    static let requestClosure = { (endpoint: Endpoint<MyAppMoyaAPI>, done: MoyaProvider.RequestResultClosure) in

        var request: NSMutableURLRequest = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest
        var thisEndpoint: Endpoint = endpoint

        // Do CSRF HERE

        print("Request Closure Config")

        if thisEndpoint.method == .POST{

            let csrfProvider = RxMoyaProvider<MyAppMoyaAPI>(endpointClosure: MoyaAPIClosures.endpointClosure)

            print("ENDPOINT CLOSURE CONFIG")

            csrfProvider
                .request(MyAppMoyaAPI.GetCSRF())
                .filterSuccessfulStatusCodes()
                .mapObjectOptional(CSRFToken.self)
                .subscribe{ e in
                    switch e {
                    case .Next(let token):

                        // Set HTTP Headers
                        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                        request.setValue(token?.csrf_token, forHTTPHeaderField: "X-CSRFToken")
                        request.HTTPShouldHandleCookies = true

                        // When using RxSwift returns must be done in closures

                        // The authProvider can make its own network calls to sign your request.
                        // However, you *must* call `done()` with the signed so that Moya can
                        // actually send it!

                        done(.Success(request))
                    case .Error(let error):
                        print(error)
                    default:
                        break
                    }
                }
            // DO NOT ADD disposeBag here ... request is not finished yet.

        }else{
            done(.Success(request))
        }


    }

    static let endpointClosure = { (target: MyAppMoyaAPI) -> Endpoint<MyAppMoyaAPI> in

        print("Endpoint Closure Config")

        let endpoint: Endpoint<MyAppMoyaAPI> = Endpoint<MyAppMoyaAPI>(
            URL: target.baseURL.URLByAppendingPathComponent(target.path).absoluteString,
            sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
            method: target.method,
            parameters: target.parameters,
            parameterEncoding: target.encoding
        )

        switch target {
        case .AuthenticateUser:
            // Authentication does not require httpheaders
            return endpoint
        default:

            // All authorized GET, POST requests require JWT

            let user = User()
            let userName = user.username
            let dict = Locksmith.loadDataForUserAccount(userName)
            let access_token = dict!["jwt_token"] as! String

            return endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Bearer \(access_token)"])

        }
    }
}
```

``` swift
// customvc.swift

class CustomTableViewController: UITableViewController {

    let rxProvider = RxMoyaProvider<MyAppMoyaAPI>(endpointClosure:MoyaAPIClosures.endpointClosure, requestClosure: MoyaAPIClosures.requestClosure, plugins:[NetworkLoggerPlugin(verbose:true)])
let disposeBag = DisposeBag()

    func updateGameData(){

        var listOfUpdates: [Dictionary<String,AnyObject>] = []

        // Explicit Data Updates
        for indexOfRowChanged in rowsChanged{
            let obj = DataArray[indexOfRowChanged]
            let quickDict:[String:AnyObject] = [
                "game_id": obj.gameID,
            ]
            listOfUpdates.append(quickDict)
        }

        // Return if no updates were made
        if listOfUpdates.isEmpty{
            return
        }

        rxProvider
            .request(MyAppMoyaAPI.GameData(
                UUID: aID!,
                updates: listOfUpdates)
            )
            .filterSuccessfulStatusCodes()
            .subscribe({ event -> Void in

                switch event{
                case .Next(let results):
                    print(results)

                    print("FINISH POST")

                case .Error(let _):
                    print("ERROR!!!")
                default:
                    break

                }
            }).addDisposableTo(disposeBag)
    }

}

```

So how this works is... When the Request/Endpoint is being created:
0. Checks if Endpoint/request is of POST method.
1. if it is POST: GET a CSRF Token from server
2. Injects token into request
3. Complete Async Request.

Questions: 
1. My problem here is should there be a Provider within another Provider?  The parent rxProvider has a csrfProvider embedded within the process. If not, how can I simplify this? Is there a better way of managing my providers?
2. Do all providers need to end with `.addDisposable(disposeBag)`? In my case, If i did do this with csrfProvider, it would have disposed the request and it would not have gone through to server. 

Thanks!
 @AndrewSB Thanks for the reply.

I understand you wrap your `provider` in a Networking class/struct. What is `NetworkingType` though? I'm not understanding what you're subclassing here... 

Where would my `requestClosure` and `endpointClosure` be? Also in the `provider`? I need to do be able to modify my request based on its HTTP methods.

Where does Networking's `request` function exist? Is it in the `Networking` class/struct?
If it exists within the same `Networking` struct/class... what is the `_` in front of `token`? And 

What exactly are you trying to do here:

``` swift
let actualRequest = self.provider
            .request(token)
            .filterSuccessfulStatusCodes()
            .catchError(parseMoyaError)
```

You're calling back on the same provider class and passing a token into the request? Or is it the API enum?

Does `OAuthTokenRequest` also exist inside of `Networking` class/structure, or in it's own seperate class? Also, what are the trade offs of using an `Observable` rather than `Endpoint`s?

If you can't provide the opensource version of it. Could you please provide me with a few gist? Thanks! 
 @AndrewSB I think my question should be... Did you wrap your provider within networking struct?

I'm trying to understand what is going on here with your protocol

``` swift
protocol NetworkingType {
    associatedtype T: TargetType, ProxyAPIType
    var provider: OnlineProvider<T> { get }
}

struct Networking: NetworkingType {
    typealias T = ProxyAPI
    let provider: OnlineProvider<ProxyAPI>
}
```

Where does TargetType and ProxyAPIType come from? 

My ultimate goal is to move from MoyaProvider to RxMoyaProvider for all my queries to the backend server if possible. In order for me to do this what would be the best way to structure my wrapper around my provider to be used?  Thanks! 

Really appreciate your help! 
  @AndrewSB Thanks! And is this code valid for swift 3 because i think they deprecated typealias for associatedtype?

I'm not sure if your OAuthtokens have expirations. But how have you been handling the expirations  of your tokens and retrieve a new one using the same wrapper provider? ... I'm using a singleton keychain to hold onto my tokens. I'm thinking of moving my token validation into my requestClosure to validate expiration of token and retrieve a new one from there with the same RxProvider. But I'm not sure how to structure my provider in such a way that I am able to do it. Was wondering if you had any input on this issue or ran into it yourself. Thanks! 

Reference:
https://www.natashatherobot.com/swift-protocols-with-associated-types/
 @AndrewSB Would love to see how your AuthToken.swift looks like. I'm a bit puzzled on how you were able to chain this request... I'm beginning to understand a little bit more about how you are chaining actual request to the authorized request.... Thanks! Really appreciate your help! 

Also, could you also give me a gist of what you are doing for the .error method you are calling? It seems to me it should have been returning a nil or an empty string... right? @AndrewSB Thanks man! I have a situation which would require me to chain the requests of two observables.. It is similar to what you already did.... 

Example: Say I have OAuthTokenRequest1 and OAuthTokenRequest2 that I have to chain together in the final request of Networking... how would you go about mapping these? 

I saw this was part of your code.
```swift
return OAuthTokenRequest().flatMap { _ in actualRequest }
```

But at the same time I would like to have a boolean determine when to chain and when not to chain

```

if requiresAuth1 and requiresAuth2{
  // Chain auth1 and auth2
}else if requiresAuth 1{
  return auth1().flatmap{_ in actualrequest}
}else if requiresAuth2{
  return auth2().flatmap{_ in actualrequest}
}

```

Thanks!  @AndrewSB, Lets say only post/put requests request requires a csrf token and a access token and on get requests it only requires the auth token

One of the request is to obtain a fresh crsf and the second is to validate the existing access token and then if it doesn't it has to obtain a new one as well and set it back into keychain prior to firing off the actual request.  

Apologies for the confusion. Let me know if you need more info 

My way of thinking of this was to do seperate csrfrequest and oauthrequest and then chain them together using boolean set on api

Thanks!  @AndrewSB Thanks for the tip! I got the following error after trying to use the observable.zip design pattern.... 

```
Cannot convert value of type '(_) -> Observable<Response>' to expected argument type '([_]) -> _'
```

is there something wrong with my function request that was wrapping the switch case?

```swift
func request(_ token: MidoriMoyaAPI) -> Observable<Moya.Response> {
    /// switch case....   
}
```

Thanks! @AndrewSB 

I tried this and it resolved... the problem... but I don't know if this is the proper way to sequentially do this.... 

```swift
            return CSRFTokenRequest().flatMap(){ _ in
                self.OAuthTokenRequest().flatMap{ _ in actualRequest}
            }
```

On another note,

I'm getting the following error using your method...:

```
Cannot convert value of type '(_, _) -> Observable<Response>' to expected argument type '(_, _) -> _'
``` @AndrewSB If OAuthTokenRequest is dependent on CSRFTokenRequest. Would zip still work? Or should it be be my proposed way of chain blocking? Would love your feedback on this. Thanks!  Just wanted to thanks @AndrewSB for detailed explanation and @rlam3 for all the questions I wanted to ask. üòâ 

Reading above discussion gave me more understanding on how to use Moya in real world scenarios. Thanks again! @AndrewSB I face a problem when the access token expires and multiple requests happen, that all request a new access token via the refresh token, at the same time.

I noticed that `Ello-iOS` is handling multiple unauthorized requests by call request/refresh token at a time and waiting for a new token on other requests.

I don‚Äôt see the similar feature on `Artsy Eidolon`.

Does `trackInFlights` will help. I didn‚Äôt see much information or document about it, just read in some related issues/commits?  This PR is related to #737 . Since `Cartfile.resolved` is back in #674 , this will bring the dependencies of Moya to the same stage.
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/747?src=pr) is 86.08% (diff: 100%)

> Merging [#747](https://codecov.io/gh/Moya/Moya/pull/747?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #747   diff @@
==========================================
  Files            29         29          
  Lines          2609       2609          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2246       2246          
  Misses          363        363          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [5a51cc9...f518687](https://codecov.io/gh/Moya/Moya/compare/5a51cc9a89acfaeaf95e4b281a7c7e5ba176f956...f5186876a9bb4bad3b276d4eb5455617380c269f?src=pr)
 No,  #737 does not make Carthage update dependencies _properly_, `Cartfile.resolved` should be updated together with `Cartfile` while running `carthage update --no-build`. 
 I'll update Cartfile.resolved with `carthage update` later, to keep dependencies to be same at this time, since this was a 10-days-ago commit.
 @AndrewSB  `carthage update`
 Great. I don't see any different. What does your `Cartfile.resolved` looks like now? Shouldn't this file be updated ? :)
 Yes, you're right. This file only affects `carthage bootstrap`.
  It sounds like Alamofire supports IPv6 with the caveat that reachability-type requests fail over IPv6. Does Moya work correctly over IPv6?
 I tested using an IPv6 DNS64/NAT64 network as specified in [Apple's documentation](https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW16) and everything seems to work as expected. I didn't have to configure Alamofire with a custom manager or make any other changes.

I'd say Moya is good to go for IPv6.
 It might be nice to know in the readme, but a quick search for IPv6 in the repo on GitHub will reveal this issue, too. üëç 
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/745?src=pr) is 86.08% (diff: 100%)

> Merging [#745](https://codecov.io/gh/Moya/Moya/pull/745?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #745   diff @@
==========================================
  Files            29         29          
  Lines          2609       2609          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2246       2246          
  Misses          363        363          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [da056cf...e6f5adf](https://codecov.io/gh/Moya/Moya/compare/da056cf54941eecc9b235c606cdb0cff0cf70ee0...e6f5adfa385628e6e36e79821e418ac9aeec224c?src=pr)
  I'm using Moya to talk to an API that may return HTTP 401 if a requests needs to be authenticated. Unfortunately, there's no way to know at the client if the session has expired or not, and the only way to know that is to make a request to an endpoint which requires authentication and checking the status code.

What I want to do is to make all requests to the authenticated endpoints automatically check the status code of the response, reauthenticate if needed and retry the request with the refreshed session. This way, my client doesn't need to know the specifics of the API and can just make simple requests without worrying about authentication. From what I understand, creating a `PluginType` would be the way to go. However, I'm not sure on how to replace the whole request on `didReceiveResponse`.

Is there a way to achieve this with the `PluginType` or am I completely on the wrong track here?
 I'm trying a naive implementation for this:

``` swift
public typealias AuthenticationBlock = (_ done: () -> Void) -> Void

public enum Error: Swift.Error {
    case missingAuthenticationBlock
    case invalidCredentials
}

public class RxAuthenticatedMoyaProvider<Target>: RxMoyaProvider<Target> where Target: Moya.TargetType {

    private let disposeBag = DisposeBag()

    public var authenticationBlock: AuthenticationBlock?

    public init(endpointClosure: @escaping MoyaProvider<Target>.EndpointClosure = MoyaProvider.DefaultEndpointMapping,
                requestClosure: @escaping MoyaProvider<Target>.RequestClosure = MoyaProvider.DefaultRequestMapping,
                stubClosure: @escaping MoyaProvider<Target>.StubClosure = MoyaProvider.NeverStub,
                manager: Manager = Alamofire.SessionManager.default,
                plugins: [PluginType] = []) {

        super.init(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, manager: manager, plugins: plugins)
    }

    public override func request(_ token: Target) -> Observable<Response> {
        return _request(token)
    }

    private func _request(_ token: Target, isSecondTryAfterAuth: Bool = false) -> Observable<Response> {
        return super.request(token)
            .flatMap { [unowned self] response -> Observable<Response> in
                if response.statusCode == 401 || response.statusCode == 403 { // We need to authenticate

                    if isSecondTryAfterAuth { // Server is still asking for authentication. Give up
                        return Observable<Response>.error(Error.invalidCredentials)
                    }

                    guard let authenticationBlock = self.authenticationBlock else {
                        throw Error.missingAuthenticationBlock
                    }

                    return Observable.create { observer in
                        authenticationBlock {
                            self._request(token, isSecondTryAfterAuth: true)
                                .subscribe { event in
                                    observer.on(event)
                                }
                                .addDisposableTo(self.disposeBag)
                        }

                        return Disposables.create()
                    }


                } else {
                    return Observable.just(response)
                }
        }
    }

}
```

I'm gonna document here the results for anyone who might stumble upon this in the future.
PS: @ashfurrow Am I on the right track here?
 @ashfurrow I think it would be nice to add a FAQ (or maybe a cookbook). This would definitely make it easier for people that are considering using Moya to see what it can do and how they might make it fit their requirements.
 Hello
I begin with Moya and RxSwift, i have a same problem like you, i want to know where i can add /make my request for refresh token?  And i don't understand the callback AuthenticationBlock.
And i want to know something, how i can change de header autorisation for the second try after auth
Thanks guy's    The default timeout >60s,I want to set it by myself.
  thanks!
 You can set it like as:

``` swift
import Foundation
import Alamofire

class DefaultAlamofireManager: Alamofire.SessionManager {
    static let sharedManager: DefaultAlamofireManager = {
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders
        configuration.timeoutIntervalForRequest = 20 // as seconds, you can set your request timeout
        configuration.timeoutIntervalForResource = 20 // as seconds, you can set your resource timeout
        configuration.requestCachePolicy = .useProtocolCachePolicy
        return DefaultAlamofireManager(configuration: configuration)
    }()    
}
```

and you should put DefaultAlamofireManager into the your provider like this:

``` swift
let Provider = MoyaProvider<GithubAPI>(endpointClosure: endpointClosure,
        manager: DefaultAlamofireManager.sharedManager,
        plugins: [NetworkActivityPlugin(networkActivityClosure: networkActivityClosure)])
```
 @AndrewSB how To Target special setup?
tks ```swift

public enum GitHub {
    case zen
    case userProfile(String)
    case userRepositories(String)
    case requestSomeThings
}

```

Github.requestSomeThings   may take a while, how to set timeout for this.

@AndrewSB  tks. yes„ÄÇ Oh that would be interesting for me too since I'd like to avoid reference Alamofire directly  I received a ton of Swift 3 compile errors in xCode 8 with the latest Moya - 8.0.0-beta.2.  XCode thinks it's an earlier version of swift.  
![screen shot 2016-10-25 at 3 33 07 pm](https://cloud.githubusercontent.com/assets/16111607/19706865/1fac56fa-9ac9-11e6-8ff6-81a98ef47b4e.png)

Here's my podfile:
<img width="414" alt="screen shot 2016-10-25 at 3 39 22 pm" src="https://cloud.githubusercontent.com/assets/16111607/19706882/3a3b205a-9ac9-11e6-99e2-e98567b9bfdd.png">

Here's the xCode error:
![screen shot 2016-10-25 at 3 23 55 pm](https://cloud.githubusercontent.com/assets/16111607/19706889/4367bd46-9ac9-11e6-92ab-3777daa9a478.png)
 support swift 3

``` ruby
pod 'Moya', "~>8.0.0-beta.2" 
```

I was used it. 
 What version of CocoaPods are you using? Be sure to use `1.1.0` as it contains some fixes for setting Swift version.
 Thank you marcelfabri and wilddylan.   I updated CocoaPods and I used the podfile syntac that WildDylan suggested and everythings working.   Thank you!.
 Examples:

``` ruby
pod 'Moya'
```

that means: ignore this framework's version, latest release version.

``` ruby
pod 'Moya', '0.9'
```

that means: only get version `0.9` 

``` ruby
pod 'Moya', '>0.1'
```

that means: any version bigger than version `0.1` which can be used.

``` ruby
pod 'Moya', '>=0.1'
```

that means: any bigger version or equal version which can be used.

``` ruby
pod 'Moya', '<0.1'
```

that means: any version less-than version `0.1` which can be used.

``` ruby
pod 'Moya', '<=0.1'
```

that means: less-than or equal version `0.1` which can be used.

``` ruby
pod 'Moya', '„Äú>0.1.2'
```

that means: from version `0.1.2` to `0.2`, but not contain version `0.2`, this is a `Range` of version.  >= 0.1.2 and <0.2.0.

and also, you  can use

``` ruby
pod 'Moya', :head
```

will get the latest version, but it's `risky`. or get from branch

``` ruby
pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'dev'
```

and you also can do this:

``` ruby
pod 'Moya', :configurations => ['Release', 'App Store']
```

only for appoint `build configuration`.

You also can download `Moya` to local, and use 

``` ruby
pod 'Moya', :path => '~/Documents/Moya'
```

Control source code by your self.

So, your question, Why install with 

``` ruby
pod 'Moya', "8.0.0-beta.2" 
```

will get some error, because Version `8.0.0-beta.2` not support swift 3, but `8.0.0-beta.3` support. so use

``` ruby
pod 'Moya', "~>8.0.0-beta.2" 
```

will get version `8.0.0-beta.3`.

verify it:
Create a new xcode project, and in Podfile:

``` ruby
pod 'Moya', "8.0.0-beta.2" 
```

and run pod install, you will get `8.0.0-beta.2`, and than, change it to:

``` ruby
pod 'Moya', "~>8.0.0-beta.2" 
```

and run pod update, you will get `Installing Moya 8.0.0-beta.3 (was 8.0.0-beta.2)` on your ssh screen.
  In my project, I have a ip list. When I send every request, I need to check which ip can be used, if not, I will try next ip. How to do it?
 Hey, sometimes, write a plug-in class for `validate` ip list and check it before request is better. But if you want to do what you mind, just create an array in any `Singleton` that contain all your ips, and then, in your own `TargetType` enum extension, return the `current ip` address from `Singleton` to `baseURL`. Next step, Make a request created with `MoyaProvider`, change the `current ip` in your `Singleton` when get `.failure(error)`. Loop this step, set a flag when get `.success(Response)`, just for break the loop.
  When doing a GET (using Postman) request from my backend the string looks like this:

`"En kort information om Passalen\r\n\r\nSer bra ut va? :)"`

But after using this command to get the string:

``` swift
let about = try moyaResponse.mapString()
```

Moya will transform the string and it will look like this:

`\"En kort information om Passalen\\r\\n\\r\\nSer bra ut va? :)\"`

How can I have the string unmodified?
 Anyone?
 What do you mean how I'm getting the value?

I'm just doing this:

``` swift
do {
    let about = try moyaResponse.mapString()
} catch {
    print(error)
}
```
 No I'm debugging the code and checking the value of `about`
 Yes looks like the original '\' are getting escaped and also the '"'

Do you have a solution for this?
 Seems that the response I got was content-type json so when I used mapJson() instead it was parsed correctly. Thanks for your help!
  Sometimes you don't want to add error handling code manually to every
request. Here is extension for `Observable` to add simple error handling:

``` swift
extension Observable {
    func showErrorHUD() -> Observable<Element> {
        return self.doOn { event in
            switch event {
            case .error(let e):
                // Unwrap underlying error
                guard let error = e as? Moya.Error else { throw e }
                guard case .statusCode(let response) = error else { throw e }

                // Check statusCode and handle desired errors
                if response.statusCode == 401 {
                    SVProgressHUD.showErrorWithStatus("Please log in again")

                    UserInfo.sharedInstance.invalidate()
                    Router.sharedInstance.popToLoginScreen()
                } else {
                    SVProgressHUD.showErrorWithStatus("Error \(response.statusCode)")
                }

            default: break
            }
        }
    }
}
```

Above is older, how to use in the latest version
 Have you tried replacing `doOn` with `do(onError:)`?
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/737?src=pr) is 86.08% (diff: 100%)

> Merging [#737](https://codecov.io/gh/Moya/Moya/pull/737?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #737   diff @@
==========================================
  Files            29         29          
  Lines          2609       2609          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2246       2246          
  Misses          363        363          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [da056cf...dbcf32f](https://codecov.io/gh/Moya/Moya/compare/da056cf54941eecc9b235c606cdb0cff0cf70ee0...dbcf32f70a172ac82ade31a6fe9a4c903e8a843f?src=pr)
  Sometimes a custom`PluginType` doesn't need to do anything in `willSendRequest` or `didReceiveResponse` but has to provide an empty implementation to conform. Adding a default implementation in an extension leaves the custom plugin free to implement either, none, or both functions.

Not quite sure if this is a good idea or not for the framework, but I've found it useful in my Moya-based projects.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/736?src=pr) is 86.02% (diff: 0.00%)

> Merging [#736](https://codecov.io/gh/Moya/Moya/pull/736?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.06%**

``` diff
@@             master       #736   diff @@
==========================================
  Files            29         30     +1   
  Lines          2609       2611     +2   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2246       2246          
- Misses          363        365     +2   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [da056cf...f959a0a](https://codecov.io/gh/Moya/Moya/compare/da056cf54941eecc9b235c606cdb0cff0cf70ee0...f959a0af3f2397ef2b71b1ef6b960e01c5377b85?src=pr)
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/735?src=pr) is 86.08% (diff: 100%)

> Merging [#735](https://codecov.io/gh/Moya/Moya/pull/735?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #735   diff @@
==========================================
  Files            29         29          
  Lines          2609       2609          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2246       2246          
  Misses          363        363          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [5f6fcae...4c9e59a](https://codecov.io/gh/Moya/Moya/compare/5f6fcaed0a3fe99a6569f43620633a8d76ed3cfb...4c9e59afca22ed862d222ecc71b11f3846504206?src=pr)
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/734?src=pr) is 86.08% (diff: 100%)

> No coverage report found for **master** at a0f1e00.
> 
> Powered by [Codecov](https://codecov.io?src=pr). Last update [a0f1e00...45142d9](https://codecov.io/gh/Moya/Moya/compare/a0f1e00b8f3a2e4739c101fdb4a90d317587d571...45142d9a64fdbdc0d59b0c40a1ebdb503acc539f?src=pr)
    ``` swift
let requestClosure: MoyaProvider<RequestAPI>.RequestClosure = { endpoint, done in
    let request = endpoint.urlRequest


    done(Result<NSURLRequest, Moya.Error>.Success(request))
}
```

error: Generic type Result speciallzed with too many type parameters (got 2, but expected 1)
 I have a similar issue.

The doc gives this example:

``` swift
let requestClosure = { (endpoint: Endpoint<ArtistsAPI>, done: MoyaProvider.RequestResultClosure) in
    let request = endpoint.urlRequest
    done(.success(request))
}
```

But Xcode will complain that:

``` bash
Member 'success' in 'Result<URLRequest, Error>' produces result of type 'Result<T, Error>', but context expects 'Result<URLRequest, Error>' 
```

How to fix that?
 ``` swift
let requestClosure = { (endpoint: Endpoint<GithubAPI>, done: @escaping MoyaProvider<GithubAPI>.RequestResultClosure) in
    var request = endpoint.urlRequest as URLRequest
    done(.success(request))
}
```

It works for me like as the above code.
 Thanks man
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/731?src=pr) is 86.09% (diff: 100%)

> Merging [#731](https://codecov.io/gh/Moya/Moya/pull/731?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #731   diff @@
==========================================
  Files            29         29          
  Lines          2610       2610          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2247       2247          
  Misses          363        363          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [0ffb350...5618f68](https://codecov.io/gh/Moya/Moya/compare/0ffb350f3e54f29dd30bb6393a1701f255135e09...5618f68bde279780da864c9379ff3c4276b695b4?src=pr)
  Thank you guys üëç
  This api `GET https://www.googleapis.com/blogger/v3/blogs/blogId/pages?status=draft&status=live&key={YOUR_API_KEY}
` from Google Blogger needs two values for status parameter. The statuses could be both `draft` and `live`. I have checked Moya documentation but seems this could not be done with parameters dictionary in the TargetType. Have any of you done the same thing like this before?
 I have applied that solution with no luck. Here is the URL in the console: `https://www.googleapis.com/blogger/v3/blogs/2093381839762195747/comments?fields=items,nextPageToken&status[]=live&status[]=spam`. Don't know why the `[]` happen right after the `status` parameter. They should not be there.

Here is target's parameters:

``` swift
case .CommentList:
    var parameters = [String: Any]()
    parameters["status"] = ["emptied", "live", "pending", "spam"]
    parameters["fields"] = "items,nextPageToken"
    return parameters
```

P/S: I am using Moya `8.0.0-beta.2`
 Here is the link to documentation of Google Blogger
[https://developers.google.com/blogger/docs/3.0/reference/comments/list](https://developers.google.com/blogger/docs/3.0/reference/comments/list)
  Seeing if this sorts out the Carthage issues in https://github.com/Moya/Moya/issues/726
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/727?src=pr) is 86.09% (diff: 100%)

> Merging [#727](https://codecov.io/gh/Moya/Moya/pull/727?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #727   diff @@
==========================================
  Files            29         29          
  Lines          2610       2610          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2247       2247          
  Misses          363        363          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [14a21cb...a9042d0](https://codecov.io/gh/Moya/Moya/compare/14a21cb0b7927f6d5a2d86e586ae221a64c3a9e3...a9042d09048021a84e344b5c480a4485eb3072b3?src=pr)
  The dependency update two-step is an interesting problem, is there a good way to circumvent this? Or do we just need to not update RxSwift because Moya is still requiring an older version?

Thanks!
 I'm currently getting some sort of cyclical dependency bug (I think) from Carthage when I do. It just keeps fetching RxSwift perpetually.
 Using my fork until the PR is merged, it does fix the issue.
  Relevant issues are travis-ci/travis-ci#6422 and travis-ci/travis-ci#6675 and travis-ci/travis-ci#6251. Seems like this is an issue not only in Circle CI, but also Travis CI, which the output of failure is something identical.
  Hi,

I am getting an error after updating to the latest release. Error message

> ParameterEncoding has no member JSON

My code

``` swift
public var parameterEncoding: Moya.ParameterEncoding {
        switch self {
        case .Search(_):
            println("parameterEncoding for .Search: JSON")
            return .JSON
        default:
            println("default parameterEncoding: URL")
            return .URL
        }
    }
```

I am using  this version of Moya 'Moya', '8.0.0-beta.2'

Please help

<!-- Please wrap code blocks in backticks, like so:
```swift
*your code goes here*
```

The code will automatically get its syntax highlighted, and doesn't need to be indented 4 spaces to be shown as code.

When referencing a dependancy manager-related issue (think CocoaPods, Carthage, SwiftPM), please add its configuration file to the issue.
It would be helpful to put the contents in a code block too, using ```ruby for CocoaPods and ```swift for SwiftPM.

Also please make sure your title describes your problem well. Questions end with a question mark.
-->
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/723?src=pr) is 86.09% (diff: 100%)

> No coverage report found for **master** at 3832192.
> 
> Powered by [Codecov](https://codecov.io?src=pr). Last update [3832192...b2b422d](https://codecov.io/gh/Moya/Moya/compare/3832192c4860d32fdbad2df5828d1590a4c7a2d7...b2b422d83e6c8238014a51d695dccdd1ce2d5218?src=pr)
 Would you mind filing a radar and including the logs, xcactivity, etc? We are very interested in resolving these issues. 
  I haven't found it anywhere and it seems that the Moya 8 milestone is empty: https://github.com/Moya/Moya/issues?q=is%3Aopen+is%3Aissue+milestone%3A%22Moya+8+%2F+Swift+3%22, so what is blocking Moya 8.0.0 to be released? 

My guess would be `ReactiveCocoa` and `RxSwift`. If so, couldn't we just pin their versions to their latest betas for now and once they're final we can make a new release. Thoughts?

Another (much more difficult) option would be making these subspecs projects themselves so that they can have their own release cycle. Of course that would break everyone's Podfiles üòÖ 
 My main issue with staying in beta is that the main reason seems to the optional subspecs dependencies and that only Moya 8 is compatible with Swift 3 - which is out for a while. I don't like the idea of "being stuck" because of RxSwift/RAC as none of those are dependencies of my project.

I know it's unfair, but just tried to expose my concern as others might have the same feeling.

I opened this issue to check if they were any other blockers and how I could help üòä 

Also, since we're here, it seems that there're a lot of changes since beta 2. Could we have a new beta? üòÖ 
 Thanks for the update, Ash! üíØ 
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/719?src=pr) is 86.09% (diff: 97.77%)

> Merging [#719](https://codecov.io/gh/Moya/Moya/pull/719?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.32%**

``` diff
@@             master       #719   diff @@
==========================================
  Files            29         29          
  Lines          2565       2610    +45   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits           2200       2247    +47   
+ Misses          365        363     -2   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [cdafa50...9399ae3](https://codecov.io/gh/Moya/Moya/compare/cdafa50849ee1e659dea2b38449b3f756f35d1ef...9399ae36254b31406589111c33abf160cdc4625e?src=pr)
  There are occasions where a base URL isn't available and the `sampleData` is relied on for all requests. For example:
- The app is in development and the API isn't available yet. 
- The app allows the user to switch to a 'demo mode' at runtime, where the provider relies only on `sampleData`.

What is the correct `NSURL` to provide as the `baseURL` in such instances? A simple `NSURL()` will result in fatal error `url is not valid` when the url is constructed by Moya:

``` swift
// Moya.swift
guard let stringURL = target.baseURL.URLByAppendingPathComponent(target.path)?.absoluteString else {
    fatalError("\(target) url is not valid")
}
```

The URL won't be accessed so should I try just sticking `google.com` in there? Even then, I still need to account for the fact that `NSURL(string: String)` returns an optional and `baseURL` does not, so if I either have to force unwrap, or fall back to `NSURL()` eventually:

``` swift
var baseURL: NSURL {
    return appDefaults.selectedShow.apiURL ?? NSURL(string: "http://google.com") ?? NSURL()
}
```

This all feels like I'm on the wrong track - is there something I'm missing? What is the best practice here?

I'm using Moya 7.0.2 on Swift 2.3. Thanks.
 Thanks Ash - still feels slightly fishy to have to provide a URL that should never be used, plus a fallback (`NSURL()`) that returns a known fatal error. What would the ramifications be of making `baseURL` optional, I wonder? Likely a can of worms, I guess?
 I think that's the right call. In my own example, if I don't have a URL string I'm debating whether to throw my own fatal error, let Moya do so, or output a warning and use `example.com` and it makes sense that I get to determine that.

I guess the [Basic Usage](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md) page is where the `!` first raises an eyebrow but I think that page does a nice succinct job of explaining setup and it probably wouldn't be a good idea to add it there.
  Fixes #701.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/717?src=pr) is 84.24% (diff: 0.00%)

> Merging [#717](https://codecov.io/gh/Moya/Moya/pull/717?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.13%**

``` diff
@@             master       #717   diff @@
==========================================
  Files            29         29          
  Lines          2496       2500     +4   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2106       2106          
- Misses          390        394     +4   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [0b2c725...fcc23d1](https://codecov.io/gh/Moya/Moya/compare/0b2c725d5e562aac0bee41f32a15bb89ac02c37b...fcc23d10767c0498cc2a82a6c54da30f8277921e?src=pr)
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          :white_check_mark: Well done.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/716?src=pr) is 85.90% (diff: 97.36%)

> Merging [#716](https://codecov.io/gh/Moya/Moya/pull/716?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **1.52%**

``` diff
@@             master       #716   diff @@
==========================================
  Files            29         29          
  Lines          2496       2561    +65   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits           2106       2200    +94   
+ Misses          390        361    -29   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [0b2c725...aba2187](https://codecov.io/gh/Moya/Moya/compare/0b2c725d5e562aac0bee41f32a15bb89ac02c37b...aba2187f480ca2e237a5d8e7be1741db09b8ed4b?src=pr)
 still not call .completed in RxMoyaProvider. That's possible. I don't think that scenario has been tested.   Hello, I am new to Moya, I would like to have a parameterised url and also httpbody as json. I followed the issue #431 using xcode 8 with swift 3. I am geting ambiguous error while compiling. Apart from that Issue #431 discusses about having custom parameterisation, but do not discuss on how do I pass url paramters and httpbody to the end point. Early help appreciated. Below is the code snippet

``` swift
import Foundation
import Moya
import Alamofire

public enum CCV2Api {

    case addContact(urlParam:[String:Any]?)
}

typealias MyAPICallCustomEncoding = (URLRequestConvertible, [String:AnyObject]?)throws -> URLRequest


let JsonArrayEncodingClosure: (URLRequestConvertible, [String:AnyObject]?) -> (URLRequest, NSError?) = { request, data in
    var req = request.urlRequest

    return (req!, nil)
}

let MyAPICallCustomEncodingClosure: MyAPICallCustomEncoding = { request, data in
    let sort = URLQueryItem(name: "sort", value: "distance")
    var req = request.urlRequest

    guard var components = URLComponents(string: (req?.url!.absoluteString)!)
        else {
            // even though this is an error, Alamofire ignores the returned error.
            return (req!)
    }
    //Create our query string params
    components.queryItems = [sort as URLQueryItem]
    req?.url = components.url
    req?.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")

        let json = try JSONSerialization.data(withJSONObject: data!, options: .prettyPrinted)


        req?.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
        req?.httpBody = json
    return req!
}

extension  CCV2Api: TargetType {

    public var baseURL: URL { return URL(string: "https://XYZ.com/v2")! }
    public var path: String {
        switch self {
        case .addContact(_):
            return "contacts"
        }
    }
    public var method: Moya.Method {
        switch self {
        case .addContact(_):
            return .POST
        }
    }
    public var parameters: [String: Any]? {
        switch self {

        case .addContact(let bodyParam):
            return bodyParam
        }
    }

    public var parameterEncoding: Moya.ParameterEncoding {
        switch self {
        case .addContact(let bodyParam):

            return ParameterEncoding.Custom(MyAPICallCustomEncodingClosure)
        }
    }
    public var sampleData: Data {
        return Data()
    }
    public var task: Task {
        return .request
    }

}
```

I get the below error message on ParameterEncoding.Custom
Ambiguous reference to member 'ParameterEncoding'. Am i doing something wrong?
 @BasThomas Even after changing to .custom still I am facing the same issue
 @sunshinejr Thank you for the information. Looking into documentation I have few questions

 Can I add httpBody in endPointCloser? If so, is it the right way of doing it rather creating custom parameterEncoding? How can I add httpBody in the EndpointCloser
 @sunshinejr Thank you. The reason for asking is I have to set url parameter as well as httpbody. The way I am looking is endpoint will have 2 arguments, one for url parameter and another is the httpbody. From #431 I can understand that Moya is supporting either httpbody or url parameter. Both cannot be accomplished.  The way I am looking is, url parameter can be set as it is by the Moya and the other parameter to the endpoint can be be added to httpBody in endpointCloser. Hope this is fine. Also I would like to know how to set the httpBody in the endpoint closer?
Thanks a lot  
 I am stuck,. Any help appreciated. 
 Resolved my self by using custom endpointClosure. For the POST method Moya treats it as BODY. In order to send both url parameter and Body parameter to the endpoint, for parameter return the body to be used and for the url parameters you can add the to url in endpoint closure.
  Using: 8.0.0-beta2

``` swift
var sampleData: Data {
  return Data(base64Encoded: "")!
}
```

Hi, When i want to use `Moya`, i find that:
What should i return when my request without sampleData?

Why not change sampleData to optional?
 After your comment, i tried to read source code of `Moya`. `sampleData` will be used as the default `EndPoint`:

``` swift
endpointClosure: @escaping EndpointClosure = MoyaProvider.DefaultEndpointMapping
```

And

``` swift
Endpoint(URL: url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
```

I think: `sampleData` should be cached response as you say: " I'll store this JSON as files and read them from disk when asked to", Why not change the `var sampleData: Data` to `var cachePolicy: Moya.cachePolicy`, cache expired date is read from response like that: `Cache-Control: max-age=3600, must-revalidate; Expires: Fri, 30 Oct 2016 14:19:41 GMT`.

It's simple for developer to use `Moya` with cache control.
 Return cached response when without network. Also as you say.  Let's talking about it. 
 Return previous requests is better, but is that the things Moya should do? I think it's the data-model's job. And we should not confuse the data-model with the service-model. this is my opinion... Nooooo, i recommand use this:

```objc
typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)
{
    NSURLRequestUseProtocolCachePolicy = 0,
    NSURLRequestReloadIgnoringLocalCacheData = 1,
    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // Unimplemented
    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,
    NSURLRequestReturnCacheDataElseLoad = 2,
    NSURLRequestReturnCacheDataDontLoad = 3,
    NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented
};
```
With header fields like `Cache-Control: max-age=3600, must-revalidate; Expires: Fri, 30 Oct 2016 14:19:41 GMT`, request cache-control is my original opinion.

------Edit-------

I think, request cache-control is useful.  I know this is wrong, but it does happen. :(

Currently, we have these properties for a target.

``` swift
public protocol TargetType {
    var baseURL: NSURL { get }
    var path: String { get }
    var method: Moya.Method { get }
    var parameters: [String: AnyObject]? { get }
    var sampleData: NSData { get }
}
```

Is there a easy way to extend this list to include `ParameterEncoding` as well?

Thanks
 wow,  sweet. 

Right on... Thank you.. üòÑ 

üçª 
  How did you setup that close issues?
 @BasThomas 

@BasThomas 
For example:

https://github.com/Moya/Moya/pull/563 MoyaBot helps in checking PR.

https://github.com/MoyaBot
 @BasThomas thanks!
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/709?src=pr) is 84.37% (diff: 100%)

> Merging [#709](https://codecov.io/gh/Moya/Moya/pull/709?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #709   diff @@
==========================================
  Files            29         29          
  Lines          2496       2496          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2106       2106          
  Misses          390        390          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [606fd46...1533583](https://codecov.io/gh/Moya/Moya/compare/606fd46080ed3e4eabdfa1d50cdbe6b103466c62...15335835ce0db9032f02c581f7b4db3acbccb690?src=pr)
  Hello,

I'm trying to upload an image to AWS and I receive the following response: "Bucket POST must contain a field named 'key'.  If it is specified, please check the order of the fields. ". 

Request Body:
 {"policy":"CiAgICA...",
"signature":"RYm9...",
"ContentType":"image\/jpeg",
"key":"7c20c...jpeg",
"AWSAccessKeyId":"AKI...",
"acl":"public-read"}

``` swift
public var parameters: [String: AnyObject]? {
  switch self {
    case let .UploadFile(data: dataResponse , file: _):
                        return [
                            "key" : dataResponse.filename,
                            "AWSAccessKeyId" : dataResponse.awsKey,
                            "acl" : "public-read",
                            "signature" : dataResponse.signature,
                            "policy" : dataResponse.policy,
                            "Content-Type" : "image/jpeg"
                        ]
  }
}

    public var multipartBody : [MultipartFormData]? {
        switch self {
        case .UploadFile( _, let file):
            let formData = [MultipartFormData(provider: .Data(file), name: "file", mimeType:"image/jpeg", fileName: "file")]
            return formData
        default:
            return []
        }
    }

```

Also, in the endpoint closure I change the headers to `assigned = ["Accept": "application/json", "Accept-Language": "", "Content-Type": "image/jpeg"]`  but they get overridden when the request is logged into 
`["Accept": "application/json", "Accept-Language": "", "Content-Type": "multipart/form-data; boundary=alamofire.boundary.05a9529d0374a3b8"]`

Anyway, I guess the headers aren't the problem because the content type is indeed multipart/form-data, but the question is: How can I change the order of the fields from body request or what would be another way to upload to AWS using MOYA?
  I looked at `.xcodeproj` targets.

As I understand, framework / target depends on RxSwift or ReactiveSwift ( choose either ).

How do you solve dependency for cocoapods and for carthage simultaneously?
 We don't solve it for both at the same time. For Carthage we use the xcodeproj and for cocoapods we use the podspec. 

For cocoapods you don't need a xcodeproj since we just need to define a file that says what our dependencies are, where the source files are etc. Later when a user uses cocoapods to install our library it creates a target based on the settings we provide. 
 @petester42 but there are ReactiveSwift and RxSwift in some targets. ( `import RxSwift` or `import ReactiveSwift` statements ) 

How do you build them in case of `carthage update`.
As I know, you can not tell `carthage update` about dependencies. It will download them and put in one pile. Only hosted app can make dependencies.

If your target has a dependency, it should make tricks with them to be carthage-compatible.
( As I mentioned above, ReactiveSwift or RxSwift )

So, how do you specify an 'optional' dependency from ReactiveSwift and from RxSwift for `carthage update`?
 @AndrewSB thank you for swift reaction! 
Not sure, it is a fat pull request. 
However, you use compiler directives to determine building choice. That's sound good.

However, Moya, as I understand, uses Alamofire under the hood ( dependency ).

Also there are several Moya versions - ReactiveMoya ( + ReactiveSwift ) and RxMoya ( RxSwift ).
So different version of Moya uses different set of dependencies.

Summing up my knowledge:

Moya has core that uses Alamofire.
ReactiveMoya uses Moya and ReactiveSwift.
RxMoya uses Moya and RxSwift.

Strange for Carthage.

Carthage idiom is 'module without dependencies'. All dependencies are linked together in your app ( final point ).

So, how do you make your scheme for Carthage?

ReactiveMoya: ReactiveSwift + Moya
Moya: Core + Alamofire
RxMoya: RxSwift + Moya

Cocoapods could solve this dependency tree in a several lines. 
Carthage can not. ( My knowledge ).
 We don't make the scheme for Carthage. We just make it a normal xcode scheme. We use Carthage to download the dependencies so that our schemes will compile by specifying a Cartfile. 

So what happens when someone uses Carthage to get Moya for their app. Carthage builds all Moya dependencies (by looking at all of the cartfile) and Moya itself (by looking at the xcodeproj). The developer now has to add Moya and all it's dependencies to their own scheme. You can't just include Moya, you have to include all the dependencies of the Moya version you want to use as well. 
 @petester42 @AndrewSB and also Moya uses Carthage/Build/<Module> in **Framework Search Paths**. It's clear now, thanks!
  @cocoatoucher Have you find out the solution?

Now you can create your own custom Plugin, may be named as `MyErrorPlugin`. Then you can parse your response data and change it to Error if need:

```ruby
public struct MyErrorPlugin: PluginType {
    func process(_ result: Result<Moya.Response, MoyaError>, target: TargetType) -> Result<Moya.Response, MoyaError> {
        let json = JSON(data: response.data)

        // Convert response.data to APIError instance
        guard let apiError = APIError(jsonData: json) else {
            return Result.success(response.data).
        }

        let userInfo = [NSLocalizedDescriptionKey: apiError.message, "httpStatus": response.statusCode, "areaStatus": apiError.errorCode, "url": response.request?.url?.absoluteString] as [String : Any]
        let mappedError: NSError = NSError(domain: "custom error domain", code: response.statusCode, userInfo: userInfo)

        return Result.failure(mappedError)
    }
}
```

So, you don't need to subclass `ReactiveCocoaMoyaProvider`  Hi,

I am getting couple of compilation errors in xcode 8. Please help me.

![screen shot 2016-10-04 at 1 07 00 pm](https://cloud.githubusercontent.com/assets/4919645/19065835/84ab32b6-8a33-11e6-83bc-d42ead54b110.png)
![screen shot 2016-10-04 at 1 06 49 pm](https://cloud.githubusercontent.com/assets/4919645/19065836/84dceb9e-8a33-11e6-9edf-cfdfba8976c7.png)

Update: Alamofire is throwing errors as well
![screen shot 2016-10-04 at 1 08 43 pm](https://cloud.githubusercontent.com/assets/4919645/19065872/c551d6ee-8a33-11e6-96d7-17b6946a8d01.png)
 ``` ruby
# Uncomment this line to define a global platform for your project
# platform :ios, '9.0'

target 'BetMe' do
  # Comment this line if you're not using Swift and don't want to use dynamic frameworks
  use_frameworks!

  # Pods for BetMe
  pod 'Firebase/Core'
  pod 'Firebase/Database'
  pod 'Firebase/Auth'
  pod 'SideMenu'
  pod 'TGLStackedViewController', '~> 2.0'
  pod 'Moya/RxSwift'
  pod 'Moya/ReactiveCocoa'
  pod 'SwiftyJSON'
  pod 'GMStepper'
  pod 'YUTableView-Swift', :git=> 'https://github.com/ujell/YUTableView-Swift.git', :branch => 'Swift3'
  pod 'SwiftDate'
  pod 'ScrollableGraphView'
  pod 'FoldingCell'
  pod 'STCollapseTableView'
  pod 'DLRadioButton', '~> 1.4'
  pod 'PageMenu'
  pod 'LiquidFloatingActionButton'
  pod 'SnapKit', '~> 3.0'
  target 'BetMeTests' do
    inherit! :search_paths
    # Pods for testing
  end

  target 'BetMeUITests' do
    inherit! :search_paths
    # Pods for testing
  end

end

```
 It did. Thanks a lot :)
  We are using Moya to build a caching layer on top of a restful service.  The way we uniquely identify requests in our system is via their URL, which we store into our data store (using Realm).   Specifically, we are using the `response?.URL?.absoluteString` property of `Response`.  We would like to test this functionality, but the only way to stub a response seems to be with a `EndpointSampleResponse`, which always has a `response` of `nil`.  

Is there any way we can open the response property up for stubbing?  Something like

``` swift
/// Used for stubbing responses.
public enum EndpointSampleResponse {

    /// Note the additional NSURLResponse field
    case NetworkResponse(Int, NSData, NSURLResponse?)

    /// The network failed to send the request, or failed to retrieve a response (eg a timeout).
    case NetworkError(NSError)
}

```
 Here is a PR: https://github.com/Moya/Moya/pull/717

One thing is that I ended up using an NSHTTPURLResponse not a plain NSURLResponse because those don't have status codes, let me know if you have thoughts on another direction here though.

Also, if we make this change we probably need to update the documentation, which I can do also do if you want.
  Hi all,

I'm currently trying to implement a cache solution with a custom URLCache (and modify some cache methods like in this example (http://stackoverflow.com/a/19847811), Moya/Alamofire and therefore I'm using a custom SessionManager with my provider which configures the URLCache to use.

Especially this part is interesting:

``` swift
// ...
URLCache.shared = myCustomURLCache
sessionConfig.urlCache = URLCache.shared
sessionConfig.requestCachePolicy = .returnCacheDataElseLoad
// ...
```

I pass the final manager to my `MoyaProvider`, but it seems, that the send request does not have the correct `RequestCachePolicy` set.

Now if I put some output in 
`func sendRequest(_ target: Target, request: URLRequest, queue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -> CancellableToken {`

I'm seeing this:

``` swift
print(manager.session.configuration.requestCachePolicy.rawValue) // correctly set
print(request.cachePolicy.rawValue) // wrong (always `useProtocol...`)
let alamoRequest = manager.request(request as URLRequestConvertible)
print(alamoRequest.request?.cachePolicy.rawValue) // wrong
```

I don't know if this is intended or maybe a bug in Alamofire as Moya is using the correctly configured `manager` to build the `alamoRequest`.

Is this behavior intended in any way?
 Also have this problem. I tried to set custom SessionManager with RequestRetrier that was introduced in Alamofire 4, but implementation of RequestRetrier protocol not invokes.
 _Edit: moved my comment in a new issue_
I opened a new issue concerning the request retrier, and will try to do a pull request with this functionality.
Of course you can still try and use this reference https://github.com/Moya/Moya/blob/master/docs/Examples/SubclassingProvider.md, but It would cause less surprise, if the Alamofire's requestRetrier worked transparently.
 Yes, I will do that tomorrow. I tested it and it works well :)
  You can't. It doesn't exist. 
  When I initially tried to initialize all parameters within one line, I found out that the parameters won't be removed from the request if their value is `nil`, nor unwrapped if they contain a value.
Added a hint to the example to avoid that wrong implementation for others.
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/694?src=pr) is 84.37% (diff: 100%)

> Merging [#694](https://codecov.io/gh/Moya/Moya/pull/694?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #694   diff @@
==========================================
  Files            29         29          
  Lines          2496       2496          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2106       2106          
  Misses          390        390          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [8e3e9a0...59f0003](https://codecov.io/gh/Moya/Moya/compare/8e3e9a08825a145de44dcb645938ddac4fca67a4...59f00032dd28aae83adbd73c864db403a0f2ba0c?src=pr)
  Changes for install on Readme for pod ReactiveSwift, for same in Podfile from Demo.
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  This seems to be related to #681 
Still trying to figure out how to set the encoding in Alamofire.request via Moya now.
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/689?src=pr) is 84.96% (diff: 94.44%)

> Merging [#689](https://codecov.io/gh/Moya/Moya/pull/689?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #689   diff @@
==========================================
  Files            29         29          
  Lines          2454       2454          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2085       2085          
  Misses          369        369          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [ff9a558...7b48a8e](https://codecov.io/gh/Moya/Moya/compare/ff9a5582440b7a0da4f91bf9c159c822fbbe26a2...7b48a8e84de4e1499c3faf38f18539ced54e7ed2?src=pr)
  Small updates for Swift 3 and respective framework updates in Readme.md and ReactiveCocoa.md
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/686?src=pr) is 84.96% (diff: 100%)

> Merging [#686](https://codecov.io/gh/Moya/Moya/pull/686?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #686   diff @@
==========================================
  Files            29         29          
  Lines          2454       2454          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2085       2085          
  Misses          369        369          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [517a145...68983ff](https://codecov.io/gh/Moya/Moya/compare/517a1452f65a23e4a52498dbae2daed27c3a8c9b...68983ff68851880e61743640b5a8be998222cc3f?src=pr)
  Currently the `urlRequest` [property](https://github.com/Moya/Moya/blob/master/Source/Endpoint.swift#L92) of a `Endpoint` is a IUO (Implicitly Unwrapped Optional). But this doesn't seems to be correct. Let's say if we think the `urlRequest` definitely exists (not true) then we should delete the `excalmatory mark` to make it non-optional at all. On the other hand, if we think the `urlRequest` might not exist (sometimes when the url is invalid or the encoding fails), then we should explicitly mark it as optional.

Although we could assume the user should be responsible for the risks, I like the latter assumption better. This PR made the `urlRequest` optional. And because the `hashValue` relies on the property, I have to change that as well. ATM, I'm using the URL as a backup if the request doesn't exist. (Might need to consider the parameters/parameterEncoding as well. method/headers won't effect.)

We can discuss the problem here or in a separate issue.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          :white_check_mark: Congrats.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 Updated the error type to include the corresponding url(path) and updated the change log as well. I would want to test the error case but have no idea where to start. Ideally I should create a new `TargetType` with some faulty url or by sending some faulty parameters. (by using some wired characters?) Right now we only have `Github` available.

BTW: tests passed locally. (`rake test`) Maybe I should revert the `Podfile.lock` file?
 @ashfurrow 
I just realise there's a struct called `ObjectIdentifier` which can help us get the unique identifier for `AnyObject` (it's different from `hashValue` property). And this brings up another question, since the `hashValue` property would be the same even when the `URLRequest` has different `httpMethod` as shown below.

``` Swift
let path = "www.google.com"
let url = URL(string: path)!
var request1 = URLRequest(url: url)
request1.httpMethod = "GET"
let request2 = URLRequest(url: url)
request2.httpMethod = "POST"
request1.hashValue // -506241750264670446
request2.hashValue // -506241750264670446
```

And the current implementation in the `requestNormal` function seems to treat the two requests the same as long as the have the same `hashValue` (as the key of the dictionary). Would this be a problem? 

I only had some experience developing web apps and I remembered you can use the same url endpoint with different methods to do different things such as `GET` & `DELETE`.... I could be wrong.
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">PR is classed as Work in Progress</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/683?src=pr) is 84.96% (diff: 100%)

> Merging [#683](https://codecov.io/gh/Moya/Moya/pull/683?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #683   diff @@
==========================================
  Files            29         29          
  Lines          2454       2454          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2085       2085          
  Misses          369        369          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [517a145...fb59431](https://codecov.io/gh/Moya/Moya/compare/517a1452f65a23e4a52498dbae2daed27c3a8c9b...fb59431070a1de52b62825faee773669f4cc9d95?src=pr)
 And... #689
  Hi!
I noticed a broken link on the page
https://github.com/Moya/Moya/blob/9bee1ff9117d2a743cfc39d57839473dbf470fe6/docs/Providers.md
The link is [Examples](Examples.md)
I would fix it myself but I'm not sure that I will do it correctly. Thanks.
  Any word on a fix for this? It is unclear to me at this point how to properly encode requests.

Edit: It seems that using `URLEncoding()` and `JSONEncoding()` instead of `Moya.ParameterEncoding.URL` and `Moya.ParameterEncoding.JSON` does the trick, for now at least.

As in:

``` swift
public var encoding: Moya.ParameterEncoding {
    if self.method == .GET || self.method == .HEAD {
        return URLEncoding()
    }
    else {
        return JSONEncoding()
    }
}
```
 Just a heads up, I'm using 8.0 Beta 2 in a framework project I'm working on and this is giving me fits. Using @RamwiseMatt solution in my endpoint closure:

``` Swift
let endpointClosure = { (target: RebatesProvider) -> Endpoint<RebatesProvider> in
  let url = target.baseURL.appendingPathComponent(target.path).absoluteString
  var encoding: Moya.ParameterEncoding = JSONEncoding()

  switch target.method {
    case .GET:
      encoding = URLEncoding()
    default:
      encoding = JSONEncoding()
  }

  let endpoint: Endpoint<RebatesProvider> = Endpoint<RebatesProvider>(URL: url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters, parameterEncoding: encoding)

  return endpoint
}
```

gives me the following compiler errors:

```
Undefined symbols for architecture x86_64:
  "type metadata for Alamofire.URLEncoding", referenced from:
      function signature specialization <Arg[0] = Owned To Guaranteed> of OffersKit.Rebates.(init () -> OffersKit.Rebates).(closure #1) in Rebates.o
  "type metadata for Alamofire.JSONEncoding", referenced from:
      function signature specialization <Arg[0] = Owned To Guaranteed> of OffersKit.Rebates.(init () -> OffersKit.Rebates).(closure #1) in Rebates.o
  "protocol witness table for Alamofire.URLEncoding : Alamofire.ParameterEncoding in Alamofire", referenced from:
      function signature specialization <Arg[0] = Owned To Guaranteed> of OffersKit.Rebates.(init () -> OffersKit.Rebates).(closure #1) in Rebates.o
  "protocol witness table for Alamofire.JSONEncoding : Alamofire.ParameterEncoding in Alamofire", referenced from:
      function signature specialization <Arg[0] = Owned To Guaranteed> of OffersKit.Rebates.(init () -> OffersKit.Rebates).(closure #1) in Rebates.o
  "static Alamofire.URLEncoding.default.getter : Alamofire.URLEncoding", referenced from:
      function signature specialization <Arg[0] = Owned To Guaranteed> of OffersKit.Rebates.(init () -> OffersKit.Rebates).(closure #1) in Rebates.o
  "static Alamofire.JSONEncoding.default.getter : Alamofire.JSONEncoding", referenced from:
      function signature specialization <Arg[0] = Owned To Guaranteed> of OffersKit.Rebates.(init () -> OffersKit.Rebates).(closure #1) in Rebates.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```

Commenting out my endpoint closure and removing it from the provider initializer causes everything to work just fine.
 @bryanbartow I got the same error of yours, and in the same context (a podspec that depends on Moya). What I did was to add Alamofire directly on the podspec. However, this is weird because we didn't have this issue on previous Moya versions ü§î 
 @sunshinejr Although I believe you had renamed the method cases in master by the time this came up, pod specs only allow you to point to releases and the 8.0.0 beta 2 tag/release still had uppercase cases. Either way, I don't think that's the issue.

@marcelofabri I'll give that a shot.
 @marcelofabri I forgot to report back on this. Following your suggestion of explicitly adding Alamofire to the podspec dependencies seems to have fixed this issue for me.
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/680?src=pr) is 84.96% (diff: 100%)

> Merging [#680](https://codecov.io/gh/Moya/Moya/pull/680?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #680   diff @@
==========================================
  Files            29         29          
  Lines          2454       2454          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2085       2085          
  Misses          369        369          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [515ae70...b43428d](https://codecov.io/gh/Moya/Moya/compare/515ae70902469ecc11f05a06aa95f6ff06e87167...b43428d2b265169e8d0badf21205d58d1ab1e3fc?src=pr)
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/678?src=pr) is 84.96% (diff: 100%)

> Merging [#678](https://codecov.io/gh/Moya/Moya/pull/678?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #678   diff @@
==========================================
  Files            29         29          
  Lines          2454       2454          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2085       2085          
  Misses          369        369          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [33d4724...4d84f63](https://codecov.io/gh/Moya/Moya/compare/33d4724790e775fdd94dbe48c9a5e7a2d8e6b698...4d84f631e46eec749f40028e7d12f1a72a4e7666?src=pr)
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/676?src=pr) is 84.96% (diff: 100%)

> Merging [#676](https://codecov.io/gh/Moya/Moya/pull/676?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #676   diff @@
==========================================
  Files            29         29          
  Lines          2454       2454          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2085       2085          
  Misses          369        369          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [25b8072...9c390b1](https://codecov.io/gh/Moya/Moya/compare/25b8072a2cffa3baff3aea90ed94afed2c03b076...9c390b1ca9f329a8ade26f4b9ae4faea691700c3?src=pr)
  Are you using cocoapods 1.1.0.rc.2? Using it fixed all my problems related to lint fails.
   @ashfurrow Would you like to rebuild it manually?
 Seems like Circle is complaining about RxSwift. I saw `error: assigning non-escaping parameter 'selector' to an @escaping closure` in this build.
 I've notice Moya is ignoring `Carthage.resolve` and `Carthage.parivate`. Should we move them back?
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/674?src=pr) is 84.96% (diff: 100%)

> Merging [#674](https://codecov.io/gh/Moya/Moya/pull/674?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **1.12%**

``` diff
@@             master       #674   diff @@
==========================================
  Files            29         29          
  Lines          2610       2454   -156   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits           2247       2085   -162   
- Misses          363        369     +6   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [b4a38c0...25e41b3](https://codecov.io/gh/Moya/Moya/compare/b4a38c0d4c40aa93faa5419dcf3834c017c66462...25e41b3ebf2b51d332c6ce879c8ca3bbbf943095?src=pr)
 For a library I don't see the resolved file being necessary since we don't really need to care which exact version we are using. Not having the resolved file means that if we specify ~> 2.2 then when someone builds Moya they will always get the most recent 2.2.x version without us having to run carthage update to update the resolved file.

At least, that is what I understood from reading the description of the resolved file.
 > Not having the resolved file means that if we specify ~> 2.2 then when someone builds Moya they will always get the most recent 2.2.x version without us having to run carthage update to update the resolved file.

Partly, that is what `~>` use for version requirement compatibility in Cartfile, since Carthage's compatibility is determined according to Semantic Versioning.

IMO, `Carthage.resolve` file is supplementary which describes the versions of Moya's _dependencies_.

Imagine this scenario: You saw Moya released a new version with patch, so  bumped your project to a new stage. However, some dependencies of Moya have new commits. (And this is why we should avoid using `github "SOME_DEP" "master/branch"` or `github "SOME_DEP" "https://github.com/XXX.git"` unless you indeed need it.)  You saw errors and ticketed an issue. Unfortunately, we don't exactly know why you are facing those errors, for the reason that our dependencies are totally different.

FYI: [cartfileresolved](https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#cartfileresolved)

Correct me if I am wrong. :)
 Circle CI timeout: pod install took more than 10 minutes üò¢ 
  Update these statements, `https://github.com/Moya/Moya/blob/master/docs/ReactiveCocoa.md` or that are in the readme? @ashfurrow 
 @ashfurrow I made a change in the ReadMe for Active installation equal to podfile Demo project. üëç  #693 
  ReactiveSwift is released! üéâ
 @ashfurrow ah, I have no idea why the test is failed.
 I just open https://github.com/Moya/Moya/pull/674,
This pull request has been deleted, unfortunately.
  Refactor code to remove xcode warnings
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Hey guys. I've got build errors when I try to update Moya by carthage:

`carthage update Moya --platform iOS`

Errors:

```
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:26:30: error: 'sendNext' has been renamed to 'send(value:)'
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:29:30: error: 'sendFailed' has been renamed to 'send(error:)'
                             send       error:
    public func sendFailed(_ error: Self.Error)
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:26:30: error: 'sendNext' has been renamed to 'send(value:)'
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:29:30: error: 'sendFailed' has been renamed to 'send(error:)'
                             send       error:
    public func sendFailed(_ error: Self.Error)
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:33:31: warning: result of call to 'add' is unused
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:26:30: error: 'sendNext' has been renamed to 'send(value:)'
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:29:30: error: 'sendFailed' has been renamed to 'send(error:)'
                             send       error:
    public func sendFailed(_ error: Self.Error)
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:68:26: error: 'sendNext' has been renamed to 'send(value:)'
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:76:30: error: 'sendNext' has been renamed to 'send(value:)'
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:79:30: error: 'sendFailed' has been renamed to 'send(error:)'
                             send       error:
    public func sendFailed(_ error: Self.Error)
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:76:30: error: 'sendNext' has been renamed to 'send(value:)'
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:79:30: error: 'sendFailed' has been renamed to 'send(error:)'
                             send       error:
    public func sendFailed(_ error: Self.Error)
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:76:30: error: 'sendNext' has been renamed to 'send(value:)'
/Users/Alan/Coding/Project/carthage/Moya/Carthage/Checkouts/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift:79:30: error: 'sendFailed' has been renamed to 'send(error:)'
                             send       error:
    public func sendFailed(_ error: Self.Error)
```

It seems ReactiveCocoa has changed sendFailed to send(error:), and sendNext to send(value:).
 Thanks. Waiting the new release.
 It works!.
Thanks!
   Swift 3 support is still a work-in-progress: #608.
 7.0.1 is the last version that is compatible with Xcode 7 / Swift 2.2. Moya 7.0.2 is compatible with Xcode 8 running Swift 2.3. #631 
 thank you
 I found the 8.0-beta version is compatible with iOS  9.0 and Swift 3. but which version is compatible with iOS  8.0 and Swift 3 ?
  @ashfurrow this task requires expanding the use of different classes? Or use more RxSwift and others?
 @ashfurrow There are some files that are not being found for example `Moya + Internal.swift`, is giving 404 error.
  @leoneparise and @sunshinejr 

the browser shows following request payload after the file upload

```
------WebKitFormBoundarycYWpVxvmArIdBkb5
Content-Disposition: form-data; name="__operation"

upload
------WebKitFormBoundarycYWpVxvmArIdBkb5
Content-Disposition: form-data; name="upFile"; filename="IMG_6543.JPG"
Content-Type: image/jpeg


------WebKitFormBoundarycYWpVxvmArIdBkb5--
```

and sent to following Request URL

> https://localhost:3000/api/handler/fileviewer/slave?__form_token=g36dn786ab&relkind=datatemplate.message&filelinkkind=&target=-1&tmpId=-1

to accommodate above request I have made following request

``` swift
enum TestApi {
    ...
    case PostFile(imageFile: AnyObject, token: String)
    ...
}

extension TestApi: TargetType {

    var baseURL: NSURL {
        switch self {
        case .PostFile:
            return NSURL(string: "http://192.168.9.121:3000")!
        }
    }

    var path: String {
        switch self {
        case .PostFile(_, let token):
            return "/handler/fileviewer/slave?__form_token=" + token + "&relkind=datatemplate.message&filelinkkind=&target=-1&tmpId=-1"
        }
    }

    var method: Moya.Method {
        switch self {
        case .PostFile:
            return .POST
        }
    }

    var parameters: [String: AnyObject]? {
        switch self {
        case .PostFile(_, _):
            return ["__operation":"upload"]
        }
    }

    var sampleData: NSData {
        return "".dataUsingEncoding(NSUTF8StringEncoding)!
    }

    var multipartBody: [MultipartFormData]? {
        switch self {
        case .PostFile(let imageFile, _):
            guard let data = UIImageJPEGRepresentation(imageFile as! UIImage, 1.0) else { return nil }
            return [MultipartFormData(provider: .Data(data), name: "upFile", mimeType:"image/jpeg", fileName: "photo.jpg")]

        default:
            return []
        }
    }
}
```
 ok the issue was with my the endpoint construction, I had to `stringByRemovingPercentEncoding` my url that was encoding my `?` character in url
  As discussed in #662 Response.mapJSON() could throw Error.jsonMapping here.
Otherwise the dedicated error type isn't used at all.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  It would be great If we have examples/demos and/or documentation for file uploads as well, I'm looking for multiple file uploads with other post data with it.

Thanks
  Hi all!

I'm wondering why there is an `Moya.Error` `jsonMapping`, but it isn't used anywhere.
Shouldn't mapJSON throw this error like this?

``` swift
func mapJSON(failsOnEmptyData: Bool = true) throws -> Any {
        do {
            return try JSONSerialization.jsonObject(with: data, options: .allowFragments)
        } catch {
            if data.count < 1 && !failsOnEmptyData {
                return NSNull()
            }
            throw Error.jsonMapping(self)
        }
    }
```
 Hi @sunshinejr! Alright, I've committed a pull request ‚úåüèº 
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Hello everyone,

I'm using Moya with pleasure but i'm facing a problem. I like seeing in XCode my REST requests be launched, with header fields, url and params.

Is it possible to add some debugRequest()/debugResponse() Observables to let us show or not full informations about what has been sent ?

I don't know how to do it but if there are some clue on Moya how to do it, I can try !

PS: same question for users who don't use RxSwift 

tag: question, enhancement, feature
 You completely right ! Sorry for this question, can be closed 
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Updated Alamofire and RxSwift versions
 ### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  PR addresses issue discussed in #473. It is non-breaking change. Appropriate unit-test added to ensure that request is provided upon receiving a response.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          :white_check_mark: Jolly good show.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/650?src=pr) is 67.22% (diff: 88.88%)

> Merging [#650](https://codecov.io/gh/Moya/Moya/pull/650?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.15%**

``` diff
@@             master       #650   diff @@
==========================================
  Files            16         16          
  Lines           653        653          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits            438        439     +1   
+ Misses          215        214     -1   
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/650/graphs/sunburst.svg?src=pr&size=150)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [7adb73a...302db1b](https://codecov.io/gh/Moya/Moya/compare/7adb73ae4736c4f02b4cf9e076c6ddaeb435c56a...302db1bda76188882760c5217e423e6f7054beb2?src=pr)
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Big PR</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>PR is classed as Work in Progress</del></td>
      </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Big PR</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  I find the [Realm](https://github.com/realm/realm-cocoa/blob/master/.github/ISSUE_TEMPLATE.md) template really useful.
 Totally agreed with @BasThomas. Some users don't know how to use code blocks. We can add some examples in issue/PR templates. For example:

<pre>
### What you did:
```swift
func example() {
  thisCodeWillBeFormatted(in: .swift)
}
```
### What you expected:
blah blah
</pre>
 I agree with @devxoul, templates are helpful for newcomer contributors.
  ```
Resolving dependencies of `Podfile`
[!] Unable to satisfy the following requirements:

- `Moya/RxSwift (from `https://github.com/Moya/Moya`, branch `swift-3.0`)` required by `Podfile`

Specs satisfying the `Moya/RxSwift (from `https://github.com/Moya/Moya`, branch `swift-3.0`)` dependency were found, but they required a higher minimum deployment target.
```

My podfile is:

``` ruby
  pod 'RxSwift', '~> 3.0.0-beta.1'
  pod 'RxCocoa', '~> 3.0.0-beta.1'
  pod 'Moya', :git => 'https://github.com/Moya/Moya', :branch => 'swift-3.0'
  pod 'Moya/RxSwift', :git => 'https://github.com/Moya/Moya', :branch => 'swift-3.0'
```
 I set it to iOS9.0
 ```
IPHONEOS_DEPLOYMENT_TARGET = 9.0;
```
 solved, thank you. I set the target in project build setting. I forgot to change the platform setting in pod file:

```
platform :ios, '8.0'
```
 why is that  "platform :ios, '8.0' ", moya 8.0.4 beta only support for IOS 9?  Hi,
I have a problem where I'm required to sort the request parameters before sending it ,Is there any way to sort request parameters? or sending it as String instead of a dictionary?
 @Henawey My initial thought would be to pass in a custom `RequestClosure` when you create your `MoyaProvider`. You can modify a request that's been assembled by Moya just before it goes out the door. So it should already be populated with your parameters and just need last minute adjusting by you.

See:
- [RequestClosure Documentation](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#request-mapping)
- [MoyaProvider Initializer](https://github.com/Moya/Moya/blob/7adb73ae4736c4f02b4cf9e076c6ddaeb435c56a/Source/Moya.swift#L58-L72)
 Yes, I do it with Custom `RequestClosure` and add string with structure I want I know this is not a good practice but solve the problem :)
  Any update ? <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="false">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/643?src=pr) is 73.46% (diff: 100%)
> Merging [#643](https://codecov.io/gh/Moya/Moya/pull/643?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

```diff
@@             master       #643   diff @@
==========================================
  Files            19         19          
  Lines           701        701          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            515        515          
  Misses          186        186          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [ea1406d...fc99d7e](https://codecov.io/gh/Moya/Moya/compare/ea1406d1547fc1721d36fb12c197411bdb5d5127...fc99d7e59e2e255980d13300125735cf222965d9?src=pr)  Hey! I'm trying to get Moya via Carthage as part of the following Cartfile: 

```
github "thoughtbot/Argo"
github "thoughtbot/Curry"
github "thoughtbot/Runes"
github "ReactiveX/RxSwift" ~> 2.0
github "Moya/Moya" ~> 7.0
```

Tried it on XCode 7.3 first, meanwhile upgraded to XCode 8 (because of Swift 2.3). I'm running 

``` bash
carthage update --no-use-binaries --toolchain com.apple.dt.toolchain.Swift_2_3 --platform mac
```

which gives me back

```
<..>/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: <..>/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
<..>/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: <..>/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
<..>/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: <..>/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
<..>/Carthage/Checkouts/Moya/Source/RxSwift/Moya+RxSwift.swift:2:8: error: module file's minimum deployment target is OS X v10.10: <..>/Carthage/Checkouts/Moya/Carthage/Build/Mac/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule
A shell task (/usr/bin/xcrun xcodebuild -project <..>/Carthage/Checkouts/Moya/Moya.xcodeproj -scheme RxMoya OSX -configuration Release -toolchain com.apple.dt.toolchain.Swift_2_3 ONLY_ACTIVE_ARCH=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:
** BUILD FAILED **

```

Hence I've opened the Moya project file, changed the deployments targets to 10.10 (in all OSX targets) and run

``` bash
carthage build --toolchain com.apple.dt.toolchain.Swift_2_3 --platform mac
```

This returns

```
<..>/Carthage/Checkouts/Moya/Source/Error.swift:12:18: error: use of undeclared type 'RxMoya'
<..>/Carthage/Checkouts/Moya/Source/Error.swift:12:18: error: use of undeclared type 'RxMoya'
<..>/Carthage/Checkouts/Moya/Source/Error.swift:12:18: error: use of undeclared type 'RxMoya'
<..>/Carthage/Checkouts/Moya/Source/Error.swift:12:18: error: use of undeclared type 'RxMoya'
<..>/Carthage/Checkouts/Moya/Source/Plugins/NetworkActivityPlugin.swift:27:51: error: use of undeclared type 'RxMoya'
<..>/Carthage/Checkouts/Moya/Source/Moya.swift:66:17: error: use of undeclared type 'RxMoya'
<..>/Carthage/Checkouts/Moya/Source/Moya.swift:66:17: error: use of undeclared type 'RxMoya'
<..>/Carthage/Checkouts/Moya/Source/Plugin.swift:15:44: error: use of undeclared type 'RxMoya'
A shell task (/usr/bin/xcrun xcodebuild -project <..>/Carthage/Checkouts/Moya/Moya.xcodeproj -scheme Moya OSX -configuration Release -toolchain com.apple.dt.toolchain.Swift_2_3 ONLY_ACTIVE_ARCH=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:
** BUILD FAILED **
```

Removing all those occurences gives the next error, something with `RxRxReactiveMoya` etc.

The `carthage update` at first was on a clean directory. No build directory, no checkouts.

Thanks in advance for having a look.
 The OS X 10.0 issue is the same thing I ran into with #636, but I didn't include OS target change with my other changes because I wasn't clear on the overall impact to the project.

For this issue, could the problem be an incompatibility between the version of RxSwift that you specify in your Cartfile (~> 2.0) and the one that Moya specifies (~> 2.6)? I ask because I created a sample OS X project, created a Cartfile with just Moya (~> 7.0), and after making the same changed you did to update the Moya OS X target to 10.0 my build was successful with:

```
carthage build --platform mac
```
 [Sorry for my late response]

Running a `carthage build --platform mac` after updating without version constraints on `RxSwift` and changing the deployment target to `10.10` gives me errors of the form 

```
<..>/Carthage/Checkouts/Moya/Source/Error.swift:12:18: error: use of undeclared type 'RxReactiveRxMoya'
public extension RxReactiveRxMoya.Error {
```

I'm wondering where this `RxReactiveRxMoya` namespace is coming from.   :/
 Hey,

I‚Äôm sorry but I‚Äôve stopped using Moya.  : /. In fact I‚Äôve stopped using Swift‚Ä¶ for the next months until some standardized package manager appears.  ; )

> Am 10.11.2016 um 14:13 schrieb Bas Broek notifications@github.com:
> 
> Is this issue still present in the latest release, @aphorisme https://github.com/aphorisme?
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub https://github.com/Moya/Moya/issues/642#issuecomment-259686598, or mute the thread https://github.com/notifications/unsubscribe-auth/AFVH-NQCX_zSfJ_y4ojLjUHCaWkjAE6aks5q8xiBgaJpZM4J-46N.
  Hello,

It could be cool to have a `7.1.0-beta` tag linked on the `swift-3.0` branch; 
this could help poeple who is waiting for a swift 3 Moya dependency in their podspec.

Cheers from France
 @BasThomas I talked about dependencies into podspec not into podfile: you can't specify url and branch into podspec, that's why a `beta`tag could be cool for beta ones
 @ashfurrow I'm not sure but if:
- A need B version 1.0
- In my Podfile I put
  - A
  - B version 2.0

There is no pod conflict ? üí≠ 
 Hi, 

Ok i will try this out !

EDIT: 
@ashfurrow have a look at this issue: [Moya-ObjectMapper issue](https://github.com/ivanbruel/Moya-ObjectMapper/issues/21)
There is conflict, even by telling directly in the pod to use `RxSwift` in version `3.0.0-beta.1`
 resolved yes
  ### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Just wondering why the .podspec  (of the Swift 3.0 version) has a minimum requirement of iOS 9. According to https://developer.apple.com/support/app-store/ iOS 8 is still 9% of the market share, and our app tends to target people with slower adoption rates.

Cheers!

Love the project and all your work in the iOS/Swift/MVVM community. Our product would be far worse off if you didn't exist ;)
  ### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Hi!

This adds a simple example of using Target's associated values as parameters for our requests. I've  chosen an example with a `Bool` value according to what you've pointed out at issue #518.
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/637?src=pr) is 67.07% (diff: 100%)

> Merging [#637](https://codecov.io/gh/Moya/Moya/pull/637?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #637   diff @@
==========================================
  Files            16         16          
  Lines           653        653          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            438        438          
  Misses          215        215          
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/637/graphs/sunburst.svg?src=pr&size=150)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [b0d7439...5229e60](https://codecov.io/gh/Moya/Moya/compare/b0d743991783c222b8b0675a255cc632a24c81e0...5229e60c0967d89db870bbcedeceb20fe51c596d?src=pr)
  This should fix #629.

I ran all 12 targets through the Swift 2.3 migration process, but did not make any other project changes (i.e. Update to recommended settings). All 12 targets compiled successfully with one exception: "RXMoya OSX" complained that the RxSwift module required OS X 10.10, but "RXMoya OSX" targeted 10.9. Once I updated the "RXMoya OSX" to target 10.10 the build was happy.

I tested this by updating the Cartfile in my test project to point to my local fork / branch, and the original compilation errors are fixed.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">No Changelog entries made</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 I believe so, though I am not sure what to make of the CI failures.

In my iOS project that is using RxMoya via Carthage, Xcode 8 and Swift 2.3, the changes in this PR fix the Carthage compilation errors and my project builds and runs correctly.
 Updated to 7.0.3, and everything is working. Thanks again!

I'll close #629.
  üò±

<img width="655" alt="screen shot 2016-09-15 at 11 43 33 pm" src="https://cloud.githubusercontent.com/assets/931655/18554165/42b0e192-7b9e-11e6-85f5-288c71b36874.png">
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 @ashfurrow Sounds interesting, thanks!
  Just updated from 7.0.0 to 7.0.2 and received an error in:

``` swift
public extension MoyaProvider {

    public final class func DefaultEndpointMapping(target: Target) -> Endpoint<Target> {
        guard let stringURL = target.baseURL.URLByAppendingPathComponent(target.path)?.absoluteString  else {
            fatalError("\(target) url is not valid")
        }
        return Endpoint(URL: stringURL, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
    }
}
```

`URLByAppendingPathComponent` is non-optional, but there is a "?".
What am I doing wrong? :)
 So what should i do to fix that ? @BasThomas 
 Hi,
pod 'Moya', '~> 7.0.0'
pod install
Using Moya (7.0.2) 

Drop to 6.5.0 working
O_o
 No,
pod 'Moya', '~> 7.0.0'
pod update
Installing Moya 7.0.2 (was 6.5.0)
 @sunshinejr thx.
 @BasThomas yep, thx for answer :)
 README needs to be updated...

<img width="307" alt="screen shot 2016-10-13 at 4 58 40 pm" src="https://cloud.githubusercontent.com/assets/5682879/19338092/6576ee46-9166-11e6-8756-9db5b1bd8deb.png">
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/633?src=pr) is 67.07% (diff: 100%)

> Merging [#633](https://codecov.io/gh/Moya/Moya/pull/633?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #633   diff @@
==========================================
  Files            16         16          
  Lines           653        653          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            438        438          
  Misses          215        215          
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/633/graphs/sunburst.svg?src=pr&size=150)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [ac898ea...52e4b96](https://codecov.io/gh/Moya/Moya/compare/ac898ea7c84d19efc7c1bedb0252452919335284...52e4b96df3a00b11afdfd08bc34a6ee2b6b2a507?src=pr)
   What version is still compatible with xcode 7 and swift 2.3?
 There's also a table in README now: https://github.com/Moya/Moya#moya-version-vs-swift-version
 @BasThomas Thanks! 
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/630?src=pr) is 67.07% (diff: 100%)

> Merging [#630](https://codecov.io/gh/Moya/Moya/pull/630?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #630   diff @@
==========================================
  Files            16         16          
  Lines           653        653          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            438        438          
  Misses          215        215          
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/630/graphs/sunburst.svg?src=pr&size=150)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [43d09f2...8c726c5](https://codecov.io/gh/Moya/Moya/compare/43d09f238856ca865527810146c918b38e776230...8c726c535d49dea0c4434b20c5c48d9b5c31da7c?src=pr)
  I ran into this issue initially with an existing project that had gone through the migration process to Swift 2.3, but I've also been able to reproduce it with a new "Single View Application" iOS project.

Carthage version: 0.18
Moya version: 7.0.2
Xcode version: 8.0 (8A218a)

After creating a new project, I add a Cartfile with the following contents:

```
github "Moya/Moya" ~> 7.0
```

Then:

```
$ carthage bootstrap --platform iOS
*** No Cartfile.resolved found, updating dependencies
*** Fetching Moya
*** Fetching RxSwift
*** Fetching Alamofire
*** Fetching Result
*** Checking out Alamofire at "3.5.0"
*** Checking out Result at "2.1.3"
*** Checking out ReactiveCocoa at "v4.2.2"
*** Checking out RxSwift at "2.6.0"
*** Checking out Moya at "7.0.2"
*** xcodebuild output can be found in /var/folders/d1/h0cf2xs12gv7w1wx5k41q7sc0000gp/T/carthage-xcodebuild.7jZFKG.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Result-iOS" in Result.xcodeproj
*** Building scheme "ReactiveCocoa-iOS" in ReactiveCocoa.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa.xcworkspace'.
*** Building scheme "RxBlocking-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxCocoa-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxSwift-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "RxTests-iOS" in Rx.xcworkspace
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
--- xcodebuild: WARNING: Unable to open project file '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.playground' in workspace '/Users/tim/tmp/MoyaTest/Carthage/Checkouts/RxSwift/Rx.xcworkspace'.
*** Building scheme "Moya iOS" in Moya.xcodeproj
** CLEAN FAILED **


The following build commands failed:
    Check dependencies
(1 failure)
** BUILD FAILED **


The following build commands failed:
    Check dependencies
(1 failure)
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
/Users/tim/tmp/MoyaTest/Carthage/Checkouts/ReactiveCocoa/ReactiveCocoa/Swift/SignalProducer.swift:1945:69: warning: 'buffer' is deprecated: Use properties instead. 'buffer' will be removed in RAC 5.0
A shell task (/usr/bin/xcrun xcodebuild -project /Users/tim/tmp/MoyaTest/Carthage/Checkouts/Moya/Moya.xcodeproj -scheme "Moya iOS" -configuration Release -sdk iphoneos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:
** CLEAN FAILED **


The following build commands failed:
    Check dependencies
(1 failure)
** BUILD FAILED **


The following build commands failed:
    Check dependencies
(1 failure)
```

The end of the build log shows what I think is the root issue:

```
/usr/bin/xcrun xcodebuild -project /Users/tim/tmp/MoyaTest/Carthage/Checkouts/Moya/Moya.xcodeproj -scheme "Moya iOS" -configuration Release -sdk iphoneos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean buildBuild settings from command line:
    BITCODE_GENERATION_MODE = bitcode
    CARTHAGE = YES
    CODE_SIGN_IDENTITY = 
    CODE_SIGNING_REQUIRED = NO
    ONLY_ACTIVE_ARCH = NO
    SDKROOT = iphoneos10.0

=== CLEAN TARGET Moya iOS OF PROJECT Moya WITH CONFIGURATION Release ===

Check dependencies
‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.
‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.

=== BUILD TARGET Moya iOS OF PROJECT Moya WITH CONFIGURATION Release ===

Check dependencies
‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.
‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.
```
 No worries, I know you are all working hard on the recent Swift/Xcode changes.

If I had to guess, it looks like the migration changes to the Moya project file weren't included in the commit with the other Swift 2.3 updates #(2fc967f).
 I've mostly got a PR together; just finishing up some testing. Expect to see it within a few hours.
 This is fixed with #636.
  today ,i updated my Xcode to 8.0 and found that moya does not support swift 3.0,what can i do then?
 @sunshinejr What if we need moya with rxswift and swift 3.0? 
What is the rxswift for moya?
 Hi @ashfurrow, I tried using the above but it doesn't seem to work as Moya/RxSwift is pointing to this branch of RxSwift (~> 3.0.0-beta.1). Is there any temporary solution to this?
 @BasThomas The RxSwift branch
<img width="361" alt="screen shot 2016-09-15 at 12 02 09 am" src="https://cloud.githubusercontent.com/assets/5516761/18541072/b3d4b03c-7ad7-11e6-983a-286d52315a08.png">
 use of undeclared type RxMoyaProvider...the same problem,how to slove
 waiting for answer Ôºåthank 
 you are right , i check my Podfile and modify it.
use this can slove it

``` ruby
pod "Moya/RxSwift", :git => "https://github.com/Moya/Moya", :branch => "swift-3.0"
```
 @sunshinejr thank you ,it works well
  I have recently updated to Xcode 8 and attempted to convert my existing projects to Swift 2.3. Even though I updated Moya to 7.0.1 through CocoaPods, the following build error persists from the following Moya source code (as a part of the extension of `MoyaProvider`): `Value of optional type 'NSURL?' not unwrapped; did you mean to use '!' or '?'?`

``` Swift
public final class func DefaultEndpointMapping(target: Target) -> Endpoint<Target> {
    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
    return Endpoint(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
}
```

Hope this can be resolved soon. Thanks very much!
 @ashfurrow Hi, I'm investigating this issue for also me.
There is `release-7.0.1` branch, and also there is `7.0.1` tag. However, that tag is tagged at the same commit which is tagged name specified as `7.0.0`. 
That branch is working in Swift2.3, I know. Perhaps, is that tag your mistake? if so, I want you to tag `7.0.1` on `release-7.0.1` branch.

Thanks.
 I still get the error. Seem that code was not updated?
 @BasThomas Yes, i'm using CocoaPods and pod version is 7.0.2. Try to set to 7.0.0 but it still load as 7.0.2?
 @ashfurrow Looks good after updating to 7.0.2. Thanks the team for your quick response!
 Oops, sorry, i'm using XCode 7.3.1/Swift 2.2. 
In #631 @ashfurrow told that 7.0.1 is latest version support Swift 2.2.. But i cannot install although i have specific version number in pod, it always get 7.0.2.

This is my pod:

```
    pod 'Moya', '~> 7.0.0'
    pod 'Moya/RxSwift', '~> 7.0.0'
    pod 'ObjectMapper'
    pod 'Moya-ObjectMapper/RxSwift', '~> 1.3.1'
```

Here is pod log:

> Installing Moya (7.0.2)
> Installing Moya-ObjectMapper (1.3.1)
> Installing ObjectMapper (1.4.0)
 Thanks @sunshinejr, i used wrong opertor :(. Thanks the team for yours really quick response!
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          3 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">PR is classed as Work in Progress</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Big PR</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  Lets say I have an API with endpoints 
- `/CreateUser`
- `/GetActivities` 
- `/GetSettings`

Should I create:
- `UserService`
- `ActivityService`
- `SettingsService`

And then `MoyaProvider<UserService>` ... `MoyaProvider<ActivityService>` and so on?

Or should should I just create one Service which manages all endpoints? 
Like `MoyaProvider<APIService>` ?

I don't really understand the architecture of Moya.
  Hi, I tried Moya 7.0.1 to support Xcode 8 & Swift 2.3 but failed, then I noticed that the tag in the new added [Moya 7.0.1 podspec (for Swift 2.3)](https://github.com/CocoaPods/Specs/blob/master/Specs/Moya/7.0.1/Moya.podspec.json) is 7.0.1 which identical to tag 7.0.0.

Could you please update the tag 7.0.1? Thanks
  Adding a mapping community extension to README.md: this time for Unbox
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/622?src=pr) is 67.07% (diff: 100%)

> Merging [#622](https://codecov.io/gh/Moya/Moya/pull/622?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #622   diff @@
==========================================
  Files            16         16          
  Lines           653        653          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            438        438          
  Misses          215        215          
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/622/graphs/sunburst.svg?src=pr&size=150)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [a65cdd7...6b704bb](https://codecov.io/gh/Moya/Moya/compare/a65cdd7dfd2ca9f618457b894e04b3da7883eb08...6b704bb3f2022f620c1ba2fc954c4d1c22889f9d?src=pr)
  This is based of of PR #616 

I know there are already 2 PR's for Swift 2.3 support, but there hasn't been any activity on them for a couple days. This is the only dependency that is blocking me from building my project on swift 2.3 so I figured I'd do what I can to get this working.

I've updated the demo project and the tests so that they all are able to run locally on my machine. Hopefully CI agrees.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/621?src=pr) is 67.07% (diff: 100%)

> Merging [#621](https://codecov.io/gh/Moya/Moya/pull/621?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.30%**

``` diff
@@             master       #621   diff @@
==========================================
  Files            16         16          
  Lines           653        653          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits            436        438     +2   
+ Misses          217        215     -2   
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/621/graphs/sunburst.svg?size=150&src=pr)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [d0c073b...5a7012e](https://codecov.io/gh/Moya/Moya/compare/d0c073b6bf538d8cc8d6a47c2de32d402ff8f0b8...5a7012e112c9b69d1958ced5df2360fb636d5fe6?src=pr)
 For anyone that is confused about what happened to the release with this change in it, see the referenced PR #594 for the discussion about what is happening
  my moya config

``` swift
public var method: Moya.Method {
    switch self {
    case .uploadPictureTest:
        return .GET
    case .register:
        return .POST
    case .login:
        return .POST
    }
}

public var parameterEncoding: Moya.ParameterEncoding {
    switch self {
    case .register:
        return ParameterEncoding.JSON
    default:
        return ParameterEncoding.Custom(MyAPICallCustomEncodingClosure)
    }
}
```

get this errror

```
Moya_Logger: [11/09/2016 15:53:17] Request: <NSMutableURLRequest: 0x7f801492de90> { URL: http://test.fragment.com.cn/rest/phone_register/new }
Moya_Logger: [11/09/2016 15:53:17] Request Headers: ["X-ApiKey": "xxx", "Content-Type": "application/json"]
Moya_Logger: [11/09/2016 15:53:17] HTTP Request Method: POST
Moya_Logger: [11/09/2016 15:53:17] Request Body: {"country_code":"86","phone":18815289863}
Moya_Logger: [11/09/2016 15:53:17] Response: Received empty network response for register("86", 18815289863).
```

How to solve this problem, thanks 
 not any status code return, this request is failed
 why get this error , i use OC call swift functionÔºåis this reason? swift project is fine.
 I solve it , it is my mistake . 

``` swift
class xxx: NSObject {
    let disposeBag = DisposeBag()
xxxx
}
```

will get this error
use static or shareInstance
 NOt getting the proper answer here . please reply  If I pass parameter as JSONEncoding getting response as Response: Received empty network response for login."  (Request Body: {\"email\":\"test@gmail.in\",\"device_id\":\"gddhshfs\",\"password\":\"123456\",\"device_type\":\"1\"}"])  And 


If I pass parameter as URLEncoding , still getting responce as  Received empty network response for login.

what is wrong ? can you please let me know how to add APIKEY to header ? 

let WebServiceProvider =  MoyaProvider<WebServices>(plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])


I have created like this, created ApiManager as in your demo
Server side is working proper as i tested it on rest client.  # Moya_Logger: [11/09/2016 15:53:17] Request Headers: ["X-ApiKey": "xxx", "Content-Type": "application/json"]

Moya_Logger: [11/09/2016 15:53:17] HTTP Request Method: POST
Moya_Logger: [11/09/2016 15:53:17] Request Body: {"country_code":"86","phone":18815289863}
Moya_Logger: [11/09/2016 15:53:17] Response: Received empty network response for register("86", 18815289863).

``` swift
let endpoint: Endpoint<RequestAPI> = Endpoint<RequestAPI>(URL: url,
                                                          sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
                                                          method: target.method,
                                                          parameters: target.parameters,
                                                          parameterEncoding: target.parameterEncoding,
                                                          httpHeaderFields: ["X-ApiKey": ApiKey,
                                                            "Content-Type": "application/json"])

public var parameterEncoding: Moya.ParameterEncoding {
    switch self {
    case .uploadPictureTest:
        return ParameterEncoding.URL
    case .register:
        return ParameterEncoding.JSON
    default:
        return ParameterEncoding.Custom(MyAPICallCustomEncodingClosure)
    }
}
```
 How/where to set the HTTP JSON body...this code is unusefule
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          :white_check_mark: Congrats.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</del></td>
      </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  What is the difference between requestclosure and endpointclosure?  Are they technically the same thing? They look very similar.

What are the different circumstances in which on would utilize them? 
Can they both be used together on the same provider?

The definition I'm getting from the following is that requestclosures sort of wrap around the endpoint? I'm trying to find a more concrete definition to distinguish the two. Thanks!

```
The next optional initializer parameter is requestClosure, which resolves an Endpoint to an actual NSURLRequest. Again, check out the Endpoints documentation for how and why you'd do this
```

Is there some sort of precedence that request closures follows after endpoint closures, or vice versa?
 @ashfurrow Would love to see more on authentication documentation using OAuth/JWT and how to store and mange tokens to be integrated with Moya. 

Because checking if a token is expired and updating the token prior to firing off an authenticated request is a synchronous task. I would like to see a proper way for authenticated requests to be organized with the use of keychain libraries like Locksmith.swift to manage tokens. 

Thanks!
 @ashfurrow thanks for the pointers to the authentication/oauth posts. I'm still a bit stuck on the point on how to actually get moya refresh an access token prior to firing off another authenticated request. 

I've been poking around the following code from eidolon and ello...

https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/Networking.swift

https://github.com/ello/ello-ios/blob/master/Sources/Networking/ElloProvider.swift

I see some similarities but also many diffferences. For instance, they are using a state machine to deal with authenticated requests. But how is eidolon checking if the token is expired and updating the access_token on the client side?

I saw the following piece of code, but this doesn't require the user credentials to return the token...

https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/Networking.swift#L51-L83

How is the access_token refreshed? Many Thanks!
 Hey @ashfurrow. I like that approach! I was thinking of something similar myself. I had a few of questions for you:

I assume you are using `NSUserDefaults` for persistence between app launches. That being said, I don't see a `.synchronize()` call anywhere, so are you just relying on the periodic automatic synchronization? It also looks like `AppDelegate` clears out the token values from user defaults at launch. If that is the case, then is using the defaults system as a on-disk cache useful at all? Is it just being used as an in-memory cache? If so, wouldn't you get the same effect by giving the `XAppToken` a static var to store an in-memory version of the current token? As much as I hate that sort of global state, it doesn't seem worse and is as testable as `NSUserDefaults`. Sorry if I am completely misunderstand the intention here. üò¨ 

Also, could you point me to where in the code you inject the tokens into the requests? I'm really interested in using a similar pattern, but this is my first go around with Moya and that's one of the last pieces of the puzzle for me. Thanks!
 @ashfurrow Is XAppTokenRequest different from a normal acess_token? I'm a bit confused here. Or is XAppTokenRequest supposed to request back a new JWT? 
 @ashfurrow This may not be the right thread to ask but I'm a little confused on how to retrieve the auth token from the response headers and was hoping you'd be able to help me understand how to access it?
 Awww thank you! My problem was I had to cast response.response as? NSHTTPURLResponse before it allowed me to use the .allHeaderFields["..."] function on it
  Updated project settings and one tiny change in MoyaProvider.swift
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 The podspec needs to be updated as well
  Changed the type of parameters to `[String: Any]` instead of `[String: AnyObject]`. This matches how `Alamofire` treats parameters.

BTW, I also created a [branch](https://github.com/KelvinJin/Moya/tree/swift3) that merges the [PR](https://github.com/Moya/Moya/pull/613) so that Moya will compiles with Xcode 8 GM with Alamofire 4.0.0-beta.2. Feel free to try it out if you need Moya support now.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  ### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  ### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  ### SwiftLint found issues

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Endpoint.swift | 97 | Force tries should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          :white_check_mark: Yay.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          2 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Big PR</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>PR is classed as Work in Progress</del></td>
      </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 We should also update README, docs and example, right? Don't mind updating TODO?
 Are there any commits that buildable with Xcode8GM?

I am trying to build Moya using Carthage, but some errors appear and build fails.

I forked Moya to my account and modify RxSwift dependency branch to "master" in Cartfile.

```
/Users/hiragram/Development/proj/Carthage/Checkouts/Moya/Source/Moya+Internal.swift:178:36: error: argument labels '(resource:, to:)' do not match any available overloads
/Users/hiragram/Development/proj/Carthage/Checkouts/Moya/Source/Moya+Internal.swift:194:13: error: value of type 'Request' has no member 'progress'
/Users/hiragram/Development/proj/Carthage/Checkouts/Moya/Source/Moya+Internal.swift:209:22: error: cannot call value of non-function type 'HTTPURLResponse?'
            .response(queue: queue) { (_, response: HTTPURLResponse?, data: Data?, error: NSError?) -> () in
```

It looks like dependency to Alamofire causes this error but I can't find what I should do.

I am working on my new personal iOS app project and going to start with Swift3 so anyone can help me? or Moya with Swift3 won't be available for a while?
 Actually, CircleCI supports Xcode 8 as well
https://circleci.com/blog/xcode-8-0-beta-support-for-ios-builds/
 Ah, sorry, didn't read it properly.
 Thank you a lot, you did a huge work out there.
I've got a question. Is there a particular reason why 'swift-3' branch has  s.ios.deployment_target = '9.0' ? 
 Regarding swift 3.0 I think we should change Alamofire from master branch to 4.0.0
Ref Link - https://github.com/Moya/Moya/blob/swift-3.0/Cartfile
 Also RxSwift should be changed from develop to 3.0.0-beta.1
 @ashfurrow here you go - https://github.com/Moya/Moya/pull/652
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/608?src=pr) is 79.48% (diff: 74.96%)

> Merging [#608](https://codecov.io/gh/Moya/Moya/pull/608?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **12.26%**

``` diff
@@             master       #608   diff @@
==========================================
  Files            16         33     +17   
  Lines           653       2623   +1970   
  Methods           0          0           
  Messages          0          0           
  Branches          0          0           
==========================================
+ Hits            439       2085   +1646   
- Misses          214        538    +324   
  Partials          0          0           
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [6b9b08d...17426f8](https://codecov.io/gh/Moya/Moya/compare/6b9b08df8c03366e9a0a9a029cfc21b35c32bc64...17426f87e4906c43b0b9eb26a231de8fcc5e0838?src=pr)
  Hello Moya team and thanks for this awesome library!

This is a very simple PR. It only completes documentation about `multipartBody` property on `TargetType` that was missing in **Targets.md** file.

Have a nice day!
 Thanks to you guys!
I'll be happy to improve this project when I can :)
  Hi, thank you for the cool framework!
I have parameters in request:

``` swift
case .SearchUPC(let ups):
      return [   "upc": ups,
                 "limit": 1  ]
```

On server side I am getting this:

``` json
{
  "upc": "9",
  "limit": "1"
}
```

How I can serialize parameters this way:

``` json
{
  "upc": "9",
  "limit": 1
}
```
 Thank you @ashfurrow I was surprised too. It looks pretty weirdly. I have checked all stuff twice and didn't find any reason for this behavior.
By the way, I have solved issue. Thank you for the help again!
 Hello @BasThomas I have changed server side for accepting ups in String. Not very good solution :)
I am wondered. Why this problem occurs only with me. I suppose it my fault.
  How do we debug the request being set over to backend servers? \

I'd like to be able to see exactly or print out the full request with headers parameters, etc... that is being sent over to servers when i'm doing rxswift with moya...

How exactly should we be using the .debug()? 

Thanks!
 @ashfurrow Thanks! 
  Following on from #600 and the suggestions of @vzsg 
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/603?src=pr) is 66.76% (diff: 100%)

> Merging [#603](https://codecov.io/gh/Moya/Moya/pull/603?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #603   diff @@
==========================================
  Files            16         16          
  Lines           653        653          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            436        436          
  Misses          217        217          
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/603/graphs/sunburst.svg?src=pr&size=150)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [48e3440...72b1c0a](https://codecov.io/gh/Moya/Moya/compare/48e34406ec76bf10d26b735f2071b654fdc18714...72b1c0a2240cef8f95226dd42ff827e7a8a5cbf5?src=pr)
 Cheers!  Would love to üòÑ 
  Hey there - I'm probably missing something suuuper obvious but is there an idiomatic Moya way for me to load stubs using .json local files?

Or should I just roll something myself and give an escaped string to `sampleData`.

Cheers! üòÄ
 I don't know about being idiomatic, but you could try this approach:

``` swift
var sampleData: NSData {
    let name: String

    switch self {
    case .Search:
        name = "sample_search"
        break
    }

    guard let path = NSBundle.mainBundle().pathForResource(name, ofType: "json"),
        data = NSData(contentsOfFile: path) else {
            return NSData()
    }

    return data
}
```

Provided you have a file named `sample_search.json` in your bundle.
 Aaaand I just realised that was exactly the way to go.  Just wanted to make sure there wasn't some nice way I could give a filename to `sampleData` rather than doing that myself.  I think the escaped JSON string in the README example for `sampleData` made me wonder whether I had to provide some kind of escaped variant of the data also.

Thanks for your help either way - appreciate it üòÉ 
 @ashfurrow hope #603 is up to scratch üòÑ 
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/599?src=pr) is 66.76% (diff: 100%)

> Merging [#599](https://codecov.io/gh/Moya/Moya/pull/599?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #599   diff @@
==========================================
  Files            16         16          
  Lines           653        653          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            436        436          
  Misses          217        217          
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/599/graphs/sunburst.svg?size=150&src=pr)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [70ade6c...19d8654](https://codecov.io/gh/Moya/Moya/compare/70ade6cd96b826d511041609b10c105cf4d88262...19d8654e459b3e347d547e2531a1e5d0533c47f7?src=pr)
  I tried all possible solution to upload image with moya but cant get proper way to upload it to server.
i tried same with alamofire and it is working fine.

can you please help me to upload image or multipart data using moya please ? 
your give demo project too complex to understand also cant find documentation for this in your documentation list.

Thanks in advance 
 Hello leoneparise,

Thanks for quick reply.
Still i am stuck in uploading image to server using Moya. 

Here is my code. Give me some solution please .. 

``` swift
enum SomeAPI {
  case ChangeProfileImage(guideid: String, profileImage: UIImage, remove_pic_id: String)
}

extension SomeAPI: TargetType {

  var path:String {
    switch self {
    case .ChangeProfileImage: return "/posts"
    }
  }

  var method: Moya.Method {
    switch self {
    case .ChangeProfileImage: return .POST
    }
  }

  var parameters: [String: AnyObject]? {
    switch self {
     case .ChangeProfileImage(let guideid, let remove_pic_id, _):
            let values = ["guide_id": guideid, "remove_pic_id": remove_pic_id]
            return values
    }
  }

  var multipartBody: [MultipartFormData]? {
        switch self {
        case .ChangeProfileImage(_, let profileImage, _):
            return [MultipartFormData(provider: .File(profileImage), name: "files", mimeType:"image/jpeg", fileName: "photo.jpg")]  //HERE IS ERRO: ARGUMENT PASSED TO CALL THAT TAKES NO ARGUMENTS
        default:
            return []
        }
    }
    }
  }
}
please help me to upload image. Thanks in advance
```
 <img width="926" alt="screen shot 2016-09-04 at 1 17 16 pm" src="https://cloud.githubusercontent.com/assets/15198865/18229763/2f8ad06e-72a2-11e6-9521-d8badce32a9e.png">
 Thanks for reply. i have implemented code you have given but i am still getting same error of argument passed to call that takes no arguments.

I am sorry i giving trouble to you but just stuck in that passing parameters things.

I have imported `Alamofire` to resolve undifined identifier error of "MultipartFormData"

My imports are as 

``` swift
import Moya
import RxSwift
import Moya_ObjectMapper
import ObjectMapper
import Alamofire
```

See the error below. Please correct me what i am missing??

<img width="983" alt="screen shot 2016-09-06 at 12 46 44 pm" src="https://cloud.githubusercontent.com/assets/15198865/18264962/db726006-7430-11e6-94fd-496b76bc7364.png">

Thanks in advance
 Installing Moya using pod command

``` ruby
pod 'Moya'
```

I hope it installing latest version of Moya
 I tried manually to install latest version like
pod 'Moya', '7.0.0'

but in that case is produce another error while installing pod like 

[!] Unable to satisfy the following requirements:
- `Moya (= 7.0.0)` required by `Podfile`
- `Moya (= 7.0.0)` required by `Podfile`
- `Moya (~> 6.0.0)` required by `Moya-ObjectMapper/Core (1.1.2)`
 You should update [Moya-ObjectMapper](https://github.com/ivanbruel/Moya-ObjectMapper/blob/master/Moya-ObjectMapper.podspec) to `1.3.1`, as it supports Moya 7.0. 
 Another error 

[!] Unable to satisfy the following requirements:
- `Moya-ObjectMapper/RxSwift (= 1.1.2)` required by `Podfile`
- `Moya-ObjectMapper/RxSwift (= 1.1.2)` required by `Podfile`

Specs satisfying the `Moya-ObjectMapper/RxSwift (= 1.1.2)` dependency were found, but they required a higher minimum deployment target.

Specs satisfying the `Moya-ObjectMapper/RxSwift (= 1.1.2)` dependency were found, but they required a higher minimum deployment target.
 Can you copy-paste your Podfile? Seems like you should also update `Moya-ObjectMapper/RxSwift` to `1.3.1`, but a Podfile would provide more info.
 ``` ruby
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'ALCameraViewController'

pod 'Google/SignIn'

pod 'FBSDKCoreKit'
pod 'FBSDKShareKit'
pod 'FBSDKLoginKit'

pod 'Locksmith'
pod 'LicensesViewController', '~> 0.5.0'
pod 'SwiftyTimer'
pod 'SwiftyJSON'
pod 'SwiftLocation', '~> 1.0'
pod 'SwiftyUserDefaults'
pod 'TPKeyboardAvoiding'
pod 'SDWebImage', '~> 3.7'
pod 'SnapKit', '~> 0.15.0'
pod 'R.swift'
pod 'RxCache', '~> 0.1.2'
pod 'OkDataSources'
pod 'OkDataSources/RxSwift'
pod 'SwiftGen'
pod 'Alamofire', '~> 3.1.0'

pod 'Google/CloudMessaging'
pod 'GoogleMaps'
pod 'GooglePlaces'

pod 'PKHUD'
pod 'Swinject', '~> 1.0'
pod 'RxSwift',    '~> 2.0'

pod 'ObjectMapper', '~> 1.1.0'
pod 'Moya', '~> 7.0.0'
pod 'Moya/RxSwift'

pod 'Moya-ObjectMapper', '1.3.1'
pod 'Moya-ObjectMapper/RxSwift', '~> 1.3'


```
 Try running `pod update` with the following pod versions.

``` ruby
pod 'Moya', '~> 7.0.0'
pod 'Moya/RxSwift', '~> 7.0.0'

pod 'Moya-ObjectMapper', '1.3.1'
pod 'Moya-ObjectMapper/RxSwift', '1.3.1'
```
 Awesome Guys!!
You are best. Its Working fine now,  Thanks For helping me.

One last question please

How to upload multiple images??
 Any solution for uploading multiple images??
 Hi

I'm using Moya for handling communication between my swift application and api, I'm able to post and get data but unable to post file to api server, following is my code

``` swift
enum TestApi {
  ...
  case PostTest(obj: [String: AnyObject])
  ...
}

extension TestApi: TargetType {

  var baseURL: NSURL {
    switch self {
    case .PostTest:
      return NSURL(string: "http://192.168.9.121:3000")!
    }
  }

  var path: String {
    switch self {
    case .PostTest:
      return "/api/file"
    }
  }

  var method: Moya.Method {
    switch self {
    case .PostTest:
      return .POST
    }
  }

  var parameters: [String: AnyObject]? {
    switch self {
    case .PostTest(let obj):
      return ["image": obj["image"]!]
    }
  }

  var sampleData: NSData {
    return "".dataUsingEncoding(NSUTF8StringEncoding)!
  }

  var multipartBody: [MultipartFormData]? {
    switch self {
    case .PostTest(let multipartData):

      guard let image = multipartData["image"] as? [NSData] else { return[] }

      let formData: [MultipartFormData] = image.map{MultipartFormData(provider: .Data($0), name: "images", mimeType: "image/jpeg", fileName: "photo.jpg")}
      return formData


    default:
      return []
    }
  }
}
```

 and following is the way I called

``` swift
return testApiProvider.request(.PostTest(obj: _file)).debug().mapJSON().map({ JSON -> EKResponse? in
  return Mapper<EKResponse>().map(JSON)
})
```

I dont receive no response and no hit was sent to the api server 
 @sunshinejr exactly that was the issue, 

Thankyou Sir
  Hey guys! There is a get request which might be in this format: 
`http://address.com?parameter1=["15", "19"]`
I tried many things: tried to pass array of int `[Int]`, try to pass array of String `[String]`, tried to generate simple string like `["15", "19"]`. In the last case it encodes with percent encoded string. For me no need to encode this parameter. What should I do? Please help
 I used already this solution with Custom parameter encoding. But It did not resolve a problem. 

``` swift
let AuthURLEncodingclosure: AuthEncoding = { request, data in
    var queryParameters: [NSURLQueryItem] = []
    for (key, value) in Session.authParameters() {
        let queryParameter = NSURLQueryItem(name: key, value: value)
        queryParameters.append(queryParameter)
    }

    if let data = data {
        for (key, value) in data {
            let queryParameter = NSURLQueryItem(name: key, value: "\(value)")
            queryParameters.append(queryParameter)
        }
    }
    var req = request.URLRequest as NSMutableURLRequest

    guard var components = NSURLComponents(string: req.URL!.absoluteString) else {
        return (req, nil)
    }

    components.queryItems = queryParameters
    req.URL = components.URL

    return (req, nil)
}
```

The problem is when I print req from last string - it is percent encoded(param1==%5B%2215%22,%20%22418%22)
 Thanks @ashfurrow ! Sorry for late response. We postpone this issue and will change api. 
It's bad expirience to use that kind of request parameters. 
And yes - I've try kind of string for the parameters. I generate it in a string messy way. 
This does not work. Waiting for api changes üòÑ 
  The example code at the bottom of the Examples/ErrorTypes page generates the following warning in Xcode:

‚ÄúConditional cast from 'Error' to 'Error' always succeeds‚Äù 

It is generated on the

`if let moyaError = error as? Moya.Error {`

 line.

Any ideas on how to get rid of that warning?

Thank you.
 I had tried that.   If you omit the ?, then you get an error which says:

`Enum case 'Some' not found in type 'Error'`
  I'm implementing something similar to the [OAuth example](https://github.com/Moya/Moya/blob/master/docs/Authentication.md#oauth), but in my case I'm wrapping a third-party API call as an RxSwift Observable. The success case works just fine, but I'm having a bit of difficulty with error types in the failure case.

``` swift
let requestClosure = { endpoint, done:RequestResultClosure in
    self.auth(endpoint.urlRequest)
        .subscribe { event in
            switch event {
            case .Error(let error):
                done(.Failure(...))
```

Since RequestResultClosure expects the failure to be a Moya.Error type, I can't use the error directly. Moya.Error.Underlying seems to be the intended way to handle these situations, but since it expects an NSError there are a few shortcomings with it's use; casting to NSError loses fidelity, and a mapping layer is a bit painful since the underlying error domain is part of the third-party library.

I know there have been discussions and changes in this area in the past, so forgive me if this is rehashing old conversations...

Question 1: Would it make sense to add another case to Moya.Error for wrapping underlying ErrorTypes?, something like:

``` swift
case UnderlyingErrorType(ErrorType)
```

Question 2: What about widening the type of RequestResultClosure to allow for a broader range of errors? Perhaps something like:

``` swift
public typealias RequestResultClosure = Result<NSURLRequest, ErrorType> -> Void
```

Question 3: Is this a non-issue once we have Swift 3 and [SE-0112](https://github.com/apple/swift-evolution/blob/7fcba970b88a5de3d302d291dc7bc9dfba0f9399/proposals/0112-nserror-bridging.md)?
 I've also ran into this issue. I've done a auth check in a requestClosure and found myself wanting to throw my own ErrorType. One way around this is to check for conditions that might throw errors beforehand by wrapping the request like is shown [here](https://github.com/Moya/Moya/blob/master/docs/Examples/WrappingInAdapter.md)

Although, if you need to add a header to the http request then you can't do everything by wrapping the Request, and still have to alter the headers in the requestClosure, which may have errors which you'll want to bubble down...
 Just a follow up. I've found an OK workaround for this:

In my request closure I am putting my own ErrorType into the underlyingError like so:

``` swift
let error = Moya.Error.Underlying(ErrorController.LocalError.NoCurrentUser as NSError)
done(Result.Failure(error))
```

Then by [wrapping the request](https://github.com/Moya/Moya/blob/master/docs/Examples/WrappingInAdapter.md) I am checking for the existence of the ErrorType, casting it, and throwing it. 

``` swift
func authenticatedRequest(token:AuthenticatedRemoteService) -> Observable<Response> {

        return Observable.create {[unowned self] observer in

            self.authenticatedRemoteService
                .request(token)
                .filterSuccessfulStatusCodes()
                .subscribe(
                    onNext:{ response in
                        observer.onNext(response)
                    },
                    onError: { error in

                        // If the underlying error is one of our own types. Then throw it as an Error Type.
                        if case Moya.Error.Underlying(let error) = error {
                            if (error as ErrorType) is ErrorController.LocalError {
                                observer.onError(error)
                                return
                            }
                        }

                        observer.onError(error)
                    }, onCompleted: {
                        observer.onCompleted()
                    }, onDisposed: nil)
                .addDisposableTo(self.disposeBag)

            return NopDisposable.instance
        }
    }
```

Not ideal but it seems to work.
  add support to swift 2.3
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 Excuse me, I may be wrong, but why Xcode version in CircleCI is set to "7.3.1"? Tests fail because of that I suppose. Looks like they support Xcode 8 already https://circleci.com/blog/xcode-8-0-beta-support-for-ios-builds/
 Are there any blockers on this besides updating `circle.yml`?
 Is there a plan on updating to 2.3/3.0? Xcode is GM now. I want to help with migration but don't know what is the right way to do it.
 any update on this being released?
 I think we should have a Swift 2.3 release üíØ 
 2.3 could be awesome. I don't think there will be much support for 3.0 until the middle of October and Moya is one if my 'blockers' (I still love it!).
 @ashfurrow You probably want to bump Alamofire version to 3.5.0 in the podspec as well üí™ 
(that PR only bumps in Cartfile)
 It should prompt you to migrate if `SWIFT_VERSION` is not set on the project (which #621 set).
 It seems it's working with CocoaPods, but apparently (at least one) breaking change got in: https://github.com/Moya/Moya/blob/7.0.1/Source/Target.swift#L10
 @ashfurrow I think all of them got in, since there are no commits to master after the tag üò¨ 

![](http://i.imgur.com/LY17PqB.png)
 All good from what I've seen üëç üéâ 
  add support to swift 2.3
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          :white_check_mark: Nice work.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  When your API grows. It looks like the enum of the Target swift file grows too.
Is there a way that this could made more modular? 

Is it to use multiple providers as the modular approach when architecting the API routing with Moya?  Like a 1 resource per 1 target approach is all I can think of. 

But problem arises when a situation like `if checking JSON Web Token` are expired prior firing off an async request. If authentication/JSON Web Token is one resourceTarget and obtaining a resource like user profile is dependent on JSON Web Token. How do we collectively provide enough modularity that both will work together synchronously? 

I'm not sure if it is be a good idea to use a class based router instead of enums approach.

``` swift

//API.swift
class API{
// base url
// token
// generic calls
}

//authentication.swift
extension API{
// func authenticateUser
}

//getUserProfile.swift
extension API{
// func getResource
// func postResource
// func deleteResource
}

```

Or is this it recommended to just use one provider in a large file? 

I'm new to Moya. Thanks!
 The man @colinta always throws around the Ello API as an example. See the `networking/` dir for examples: https://github.com/ello/ello-ios/tree/master/Sources/Networking

The real magic is in [ElloProvider](https://github.com/ello/ello-ios/blob/master/Sources/Networking/ElloProvider.swift) though.

I've borrowed heavily from it in the past. IMO, the provider set up is all about what your project needs. `TargetType` provides enough flexibility that you can request different URLs with the same provider, however, as you mentioned, you might have different requirements for different APIs.

Personally, I set up a provider per API service. In my current project, I created a `MyProjectAPI` struct, which manages providers and a singleton instance. The struct has a static method named  

``` swift
request(target: MyProjectAPI.Target, queue: NSOperationQueue, progress: ReactiveMoya.ProgressBlock)
```

on it. When you invoke something like `MyProjectAPI.request(.SignIn(username, password))`, it grabs the default provider, which is configured with a custom `endpointClosure` (to add headers/auth fields to the request based on the `Target`), and plugins. Since I use `ReactiveMoya`, I just added parsing the JSON response as an extension on `SignalProducerType`, so my API looks like this:

``` swift
let target: MyProjectAPI.Target = .SignIn(username, password)
MyProjectAPI.request(target)
  .mapSignInResponse()
  .flatMap(.Latest) { // Do some work on the mapped response }
```

The `request` method also handles checking the response for errors related to authentication, and will post a notification if the user is not authenticated, to which I respond by kicking the user back to sign in.

Ultimately, the decision is up to you. In the example above, I'm only interacting with a single API, so wrapping it into a single struct seemed best. Ello has a very similar set up. In the Moya example project, you can see that we set up a provider per API service.
 @justinmakaila Would love to your take on how to implement Moya with an authentication of using JWT. But prior to firing off each request back to the server, the token is to be checked, and if expired, the token should be refreshed prior to firing off the next request. I know this has something to do with promises, but I'm sure where I can some how do a callback wrapper per request with moya. 

Looking at the OAuth approach, I cannot seem to see the connection between how to refresh a token prior to firing off the next request. 
1. What is the difference between requestClosure and endpointClosure when we create a MoyaProvider instance?

I've been trying to follow the Authentication.md documentation from Moya but still have a few question that I need to clear up.
1. Is YourAPI the `Target` for which we have to seperate Authentication Target and another one for GET/POST a resource Target? Or Do we keep it as one cohesive structure and use the same provider for authentication / fetch resource?
2. YourAwesomeOauthProvider... Is this a seperate Provider/Library I have to get for JWT to work or is it another instance of from MoyaProvider? 
3. At the let provider = MoyaProvider line, is this now being wrapped by requestClosure? where it now knows 

``` swift
let requestClosure = { (endpoint: Endpoint<YourAPI>, done: NSURLRequest -> Void) in
    let request = endpoint.urlRequest 
    YourAwesomeOAuthProvider.signRequest(request, completion: { signedRequest in
      // The OAuth provider can make its own network calls to sign your request.
      // However, you *must* call `done()` with the signed so that Moya can
      // actually send it!
      done(signedRequest)
    })
}
let provider = MoyaProvider(requestClosure: requestClosure) <<< So is every request with this provider wrapped with request closure to check for token expiration?
```

Would greatly appreciate it if you could point me to how to refresh an access token prior to firing off another request. 

Thanks!
  Hello,

Alamofire and RxSwift have updated their pods recently to meet swift 3 requirements, and change their major versions (Alamofire 4 and RxSwift 3). We are using them now in our app, but Moya, even in the swift 3 branch, needs older versions.
Also the code in the swift 3 branch seems outdated comparing to master.
We're kind of stuck and can't continue our migration to swift 3 now because of that. We will give a shot to update the code by ourselves but I'm not sure It will be easy for us to do it.
So I was wondering, do you plan to update Moya soon or are you waiting for the GM version of XCode to update your code ?

Thanks a lot.

Kind regards,
Denis
 OK thanks for the comment! I will track also this issue :)
We're trying to redo the migration from master since this morning, but we have many errors...
 I'm trying to get the demo app building with Alamofire 4 and RxSwift 3.0.0.alpha.1 and am having issues with Cocoapods. Changing the `libraries` target in the podfile to require these:

```
def libraries
  pod 'Moya', :path => "../"
#  pod 'Moya/ReactiveCocoa', :path => "../"
  pod 'Moya/RxSwift', :path => "../"
  pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :tag => '4.0.0-beta.2'
  pod 'RxSwift', '~> 3.0.0.alpha.1'
  pod 'RxCocoa', '~> 3.0.0.alpha.1'
#  pod 'ReactiveCocoa', :git => 'https://github.com/mhuusko5/Podspecs.git', :branch => 'swift3.0'
end
```

and running `pod install` or `pod update` generates the following error:

```
Analyzing dependencies
Pre-downloading: `Alamofire` from `https://github.com/Alamofire/Alamofire.git`, tag `4.0.0-beta.2`
Fetching podspec for `Moya` from `../`
Pre-downloading: `Nimble` from `https://github.com/Quick/Nimble.git`, branch `swift-3.0`
Pre-downloading: `Quick` from `https://github.com/Quick/Quick.git`, branch `swift-3.0`
[!] Unable to satisfy the following requirements:

- `RxSwift (~> 3.0.0.alpha.1)` required by `Podfile`
- `RxSwift (~> 3.0.0.alpha.1)` required by `Podfile`
- `RxSwift (~> 3.0.0.alpha.1)` required by `Podfile`
- `RxSwift (~> 3.0.0.alpha.1)` required by `Podfile`

Specs satisfying the `RxSwift (~> 3.0.0.alpha.1)` dependency were found, but they required a higher minimum deployment target.
```

Looking at the [Cocoapods source](https://github.com/CocoaPods/CocoaPods/blob/a2be2d30e7311a5ed33888fd32b3e42d90c768ab/lib/cocoapods/resolver.rb#L435), it looks like this error is actually a catchall for a general failure to resolve dependencies. I've tried updating the `platform` in both the `test_pods` and `Demo` targets to iOS 9.0 but it doesn't help. There's also no reason why the minimum target should be bad, given that RxSwift 3.0.0.alpha.1 [targets iOS 8.0](https://github.com/ReactiveX/RxSwift/blob/3.0.0.alpha.1/RxSwift.podspec#L30).

Does anyone have any idea why this error would be generated? Or, failing that, has anyone been able to get the demo app running with AF4 and RxSwift 3?
 I'm in holidays for 2 weeks, so I don't have any issue :).
If it's ok for you, you can close the issue, I will test it at the end of the month, and keep you posted if there's a problem.
  Hi,
I am new to Moya.
Working on Basic.md and try to stub response, `endpointClosure` is called, but then `sampleResponseClosure` won't be called.
I don't know very well about architecture of Moya, but I want you to confirm that instruction on Basic.md is correct.
 I'm using v7.0.0
 I found the answer by myself.
I had to pass `stubClosure` and return .Immediate to perform `endpointClosure`.

If needed, I will update Basic.md and create pull request.
  Should Moya be used in conjunction with Promise?
 @colinta Is there a reason for you guys to choose FutureKit over PromiseKit? 
 @colinta the source code seems to be missing. Please update? Thanks!
 Here is an example of implementation I did with PromiseKit, the first is Moya native, the second is a promise which wrap the native call. Of course you don't need the first request is you only use Promises, this is for example:

``` swift
    /// Load Place object fullfilled by Google Place API Details response
    ///
    /// - Parameter query: placeID, id of the place to be loaded
    static func getPlace(
        placeID: String,
        success successCallBack: @escaping (Place) -> Void,
        error errorCallback: @escaping (_ error: Moya.Error) -> Void
        ) {
        self.request(
            target: .placeDetails(placeID: placeID),
            success: { response in
                do {
                    let place = try response.mapObject(Place.self)
                    successCallBack(place)
                } catch {
                    errorCallback(.jsonMapping(response))
                }
            }) { error in
                errorCallback(error)
        }
    }
    static func getPlace(placeID: String) -> Promise<Place> {
        return Promise { fulfill, reject in
            self.getPlace(
                placeID: placeID, success: { place in
                    _ = fulfill(place)
                }, error: { error in
                    _ = reject(error)
            })
        }
    }
```

Then in your code, you can use PromiseKit as usual:

``` swift
GooglePlacesProvider.getPlace(placeID: "placeId").then { place in
    // Do something
}
```
  This is an extremely timely issue, as I found this issue just now while searching for some documentation on this very feature! One question: in the `demo` directory tree, there is a sample implementation of the Giphy API that appears to demonstrate how to use the multipart-form-upload features. Does anybody know if the code in this demo is accurate according to the final API? If so, that might be a good place to start with formal documentation.
 Sorry for the long delay, didn't notice I was mentioned till just now.  AFAIK the code in `demo/` that uses the multiform upload is correct, unless something changed and it wasn't updated!  It should be easy to document the usage, I think the code is straightforward.  Hi guys, I am trying to get this to work with V4 signed amazon requests. This is my code so far but it does not work. Anyone here who has done this before and can help out:

``` swift
class AuthenticatedProvider : RxMoyaProvider<ApiDefinition> {

    static let requestClosure = { (endpoint: Endpoint<MYENDPOINT>, closure: RequestResultClosure) -> Void in

        let request = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest

        let awsEndpoint = AWSEndpoint(region: AWSRegionType.USEast1,
                                      service: AWSServiceType.APIGateway,
                                      URL: NSURL(string:"URLGOESHERE")!)


        let signer = AWSSignatureV4Signer(credentialsProvider: AuthAWSCognitoService.sharedInstance.credentialsProvider,
                                          endpoint: awsEndpoint)

        //_configuration.baseURL = _configuration.endpoint.URL;

        let task = signer.interceptRequest(request)
        task.continueWithBlock {(task: AWSTask!) -> AnyObject? in

           closure(.Success(request))
           return nil
        }

    }


    override internal init(endpointClosure: EndpointClosure = MoyaProvider.DefaultEndpointMapping,
                           requestClosure: RequestClosure = requestClosure,
                           stubClosure: StubClosure = MoyaProvider.NeverStub,
                           manager: Manager = RxMoyaProvider<ApiDefinition>.DefaultAlamofireManager(),
                           plugins: [PluginType] = [],
                           trackInflights: Bool = false) {
        super.init(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, manager: manager, plugins: plugins, trackInflights: trackInflights)
    }
}
```
 To add more info: The request gets signed but I still get 403 errors. 
 So I figured it out. Here is working code:

```
static let requestClosure = { (endpoint: Endpoint<APIV3Authenticated>, closure: RequestResultClosure) -> Void in

    var request = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest

    let date = NSDate.aws_clockSkewFixedDate().aws_stringValue(AWSDateISO8601DateFormat2)

    request.addValue(date,forHTTPHeaderField: "X-Amz-Date")

    let credentialsProvider = AuthAWSCognitoService.sharedInstance.credentialsProvider!

    let awsEndpoint = AWSEndpoint(region: AWSRegionType.USEast1,
                                  service: AWSServiceType.APIGateway,
                                  URL: NSURL(string:"https://.......")!)


    // Refresh credentials
    credentialsProvider.credentials().continueWithBlock {(task: AWSTask!) -> AnyObject? in


        let signer = AWSSignatureV4Signer(credentialsProvider: credentialsProvider,
            endpoint: awsEndpoint)

        //_configuration.baseURL = _configuration.endpoint.URL;

        let task = signer.interceptRequest(request)
        task.continueWithBlock {(task: AWSTask!) -> AnyObject? in



            closure(.Success(request))
            return nil
        }


        return nil
    }
}
```
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">Any changes to library code need a summary in the Changelog.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  MultipartFormData objects in Moya will call an AlamoFire method `appendData` to build the form for the request. The `appendBodyPart` method in AlamoFire is not overloaded with nil defaults for mimeTypes or filenames, rather it calls a different `appendBodyPart` method that never assigns them to the form. However, when adding a mimeType (even if it's an empty String) AlamoFire places the content in the "files" section of the request. JSON and String data belong in the "fields" section. This means anything added in a MultipartFormData are added to "files". 
### Fix
- `mimeType` and `fileName` were made into optionals and the default values were set to `nil`, rather than `""`. The loop that iterates over the array of MultipartFormData will call the appropriate AlamoFire function based on the mimetype and filename. This will case a **break** when a consumer is reading the mimeType property. 
- A helper append function was crated for each data type (data, file, stream) that checks the values of the mimeType and fileName before calling the AlamoFire method. 

I brought this up in Issue #580 
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          :white_check_mark: Yay.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/581?src=pr) is 66.76% (diff: 0.00%)

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/581/graphs/sunburst.svg?size=150&src=pr)

> No coverage report found for **master** at 87bbac2.
> 
> Powered by [Codecov](https://codecov.io?src=pr). Last update [87bbac2...6060941](https://codecov.io/gh/Moya/Moya/compare/87bbac2a8c0ad2b4a03be89545fbdae423f39dbb...606094187bce2f8a849362ab27e609152b7cb8b2?src=pr)
  Using Charles, I noticed anything in the MultipartFormData array is added to the files section of the request. When testing the same request Postman, text is added to "fields" and the image is added to "files". 

Is this Moya's intended behavior? It seems like only files should go to files 
 I did some digging, it looks like by setting the `mimeType` to "", Moya tells Alamofire that it's a file type, adding it to the files section of the multipart/form-data request. 

I'm happy to provide a fix. 
 This change never made it into Swift 2.3 or 2.2. Are there plans to release an update or can I merge into the release branch?  @Moya/contributors should we make another 2.2/2.3 release?  This means that MultipartForm is still broken before 3.0
  Hi.

The aforementioned part of the documentation was using two different, but nevertheless obsolete versions of the RequestClosure. To help others avoid hitting the same wall as I did this morning, here's a small patch that brings them up to date.

I also added a force type cast as otherwise it wouldn't compile with Swift 2.2.
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/579?src=pr) is 68.33% (diff: 100%)

> Merging [#579](https://codecov.io/gh/Moya/Moya/pull/579?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #579   diff @@
==========================================
  Files            16         16          
  Lines           641        641          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            438        438          
  Misses          203        203          
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/579/graphs/sunburst.svg?src=pr&size=150)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [6f0b8fe...ca8be19](https://codecov.io/gh/Moya/Moya/compare/6f0b8fe3a78e71b997e76c5176efa8ccfea4f857...ca8be19be1040bb7dada4a30b833eee8dd6a7bd7?src=pr)
 I have mixed feelings about using a `guard` here.

Sure, under any other circumstance, forcing is a bad smell; but here it's a direct consequence of how `NSMutableCopying` works. As such, it cannot actually fail.
 That's a nice catch. (It would be pretty nice if this was a public extension, or Moya called the closure with a mutable URLRequest in the first place.)
Also the NSMutableURLRequest documentation states that NSURLSession and co. all use mutableCopy internally. I'd trust the system.

Is that okay if I go with the "add a comment" route?
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/578?src=pr) is 68.33% (diff: 100%)

> Merging [#578](https://codecov.io/gh/Moya/Moya/pull/578?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #578   diff @@
==========================================
  Files            16         16          
  Lines           641        641          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            438        438          
  Misses          203        203          
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/578/graphs/sunburst.svg?src=pr&size=150)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [c15ead6...9369677](https://codecov.io/gh/Moya/Moya/compare/c15ead60b92111ad73f7cf12f7b5e865d8ac61ac...936967743add75da95f54258688194bd8f7629f3?src=pr)
  Fixes https://github.com/danger/danger.systems/issues/78
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/577?src=pr) is 68.33% (diff: 100%)

> Merging [#577](https://codecov.io/gh/Moya/Moya/pull/577?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #577   diff @@
==========================================
  Files            16         16          
  Lines           641        641          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            438        438          
  Misses          203        203          
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/577/graphs/sunburst.svg?size=150&src=pr)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [c42033f...7087a47](https://codecov.io/gh/Moya/Moya/compare/c42033fd26c12fc4bd228e28d3fa6933bdf61b8b...7087a473f3079bc966fc7778a03f6550c2922313?src=pr)
  Very little improvement in the Endpoints.md
  ok..thank you, i will check it again
  I create an endpoint for my Moya API to post text and upload images at the same time to my remote RESTful service. Before trying Moya, I was using `Alamofire` natively for such POST request, however, I got http status code `413` (Entity is too large) with my Moya API abstraction layer. The same set of images (2) was used for both of my Alamofire native API and Moya API, and only Alamofire API works for me. So I am hoping to use some of the help here for troubleshooting:

**The relevant code in my Moya API layer:**

``` swift
enum MyAPI {
  case CreateObj([String: AnyObject])
}

extension MyAPI: TargetType {
  var path: String {
    switch self {
    case .CreateObj(_):
      return MyURI.CREATE_OBJ
    }
  }

  var multipartBody: [MultipartFormData]? {
    switch self {
    case .CreateObj(let dictObj):
      guard let imagesDataArr = dictObj["imagesDataArr"] as? [NSData] else { return[] }

      let formData: [MultipartFormData] = imagesDataArr.map{MultipartFormData(provider: .Data($0), name: "images", mimeType: "image/jpeg", fileName: "photo.jpg")}
      return formData

    default:
      return []
    }
  }

  var method: Moya.Method {
    switch self {
    case .CreateObj:
      return .POST
    }
  }

  var parameters: [String: AnyObject]? {
    switch self {
    case .CreateObj(let objDict):
      return objDict

    default:
      return nil

    }
  }
}
```

I am wondering if it could be due the `parameters` in the code above. Any ideas why I receive `413` status from my Moya API code? Thanks
 I don't think that it's `Moya` witch causes this. `Moya` is a network abstraction layer that encapsulates calling `Alamofire` directly, if your request works with `Alamofire`, it should work work with `Moya`.

Did you try the same request with an Http client ? ( postman, Paw, ...) 
 @samirGuerdah 
It may not be Moya that causes this error code **413**, but my code of using Moya may cause this, because the multipart form data is a relatively new feature in Moya and there has not been much tutorial or documentation on how to use it.

I have tried Alamofire, PostMan in Chrome browser, and they all work until I came to try **Moya**
 @colinta 
My understanding is the `"name": "images"` is for specifying the field name in the form data to be `"images"`, and this field is parsed by my remote REST api for uploading the images associated to this field. The field name `fileName` is for the image name with an extension: `photo.jpg` (see the code in my original post).

You said the `imagesDataArr` in my parameter `dictObj` would be included for the http request going out to the API, that made me think maybe I should have deleted the field `imagesDataArr` after creating the `MultipartFormData` object. 

Thanks! - will report back if removing `imagesDataArr` works for me.
 My code above works fine if I don't upload images when doing the POST request with the API, but it does not work with uploading images same time. I've confirmed my remote REST API works fine by using PostMan in Chrome browser. 

The errors I see from uploading images and posting input texts same time are because of the other fields being `undefined`. 

For example, my input text fields are `title` and `content`. These two input fields contain the correct string value when I do **NOT** upload images same time, however, these two fields turn out to be `undefined` when uploading images.

This made me think if I should also include my text inputs in the form data generated in the `var multipartBody: [MultipartFormData]?` block:

``` swift
// current code
var multipartBody: [MultipartFormData]? {
  switch self {
  case .CreateObj(let dictObj):
    guard let imagesDataArr = dictObj["imagesDataArr"] as? [NSData] else { return[] }

    var formData: [MultipartFormData] = imagesDataArr.map{MultipartFormData(provider: .Data($0), name: "images", mimeType: "image/jpeg", fileName: "photo.jpg")}
    return formData

  default:
    return []
  }
}
```

If so, how should I convert my text input string to form data here? I've tried the following:

``` swift
for (key, val) in questionDictObj {
  formData.append(MultipartFormData(provider: .Data(String(val).dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!), name: key)) // does not work! the field's value is still undefined at the remote API
}
```

I don't see any examples for casting text input string values to `MultipartFormData` type. Anyone knows?  How come the text input fields disappeared when they are POSTed together with images for uploading?
 @rcholic Can you please compare the request details between an Http client and using `Moya` ( by using Charles proxy for example) ? I think that your code is the correct way to send a multipart data (Perhaps `Moya` or `Alamofire` are not setting correctly the content types). 
 your problem can be related to the issue #580
 @leoneparise , below is my code in using Alamofire, my original post includes my Moya code:

``` swift
Alamofire.upload(.POST, targetURL, headers: headers, multipartFormData: { (multipartFormData) -> Void in

  for (key, val) in questionObj {
    print("iterating key-val: \(key): \(val) in question JSON")
    multipartFormData.appendBodyPart(data: String(val).dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!, name: key)
  }

  for i in 0..<self.selectedImageData.count {
    let img = self.selectedImageData[i] // array of NSData from UIImage
    multipartFormData.appendBodyPart(data: img, name: "images", fileName: "file\(i).png", mimeType: "image/png")
  }

  }, encodingCompletion: { (encodingResult) -> Void in
    switch encodingResult {
    case .Success(let upload, _, _):
      upload.responseJSON(completionHandler: { (response) -> Void in
        print("successful response: \(response)")
      })

    case .Failure(let error):
      print("in encoding completion, error: \(error)")
    }
})
```

So your example basically suggest that I should not include the `images` for uploading in the `paramaters` return, but rather should return `images` only in the `multipartBody`? Thanks
 @leoneparise thanks so much with my wholeheart! Your help solved my problem completely! I'm closing it now :)
 For folks running services behind Nginx, http://stackoverflow.com/questions/18908426/increasing-client-max-body-size-in-nginx-conf-on-aws-elastic-beanstalk  Hi,

I just installed Moya with pod, and getting this error in my Service Enum. Please help

![image](https://cloud.githubusercontent.com/assets/4919645/17321286/5862c20a-58b5-11e6-92dd-e7eba9cb41b7.png)

Here's my code

``` swift
import Foundation
import Moya


enum MyService {
    case Login(userName: String, password: String)
}

// MARK: - TargetType Protocol Implementation
extension MyService: TargetType {
    var baseURL: NSURL { return NSURL(string: "https://identitysso.betfair.com/api")! }
    var path: String {
        switch self {
        case .Login:
            return "/login"
        }
    }
    var method: Moya.Method {
        switch self {
//        case .Zen, .ShowUser:
//            return .GET
        case .Login:
            return .POST
        }
    }
    var parameters: [String: AnyObject]? {
        switch self {
//        case .Zen, .ShowUser:
//            return nil
        case .Login(let userName, let password):
            return ["username": userName, "password": password]
        }
    }
    var sampleData: NSData {
        switch self {
//        case .Zen:
//            return "Half measures are as bad as nothing at all.".UTF8EncodedData
//        case .ShowUser(let id):
//            return "{\"id\": \(id), \"first_name\": \"Harry\", \"last_name\": \"Potter\"}".UTF8EncodedData
        case .Login(let userName, let password):
            return "{\"id\": 100, \"first_name\": \"\(userName)\", \"last_name\": \"\(password)\"}".UTF8EncodedData
        }
    }
}

// MARK: - Helpers
private extension String {
    var URLEscapedString: String {
        return self.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLHostAllowedCharacterSet())!
    }
    var UTF8EncodedData: NSData {
        return self.dataUsingEncoding(NSUTF8StringEncoding)!
    }
}
```
 Thanks a lot for the quick response @AvdLee . That solved my problem. 

But, I am getting this error while invoking the Service. 

![screen shot 2016-08-02 at 2 29 56 pm](https://cloud.githubusercontent.com/assets/4919645/17322965/a57bf6b2-58bd-11e6-99ef-6c408f84b770.png)

Am I doing something wrong here?

I am declaring the provider like this 

`let BetFairProvider = MoyaProvider<BetFairService>(plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])`
 Where are you declaring the `let BetFairProvider = ...` ? Can you show the code of the `BetFairService` ? 

PS: I think that this question is not related to a Moya issue. You can ask those questions in [http://stackoverflow.com/](http://stackoverflow.com) for example.
 Yes, I did. It was due to an error in my code. Thanks for the help :)
   i am dependent on the error.nserror to inform me of whether the operation is cancelled, or it is a network failure.

Right now, i can cast it as customconvertiblestring, but i lose the parsing, and if i cast it as error, i do not get the needed information (999)

See below for what i am doing. I do not want to throw a error message if operation is cancelled, rather than network failure.

Thanks in advance! 

``` swift
struct Network {

  static let sharedInstance = Network()
  let provider = MoyaProvider(endpointClosure: endpointClosure)
  let db = DisposeBag()

  // this returns an reactive operation able to be triggered asynchronously
  func reactiveRequest<T:Mappable>(target:Spark) -> Operation<[T], NSError> {
    return Operation(producer: { observer in
     .....
        case let .Failure(error):
          if error.nsError.code == -999{
            print ("operation cancelled")
          } else {
            self.defaultFailureCallback(error)
            // this throws an error message
          }
          observer.completed()
        }
      }

      return BlockDisposable({
        request.cancel()
      })
    })
  }

```
 Yes, that is what i would like to do - catch and ignore the error. 

As you can see, if the errorcode is -999, i am not showing the user any UI. otherwise, i am calling the default network failure indicator.

``` swift
if error.nsError.code == -999{
  print ("operation cancelled")
} else {
  self.defaultFailureCallback(error)
  // this throws an error message
}
```
  Uses new `supportsMultipart` property on `Method` to determine compatibility.

No breaking changes to API.
Added specs on `Method` to guarantee expected values for `supportsMultipart`.
 Resolves #567 
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/569?src=pr) is 67.91% (diff: 90.00%)

> Merging [#569](https://codecov.io/gh/Moya/Moya/pull/569?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.45%**

``` diff
@@             master       #569   diff @@
==========================================
  Files            16         16          
  Lines           633        642     +9   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits            427        436     +9   
  Misses          206        206          
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/569/graphs/sunburst.svg?size=150&src=pr)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [7eb2f49...e15e649](https://codecov.io/gh/Moya/Moya/compare/7eb2f492364292cf75bd164c61bf88c1caa4b495...e15e649136aba3d532e7fb49bcc683b1b098bfca?src=pr)
  [Enhancement (bug? fix)] modified function `Response.mapJSON` to take an optional paramenter "failsOnEmptyData:" to give users control if they want to get an empty response or throw an error if the response data is empty.

fixes #494
 two things worth noting:
1. `failesOnEmptyData:` is a named parameter to promote overriding this behavior explicit as possible when calling.
2. I chose to return an `NSNull` item instead of an `NSArray` or `NSDictionary` because i guess it felt more representative of an _empty_ result. 

open for discussion/input from other @Moya/contributors if they have differing opinions üò∏ 
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          :white_check_mark: Woo!
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/568?src=pr) is 67.87% (diff: 87.50%)

> Merging [#568](https://codecov.io/gh/Moya/Moya/pull/568?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **0.42%**

``` diff
@@             master       #568   diff @@
==========================================
  Files            16         16          
  Lines           633        632     -1   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits            427        429     +2   
+ Misses          206        203     -3   
  Partials          0          0          
```

![Sunburst](https://codecov.io/gh/Moya/Moya/pull/568/graphs/sunburst.svg?src=pr&size=150)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [7eb2f49...86b5ac2](https://codecov.io/gh/Moya/Moya/compare/7eb2f492364292cf75bd164c61bf88c1caa4b495...86b5ac279e1934513eb2557e936ce807ac132fda?src=pr)
 ah! yes. i'll commit the new changelog item along with the test case variable update later this evening.
  In Moya+Internal.swift the case for uploading with a PATCH is not allowed. 
The multipart upload seems to be limited by this check:
`target.method == .POST || target.method == .PUT`

Alamofire supports PATCH-ing with multipart as a PATCH is just a partial PUT, is it intended for Moya to not support it?
 I think we could just add PATCH to that list. 

> On Jul 28, 2016, at 4:32 PM, Alex Quinlivan notifications@github.com wrote:
> 
> In Moya+Internal.swift the case for uploading with a PATCH is not allowed. 
> The multipart upload seems to be limited by this check:
> target.method == .POST || target.method == .PUT
> 
> Alamofire supports PATCH-ing with multipart as a PATCH is just a partial PUT, is it intended for Moya to not support it?
> 
> ‚Äï
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub, or mute the thread.
 Do you want to open a PR to address this?  I was looking at this table: https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Summary_table and it looks like even `CONNECT` can have a body.  I looked around and found no reason that it would need to receive a file (I couldn't find an example of sending a body at all), but on the other hand - why not support it?  
 A slick way to do this would be to add an extension to `Moya.Method` (aka `Alamofire.Method`) that adds `var supportsMultipart: Bool`, then we can add specs for that var.
 We can move discussion to PR #569
  related to #551 
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/563?src=pr) is 84.37% (diff: 72.22%)

> Merging [#563](https://codecov.io/gh/Moya/Moya/pull/563?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #563   diff @@
==========================================
  Files            29         29          
  Lines          2496       2496          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits           2106       2106          
  Misses          390        390          
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last update [bc434f6...2650c85](https://codecov.io/gh/Moya/Moya/compare/bc434f64bf39dc67c1fd73b4968f002dfb92e605...2650c85c442c65a517057d89d131b37c75cea863?src=pr)
 Will do @ashfurrow! I still need to finish this up - another 2 or 3 commits before this works - will get a short write up here when I get around to those commits

I'll also need to verify that this doesn't break the existing Cocoapods install - I can try a `pod install`, but it would be awesome if a contributor who's more familiar with Cocoapods (maybe you üòõ) also vets this PR when it's done
 I'll review it when you're done. üòâ
 @petester42 instead of using a build script, it may be more idiomatic to use a compiler directive - similar to how RxCocoa uses `RX_NO_MODULE` https://github.com/ReactiveX/RxSwift/blob/master/RxCocoa/Common/DelegateProxyType.swift#L10

What do you think? I haven't used a compiler directive before, but if it seems like a good idea we can give implementing it a shot
 Interesting idea. Sounds good to me. 
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Error">
          :white_check_mark: Yay.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-danger-table="true" data-kind="Warning">
          3 Warnings
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">PR is classed as Work in Progress</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Big PR</td>
    </tr>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Consider adding supporting documentation to this change. Documentation can be found in the <code>docs</code> directory.</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 This looks good but I'll review it more throughly tomorrow night. I have a question though. Why are we using the `COCOAPODS` flag in the source files? 

I believe a better solution would be to provide our own flag to do the same thing so that was we are not dependent on cocoapods having this flag. We can simply add our own flag to `Other Swift Flags` by adding `-DNEEDS_MOYA` or something to our targets. That way we check for `#if NEEDS_MOYA` in the code instead. It's basically the same but I like that better.
 As far as your other tasks I think everything has already been addressed. You can merge this whenever you feel comfortable with it. 
  The [example project from CodeCov](https://github.com/codecov/example-swift) is having the same issue: https://travis-ci.org/codecov/example-swift/builds/146633163

Seems like it's an issue with the tool itself.
 Hm, found something while digging in the tool

![image](https://cloud.githubusercontent.com/assets/1916041/17272624/e8dd3752-5671-11e6-94b5-41b6c326c7e3.png)

[These changes](https://codecov.io/gh/Moya/Moya/branch/master/commits?from=2016-07-07%2000%3A00%3A00&to=2016-07-11%2000%3A00%3A00) happened on the day the coverage went down:

![image](https://cloud.githubusercontent.com/assets/1916041/17272691/af68ea6e-5673-11e6-8024-5e6c1a7956dd.png)

The build for `48e4b01` has the same error messages in the coverage log: https://circleci.com/gh/Moya/Moya/285

Feels like it's an actual drop in the coverage, not an issue with the tool.
 @BasThomas You have to check `Show Test Bundles` on the upper right corner üòâ 
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Big PR</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/561?src=pr) is 67.45% (diff: 59.54%)

> Merging [#561](https://codecov.io/gh/Moya/Moya/pull/561?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.64%**

``` diff
@@             master       #561   diff @@
==========================================
  Files            12         16     +4   
  Lines           627        633     +6   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            427        427          
- Misses          200        206     +6   
  Partials          0          0          
```

[![Sunburst](https://codecov.io/gh/Moya/Moya/pull/561/graphs/sunburst.svg?src=pr&size=150)](https://codecov.io/gh/Moya/Moya/pull/561?src=pr)

> Powered by [Codecov](https://codecov.io?src=pr). Last update [f68b9e7...af7442d](https://codecov.io/gh/Moya/Moya/compare/f68b9e7923203c2f733d27948a5b6db99820de6b...af7442dfc0bd94525065aeda2b7f4ed033c5c4b0?src=pr)
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          :white_check_mark: Congrats.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>PR is classed as Work in Progress</del></td>
      </tr>
  </tbody>
</table>

### SwiftLint found issues\n\n#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Moya.swift | 395 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 188 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 59 lines |
| Moya.swift | 390 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 395 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 389 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 188 | Function should have complexity 10 or less: currently complexity equals 14 |
| Moya.swift | 520 | File should contain 400 lines or less: currently contains 520 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  @ashfurrow how do you get hold of a sticker?
  When using `Moya/RxSwift` Xcode complains it can't find the Result module for the file `CredentialManager`/
 CocoaPods 0.39.0
Xcode 7.3
Moya 7.0
  Fix typo about refreshToken.
 <p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  In our app we use Firebase, we would love to abstract this to the point where we can use alamofire or firebase without the caller knowing anything.

As it is we will have to either have an abstraction of an abstraction or have the code know it's calling Moya or non-moya code.
 [My fork](https://github.com/jasl/MoyaX) has done this (which we'd talked before)
 @ashfurrow I sync all commits to https://github.com/jasl/Moya and it's a fork of Moya.

I'm afraid my fork has large different with current Moya, because I've done myself version of multipart-upload, new Swift 3 naming convention, refactor example, non-generic provider etc  before (more early than Moya has these feature).
 In my fork, I wrap network engine into `Backend` which handle initiallizing and configuring the engine, and it's has a [request](https://github.com/jasl/MoyaX/blob/master/Sources/MoyaX.swift#L113) method, that accept Moya's Endpoint value.

In `request` method, the backend should handle how to make a `Endpoint` become to request and launch it, then invoking response closure when get response, Moya don't care about how to encode the parameter or how to make endpoint to request, these job is NSURLSession's or Alamofire's, Moya just provides a easy way to encapsulation the remote API definition, and give a easy way to intercept the upcoming `Endpoint`. I think this is the core value of a networking abstraction.
 and I think using `typealias` isn't a good way to abstract engines, because engines interface are different, and may need to configure, so we need to wrap them.
 I don't think there's enough common ground to abstract AlamoFire (one request -> one response pattern) and Firebase (one subscription -> 0..N events in a stream), at least not on Moya's level. 

Moving the abstraction up a layer works nice though: RxSwift is great for mapping both variants into streams. (I use it all the time.)
 @vzsg yeah currently thats what we are doing.
 I understand this is an old and closed thread but I recently started working on a project for Firebase inspired by Moya. I've called it [Nora](https://github.com/SD10/Nora). I'm really a huge fan of the Moya networking abstraction pattern. I initially tried seeing if Moya could support Firebase but like others in this thread have mentioned, Moya is too tightly coupled with Alamofire and it would require a different Provider and Target types. Thank you everyone for your hard work on this project and the inspiration.  Why GitHub enum is duplicated in /Demo/Tests/TestHelpers.swift? I commented out the duplicated code and tried to use **@testable import Demo** and got linking errors. Ideally we should directly test the target code. Is it possible to solve the issue?
 Yes. Thanks.
  <p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  - Adds Download.Request Download type
- Adds Upload.File Upload type
- Puts Multipart Upload type in UploadType enum
- Removes "**multipartBody**" from TargetType protocol and adds a "**task**" instead
- Adds new provider and and a button to Demo app to demonstrate download
- An _Alamofire_ response is now considered _Successful_ even if doesn't have any data with it and we return a _Moya_ response from it using an empty _NSData_ when converting
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          :white_check_mark: Congrats.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>Any changes to library code need a summary in the Changelog.</del></td>
      </tr>
  </tbody>
</table>

### SwiftLint found issues\n\n#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Moya.swift | 395 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 188 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 59 lines |
| Moya.swift | 390 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 395 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 389 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 188 | Function should have complexity 10 or less: currently complexity equals 14 |
| Moya.swift | 520 | File should contain 400 lines or less: currently contains 520 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Moya.swift | 395 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 188 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 59 lines |
| Moya.swift | 390 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 395 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 389 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 188 | Function should have complexity 10 or less: currently complexity equals 14 |
| Moya.swift | 520 | File should contain 400 lines or less: currently contains 520 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Moya.swift | 395 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 188 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 59 lines |
| Moya.swift | 390 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 395 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 389 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 188 | Function should have complexity 10 or less: currently complexity equals 14 |
| Moya.swift | 520 | File should contain 400 lines or less: currently contains 520 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Moya.swift | 395 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 188 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 59 lines |
| Moya.swift | 390 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 395 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 389 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 188 | Function should have complexity 10 or less: currently complexity equals 14 |
| Moya.swift | 520 | File should contain 400 lines or less: currently contains 520 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Moya.swift | 395 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 188 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 59 lines |
| Moya.swift | 390 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 395 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 389 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 188 | Function should have complexity 10 or less: currently complexity equals 14 |
| Moya.swift | 520 | File should contain 400 lines or less: currently contains 520 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Moya.swift | 395 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 188 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 59 lines |
| Moya.swift | 390 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 395 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 389 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 188 | Function should have complexity 10 or less: currently complexity equals 14 |
| Moya.swift | 520 | File should contain 400 lines or less: currently contains 520 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Moya.swift | 395 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 188 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 59 lines |
| Moya.swift | 390 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 395 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 389 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 188 | Function should have complexity 10 or less: currently complexity equals 14 |
| Moya.swift | 520 | File should contain 400 lines or less: currently contains 520 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Moya.swift | 395 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 390 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 395 | There should be no space before and one after any comma. |
| Moya.swift | 188 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 59 lines |
| Moya.swift | 390 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 395 | Return arrow and return type should be separated by a single space or on a separate line. |
| Moya.swift | 389 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 188 | Function should have complexity 10 or less: currently complexity equals 14 |
| Moya.swift | 520 | File should contain 400 lines or less: currently contains 520 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/553?src=pr) is **68.10%**

> Merging [#553](https://codecov.io/gh/Moya/Moya/pull/553?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **1.20%**

``` diff
@@             master       #553   diff @@
==========================================
  Files            12         12          
  Lines           619        627     +8   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
- Hits            429        427     -2   
- Misses          190        200    +10   
  Partials          0          0          
```

[![Sunburst](https://codecov.io/gh/Moya/Moya/pull/553/graphs/sunburst.svg?src=pr&size=150)](https://codecov.io/gh/Moya/Moya/pull/553?src=pr)

> Powered by [Codecov](https://codecov.io?src=pr). Last updated by [6453987...1c577da](https://codecov.io/gh/Moya/Moya/compare/645398713e41a0f61a36c57e707d5135f2fa8477...1c577da7f74b768e08fdb9ca36863ca80366da0a?src=pr)
 I didn't _want_ to like this, because I assumed it was bike shedding, but as soon as I started digging in, I realized that it was a really good way to design the "how am I sending / receiving this request" aspect. So yeah, I'm on board! üëç 
 Good design! Now we have support for download and upload with progress. üëç  Great work!
  I'm refactoring my networking code, and I've found a compiler error that I had previously (badly) worked around.

I have an `OnlineProvider` similar to the one in Artsy's iOS app. It's class definition looks like: 
`class OnlineProvider<Target where Target: RxMoya.TargetType>: RxMoyaProvider<Target>`

The part I don't like here, is the `Target where Target: RxMoya.TargetType` because it makes me define my `TargetType` enum as `enum MyAPI: RxMoya.TargetType`. I'd much rather have `Target where Target: Moya.TargetType` and `enum MyAPI: Moya.TargetType`

So in attempt to change that, I've been able to refactor `MyAPI` to conform to `Moya.TargetType`, but I'm now having an issue with my `OnlineProvider`:

<img width="975" alt="screen shot 2016-07-15 at 11 24 19 am" src="https://cloud.githubusercontent.com/assets/3814772/16884514/b69e0810-4a7e-11e6-8819-73343257f43f.png">
I'm not sure, but I _think_ that's because `RxMoyaProvider` wants to be specialized with a `RxMoya.TargetType`, not a `Moya.TargetType` and because `RxMoya.TargetType` doesn't inherit from `Moya.TargetType`, the compiler treats them as totally separate protocols (with the exact same definition, albeit)?
 unfortunately - waiting for the Swift Package Manager to be released

assuming that if you're using cocoapods, there is no `RxMoya.TargetType` since cocoapods doesn't actually build modules?
 @ashfurrow playing with this right now, will hopefully update soon with what I ended up doing
 I think the underlying issue (speaking from the perspective of the compiled code that Carthage gives us) is that you can't pass a Moya.TargetType to an RxMoyaProvider.
 I had started doing something like that [here](https://github.com/Moya/Moya/tree/petester42/dependent-carthage-frameworks) which works great in Xcode but I was getting Carthage errors. 
 @petester42 can you talk more about the Carthage errors? 

I feel as if this problem will be exasperated once people start using Moya through the swift package manager, so finding an answer before we're up against a wall would be üî•
 I don't really remember what they were but the build using Carthage would fail but building with Xcode worked fine. 
 hey @petester42, saw that you merged `master` into your branch. Did you mean to rebase? It's still saying that your branch is ~120 commits behind master

I'll try to take a look at this right now
 Its fine. I'm just playing around. Don't worry about it
 Discovery: 
When I try to manually run what carthage uses to build the RxMoya iOS scheme (which is `xcrun xcodebuild -project /Users/asb/Desktop/Bruh/Carthage/Checkouts/Moya/Moya.xcodeproj -scheme "RxMoya iOS" -configuration Release -sdk iphoneos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY=  CARTHAGE=YES clean build`) here's the output I get:

```
xcrun xcodebuild -project /Users/asb/Desktop/Bruh/Carthage/Checkouts/Moya/Moya.xcodeproj -scheme "RxMoya iOS" -configuration Release -sdk iphoneos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY=                        
Build settings from command line:
    BITCODE_GENERATION_MODE = bitcode
    CODE_SIGN_IDENTITY = 
    CODE_SIGNING_REQUIRED = NO
    ONLY_ACTIVE_ARCH = NO
    SDKROOT = iphoneos9.3

=== BUILD TARGET Moya tvOS OF PROJECT Moya WITH CONFIGURATION Release ===
...
...
...

CompileSwift fail
```

Where it says it's trying to build the `Moya tvOS` target, not the `RxMoya iOS` target that was passed into `xcrun` as an argument... 

Not sure why that's happening, but the other targets seem to work correctly - just `RxMoya iOS`. I'm going to check out what happens if I try the same `xcrun` on `master`.
 Stranger still: If I do a clean clone of Moya/Moya `master`, and I try the same `xcrun` with the `RxMoya iOS` target, it works, major steps:
`=== CLEAN TARGET Moya iOS OF PROJECT Moya WITH CONFIGURATION Release ===`, 
`=== CLEAN TARGET RxMoya iOS OF PROJECT Moya WITH CONFIGURATION Release ===`,
`=== BUILD TARGET Moya iOS OF PROJECT Moya WITH CONFIGURATION Release ===`, and then
`=== BUILD TARGET RxMoya iOS OF PROJECT Moya WITH CONFIGURATION Release ===`.

But if I try @petester42's branch, it sometimes first cleans `RxMoya watchOS`, or `RxMoya tvOS`, and then fails while trying to build the same. Not sure why it's doing that.

I'm going to branch off master and see if my branch has the same behavior or if one of @petester42's commits introduced the inconsistent clean+build procedure
 @petester42 can you explain how https://github.com/Moya/Moya/commit/e1b02527c15b3920c9968511303f68358040d735 works?

What script toggles the imports on and off?
 There is a prebuild and a postbuild script that is located in the build phase section of the targets. It is there because cocoapods doesn't need the extra import. By default the import should be commented out so cocoapods works and when building Carthage it will toggle it on, build, and then toggle it off again. 
 gotcha, can you also touch upon the changes you made to the `project.pbxproj`? Reorganizing the files/ folder structure?
 The changes are mainly removing the Moya files from the reactive targets. 
 @petester42 you said "cocoapods doesn't need the extra import", does having the import cause a compile error for cocoa pods? or will it just be a redundant line of code? I feel as if it would be ok to live with the redundant line of code for cocoapod users to avoid to complexity of the build script
 It won't build with cocoapods in you have `import Moya` anywhere because it is building Moya itself. 
 that makes sense - ok. Script it is
 I think this has been addressed by #563 
  This is small improvements in the sample project. The behavior of this demo doesn't change for sure.
 ### SwiftLint found issues\n\n#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Moya.swift | 182 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 54 lines |
| Moya.swift | 237 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 400 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 182 | Function should have complexity 10 or less: currently complexity equals 11 |
| Moya.swift | 500 | File should contain 400 lines or less: currently contains 500 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Moya.swift | 182 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 54 lines |
| Moya.swift | 237 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 400 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 182 | Function should have complexity 10 or less: currently complexity equals 11 |
| Moya.swift | 500 | File should contain 400 lines or less: currently contains 500 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Moya.swift | 182 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 54 lines |
| Moya.swift | 237 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 400 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 182 | Function should have complexity 10 or less: currently complexity equals 11 |
| Moya.swift | 500 | File should contain 400 lines or less: currently contains 500 |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 I've joined the organization. Thank you for your invitation. I've checked out your guidelines and its details. I'd like to involve the Moya in some form or other because I use it in my project.
  My request closure looks like this:

``` Swift
let requestClosure = { (endpoint: Moya.Endpoint<ICanHazProvider>, done: Result<NSURLRequest, Moya.Error> -> Void) in
  let request = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest

  if let token = self.getToken() {
    request.setValue(token, forHTTPHeaderField: "token")
  }

  return done(.Success(request))
}

hazAPI = MoyaProvider<ICanHazProvider>(endpointClosure: endpointClosure, requestClosure: requestClosure)
```

I'm getting the following error in Xcode now:

```
Unable to infer closure return type in current context
```

Is there any secret to getting this to work?
 Now gives me this error:

```
Cannot convert value of type '(ICanHazProvider) -> Endpoint<ICanHazProvider>' to expected argument type '_ -> Endpoint<_>'
```

My endpoint looks like this:

``` Swift
let endpointClosure = { (target: ICanHazProvider) -> Endpoint<ICanHazProvider> in

  let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString

  var encoding: Moya.ParameterEncoding = .JSON

  switch target.method {
  case .GET:
    encoding = .URL
  default:
    encoding = .JSON
  }

  let endpoint: Endpoint<ICanHazProvider> = Endpoint<ICanHazProvider>(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters, parameterEncoding: encoding)

  return endpoint
}
```
 I should clarify a bit: Error is on the next line:

``` Swift
hazAPI = MoyaProvider<ICanHazProvider>(endpointClosure: endpointClosure, requestClosure: requestClosure)
```
 Having a related issue. 

If I have this:

``` swift
private let authenticatedRequestClosure =  {
    (endpoint: Endpoint<SmartContactsPluginService>, done: MoyaProvider.RequestResultClosure) in
    let request = endpoint.urlRequest

    GlobalOAuth.authenticateRequest(request, completion: {
        result in
        switch result {
        case .Success(let signedInRequest):
            done(Result<NSURLRequest, Moya.Error>.Success(signedInRequest))

        case .Failure(let error):
            done(Result<NSURLRequest, Moya.Error>.Failure(.Underlying(error)))
        }
    })
}
```

It gives me:

![screen shot 2016-07-22 at 17 01 46](https://cloud.githubusercontent.com/assets/638474/17074223/097e32e4-502e-11e6-813c-86f74a33c2d7.png)

But if I have this:

``` swift
private let authenticatedRequestClosure =  {
    (endpoint: Endpoint<SmartContactsPluginService>, done: Result<NSURLRequest, Moya.Error> -> Void) in
    let request = endpoint.urlRequest

    GlobalOAuth.authenticateRequest(request, completion: {
        result in
        switch result {
        case .Success(let signedInRequest):
            done(Result<NSURLRequest, Moya.Error>.Success(signedInRequest))

        case .Failure(let error):
            done(Result<NSURLRequest, Moya.Error>.Failure(.Underlying(error)))
        }
    })
}
```

It gives me:

![screen shot 2016-07-22 at 17 04 31](https://cloud.githubusercontent.com/assets/638474/17074256/7724f288-502e-11e6-84ad-4f17a3d68fa5.png)
 I think I'm lost too with the same error for endpointClosure. I'm out of ideas :(
<img width="1028" alt="screen shot 2016-07-25 at 09 11 25" src="https://cloud.githubusercontent.com/assets/1580732/17093157/dda3889c-5247-11e6-9c2a-a1f89ce36061.png">

UPDATE:
I've tried to use this in the Demo.xcworkspace project and it also fails with the exact same reason:

``` swift
 let endpointClosure: MoyaProvider.EndpointClosure = { (target: GitHub) -> Endpoint<GitHub> in
            let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
            let endpoint: Endpoint<GitHub> = Endpoint<GitHub>(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
            return endpoint.endpointByAddingHTTPHeaderFields(["APP_NAME": "MY_AWESOME_APP"])
        }
```
 @ashfurrow Is this a known issue or are we all doing something wrong? Any help would be greatly appreciated.
 @ashfurrow Well, as I was preparing the example project, I realized that if I omit the variable type declarations in the closure it seems to compile and work fine. So I changed

``` Swift
let requestClosure = { (endpoint: Moya.Endpoint<ICanHazProvider>, done: Result<NSURLRequest, Moya.Error> -> Void) in
  let request = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest

  if let token = self.getToken() {
    request.setValue(token, forHTTPHeaderField: "token")
  }

  return done(.Success(request))
}
```

to

``` Swift
let requestClosure: MoyaProvider<ICanHazProvider>.RequestClosure = { endpoint, done in
  let request = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest

  if let token = self.getToken() {
    request.setValue(token, forHTTPHeaderField: "token")
  }

  done(.Success(request))
}
```
 @sunshinejr Changing my code to your suggestion yields the error in my original post in this issue:

```
Unable to infer closure return type in current context
```
 @ashfurrow @sunshinejr I'm starting to wonder if this has something to do with the Result library, which I'm using elsewhere in my project...
 @sunshinejr omitting the `Result` type did the trick, thanks!
 So - the issue is really weird.
If you do:

``` swift
let endpointClosure = { (target: GitHub) -> Endpoint<GitHub> in
            let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
            let endpoint: Endpoint<GitHub> = Endpoint<GitHub>(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
            return endpoint
        }

 _ = MoyaProvider<GitHub>(endpointClosure: endpointClosure)
```

Everything is peachy.
If you pass all the parameters, even if you copy them from the default implementation of `init` it gets the above result. So:
1. The issue isn't with endpointClosure.
2. Issue is with Xcode? compiler? I have no idea and unfortunately after being stuck for one day with this I don't have more time to dig deeper
 @BasThomas I would think so. Not sure about everyone else, but my issue has been resolved and I'm the original reporter ;)
 @ashfurrow  thanks let endpointClosure: MoyaProvider.EndpointClosure can slove it, but 
MoyaProvider.RequestClosure  can not 
  Good point - we'll probably need to be diligent about telling ourselves and others about that (e.g. if it's a refactor we should point out "include an entry that summarizes the changes, even if they aren't breaking).
 <p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 üëç I haven't gotten around to looking at the documentation, to see where a description of uploading can go.  That's enough of a mention that people can see that it's supported.
  `RxSwift OSX` has minimum deployment target 10.10 (tried with [RxSwift 2.6.0](https://github.com/ReactiveX/RxSwift/releases/tag/2.6.0)).
I found this issue while building `RxMoya OSX` on master branch

<img width="1127" alt="screen shot 2016-07-14 at 22 36 44" src="https://cloud.githubusercontent.com/assets/3948217/16845535/7bdac4c2-4a13-11e6-8c9a-c8f712f1ebe7.png">
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">No Changelog entries made</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 @ashfurrow Yep, I found out the build was broken while building with Carthage, then I dig deeper to find out. Pull request on RxSwift that bumps osx version to `10.10`

https://github.com/ReactiveX/RxSwift/pull/774

I think we could explicitly set `RxSwift` version to 2.5.x on Moya's Cartfile?  

**Edit**
Even if we set `RxSwift` version to `2.5.x`, sooner or later we would need to support swift 3 and need to upgrade `RxSwift`.
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/547?src=pr) is **69.30%**

> Merging [#547](https://codecov.io/gh/Moya/Moya/pull/547?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #547   diff @@
==========================================
  Files            12         12          
  Lines           619        619          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            429        429          
  Misses          190        190          
  Partials          0          0          
```

[![Sunburst](https://codecov.io/gh/Moya/Moya/pull/547/graphs/sunburst.svg?src=pr&size=150)](https://codecov.io/gh/Moya/Moya/pull/547?src=pr)

> Powered by [Codecov](https://codecov.io?src=pr). Last updated by [ae72ae8...8a1043d](https://codecov.io/gh/Moya/Moya/compare/ae72ae8fc774e33b55b76a825ada1e65ee89afb3...8a1043d3f00fd327b8b9b0b55ae6888a4ec758fb?src=pr)
 @ashfurrow Cool üçª !
  Didn't see anything about #483 in 7.0.0's [notes](https://github.com/Moya/Moya/releases/tag/7.0.0), was that on purpose?
 thanks for taking care of this @ashfurrow üòÑ 
  Just wondering if anyone had any tips or ideas about the way to setup parameters for http://jsonapi.org structure. 

For example the json structure for our Login is:

``` json
{
  "data": {
    "attributes": {
      "email": "pete@thegmail.com",
      "password": "password",
      "client-uuid": "e43ccaf0-b66f-49f8-95f1-ee9e14a88962"
    }
  }
}
```

And the structure for refreshing a token is:

``` json
{
  "data": {
    "type": "user-authentications",
    "id": "58fc7178-e135-462e-b328-ec8802023579",
    "attributes": {
      "long-jwt": "eyJ0eX...TIE"
    }
  }
}
```

My question is around defining a way to shuffle values into the `data.attributes`, vs `data.id` etc.
The obviously terrible, poor man's way to do it:

``` swift
extension AwesomeAPI: RxMoya.TargetType {
  ...
  var parameters: [String: AnyObject]? {
    switch self {
    case .Login(let email, let password, let clientID):
      return ["data": ["type": "user-authentications", "attributes": ["email": email, "password": password, "client-uuid": clientID]]]
    case .RefreshToken(let longToken, let clientID):
      return ["data": ["type": "user-authentications", "id": clientID, "attributes": ["long-jwt": longToken]]]
   }
}
```

Would this be the responsibility of the conformer to `TargetType`, or should someone else create these structures?
Any thoughts would be super appreciated :) This is probably more of a Slack question than a question on issues.
 I'm going to create a `mapper` for it, a public pod, if you want to participate
  Removing trailing whitespace from files is one of my favorite things to do üòâ 
 @ashfurrow Danger says `fatal: Not a valid branch point: 'b15ee3ff510e56c8fd077e724bdaf7d6ecb95afa'`
  In trying to add support for the `progress` handler to "normal" (not multipart) request, I found _lots_ of repeated code.
- `if cancellableToken.cancelled { ... }` now uses `cancelCompletion` helper
- `requestNormal` and `requestMultipart` were almost identical, now they're combined
- `sendUpload` and `sendRequest` shared code that sends the alamoRequest and notifies plugins

So yeah, now it's all consistent!

No external changes to the API, all internal.
 #542 You'll be able to pass in a `progress` block using the code from this PR!
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">No Changelog entries made</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues\n\n#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Moya.swift | 355 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 356 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 338 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 358 | Force unwrapping should be avoided. |
| Moya.swift | 182 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 54 lines |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 337 | Lines should not have trailing whitespace. |
| Moya.swift | 352 | Lines should not have trailing whitespace. |
| Moya.swift | 362 | Lines should not have trailing whitespace. |
| Moya.swift | 375 | Lines should not have trailing whitespace. |
| Moya.swift | 388 | Lines should not have trailing whitespace. |
| Moya.swift | 413 | Lines should not have trailing whitespace. |
| Moya.swift | 414 | Lines should not have trailing whitespace. |
| Moya.swift | 485 | Lines should not have trailing whitespace. |
| Moya.swift | 497 | Lines should not have trailing whitespace. |
| Moya.swift | 237 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 399 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 182 | Function should have complexity 10 or less: currently complexity equals 11 |
| Moya.swift | 499 | File should contain 400 lines or less: currently contains 499 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 355 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 356 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 338 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 358 | Force unwrapping should be avoided. |
| Moya.swift | 182 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 54 lines |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 337 | Lines should not have trailing whitespace. |
| Moya.swift | 352 | Lines should not have trailing whitespace. |
| Moya.swift | 362 | Lines should not have trailing whitespace. |
| Moya.swift | 375 | Lines should not have trailing whitespace. |
| Moya.swift | 388 | Lines should not have trailing whitespace. |
| Moya.swift | 413 | Lines should not have trailing whitespace. |
| Moya.swift | 414 | Lines should not have trailing whitespace. |
| Moya.swift | 485 | Lines should not have trailing whitespace. |
| Moya.swift | 497 | Lines should not have trailing whitespace. |
| Moya.swift | 237 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 399 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 182 | Function should have complexity 10 or less: currently complexity equals 11 |
| Moya.swift | 499 | File should contain 400 lines or less: currently contains 499 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 355 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 356 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 338 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 358 | Force unwrapping should be avoided. |
| Moya.swift | 182 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 54 lines |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 337 | Lines should not have trailing whitespace. |
| Moya.swift | 352 | Lines should not have trailing whitespace. |
| Moya.swift | 362 | Lines should not have trailing whitespace. |
| Moya.swift | 375 | Lines should not have trailing whitespace. |
| Moya.swift | 388 | Lines should not have trailing whitespace. |
| Moya.swift | 413 | Lines should not have trailing whitespace. |
| Moya.swift | 414 | Lines should not have trailing whitespace. |
| Moya.swift | 485 | Lines should not have trailing whitespace. |
| Moya.swift | 497 | Lines should not have trailing whitespace. |
| Moya.swift | 237 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 399 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 182 | Function should have complexity 10 or less: currently complexity equals 11 |
| Moya.swift | 499 | File should contain 400 lines or less: currently contains 499 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 355 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 356 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 338 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 358 | Force unwrapping should be avoided. |
| Moya.swift | 182 | Function body should span 50 lines or less excluding comments and whitespace: currently spans 54 lines |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 337 | Lines should not have trailing whitespace. |
| Moya.swift | 352 | Lines should not have trailing whitespace. |
| Moya.swift | 362 | Lines should not have trailing whitespace. |
| Moya.swift | 375 | Lines should not have trailing whitespace. |
| Moya.swift | 388 | Lines should not have trailing whitespace. |
| Moya.swift | 413 | Lines should not have trailing whitespace. |
| Moya.swift | 414 | Lines should not have trailing whitespace. |
| Moya.swift | 485 | Lines should not have trailing whitespace. |
| Moya.swift | 497 | Lines should not have trailing whitespace. |
| Moya.swift | 237 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 399 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 182 | Function should have complexity 10 or less: currently complexity equals 11 |
| Moya.swift | 499 | File should contain 400 lines or less: currently contains 499 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Moya.swift | 233 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 233 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 233 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 233 | Prefer checking `isEmpty` over comparing `count` to zero. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 `Executed 104 tests, with 0 failures (0 unexpected) in 4.819 (4.971) seconds`
 To reviewers: use the commits, not the entire files diff, because the commits are organized in a way that makes it easy to see what was changed.
  Hello everyone! I read the docs but couldn't find a way to track progress of current request ‚Äì for example, to show progress bar. Is it possible in Moya?
 It shouldn't be a ton of work (and should even be backwards compatible) to add support for `Moya.ProgressBlock` to the internal `requestNormal` method. Actually, now that I'm looking at it, `sendUpload` and `sendRequest` have a lot of duplicated code...
 Thanks for answer @ashfurrow. I don't know how to implement this in Moya but I would suggest this interface for end user:
`public func request(target: Target, progressClosure: ((progress: NSProgress) -> Void)? = nil, completion: Moya.Completion) -> Cancellable`. Probably this interface won't break current code (not sure how it will work with trailing closure syntax though).
 I might have ONE more PR...

> On Jul 13, 2016, at 11:19 AM, Ash Furrow notifications@github.com wrote:
> 
> @alexdoloz https://github.com/alexdoloz now that #543 https://github.com/Moya/Moya/pull/543 is merged, this should work if you use the latest version of Moya, on the master branch. If you're using CocoaPods, you can change the Podfile to include pod 'Moya', git: 'https://github.com/Moya/Moya.git' and do a pod update and it should work. Let us know!
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub https://github.com/Moya/Moya/issues/542#issuecomment-232424891, or mute the thread https://github.com/notifications/unsubscribe/AABrsnJZCNeLofJn60mOY489-OcM-nM6ks5qVR4hgaJpZM4JLOWe.
 #544 whitespace changes only üòÉ 
 Hello again, guys! Thank you for all your hard work implementing this feature. However, i tried to integrate it into application and noticed it doesn't work as I expect. For some reason, `bytesExpected` is always -1, therefore progress is always 1.0. 

Progress: ProgressResponse(totalBytes: 21654, bytesExpected: -1, response: nil)

Do you have any ideas about it?
 Okay, I figure out what happened. Server doesn't return `Content-Length` header. I tested other resources and progress works fine (provided these servers return `Content-Length`). So it was my mistake, no need to create new issue :)
 Glad to hear that you got to the bottom of it! Good to know about the Content-Length header. 

When you feel good about it, please close this issue. üëç

> On Jul 26, 2016, at 6:22 AM, alexdoloz notifications@github.com wrote:
> 
> Okay, I figure out what happened. Server doesn't return Content-Length header. I tested other resources and progress works fine (provided these servers return Content-Length). So it was my mistake, no need to create new issue :)
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
  So I have a view model that fetches articles from the internet and returns the changes in an array of (index, ChangeType) tuples. I basically want to test if a JSON response with 5 articles will emit an array of 5 inserts and then the next request should return a partially modified JSON that should make the viewModel emit one insertion and one update.

To test this I thought I could just make a custom provider that returns different stubs based on internal state ("isFirstResponse = true") of the provider but since the `endpointClosure` is a constant I can only do it in the init. This doesn't work though, because I would need to put `self` in the capture list of the closure, which is not yet initialised at this point.

The closure only gets the Target as an input, which doesn't change (I still request the same route for articles), so how would you model this?

Any help appreciated and thank you for his amazing framework!
 Thanks @ashfurrow for the great reply, I just took a look at your example (I've already taken a look at the whole project for reference). So you take a look at the page - a parameter depending on the target - which is a perfect fit here. 

I already implemented my test before I read your answer. I use a global variable that is changed after the first request was made and the test works fine. Personally, I would have preferred to keep the state inside the Provider subclass as a static variable, but `Static store properties not yet supported in generic types`, so I am happy for now. 

It's a great idea to discuss general best practices for Moya in the documentation (especially for testing), since I find myself so often trying to apply the sometimes specific solutions in the Artsy project to my own. I can think of special test providers, that I already use in my tests (like FailingProvider, which always returns a 404 response similar to a behaviour described in #533). 

Also, I still haven't found a best practice on how to handle my stubs. I currently have them as JSON files in the test target, which works ok, but I would prefer to have a setup like:

{ define values as variables }
{ create JSON with variables }
{ give JSON to provider as a stubbed response }
{ use provider to get response }
{ - parsing: check that the values returned are correctly parsed by comparing them with the variables declared above }
{ - viewModel: check that the viewModel returns correct values based on variables declared above
}

The motivation behind this is that I can't make a typo when asserting something by reusing the variables (actually constants) instead of taking a look at the value in my JSON stub. I've seen that you already discussed on how to inject the responses easier but I just can't find out where it was. It looked very promising!
 That's EXACTLY the issue I was talking about!

The list looks like a very good start and linking to an actual implementation sounds great as well üëç 
Having just reread the list, I really cannot think of anything else right now. It would cover all my testing scenarios. 

Another thing that doesn't relate to testing specifically is how to handle pagination. I don't know if there should be a snippet for that as well (especially if you want to focus on testing practices first). Currently, I use the following approach:

```
public struct PaginationInfo {
  let page: Int
  let limit: Int
  let offset: String?
}

enum MyAPI {
  case Search(query: String, pagination: PaginationInfo?)
  case UserByName(name: String, pagination: PaginationInfo?)
  ...

  func appending(paginationInfo info: PaginationInfo) -> MyAPI {
    switch self {
      case let Search(query, _):
        return Search(query: query, pagination: info)
      ...   
    }
  }
}
```

Pagination might work differently for each API, but a general approach might be helpful. The client then uses the `appending` function inside the `request` call to add the pagination info.

Anyways, do you want to open a new issue for the community to discuss the list?
  RxSwift is causing the current Moya version not to build using Carthage:

> A shell task failed with exit code 66:
> xcodebuild: error: Scheme RxExample-iOS-no-module is not currently configured for the build action.

Once we delete the scheme  RxExample-iOS-no-module, everything works fine. 
We aren't using RxSwift at all but it keeps causing problems.

Related RxSwift issue: https://github.com/ReactiveX/RxSwift/issues/793
 `carthage update --platform iOS`
 See https://github.com/ReactiveX/RxSwift/issues/793#issuecomment-232515707.
 #445 is a Swift's binary compatibilty issue, so that is not related to this.
 Seems to be working fine with Moya 7.0 and RxSwift 2.6. Looks like the problem was with RxSwift 2.5.0 and is fixed. Thanks for your help!
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">No Changelog entries made</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 Hey, we know it works!
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">No Changelog entries made</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
  I think it's time to craft a new release, especially for those who are using CocoaPods to reference Moya.

It will be a release with breaking changes and some great improvements, probably a 7.0.0 release?
 Working on it right now, looks straightforward.  Thanks for stalling!

> On Jul 13, 2016, at 8:54 AM, Ash Furrow notifications@github.com wrote:
> 
> We might have a non-backwards-compatible feature request worth squeezing in: #542 https://github.com/Moya/Moya/issues/542 I believe @colinta https://github.com/colinta is taking a look, I can help too.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub https://github.com/Moya/Moya/issues/535#issuecomment-232381039, or mute the thread https://github.com/notifications/unsubscribe/AABrsveZ90i0sXvBGz7tor_Fy5iC4WaAks5qVPxCgaJpZM4JKtqk.
 I'm done I swear! üòÉ 
 üëè

> On Jul 13, 2016, at 5:20 PM, Ash Furrow notifications@github.com wrote:
> 
> Closed #535.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
  I added some tests to verify correct behavior but can't get master to build. Applying the patch to 6.5.0 builds and passes though.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          :white_check_mark: Good on 'ya.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>No Changelog entries made</del></td>
      </tr>
  </tbody>
</table>

### SwiftLint found issues\n\n#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Moya.swift | 405 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 406 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 387 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 408 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 251 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 260 | Lines should not have trailing whitespace. |
| Moya.swift | 267 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 277 | Lines should not have trailing whitespace. |
| Moya.swift | 283 | Lines should not have trailing whitespace. |
| Moya.swift | 295 | Lines should not have trailing whitespace. |
| Moya.swift | 305 | Lines should not have trailing whitespace. |
| Moya.swift | 307 | Lines should not have trailing whitespace. |
| Moya.swift | 310 | Lines should not have trailing whitespace. |
| Moya.swift | 386 | Lines should not have trailing whitespace. |
| Moya.swift | 390 | Lines should not have trailing whitespace. |
| Moya.swift | 402 | Lines should not have trailing whitespace. |
| Moya.swift | 412 | Lines should not have trailing whitespace. |
| Moya.swift | 418 | Lines should not have trailing whitespace. |
| Moya.swift | 425 | Lines should not have trailing whitespace. |
| Moya.swift | 439 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 443 | Lines should not have trailing whitespace. |
| Moya.swift | 449 | Lines should not have trailing whitespace. |
| Moya.swift | 453 | Lines should not have trailing whitespace. |
| Moya.swift | 541 | Lines should not have trailing whitespace. |
| Moya.swift | 553 | Lines should not have trailing whitespace. |
| Moya.swift | 428 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 555 | File should contain 400 lines or less: currently contains 555 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 405 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 406 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 387 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 408 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 251 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 260 | Lines should not have trailing whitespace. |
| Moya.swift | 267 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 277 | Lines should not have trailing whitespace. |
| Moya.swift | 283 | Lines should not have trailing whitespace. |
| Moya.swift | 295 | Lines should not have trailing whitespace. |
| Moya.swift | 305 | Lines should not have trailing whitespace. |
| Moya.swift | 307 | Lines should not have trailing whitespace. |
| Moya.swift | 310 | Lines should not have trailing whitespace. |
| Moya.swift | 386 | Lines should not have trailing whitespace. |
| Moya.swift | 390 | Lines should not have trailing whitespace. |
| Moya.swift | 402 | Lines should not have trailing whitespace. |
| Moya.swift | 412 | Lines should not have trailing whitespace. |
| Moya.swift | 418 | Lines should not have trailing whitespace. |
| Moya.swift | 425 | Lines should not have trailing whitespace. |
| Moya.swift | 439 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 443 | Lines should not have trailing whitespace. |
| Moya.swift | 449 | Lines should not have trailing whitespace. |
| Moya.swift | 453 | Lines should not have trailing whitespace. |
| Moya.swift | 541 | Lines should not have trailing whitespace. |
| Moya.swift | 553 | Lines should not have trailing whitespace. |
| Moya.swift | 428 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 555 | File should contain 400 lines or less: currently contains 555 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Moya.swift | 253 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 253 | Prefer checking `isEmpty` over comparing `count` to zero. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 No sweat! I was having issues building master, so I followed [this recommendation](https://github.com/Moya/Moya/issues/525#issuecomment-230854674) and branched from 6.5.0 (where it worked), but I saw that there were some changes to `Moya.request` in master, so figured it was better to apply the patch in both places there even though I couldn't get it to build locally.
 I see that there are now two failing tests, [here](https://github.com/Moya/Moya/blob/master/Demo/Tests/MoyaProviderSpec.swift#L225) and [here](https://github.com/Moya/Moya/blob/master/Demo/Tests/MoyaProviderSpec.swift#L248). Since these appear to be the opposite of the desired behavior in #531 it might make sense to remove them.
 Don't remove them - reverse the expectation!
 e.g. 

``` diff
-it("never calls completion if cancelled immediately") {
+it("calls completion if cancelled immediately") {
```
 Awesome!
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/532?src=pr) is **63.29%**

> Merging [#532](https://codecov.io/gh/Moya/Moya/pull/532?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.11%**

``` diff
@@             master       #532   diff @@
==========================================
  Files            12         12          
  Lines           667        673     +6   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits            423        426     +3   
- Misses          244        247     +3   
  Partials          0          0          
```

[![Sunburst](https://codecov.io/gh/Moya/Moya/pull/532/graphs/sunburst.svg?src=pr&size=150)](https://codecov.io/gh/Moya/Moya/pull/532?src=pr)

> Powered by [Codecov](https://codecov.io?src=pr). Last updated by [f3f7570...05c2a77](https://codecov.io/gh/Moya/Moya/compare/f3f7570dcf875d2c95cae41397176c4577cfc555...05c2a77cbd4bff9e2ac07fe18ac1006b4b4a3da3?src=pr)
 I was looking into refactoring `sendUpload` and `sendRequest` to use a shared `sendAlamofireRequest` method, and I noticed that this line wasn't updated to return an error response:

https://github.com/jefflovejapan/Moya/blob/05c2a77cbd4bff9e2ac07fe18ac1006b4b4a3da3/Source/Moya.swift#L440

I want to make sure it _should_ be added, because I'm adding it to my changes.  But if it was deliberately skipped (maybe it's redundant? I didn't look too closely, but that doesn't seem to be the case) let me know!
 Oh shoot, also the plugins aren't notified of cancellations.  I'm going to add an internal helper:

``` swift
    internal func cancelCompletion(completion: Moya.Completion) {
        let error = Moya.Error.Underlying(NSError(domain: NSURLErrorDomain, code: NSURLErrorCancelled, userInfo: nil))
        plugins.forEach { $0.didReceiveResponse(.Failure(error), target: target) }
        completion(result: .Failure(error))
    }
```
 See #543 for my changes
 @colinta No you're right, this was an oversight on my part. Thanks for fixing!
 üòÅüëç

> On Jul 13, 2016, at 11:30 AM, Jeff Blagdon notifications@github.com wrote:
> 
> @colinta No you're right, this was an oversight on my part. Thanks for fixing!
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
  Since #532 is taking care of this, we can close this one.
  Unless I'm reading this code incorrectly, there are times when calling `cancel()` on the `cancellableToken` will have no effect.
1. Assigning `innerCancellable` to a property of a struct should have no effect once `cancellableToken` is returned to the caller.  The reason it "works" so far, is because `performNetworking` is _usually_ called synchronously.
2. The `isCancelled` property on `CancellableWrapper` always returns `false`, so the request would always be sent, _even if_ we fixed (1)

To address these issues:
1. Make `CancellableWrapper` a class, so that assigning `innerCancellable` asynchronously in `performNetworking` will have the desired effect.
2. Rename `isCancelled` to `canceled` for consistency w/ `Cancellable / CancellableToken`
3. Assign a default value to `innerCancellable` that keeps track of `canceled`, so that requests can be aborted before they are sent.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">No Changelog entries made</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 These are internal changes, no changelog entry necessary, I think.

If the changes are good, I would like to add specs around cancellables.  Async specs - UG.
 Some final notes as I let specs run on CI:
- Renamed `canceled` to `cancelled`, because it's spelled with two LLs throughout the rest of the code.
- Prior to this PR, the only place `canceled` was "exposed" was in `CancellableToken` as an internal property, so no breaking changes.  In `CancellableWrapper` it was `isCancelled`, and this was a private var.
- Updated specs accordingly
- Added specs to test cancel behavior, and here's the (strange? unintended?) logic that is tested:
  - if the request is cancelled immediately, the completion handler is not called
  - if the request is cancelled _before the request is sent_, the completion handler is not called
  - if the request is cancelled _after the request is sent_, the completion handler is called with a `.Failure`

In most cases, the completion handler _will be called_, because most people use the default `requestClosure`, which starts the request before `request` returns the `Cancellable`

It's strange, to me, that the completion handler works this way.  Anyone else? CC @Moya/contributors 
 `Executed 102 tests, with 0 failures (0 unexpected) in 3.764 (3.935) seconds`

It's `danger` that is causing circleci to fail üò¢ 

@ashfurrow good to go?
  Not sure why the schemes in Demo.xcworkspace were shared, they were causing a build failure with Carthage.
 From the test failing on this PR, it looks like they were shared so circleci could find them and run tests on the demo & test schemes.

Is there any way for circle CI to do so without the schemes being shared?
 Here was the relevant Carthage update output:

```
*** Building scheme "RxMoya iOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya iOS" in Moya.xcodeproj
*** Building scheme "Moya" in Demo.xcworkspace
*** Building scheme "Moya iOS" in Moya.xcodeproj
*** Building scheme "ReactiveMoya" in Demo.xcworkspace
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:395:17: warning: passing 2 arguments to a callee as a single tuple value is deprecated
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:693:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:695:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:697:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:699:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:701:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ParameterEncoding.swift:239:29: warning: 'init(start:end:)' is deprecated: it will be removed in Swift 3.  Use the '..<' operator.
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Request.swift:471:17: warning: keyword 'protocol' does not need to be escaped in argument list
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:32:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:35:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:187:9: warning: 'var' parameters are deprecated and will be removed in Swift 3
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:395:17: warning: passing 2 arguments to a callee as a single tuple value is deprecated
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:693:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:695:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:697:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:699:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:701:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ParameterEncoding.swift:239:29: warning: 'init(start:end:)' is deprecated: it will be removed in Swift 3.  Use the '..<' operator.
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Request.swift:471:17: warning: keyword 'protocol' does not need to be escaped in argument list
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:32:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:35:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:187:9: warning: 'var' parameters are deprecated and will be removed in Swift 3
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Moya/Moya.swift:174:40: warning: curried function declaration syntax will be removed in a future version of Swift; use a single parameter list
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Moya/Moya.swift:174:40: warning: curried function declaration syntax will be removed in a future version of Swift; use a single parameter list
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:395:17: warning: passing 2 arguments to a callee as a single tuple value is deprecated
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:693:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:695:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:697:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:699:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:701:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ParameterEncoding.swift:239:29: warning: 'init(start:end:)' is deprecated: it will be removed in Swift 3.  Use the '..<' operator.
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Request.swift:471:17: warning: keyword 'protocol' does not need to be escaped in argument list
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:32:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:35:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:187:9: warning: 'var' parameters are deprecated and will be removed in Swift 3
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:395:17: warning: passing 2 arguments to a callee as a single tuple value is deprecated
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:693:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:695:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:697:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:699:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:701:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ParameterEncoding.swift:239:29: warning: 'init(start:end:)' is deprecated: it will be removed in Swift 3.  Use the '..<' operator.
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Request.swift:471:17: warning: keyword 'protocol' does not need to be escaped in argument list
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:32:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:35:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:187:9: warning: 'var' parameters are deprecated and will be removed in Swift 3
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Moya/Moya.swift:174:40: warning: curried function declaration syntax will be removed in a future version of Swift; use a single parameter list
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Moya/Moya.swift:174:40: warning: curried function declaration syntax will be removed in a future version of Swift; use a single parameter list
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:89:70: warning: __FUNCTION__ is deprecated and will be removed in Swift 3, please use #function
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:89:99: warning: __FILE__ is deprecated and will be removed in Swift 3, please use #file
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:89:121: warning: __LINE__ is deprecated and will be removed in Swift 3, please use #line
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:164:41: warning: __FUNCTION__ is deprecated and will be removed in Swift 3, please use #function
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:164:70: warning: __FILE__ is deprecated and will be removed in Swift 3, please use #file
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:164:92: warning: __LINE__ is deprecated and will be removed in Swift 3, please use #line
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:174:38: warning: __FUNCTION__ is deprecated and will be removed in Swift 3, please use #function
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:174:67: warning: __FILE__ is deprecated and will be removed in Swift 3, please use #file
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:174:89: warning: __LINE__ is deprecated and will be removed in Swift 3, please use #line
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/ResultType.swift:5:2: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/ResultType.swift:6:2: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:89:70: warning: __FUNCTION__ is deprecated and will be removed in Swift 3, please use #function
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:89:99: warning: __FILE__ is deprecated and will be removed in Swift 3, please use #file
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:89:121: warning: __LINE__ is deprecated and will be removed in Swift 3, please use #line
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:164:41: warning: __FUNCTION__ is deprecated and will be removed in Swift 3, please use #function
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:164:70: warning: __FILE__ is deprecated and will be removed in Swift 3, please use #file
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:164:92: warning: __LINE__ is deprecated and will be removed in Swift 3, please use #line
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:174:38: warning: __FUNCTION__ is deprecated and will be removed in Swift 3, please use #function
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:174:67: warning: __FILE__ is deprecated and will be removed in Swift 3, please use #file
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/Result.swift:174:89: warning: __LINE__ is deprecated and will be removed in Swift 3, please use #line
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/ResultType.swift:5:2: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Result/Result/ResultType.swift:6:2: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:395:17: warning: passing 2 arguments to a callee as a single tuple value is deprecated
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:693:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:695:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:697:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:699:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:701:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ParameterEncoding.swift:239:29: warning: 'init(start:end:)' is deprecated: it will be removed in Swift 3.  Use the '..<' operator.
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Request.swift:471:17: warning: keyword 'protocol' does not need to be escaped in argument list
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:32:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:35:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:187:9: warning: 'var' parameters are deprecated and will be removed in Swift 3
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:395:17: warning: passing 2 arguments to a callee as a single tuple value is deprecated
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:693:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:695:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:697:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:699:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Manager.swift:701:18: warning: use of string literal for Objective-C selectors is deprecated; use '#selector' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ParameterEncoding.swift:239:29: warning: 'init(start:end:)' is deprecated: it will be removed in Swift 3.  Use the '..<' operator.
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/Request.swift:471:17: warning: keyword 'protocol' does not need to be escaped in argument list
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:32:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:35:5: warning: use of 'typealias' to declare associated types is deprecated; use 'associatedtype' instead
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/Alamofire/Source/ResponseSerialization.swift:187:9: warning: 'var' parameters are deprecated and will be removed in Swift 3
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:67:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:68:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:69:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:70:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:71:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:72:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:73:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:74:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:75:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:76:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:77:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:78:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:79:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:80:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:81:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:82:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:83:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:84:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:85:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
<unknown>:0: error: could not build Objective-C module 'ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:67:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:68:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:69:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:70:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:71:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:72:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:73:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:74:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:75:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:76:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:77:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:78:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:79:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:80:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:81:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:82:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:83:10: error: include of non-modular header insid** BUILD FAILED **


The following build commands failed:
    CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
    CompileSwift normal arm64 /Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/Swift/Action.swift
    CompileSwift normal arm64 /Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/Swift/Atomic.swift
    CompileSwift normal arm64 /Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/Swift/Bag.swift
    CompileSwift normal arm64 /Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/Swift/Disposable.swift
(5 failures)
e framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:84:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:85:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
<unknown>:0: error: could not build Objective-C module 'ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:67:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:68:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:69:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:70:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:71:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:72:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:73:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:74:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:75:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:76:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:77:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:78:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:79:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:80:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:81:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:82:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:83:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:84:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:85:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
<unknown>:0: error: could not build Objective-C module 'ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:67:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:68:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:69:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:70:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:71:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:72:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:73:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:74:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:75:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:76:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:77:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:78:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:79:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:80:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:81:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:82:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:83:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:84:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
/Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h:85:10: error: include of non-modular header inside framework module 'ReactiveCocoa.ReactiveCocoa'
<unknown>:0: error: could not build Objective-C module 'ReactiveCocoa'
A shell task (/usr/bin/xcrun xcodebuild -workspace /Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Demo.xcworkspace -scheme ReactiveMoya -configuration Release -sdk iphoneos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:
** BUILD FAILED **


The following build commands failed:
    CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
    CompileSwift normal arm64 /Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/Swift/Action.swift
    CompileSwift normal arm64 /Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/Swift/Atomic.swift
    CompileSwift normal arm64 /Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/Swift/Bag.swift
    CompileSwift normal arm64 /Users/asb/Developer/proxy-consumer-ios/Carthage/Checkouts/Moya/Demo/Pods/ReactiveCocoa/ReactiveCocoa/Swift/Disposable.swift
(5 failures)
```

Looks like it fails on scheme "ReactiveMoya" in Demo.xcworkspace
 The strange thing is, this is the first time I've seen the build error with schemes in Demo.xcworkspace, and I'm targeting release 6.5.0, so I'm not sure why this is coming up now...

Debugging on my machine, seeing if anything has changed with carthage or the flags I've been using
 Weird. So I got the problem fixed by deleting my project directory, cloning from github, and trying to build again.

Prior to that I wiped Carthage's cache, deleted my Cartfile.resolved and the Carthage Build & Checkouts folder... 

Not sure why that happened, but it seems to be working as a clean install.

Weird bug, but closing this because it doesn't seem to be a problem with Moya
  Moya target expected all request parameters to have unique keys. This requirement is not clearly specified HTTP requirement and pretty often disregarded by various frameworks and APIs developers. So sometimes we do need to send request like following http://someserver.com/api/?filter=a&filter=b while Moya due to current interface limitations is not able to do so. Is there any quick way to workaround it?
 It seems I can workaround it with Plugin with willSend implementation. It would be hard to actually fix it in Moya, as Alamofire underlaying implementation does expect Dictionary too.
 Ok, apparently Plugins are not able to modify requests due to following issue https://github.com/Moya/Moya/issues/326 Need to find another workaround. 
 Augmenting of request by overriding `urlRequest` property for endpoint is also impossible, since it is defined in extension :(
 It seem that the best option possible now is defying of requestClosure and intercept NSURLRequest there.
 Since there is no way to find out Endpoint Target value within RequestClosure, I was forced to match response URLs and define override behavior based on a URL patterns. Looks like a complete hack :(
 Yes, arrays specified as you described actually are duplicated parameter keys. This is what I was trying to solve. Custom endpoint mapping with a custom encode parameters for the scenario where duplicated parameter keys required helped. Thanks for a guidance. 

Meanwhile the amount of code required to handle the case that is correct use case for APIs is a little bit disappointing. Should I keep this issue closed or open for further discussion how possible to address this case?
 OK to close?
 Yes, it was fine to close. Sorry next time I will close myself. 
  fixes #525 
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          :white_check_mark: Well done.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>No Changelog entries made</del></td>
      </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="https://github.com/danger/danger/">danger</a>
</p>
 got it @esttorhe üòÑ 
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/526?src=pr) is **85.95%**

> Merging [#526](https://codecov.io/gh/Moya/Moya/pull/526?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will not change coverage

``` diff
@@             master       #526   diff @@
==========================================
  Files            12         12          
  Lines           484        484          
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
  Hits            416        416          
  Misses           68         68          
  Partials          0          0          
```

[![Sunburst](https://codecov.io/gh/Moya/Moya/pull/526/graphs/sunburst.svg?src=pr&size=150)](https://codecov.io/gh/Moya/Moya/pull/526?src=pr)

> Powered by [Codecov](https://codecov.io?src=pr). Last updated by [de5caed...1d06108](https://codecov.io/gh/Moya/Moya/compare/de5caed56ab5342e05a010069798a5e1e2878bea...1d06108eabc498e8cd9e57c319e054085506d3c9)
 thanks for the invite @ashfurrow üòÑ, I accepted!

All the new notifications I'm getting from Moya are a little crazy, but I love what you're trying to do setting up a community of people around Moya.

üî•
  The file `NetworkCurlLoggerPlugin.swift` doesn't exist. Tried looking back in the logs & blame, couldn't find much about the file. May be related to #505?
 of course, sorry about the lack of details @ashfurrow.

I'm on Xcode Version 7.3.1 (7D1014). I've tried building by:
1. Cloning the repo, opening in Xcode and attempting to build `Moya-iOS`
2. Doing a `carthage update --no-use-binaries --platform ios` with `github "Moya/Moya" "master"` in my Cartfile
 @orta that sounds right

@ashfurrow I downgraded to the latest release (6.5.0), so its not blocking üòÑ thank you for the suggestion 
I'll work on that PR and have it up in a couple minutes!
  Hello, 

why sample data function is required ? and not optional ?

thanks.
 Are there any good examples of how people have setup testing for their apps?
 The Ello iOS app makes very heavy use of `sampleData` https://github.com/ello/ello-ios
 Woah - thank you for open sourcing @colinta üéâ
 Well it's way more than just me!  The entire Ello team - from devs to marketing to leadership - were all very much a part of the decision to open source and the process that got us there.

So on behalf of everyone at Ello: happy to help!
 OK to close?
  <p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="https://github.com/danger/danger/">danger</a>
</p>
  After seeing Moya and that it has support for RxSwift I was really hoping to add it to a project that I was just about to get started on. However without support for swift 3.0 I would be unable to use Moya without updating it myself. I was wondering what the plans for swift 3.0 are and if there will be an update in the near future. 
 Thank you for referring me to that. It may be beneficial to add /3.0 to the end of the title because there is discussion about more than just 2.3.
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/521?src=pr) is **85.95%**

> Merging [#521](https://codecov.io/gh/Moya/Moya/pull/521?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will decrease coverage by **0.50%**

``` diff
@@             master       #521   diff @@
==========================================
  Files            12         12          
  Lines           480        484     +4   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits            415        416     +1   
- Misses           65         68     +3   
  Partials          0          0          
```

[![Sunburst](https://codecov.io/gh/Moya/Moya/pull/521/graphs/sunburst.svg?src=pr&size=150)](https://codecov.io/gh/Moya/Moya/pull/521?src=pr)

> Powered by [Codecov](https://codecov.io?src=pr). Last updated by [f6af892...69b517e](https://codecov.io/gh/Moya/Moya/compare/f6af892abb5b10870016ab897941c50a3be968ea...69b517ee8d41e906488a9f108de1b4ce9f60ebd2)
 hope this help [https://gist.github.com/at-daonv/af317a2c41c6336810ab48c0d90f323d](https://gist.github.com/at-daonv/af317a2c41c6336810ab48c0d90f323d)
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          :white_check_mark: Yay.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>No Changelog entries made</del></td>
      </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">PR is classed as Work in Progress</td>
    </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="https://github.com/danger/danger/">danger</a>
</p>
  ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/520?src=pr) is **86.45%**

[![Sunburst](https://codecov.io/gh/Moya/Moya/pull/520/graphs/sunburst.svg?src=pr&size=150)](https://codecov.io/gh/Moya/Moya/pull/520?src=pr)

> No coverage report found for **master** at f00ac46.
> 
> Powered by [Codecov](https://codecov.io?src=pr). Last updated by [f00ac46...1eb7e7a](https://codecov.io/gh/Moya/Moya/compare/f00ac461719a3c8d189432e7f2810ff6695d3648...1eb7e7a19b3bc125c02315ac622961a9d7f99af7)
  'OSSpinLock' is unsafe, so change to 'dispatch_semaphore'.
why 'dispatch_semaphore' ? because the efficiency. it's faster than other ,except 'OSSpinLock'.
detail in #516
  Hi,

I'm trying to send a request with a boolean value, so I configured my Target like this:

``` swift
public enum MyAPI {
   ...
  case Foo(NSNumber, String, String, String, Bool)
  ...
}
```

My parameters:

``` swift
  public var parameters: [String: AnyObject]? {
    switch self {
   ...
    case .Foo(_, let data1, let data2, let data3, let boolData):
      return [
        "data1": data1,
        "data2": data2,
        "data3": data3,
        "somethingBool": Int(boolData)
      ]
    default:
      return nil
    }
  }
```

Problem:
My request is always sending false as the value.
 What about

``` swift
  public var parameters: [String: AnyObject]? {
    switch self {
   ...
    case .Foo(_, let data1, let data2, let data3, bool data4):
      return [
        "data1": data1,
        "data2": data2,
        "data3": data3,
        "somethingBool": data4 ? 1 : 0
      ]
    default:
      return nil
    }
  }
```
 @ashfurrow: Sorry, I forgot to mention it. That was my first attempt, and it also sends false there.
I've tried to make the request via postman and it succeeded with the proper value. Maybe the specification of the request helps to detect if it's a server error or Moya's configuration one.
 @ashfurrow I'm detecting it on the client side. The parameter is being sent as 0 or 1 but I guess I'm missing to track the **real** request body being sent to the server. I'll try to use that plugin and see what happens
 @jasl I've tried to do what you've said and got the same result.

I've finally managed to save the value by sending the value as a string: `"true"` or `"false"`, but I'm not really sure what's causing the boolean to fail.

``` swift
  public var parameters: [String: AnyObject]? {
    switch self {
   ...
    case .Foo(_, let data1, let data2, let data3, bool data4):
      return [
        "data1": data1,
        "data2": data2,
        "data3": data3,
        "somethingBool": "\(data4)"
      ]
    default:
      return nil
    }
  }
```
 @lucasp90 
Sorry my previous answer is wrong.

Both URI query and form are only support string, other types should be encoded to string (Moya can help you do some, but not all, [details here](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L93-L102)) .
There are three common practices for passing boolean value to server side:
- `"1"` for `true`, `"0"` for `false`
- `"t"` for `true`, `"f"` for `false`
- `"true"` for `true`, `"false"` for `false`

Choose what is depending your server side, if you passing string `"true"` or `"false"` to server can get right response, just keeping the way.
 @ashfurrow 
I think better not do this, because there haven't a standard practice for passing boolean value yet, different web framework may have different convention.
 @ashfurrow 
Ruby on Rails (one of the most famous web framework) both using `1`/ `0` and `t` / `f`
 Oh, sorry! I thought I'd answered after my issue was detected! 
I think my question has been properly answered :)

Would it be a good idea to add examples about passing different parameter types to an endpoint?
 I think that's a good place for them.
 Yeah, of course!! üëç 
  Hi there,
i hope this won't be a another repeated question, in case please tell where i should read about this.
So this is my situation:

``` swift
public enum MyAPI {
  case EditUser(user: AnyObject, profilePicture: AnyObject?)
}
public var parameters: [String: AnyObject]? {
    switch self {
    case .EditUser(let user, let profilePicture):
      let currentUser: User = user as! User
      var currentUserDictionary: [String: AnyObject]?
      try! Realm().write({
       currentUserDictionary = Mapper().toJSON(currentUser)
      })      
      return ["user" : currentUserDictionary!]
    default:
      return nil
    }
 }

```

I'm using Moya + Realm + ObjectMapper and everything works great but now, as you can understand from code, i need to eventually pass also an image in parameters .  
Actually i correctly do this `.PUT` request if i pass `nil` as profilePicture. ObjectMapper serialize without problems object `User`, sending it to back-end doing the user edit.
I would insert `profilePicture` inside currentUserDictionary but i currently don't understand if i need to implement a multipart upload.
Does anyone encountered this kind of situation and can help me with some suggestions?
Thank's in advance
 @justinmakaila At the moment  and for the server implementation i decided to use this approach

```
let image: UIImage? = images.first!
    let url = Constants.baseURLAPI + "/users/\(CurrentUser.get().id)"
    var currentUserAsJSONDictionary: [String: AnyObject]?
    try! Realm().write({
      currentUserAsJSONDictionary = Mapper().toJSON(currentUser!)
    })
    let headers: [String: String] = [
      "Accept" : Constants.acceptHTTPHeaderField,
      "Accept-Language" : Constants.acceptLanguageHTTPHeaderField,
      "Client-Version" : Constants.clientVersionHTTPHeaderField,
      "If-None-Match" : "",
      "If-Modified-Since" : "",
      "X-API-Username" : CurrentUser.get().username,
      "X-API-Token" : UICKeyChainStore.stringForKey("token")]

    Alamofire.upload(.PUT, url, headers: headers, multipartFormData: { (multipartFormData) in
      if let _image = image {
        if let imageData = UIImageJPEGRepresentation(_image, 1.0) {
          multipartFormData.appendBodyPart(data: imageData, name: "user[profile_picture]", fileName: "profile_picture.jpg", mimeType: "image/jpg")
        }
      }
      }, encodingMemoryThreshold: Manager.MultipartFormDataEncodingMemoryThreshold) { (encodingResult) in
        switch encodingResult {
        case .Success(let upload, _, _):
          upload.progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
            print(totalBytesRead)
          }
          upload.responseJSON(completionHandler: { (response) in
            do {
              if response.response?.statusCode == 200 {
                let responseJSON: AnyObject = response.result.value!
                let receivedResponseUser: User = Mapper<User>().map(responseJSON)!
                try! self.realm.write { () -> Void in
                  self.realm.add(receivedResponseUser, update: true)
                }
                let url = NSURL(string: receivedResponseUser.profilePictureSmall)
                self.currentUserImageView.kf_setImageWithURL(url!)
                self.imagePickerController.dismissViewControllerAnimated(true, completion: nil)

              } else {
                print("************** PHOTO NOT UPDATED **************")

              }
            } catch {

            }

          })

        case .Failure(let encodingError):
          self.imagePickerController.dismissViewControllerAnimated(true, completion: nil)
          print(encodingError)
        }

```

And it works well :)
  Maybe ‚ÄòOSSpinLockLock‚Äô is unsafe. 

http://mjtsai.com/blog/2015/12/16/osspinlock-is-unsafe/
https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151214/000372.html
 'dispatch_semaphore' is a better one, I'll pull a request later.
  This adds 2 new doc files:
- `Plugins.md` for an overview of plugins and descriptions of the existing core plugins
- `CustomPlugin.md` for an example of creating a new plugin

Original discussion is here: https://github.com/Moya/Moya/issues/397

I wrote this locally and I wasn't sure how to setup links, use swift syntax etc in markdown so any feedback would be great. 

Thanks
 Thanks @colinta I've merged those changes

@ashfurrow I've just pushed those suggested changes

Thanks both for the feedback / help 
  Took a crack at checking out swift 2.3 support this morning... 
### The good news:
- Apple's migrator tool is great, after running on Moya, the demo target and tests (iOS,tvOS)  built and worked/passed
- The changes don't look too bad from Moya's end
- Foundation Value types and the new Swift API Guidelines don't come into play until Swift 3 which greatly limits changes.
- swift 2 and 2.3 can live side by side with `#if swift(>=2.3) ...` 
### The meh news:
- Nimble under macOS had some issues I've seen reported as Xcode/Foundation related -- affects macOS test target
- xcodebuild doesn't pick up the swift legacy flag which triggers a compile against a 2.0 toolchain Xcode _should_ in the future hopefully not do this. Until then `rake build` and `rake test` don't work without setting the TOOLCHAINS Environment flag. This is probably a bug in xcodebuild.
- Relatedly Setting of the legacy swift flag is not performed by the migrator maybe because they want 2.0/2.3/3.0 to try and live side by side but that will cause weirdness with dependent projects.

So tracking what happened when I got it all building:
- _Moya Changes:_ 
- [ ] A couple URL API's changed nullability. Should check documentation and expectations and see if implicitly unwrapped is safe. Most are similar to:

``` diff
 public func url(route: TargetType) -> String {
-    return route.baseURL.URLByAppendingPathComponent(route.path).absoluteString
+    return route.baseURL.URLByAppendingPathComponent(route.path)!.absoluteString!
 }
```
- [x] Decision on setting Swift Legacy flags. 2.0 and 2.3 coexisting is great, but value types + API guideline changes are not a small change. (probably breaking or a lot of fixme writing)
- _Dependencies_
- [ ] Alamofire:  https://github.com/Alamofire/Alamofire/pull/1313
- [ ] Result: GTG
- [x] Quick/Nimble: https://github.com/Quick/Quick/issues/55, https://github.com/Quick/Nimble/pull/302
- [ ] RxSwift: ??
- [ ] ReactiveCocoa: ?? some small attribute updates -- Don't know if they have an issue yet.

P.S. It's been a while since I ran Moya in dev mode and it took me a little while to get oriented, do you guys think a quick _Getting Started With Developing Moya_ section somewhere would be useful? maybe #270. I don't really use rake for build scripting so it took a bit to get that setup.
 > RxSwift: ??

With ReactiveX/RxSwift@9b1583f2e365ef78d250be278ca5838076b58095 RxSwift supports Swift 2.3. It doesn't have the correct build flag.
 Another thing to think about is if it makes sense to skip 2.3 and go straight to 3.0 or how to support 3 versions. The `#if swift()` tests don't work so well when swift 3.0 is in the mix. 
 I highly recommend a Swift 2.3 build, even as a version bump, before going to Swift 3. Alamofire had breaking changes so without this people won't be able to use pre-Swift 3 on Xcode 8. I know I'll be using Xcode 8 and Swift 2.3 for a while after the release.
 Looks like Alamofire is about to cut a `3.5.0` release which will have both swift 2.2 and swift 2.3 support. Then Moya.spec can point to that.

https://github.com/Alamofire/Alamofire/milestone/27

I think this is the  dependency to push a release supporting 2.3
 Is there any update on swift 3.0 support now that Xcode 8 GM is out
 Need swift 2.3 and swift 3.0 support here...
  <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          :white_check_mark: Well done.
      </th>
     </tr>
  </thead>
  <tbody>
      <tr>
        <td>:white_check_mark:</td>
        <td data-sticky="true"><del>No Changelog entries made</del></td>
      </tr>
  </tbody>
</table>

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="https://github.com/danger/danger/">danger</a>
</p>
  There is an issue like in title above, here is my code

```
import Moya

enum UserAPIService {
  case Register(user: User!)
  case Login(login: String!, password: String!)
}

// MARK: - TargetType Protocol Implementation
extension UserAPIService: TargetType {
  var baseURL: NSURL { return APIServiceConst.baseURL! }

  var path: String {
    switch self {
    case .Register:
      return "/user/create"
    case .Login:
      return "/user/login"
    }
  }

  var method: Moya.Method {
    switch self {
    case .Register, .Login:
      return .POST
    }
  }

  var parameters: [String: AnyObject]? {
    switch self {
    case .Register(let user):
      return user.toJSON()
    case .Login(let login, let password):
      return ["login": login, "password": password]
    default:
      return nil
    }
  }

  var sampleData: NSObject {
    switch self {
    case .Register:
      return "".UTF8EncodedData
    case .Login:
      return "".UTF8EncodedData
    }
  }
}

// MARK: - Helpers
private extension String {
  var URLEscapedString: String {
    return self.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLHostAllowedCharacterSet())!
  }
  var UTF8EncodedData: NSData {
    return self.dataUsingEncoding(NSUTF8StringEncoding)!
  }
}
```

I'm using cocoapods and your latest commit 
`pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :commit => '122d2f8'`
 my bad, there should by NSData instead of NSObject, please close the issue. Sorry.
  Hi. I am trying to build network layer for my app with moya, but i have this issue. I have like 25-30 endpoints and i need a custom header for almost all of them. (headers which containing token etc.). 
Can I set a default header or return header for all endpoints from TargetType enumaration? 

Or do I have to create a endpoint closure for all of them? 
 Thank you! I think there would be no problem, if I examine your library and get some inspirations :)

I am following Ello as much as I can by the way. You are doing great work! May the success be with you üëç 
  Replaced:
  `url(target)`
with:
  `let url =
target.baseURL.URLByAppendingPathComponent(target.path).absoluteString`

as the current distribution of Moya does not include `func url`.

Alternatively `func url` could perhaps be added to Moya as a helper
method, perhaps as an extension method e.g.:

``` swift
/// Endpoint closure `url` helper
extension Endpoint {
    public class func url(route: TargetType) -> String {
        return
route.baseURL.URLByAppendingPathComponent(route.path).absoluteString
    }
}
```

...which would remove some code duplication in the examples.
  Hi,

As I have no idea how the thing I want to do is called I failed to search it on the Internet.
Can you tell me how to send a parameter two times for example?
Like if I want to register a book, `Genre` can be `Science Fiction` and `Fantasy`.
So I need to do like:

``` swift
provider = MoyaProvider<TEST>()
provider.request(.Genre("Science Fiction"), .Genre(Fantasy)) { result in
    // do something with the result
}
```

But I don't think it's the right way to do.
Can someone understand what I mean?

Vivien
 You can have two enum cases. One that takes a string and one that takes an array of strings. 
 Not sure to understand what you mean :/
Can you explain it with code please?
 Sorry but we had to delay the use of Moya to one sprint in September due to bugs in our app.
Be sure that I will update this one once checked ! ;)
 Hi,
We had couple of troubles with our app (nothing related to Moya).  
We had to put aside our project so I can't update it unfortunately :/  Taking basis on #257, I changed the `NetworkLoggingPlugin` class to be able to print out **cURL** friendly logs.

I find this particularly helpful when working on integrating and testing APIs with the backend developer, as copy-pasting this will make sure he can actually replicate API calls without any burden on my end.

I realise that `CancellableToken` already has this sort of debugging, but it helps that I can turn on logging for all requests regardless.

Disregard my first few commits as I was trying an approach which was not taking into consideration the wrapping of `Alamofire.Request`s into `RequestType`s. As we can actually use the `CustomDebugStringConvertible` protocol for `cURL` printing.

To set the `NetworkLoggingPlugin` into `cURL` printing mode just init it with `NetworkLoggingPlugin(cURL: true)`.

The output generated should be similar to this: 

``` bash
$ curl -i \
    -X POST \
    -H "X-APP-USER-TOKEN: OBQ6tGUib-kPDGyi0-HqZbjvYmnpPjzGjkGyDGz62vEs4jTXpR_YZcbqzZP9tmYd" \
    -H "User-Agent: App/my.app.App (3; OS Version 9.3 (Build 13E230))" \
    -H "Accept-Encoding: gzip;q=1.0, compress;q=0.5" \
    -H "X-APP-AUTH-TOKEN: 9qqcMrb1ceIb9waEahrnDDFepPOwqTyI32k8FDPlMuNztGtPJVDM6rQmRwswNgFlUwZdpJGSL4wh1X723a4NGA==" \
    -H "Accept-Language: en;q=1.0" \
    -H "Content-Type: application/json" \
    -d "{\"city_id\":\"4c423220-dd67-4f60-8565-95714d1f359a\",\"from_date\":\"21\/06\/2016\",\"to_date\":\"24\/06\/2016\",\"public\":true}" \
    "http://backend-app.herokuapp.com/api/v1/users/trips"
```

Possible future changes, using the `Moya_Logger: [Timestamp]` before printing the `cURL` data.
    Our applications read in a configuration api that has a list of web services the application will use. 

Is there a way to dynamically generate these webservice endpoints into moya at runtime?
 Perhaps, something like this could work:

``` swift
enum APIProvider {
    // returns an array of objects with `apiPath` in each.
    /* Example: [
        {
            "title": "Followers",
            "apiPath": "/people_components/{userUUID}/followers", 
        },
        {
            "title": "Following",
            "apiPath": "/people_components/{userUUID}/following"
        },
        {
            "title": "Blocked",
            "apiPath": "/people_components/{userUUID}/blocked"
        }
    ] */
    case PeopleComponents

    case People(apiPath: String, userUUID: String)
}

extension APIProvider: TargetType {
    var baseURL: NSURL { return NSURL(string: "http://localhost:3000")! }

    var path: String {
        switch self {

        case let .PeopleComponents:
            return "/people_components"

        case let .People(apiPath, userUUID):
            return apiPath.stringByReplacingOccurrencesOfString("{userUUID}", withString: "\(userUUID)")

    }
}

// ...
```
  ``` swift
let endpointClosure = { (target: USRequestAPI) -> Endpoint<USRequestAPI> in

    let url = target.baseURL.absoluteString+target.path
    let headers = ["access_token":"6ae51080ce36493f813a1d8ed073fb36"] //userid  = 61

    let endpoint: Endpoint<USRequestAPI> = Endpoint<USRequestAPI>(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters,parameterEncoding:parameterEncoding(target),httpHeaderFields:headers)

    // Sign all non-authenticating requests
    return endpoint
}

func parameterEncoding(target: USRequestAPI) -> Moya.ParameterEncoding {
    switch target {
        default:
        return .JSON
    }
}

let USProvider = RxMoyaProvider<USRequestAPI>(endpointClosure: endpointClosure, plugins: [NetworkLoggerPlugin()])

 public func request(token: Target) -> Observable<Response> {

        // Creates an observable that starts a request each time it's subscribed to.
        return Observable.create { [weak self] observer in
            let cancellableToken = self?.request(token) { result in
                switch result {
                case let .Success(response):
                    observer.onNext(response)
                    observer.onCompleted()
                    break
                case let .Failure(error):
                    observer.onError(error)
                }
            }

            return AnonymousDisposable {
                cancellableToken?.cancel()
            }
        }
    }
```

In the log ,always twice or more request log.
If I in the code ,

``` swift
 internal extension MoyaProvider {

    func sendRequest(target: Target, request: NSURLRequest, queue: dispatch_queue_t?, completion: Moya.Completion) -> CancellableToken {
        let alamoRequest = manager.request(request)
        let plugins = self.plugins

        // Give plugins the chance to alter the outgoing request
        plugins.forEach { $0.willSendRequest(alamoRequest, target: target) }

        // Perform the actual request
        alamoRequest.response(queue: queue) { (_, response: NSHTTPURLResponse?, data: NSData?, error: NSError?) -> () in
            let result = convertResponseToResult(response, data: data, error: error)
            // Inform all plugins about the response
            plugins.forEach { $0.didReceiveResponse(result, target: target) }
            completion(result: result)
        }

        alamoRequest.resume()

        return CancellableToken(request: alamoRequest)
    }
```

run twice.
What's the problem
 I use a file ,but the all no in some class

``` swift
let endpointClosure = { (target: USRequestAPI) -> Endpoint<USRequestAPI> in

    let url = target.baseURL.absoluteString+target.path
    let headers = ["access_token":"6ae51080ce36493f813a1d8ed073fb36"] //userid  = 61

    let endpoint: Endpoint<USRequestAPI> = Endpoint<USRequestAPI>(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters,parameterEncoding:parameterEncoding(target),httpHeaderFields:headers)

    // Sign all non-authenticating requests
    return endpoint
}

func parameterEncoding(target: USRequestAPI) -> Moya.ParameterEncoding {
    switch target {
        default:
        return .JSON
    }
}

let USProvider = RxMoyaProvider<USRequestAPI>(endpointClosure: endpointClosure, plugins: [NetworkLoggerPlugin()])
```

I use e RxMoyaProvider extension

``` swift
    public func requestNoResponseMapper<T:Mappable>(token: Target) -> Observable<T?> {

        // Creates an observable that starts a request each time it's subscribed to.
        return Observable.create { [weak self] observer in
            let cancellableToken = self?.request(token) { result in
                switch result {
                case let .Success(response):
                    var validate : String?

                    do {
                        validate = try self?.validateResponse(response)
                    }catch{
                        observer.onError(error)
                    }

                    if let _ = validate {
                        observer.onError(USError.ResponseValidate(validate!))
                        return
                    }

                    observer.onCompleted()

                    break
                case let .Failure(error):
                    observer.onError(USError.NetworkError(error.nsError.localizedDescription))
                }
            }

            return AnonymousDisposable {
                cancellableToken?.cancel()
            }
        }
    }
```

So ,every time I use 

``` swift
  let checkModel : Observable<CheckModel> = USProvider.requestObjectMapper(.CheckPortfolio(version : version))

        checkModel.subscribeNext { (checkModel) in


            self.saveCheckModel(checkModel)


        }.addDisposableTo(disposeBag)

        checkModel.subscribeError { (error) in


        }.addDisposableTo(disposeBag)

```

to get the data.

In the console , I can find two log

```
[fg0,255,0;[bg;2016-06-07 09:34:55 [Info] [main] [NetworkLogger.swift:32] willSendRequest(_:target:) > Optional(<NSMutableURLRequest: 0x7fa46c2ba820> { URL: http://192.168.40.203:8000/webull-app-center/api/portfolios/check?version=4396 })[;
[fg0,255,0;[bg;2016-06-07 09:34:55 [Info] [main] [NetworkLogger.swift:32] willSendRequest(_:target:) > Optional(<NSMutableURLRequest: 0x7fa46c182600> { URL: http://192.168.40.203:8000/webull-app-center/api/portfolios/check?version=4396 })[;
```

In the requestNoResponseMapper, I can receive two .Success response

Although the log print will send request twice ,but when I subscribeNext, the only call once. 
But if the request failed ,the Moya like to try to send request  many time (maybe 6 times)
 @ashfurrow hello
public func request in a method in Moya's Moya+RxSwift 

``` swift
public func request(token: Target) -> Observable<Response> {

    // Creates an observable that starts a request each time it's subscribed to.
    return Observable.create { [weak self] observer in
    let cancellableToken = self?.request(token) { result in
        switch result {
        case let .Success(response):
            observer.onNext(response)
            observer.onCompleted()
            break
            case let .Failure(error):
                observer.onError(error)
            }
        }

        return AnonymousDisposable {
            cancellableToken?.cancel()
        }
    }
}
```

but is use some extension by myself to parse the response, like 

``` swift
 public func requestObjectMapper<T:Mappable>(token: Target) -> Observable<T> {

        // Creates an observable that starts a request each time it's subscribed to.
        return Observable.create { [weak self] observer in
            let cancellableToken = self?.request(token) { result in
                switch result {
                case let .Success(response):
                    var validate : String?

                    do {
                        validate = try self?.validateResponse(response)
                    }catch{
                        observer.onError(error)
                    }

                    if let _ = validate {
                        observer.onError(USError.ResponseValidate(validate!))
                        return
                    }

                    do{
                        let object : T = try response.mapObject()
                        observer.onNext(object)
                        observer.onCompleted()
                    }catch{
                        observer.onError(error)
                    }

                    break
                case let .Failure(error):
                    observer.onError(USError.NetworkError(error.nsError.localizedDescription))
                }
            }

            return AnonymousDisposable {
                cancellableToken?.cancel()
            }
        }
    }

```

It's only parse response use the ObjectMapper 
 @kyleYang Are you still running into this issue?  I am trying to make a POST request with parameters in the url and without body. But when I got the response there was not any parameter in the requested url. Does it mean for POST requests, Moya uses parameters to build their body? I also tried to change ParameterEncoding to .URL but still it is not adding anything to the url. 
  Greetings,

When I try to send a GET request using Moya with parameterEncoding .JSON to my server, the request fails with 400 because it says that the client disconnected too quickly.  Using httpie to make the same GET request works fine.  However, when I change both Moya and the server to treat the same method as a POST rather than a GET, everything works.

I am wondering whether GET with parameterEncoding .JSON is rather uncommon?  Here is my endPoint.

```

    let endpoint = Endpoint<MyAPI>(URL: url, sampleResponseClosure: { .NetworkResponse(200, target.sampleData) }, method: target.method, parameters: target.parameters, parameterEncoding: .JSON)

    let headerFields = [
        "Content-Type": "application/json"]

    return endpoint.endpointByAddingHTTPHeaderFields(headerFields)
}
```
 GET is meant as simply a request to a URL. Thus URL encoding is the only real thing that makes sense.

I'd try switching over to POST.
 Got it.  Thank you.
  At first I got confused when reading the documentation, because `MoyaResponse` does not exist (`RxMoyaProvider` does on the other hand). Changed the docs to match the class location which is `Moya.Response`.
 Done. ;)
  Hey Guys,

Thanks a lot for the awesome work that is being done to ship Moya. 

Actually i want to discuss with you a feature that came on my mind to extend Moya. 

Basically i'm using Alamofire and i used to make a Router that organize my Alamofire API calls. however after i heard about Moya i just checked out the documentation and realized that it's pretty awesome specially for reactive programming and for unit testing. So i said i've to stop and adopt Moya in my Swift projects. 

However, I used to do kind of technique called **Dependency Inversion Principle (DIP)** to make my web service layer more ignorant about the rest of the App. I do that by creating a new layer more abstract like a (protocol) act as a gateway between my app and the service layer(That connect to the network).  The service layer eventually implements the gateway protocol. The protocol act as as a contract. The rest of the app can now be ignorant. It knows about the contract but not about any class that satisfy the contract. This makes it easy to replace the marvel service with whatever we want to use for unit testing. 

The following Diagram illustrate what i mean:
![clean-request](https://cloud.githubusercontent.com/assets/4720325/15528081/ae1ade5e-2240-11e6-8604-6694fe009265.png)

So i thought since Moya is more like abstraction layer, why not we implement this into Moya to make the rest of the app more ignorant about Moya. 

Is that sounds interesting?

P.S. I'd be happy to share some code that i already did for implementing DIP principle with Alamofire framework.
 Hi @iSame7, can you share the code for better explaining?
 I create a protocol for my network calls wraps my methods of my target. Then I inject them into my view models using [Swinject](https://github.com/Swinject/Swinject). This way my objects have no idea what they are interfacing with just that it conforms to a service or network type. Sounds similar to what you are doing.
  Hi,

Here is the case:
- return to the app from the lock screen;
- nearly immediately (1-2 seconds) send the HTTP request via moya;

Actual Result:
- moya returns error `Moya.Error.Underlying` and says that the response (NSHTTPURLResponse) is `nil`. NSError contains - `error NSError?    domain: "NSURLErrorDomain" - code: 18446744073709550611 0x000000012c5d9700`

Note:
The code where this debug info caught:
File: `Moya.swift`
Func: `internal func convertResponseToResult(response: NSHTTPURLResponse?, data: NSData?, error: NSError?) -> Result<Moya.Response, Moya.Error>`

It could be steadily reproduced **only within 1-2 seconds after returning to the application from the lock screen**.

Please help.
 Yes. Sure. We will upload our app in a private repo and give you access as we do think that the code should be seen as a whole and not as a except from the context.
In short we have chain of two requests (rxswift). The first one goes to HTTP and works well, the subsequent one calls HTTPS youtube API and fails with the symptoms I described above.
It is reproduced on iOS 9 only. iOS 8 seems to not having this issue.
For App Transport Security the following settings are applied:
`<key>NSAppTransportSecurity</key>
<dict>
  <key>NSAllowsArbitraryLoads</key>
      <true/>
</dict>`
 Hey Ash. Just sent you the code that reproduces the issue. We just broke our heads searching for the cause of the issue but still no luck.
Please check you e-mail.
 1. Device: any iPhone physical (not simulator) device
2. wifi connection - excellent. Internet connection 10Mbps (i.e. good)
3. Server logs. As you could see there are two requests sent in a row. The first one is to our server and it's 200OK. The next one HTTPS sent to youtube. We cannot get youtube server logs.
4. **The important thing - if you will allow ~5+ seconds to pass after the moment you unlocked device and until the moment you pull to refresh for the news - everything will work ok. Also the second pull-to-refresh works ok.**
 Same problem with my App.
Turns out that if the response is empty, .mapJson() will cause this error.
 @ashfurrow Maybe a silence option to prevent the error from throwing out but rather just return a `nil` ?
 Ash, sorry what's the "PR"? Possible resolution?
 @ashfurrow please re-open the issue. This issue still exists in the latest version of Moya.

Asked on StackOverflow
http://stackoverflow.com/questions/38900522/ios-https-get-empty-response-from-server-after-the-app-returns-back-from-the-l
 Don't know. Need to check. Who can check fast?
  I completely agree. We should keep `.nsError` and get rid of RAC 2.0 with the next major release.
 I don't think we should keep the nsError property. It really doesn't add anything. You can get all the same information from `Error`. The advantage I see NSError is that can be printed nicely to the console but that can easily be added to `Error`
  Hello,

I'm having the exact same issue as #464.

I posted a comment there but here the relevant information:

I'm using Carthage to manage my dependencies. I've also used Cocoapods before, and this didn't happen.

Here is my Cartfile:

```
github "ReactiveX/RxSwift" ~> 2.0
github "Moya/Moya"
github "sunshinejr/Moya-ModelMapper"
```

I'm using the following command to build the dependencies:

```
carthage update --platform iOS
```

And then I'm just linking the frameworks that are in `Carthage/Build/iOS` inside the project.

I'm trying to create an endpoint for authentication:

``` swift
import Foundation
import Moya

enum Auth {
    case Login(email: String, password: String)
    case Logout()
}

extension Auth: TargetType {

    var baseURL: NSURL { return NSURL(string: "https://localhost/api")! }

    var path: String {
        switch self {
        case .Login(_, _):
            return "/users"
        case .Logout(_):
            return "/users"
        }
    }

    var method: Moya.Method {
        switch self {
        case .Login(_, _):
            return .POST
        case .Logout(_):
            return .DELETE
        }
    }

    var parameters: [String: AnyObject]? {
        switch self {
        case .Login(let email, let password):
            return ["email": email, "password": password]
        case .Logout(_):
            return nil
        }
    }

    var sampleData: NSData {
        switch self {
        case .Login(_, _):
            return "".dataUsingEncoding(NSUTF8StringEncoding)!
        case .Logout(_):
            return "".dataUsingEncoding(NSUTF8StringEncoding)!
        }
    }
}

private extension String {
    var URLEscapedString: String {
        return self.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLHostAllowedCharacterSet())!
    }
}
```

And I'm using it like so:

``` swift
let provider = RxMoyaProvider<Auth>()
```

This throws the following error:

``` swift
Type 'Auth' does not conform to protocol 'TargetType'
```

I've used Cocoapods before and didn't get this error.

Thanks!
 Thanks for your reply, yeah, it usually says what's missing for it to conform to the protocol, but in this case there is no arrow.

This is a wild guess, but I think there may be something wrong with the generated frameworks, I've seen something like this before, and it usually means that the 'TargetType' from the RxMoya framework, is different from the 'TargetType' in the Moya framework. 

I guess I'll make a fork and start looking around into the project's configuration.

If I don't have any luck (I'm new to Carthage), I'll guess I'll continue using Cocoapods for now.

Thanks!
 Yeah, I think that's the reason, by command-clicking the TargetType in the endpoint, I can see it under the Moya framework, but in the ViewController, the TargetType is inside RxMoya.

The endpoint now looks like:

``` swift
import Foundation
import RxMoya

enum Auth {
    case Login(email: String, password: String)
    case Logout()
}

extension Auth: RxMoya.TargetType {

    var baseURL: NSURL { return NSURL(string: "http://localhost/api")! }

    var path: String {
        switch self {
        case .Login(_, _):
            return "/users"
        case .Logout(_):
            return "/users"
        }
    }

    var method: RxMoya.Method {
        switch self {
        case .Login(_, _):
            return .POST
        case .Logout(_):
            return .DELETE
        }
    }

    var parameters: [String: AnyObject]? {
        switch self {
        case .Login(let email, let password):
            return ["email": email, "password": password]
        case .Logout(_):
            return nil
        }
    }

    var sampleData: NSData {
        switch self {
        case .Login(_, _):
            return "".dataUsingEncoding(NSUTF8StringEncoding)!
        case .Logout(_):
            return "".dataUsingEncoding(NSUTF8StringEncoding)!
        }
    }
}

private extension String {
    var URLEscapedString: String {
        return self.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLHostAllowedCharacterSet())!
    }
}
```
 The issue is all the source files are included in both Moya and RxMoya targets, usually, you'd only include RxSwift specific files inside the RxMoya target, and then you specify Moya as a RxMoya dependency.

This way you'd import both frameworks, but as it is right now, you should only use RxMoya, and you must not include Moya otherwise you'll get that error. I'm okay with the way it is right now, but it should be worth mentioning that with Carthage you should only use one. 

I'm surprised as well that this hasn't turn up before. I usually look for the project's documentation at first, so it might be helpful to add this into some sort of notes regarding to Carthage usage, I also look into the project's issues, open and close, and then SO.
 Since the project was built around cocoapod subspecs the source doesn't have `import Moya` in the subspec's files. To get Carthage support the easiest solution without changing the source too much was to include all the files. This matches the way cocoapods builds the project. 

I like the idea of dependent frameworks. I'll look into how much effort it would be. 
 Yeah, there are some changes, I already tried to do it in a fork, but got some weird errors when using it in another project through Carthage.

You don't really need another repo, you can just remove the source files from the RxMoya target, add the Moya target as a dependency inside RxMoya, and then you just `import Moya` whenever needed.

This was working for me inside the Moya project, it was building correctly, but as I mentioned above, I couldn't use it succesfully, and I'm not sure how these changes will affect the Cocoapods setup.
 I have a working branch that does this but the Carthage build command gives some errors. Works fine in Xcode though. 

The only problem was that certain things needed to be made public. I'll try to push my branch later today. Could you give it a try to see if it works for you?
 I see, nice. Sure, let me know when it's up and I'll give it a try.
 feel free to close for now, I'll reopen if I get it again.
  HI,

Can you demonstrate how you would solve this problem with your library?
https://github.com/Alamofire/Alamofire/issues/946
I'm yet to find something that will work on IOS.
Thanks
  This is I use Alamofre 

``` swift
let params =  ["service"     :"contacts.list",
                       "access_token":"37921b0595da0c02166464bd7538e075fc8c6154",
                       "params"      :""]`

Alamofire.request(.POST, "http://124.172.184.216:8080/open_api/api?sign=f93404972addb2b806a7bcb5adbaa8c3&app_id=123", parameters: params, encoding: .JSON, headers: nil).responseJSON { response in
            print(response.result)
            if let value = response.result.value {
                print(value)
            }
}
```

it's work! But when I use Moya to do this,it show 

``` swift
Optional(<html>
<head><title>404 Not Found</title></head>
<body bgcolor="white">
<center><h1>404 Not Found</h1></center>
<hr><center>nginx/1.4.6 (Ubuntu)</center>
</body>
</html>
)
.Success(Status Code: 404, Data Length: 177)
false

//let GitHubProvider = MoyaProvider<GitHub>(plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])

let GitHubProvider = MoyaProvider<GitHub>(endpointClosure: {(target: GitHub) -> Endpoint<GitHub> in

    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString

    return Endpoint(URL: url,sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
                    method: target.method,
                    parameters: target.parameters,
                    parameterEncoding:ParameterEncoding.JSON)
})

// MARK: - Provider support

private extension String {
    // ÁôæÂàÜÂè∑ÁºñÁ†ÅËΩ¨Á†ÅÔºåÈíàÂØπ‰∏≠Êñá
    var URLEscapedString: String {
        return self.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLHostAllowedCharacterSet())!
    }
}

public enum GitHub {
    case Zen
    case UserProfile(String)
    case UserRepositories(String)
    case CompanyList
}

extension GitHub: TargetType {
    public var baseURL: NSURL {
        switch self {
        case .CompanyList:
            return NSURL(string: "http://124.172.184.216:8080/open_api/api?sign=f93404972addb2b806a7bcb5adbaa8c3&app_id=123")!
        default:
            return NSURL(string: "https://api.github.com")!
        }
    }
    public var path: String {
        switch self {
        case .Zen:
            return "/zen"
        case .UserProfile(let name):
            return "/users/\(name.URLEscapedString)"
        case .UserRepositories(let name):
            return "/users/\(name.URLEscapedString)/repos"
        default:
            return ""
        }

    }
    public var method: Moya.Method {
        switch self {
        case .CompanyList:
            return .POST
        default:
            return .GET
        }
    }
    public var parameters: [String: AnyObject]? {
        switch self {
        case .UserRepositories(_):
            return ["sort": "pushed"]
        case .CompanyList:
            return ["service"     : "contacts.list",
                    "access_token": "37921b0595da0c02166464bd7538e075fc8c6154",
                    "params"      : ""]
        default:
            return nil
        }
    }
```

How can I get my data? And How can I change the code?
 OK,I will try~
 ```
Moya_Logger: [16/05/2016 10:30:51] Request: <NSMutableURLRequest: 0x7fc7facbeb60> { URL: http://124.172.184.216:8080/open_api/api/?sign=f93404972addb2b806a7bcb5adbaa8c3&app_id=123 }
Moya_Logger: [16/05/2016 10:30:51] Request Headers: ["Content-Type": "application/x-www-form-urlencoded; charset=utf-8"]
Moya_Logger: [16/05/2016 10:30:51] HTTP Request Method: POST
Moya_Logger: [16/05/2016 10:30:51] Request Body: access_token=37921b0595da0c02166464bd7538e075fc8c6154&params=&service=contacts.list
Moya_Logger: [16/05/2016 10:30:52] Response: <NSHTTPURLResponse: 0x7fc7fd022280> { URL: http://124.172.184.216:8080/open_api/api/?sign=f93404972addb2b806a7bcb5adbaa8c3&app_id=123 } { status code: 404, headers {
    Connection = "keep-alive";
    "Content-Encoding" = gzip;
    "Content-Type" = "text/html";
    Date = "Mon, 16 May 2016 02:26:48 GMT";
    Server = "nginx/1.4.6 (Ubuntu)";
    "Transfer-Encoding" = Identity;
} }
```

```
<html>
<head><title>404 Not Found</title></head>
<body bgcolor="white">
<center><h1>404 Not Found</h1></center>
<hr><center>nginx/1.4.6 (Ubuntu)</center>
</body>
</html>
```

`.Success(Status Code: 404, Data Length: 177)`
 404 Not Found is not come form my service,and when I use Alamofire buy default POST method,it is work. But it doesn't work in Moya! And, I don't know how to change the code.
 I solve the problem, the result is my url is wrong, and I wonder know, why I set my URL is `http://192.168.172.243/public_gateway/web/index.php?r=api&sign=c672431482bf5063f5d33a8654aecb41&app_id=123` ,but when I look the request `Request: <NSMutableURLRequest: 0x7fa9485e9600> { URL: http://192.168.172.243/public_gateway/web/index.php/?r=api&sign=c672431482bf5063f5d33a8654aecb41&app_id=123 }` It will insert `/` to `index.php/?`,and My orginal URL is `index.php?` not `index.php/?`, so it show 404 not found. I solve the problem to use

```
let endpointClosure = { (target: GitHub) -> Endpoint<GitHub> in
    let url = "http://192.168.172.243/public_gateway/web/index.php?r=api&sign=c672431482bf5063f5d33a8654aecb41&app_id=123"

    return Endpoint(URL: url,
                    sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
                    method: target.method,
                    parameters: target.parameters,
                    parameterEncoding: Moya.ParameterEncoding.JSON)
}

let GitHubProvider = MoyaProvider<GitHub>(endpointClosure: endpointClosure,
                                          plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])
```

And It work!
 If my URL is `http://192.168.172.243/public_open_api/api?sign=c672431482bf5063f5d33a8654aecb41&app_id=123`, my baseURL is `http://192.168.172.243/public_open_api/api?`, the sign and app_id is change by parameters, how I change the code in MyTargetType?
 Thanks very much, I solve the problem by do `let oauthEndpointClosure = { (target: OAuth) -> Endpoint<OAuth> in

```
let baseURLString = target.baseURL.absoluteString

let dict = target.parameters?["params"]

var sign = ""

if let dict = dict as? [String : AnyObject] {
    sign = signWithParamters(dict)
}

let url = baseURLString + "sign=" + sign + "&app_id=123"

return Endpoint(URL: url,
                sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
                method: target.method,
                parameters: target.parameters,
                parameterEncoding: Moya.ParameterEncoding.JSON)
```

}

let OAuthAPI = MoyaProvider<OAuth>(endpointClosure: oauthEndpointClosure,
                                    plugins: [NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)])` It's work~ But I wonder know, Can I use the ObjectMapper to change the data to JSON object? 
 OK, thanks your adive!
  This the same implementation as #481 but is based on master branch.

I need to support file upload using Moya and after look at #114 discussion, I decided to implement my own solution.

I just added a _MultipartTargetType_ protocol and made some extensions to _MoyaProvider_ where the Target matches the new type.

Here is an example:

``` Swift
enum MyAwesomeAPI {
  case EndpointWithImageUpload(NSURL)
}
// Extend from MultipartTargetType
extension MyAwesomeAPI: MultipartTargetType {
   var path: ...
   var parameters: ...
   var method: ...
   var sampleData: ...
   var multipartBody:[MultipartFormData] {
        switch self {
        case .EndpointWithImageUpload(let imageUrl):
                return [MultipartFormData(provider: .File(contentFile), name: "files", mimeType:"image/jpeg", fileName: "photo.jpg")]
        default:
            return []
        }
    }
}
// Call the api
RxMoyaProvider<MyAwesomeAPI>()
    .requestWithProgress(MyAwesomeAPI.CallWithImageUpload(fileUrl))
    .filterCompleted()
    .mapToJSON().....
```

`requestWithProgress` method returns a `ProgressResponse` that contains the progress and the response result when the http call is completed. Use the method `filterCompleted()` to get the actual `Response` and `filterProgress()` to get the progress of the Upload.

I had some trouble to compile and test the project. I can create some tests and add to this PR if some one help me with that.

Thank you and enjoy!
 Hey @ashfurrow! I improved the API a little bit. I created a `ProgressResponse` and added some `filter` methods to get the response and the result. I created a new method called `requestWithProgress` to not collide with actual `request` method. After all this work I thought: What do not make some more changes and add progress to all HTTP calls? What do you think?
 @leonereveel: I just needed multipart upload and started using your fork. 

Once I changed my `TargetType` to conform to `MultipartTargetType`, I had to change all my existing references to `request` to include `progress: nil` parameter because of the ambiguity.

I tried [experimenting](https://github.com/leonereveel/Moya/pull/1) with a slightly different API that I think is simpler. What do you guys think?
 Cool guys! Let me know if you need any contribution. @hirad The way you did works very well and make things more simple. I'll try it out here.
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/483?src=pr) is **65.02%**

[![Sunburst](https://codecov.io/gh/Moya/Moya/pull/483/graphs/sunburst.svg?src=pr&size=150)](https://codecov.io/gh/Moya/Moya/pull/483?src=pr)

> No coverage report found for **master** at e9a1382.
> 
> Powered by [Codecov](https://codecov.io?src=pr). Last updated by [e9a1382...77dea94](https://codecov.io/gh/Moya/Moya/compare/e9a13829eb86a0ef16f68dcf971d804f59f155b6...77dea948fa740729a83f44d16c7f3fd69db01f0b)
 @leonereveel this looks great! What's left before we can use it?
 @AndrewSB I need to do some tests, which I will have time next week. Community review and merge.
 <table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Error">
          1 Error
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:no_entry_sign:</td>
      <td data-sticky="true">No Changelog entries made</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th width="50"></th>
      <th width="100%" data-kind="Warning">
          1 Warning
      </th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td>:warning:</td>
      <td data-sticky="true">Big PR</td>
    </tr>
  </tbody>
</table>

### SwiftLint found issues\n\n#### Warnings

| File | Line | Reason |
| --- | --- | --- |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |
| Moya.swift | 397 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 398 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya.swift | 379 | Colons should be next to the identifier when specifying a type. |
| Moya.swift | 400 | Force unwrapping should be avoided. |
| Moya.swift | 14 | Lines should not have trailing whitespace. |
| Moya.swift | 20 | Lines should not have trailing whitespace. |
| Moya.swift | 24 | Lines should not have trailing whitespace. |
| Moya.swift | 48 | Lines should not have trailing whitespace. |
| Moya.swift | 55 | Lines should not have trailing whitespace. |
| Moya.swift | 105 | Lines should not have trailing whitespace. |
| Moya.swift | 109 | Lines should not have trailing whitespace. |
| Moya.swift | 180 | Lines should not have trailing whitespace. |
| Moya.swift | 247 | Lines should not have trailing whitespace. |
| Moya.swift | 252 | Lines should not have trailing whitespace. |
| Moya.swift | 256 | Lines should not have trailing whitespace. |
| Moya.swift | 259 | Lines should not have trailing whitespace. |
| Moya.swift | 261 | Lines should not have trailing whitespace. |
| Moya.swift | 269 | Lines should not have trailing whitespace. |
| Moya.swift | 275 | Lines should not have trailing whitespace. |
| Moya.swift | 287 | Lines should not have trailing whitespace. |
| Moya.swift | 297 | Lines should not have trailing whitespace. |
| Moya.swift | 299 | Lines should not have trailing whitespace. |
| Moya.swift | 302 | Lines should not have trailing whitespace. |
| Moya.swift | 378 | Lines should not have trailing whitespace. |
| Moya.swift | 382 | Lines should not have trailing whitespace. |
| Moya.swift | 394 | Lines should not have trailing whitespace. |
| Moya.swift | 404 | Lines should not have trailing whitespace. |
| Moya.swift | 410 | Lines should not have trailing whitespace. |
| Moya.swift | 417 | Lines should not have trailing whitespace. |
| Moya.swift | 431 | Lines should not have trailing whitespace. |
| Moya.swift | 433 | Lines should not have trailing whitespace. |
| Moya.swift | 435 | Lines should not have trailing whitespace. |
| Moya.swift | 441 | Lines should not have trailing whitespace. |
| Moya.swift | 445 | Lines should not have trailing whitespace. |
| Moya.swift | 533 | Lines should not have trailing whitespace. |
| Moya.swift | 545 | Lines should not have trailing whitespace. |
| Moya.swift | 420 | Else and catch should be on the same line, one space after the previous declaration. |
| Moya.swift | 547 | File should contain 400 lines or less: currently contains 547 |
| Moya+ReactiveCocoa.swift | 72 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 83 | Lines should not have trailing whitespace. |
| Moya+ReactiveCocoa.swift | 89 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 48 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Moya+RxSwift.swift | 46 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 58 | Lines should not have trailing whitespace. |
| Moya+RxSwift.swift | 63 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 71 | Opening braces should be preceded by a single space and on the same line as the declaration. |
| Observable+Moya.swift | 62 | Force unwrapping should be avoided. |
| Observable+Moya.swift | 55 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 58 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 64 | Lines should not have trailing whitespace. |
| Observable+Moya.swift | 67 | Lines should not have trailing whitespace. |

#### Errors

| File | Line | Reason |
| --- | --- | --- |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |
| Moya.swift | 249 | Prefer checking `isEmpty` over comparing `count` to zero. |

<p align="right" data-meta="generated_by_danger">
  Generated by :no_entry_sign: <a href="http://danger.systems/">danger</a>
</p>
 I merged from master and improved the code a little bit. Can anyone help me to test it? @colinta?
 Cool!  I will not be able to today, but definitely will do tomorrow.
 Very cool, and I found it very easy to use.  I've got some refactors for you, I'll make a PR into this branch.  I've added some code to the Demo project that uploads a file to Giphy using their public API.

Some comments:
1. Spacing in your code is a little different from the rest of Moya: `func(arg:Type)` instead of `func(arg: Type)`.  I've changed all the instances of this that I found; this follows Swift code conventions, and is internally consistent.
2. I did find an interesting issue: if you don't specify `queue: dispatch_queue_t?`, the response is not called on the main thread - that part is OK, I suppose.  If you _do_ specify the queue (e.g. `queue: dispatch_get_main_queue()`), the _progress block_ is _not called on this queue_, which surprised me.  I'll include a fix for this in my PR.
3. The design is great; really easy to create a multipart endpoint, easy to add progress.

üëç 
 For anyone interested, my recommended changes (and additions to the Demo app) are here: https://github.com/leonereveel/Moya/pull/3
 Thank you for your contribution @colinta. I have only two questions for you. I'm a little concerned about this code here:

``` swift
internal struct CancellableWrapper: Cancellable {
    internal var innerCancellable: CancellableToken? = nil

    private var isCancelled = false

    internal func cancel() {
        innerCancellable?.cancel()
    }
}
```

I check if this cancellable was canceled before starts uploading **(line 421)**. 
1) As far as I know, all struct values are passed by value (https://developer.apple.com/swift/blog/?id=10). Event if I get this value and changed it, my closure won't "see" the change.
2) I didn't see in any place that `cancel()` method will change the variable `isCancelled` to `true`.

BTW, I already merged your PR. =)
 Hmm, you've got a good point there! @ashfurrow did you read that ‚òùÔ∏è?

I see that the specs test the cancel-ability of this code, though... I'll look at this for a bit more.  Definitely fishy.
 @ashfurrow Should `isCancelled` map to `innerCancellable?.canceled ?? false`?
 @leonereveel There is a small difference in your code:

```
// Moya existing code
216:  cancellableToken.innerCancellable = self.sendRequest
...
// your code
271:  cancellableToken = self.sendUpload
```
 I need to do that because the request is not returned immediately. Alamofire builds the multi-part on background and returns the request, where I set the `innerCancellable`, that why it's different.
 Right - actually I think that _is why_ you need to assign the result of `sendUpload` (the "innerCancellable") to the original `cancellableToken`.  If you assign it again (as you are here), it will never be returned to the user - they will be calling `cancel()` on an object whose `innerCancellable` is `nil`.

In `sendUpload` you return another `CancellableWrapper`, and _I think_ this is correct - the wrapper in `request()` will call `cancel()` on that wrapper, which will then call `cancel()` on the Alamofire `Cancellable`.
 I'll try it in the Demo app - calling `cancel()` immediately should make its way into Alamofire, right?
 If define `CancellableWrapper` as `class`, this shouldn't be a problem. The object will be returned as reference and the `innerCancellable` property will be updated after Alamofire builds the multipart. The `cancel` method on that class should set `isCancelled` to `true` event if `innnerCancellable` was not set yet.
 No it's still not as simple as that, but I'm learning more about what's going on.

So because `performNetworking` is asynchronous (or it _can_ be - in the case of using OAuth, for example), assigning to `cancellableToken` inside of `performNetworking` will have no effect on the code that calls `request`.

``` swift
func request() -> String {
    var cancellable = "foo"
    inOneSecond {
        cancellable = "bar"
    }
    return cancellable
}

request() // always "foo"
```

_BUT_, I see that `multipartFormData` is not called synchronously, and so I think the issue here is that `innerCancellable` doesn't have a default value - something that can assign and store the `isCancelled` value.

I propose this: for one, I agree that it _seems like_ `CancellableWrapper` should be a class, not a struct, because we're treating it as a reference. Next, I think that `innerCancellable` should be a `Cancellable`, not a `CancellableToken`.  Then, we can assign a default value to `innerCancellable` that can be "canceled" while the request is being constructed.  Because until `innerCancellable` is assigned, the request isn't cancellable, which seems like a bug.

Something like this:

``` swift
// change to a class, for reference semantics
internal class CancellableWrapper: Cancellable {
    // calling cancel() on this initial instance will just update the canceled value
    internal var innerCancellable: Cancellable = SimpleCancellable()

    // renamed 'isCancelled' for consistency
    var canceled: Bool { return innerCancellable.canceled ?? false }

    internal func cancel() {
        innerCancellable.cancel()
    }
}

internal class SimpleCancellable: Cancellable {
    var canceled = false
    func cancel() {
        canceled = true
    }
}
```
 I'm creating #530 to address this issue - and I've got a branch that combines #530 and #483 here: https://github.com/colinta/Moya/tree/multipart-after-refactor
 Good solution @colinta!  üëç 

I'm looking forward to see everything merge into master branch (upload and this refactoring). I'm glad to see that this discussion solved another possible bug.
 @ashfurrow @colinta  If you need any help to document this, let me know. I can do that this weekend.
 I tried that @ashfurrow and it override user's implementation. One of my commits was only to remove the extension.
 Fixed multipart-parameters encoding. I didn't know that this must be encoded differently.
 Sweet! I agree about the collaboration. Great feature, and tons of people working on it - awesome!

> On Jul 8, 2016, at 1:57 PM, Leone Parise notifications@github.com wrote:
> 
> Fixed multipart-parameters encoding. I didn't know that this must be encoded differently.
> 
> ‚Äï
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
  ## question 1

refer to this article [Basic](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md)

``` swift
enum MyService {
    case Zen
    case ShowUser(id: Int)
    case CreateUser(firstName: String, lastName: String)
}
```

## question 2

You can split it into more providers(TargetType).  But it just works fine in this way.

Does this works for you?
  First of all, thanks @ashfurrow for this amazing library!

I need to support file upload using Moya and after look at #114 discussion, I decided to implement my own solution.

I just added a _MultipartTargetType_ protocol and made some extensions to _MoyaProvider_ where the Target matches the new type.

Here is an example:

``` Swift
enum MyAwesomeAPI {
  case EndpointWithImageUpload(NSURL)
}
// Extend from MultipartTargetType
extension MyAwesomeAPI: MultipartTargetType {
   var path: ...
   var parameters: ...
   var method: ...
   var sampleData: ...
   var multipartBody:[MultipartFormData] {
        switch self {
        case .EndpointWithImageUpload(let imageUrl):
                return [MultipartFormData(provider: .File(contentFile), name: "files", mimeType:"image/jpeg", fileName: "photo.jpg")]
        default:
            return []
        }
    }
}
// Call the api
let (progress, response) = RxMoyaProvider<MyAwesomeAPI>()
    .request(MyAwesomeAPI.CallWithImageUpload(fileUrl))

// Do whatever you want with 'progress' and 'response' observables
```

I had some trouble to compile and test the project. I can create some tests and add to this PR if some one help me with that.

Thank you and enjoy!
 Awesome !
 Thank you @ashfurrow! I'm closing this PR and will submit a new one based on master branch. I need to make these changes on 6.4.0 tag because I'm using this in production ¬Ø_(„ÉÑ)_/¬Ø.

I'm happy that you liked the code, I tried most not change your current codebase to not affect other functions. I'll be happy to contribute more because I'm using this library a lot and need some features that it's not covered yet like: progress on all calls (download and upload) and caching support.

I'm looking forward the screenhero pair!
    According to #478
 Sure, I've added the following:

> Changes `Moya.Error.Underlying` to have `NSError` instead of `ErrorType`.
 It's a pleasure :)
  Hello,

as I see `Moya.Error`'s `nsError` property is depreceted (also confirmed by @sunshinejr in #437). What other solution would you recommend to get `NSError`'s domain from an `Underlying` type? I mean how can I get the reason of the error if e. g. if I receive the code of `NSURLErrorTimedOut` or `NSURLErrorNotConnectedToInternet`?

Thanks!
 Thanks @ashfurrow! I missed the `ErrorType` in `.Underlying`. 
 I can make a pull request about this, only I'm not comfortable with casting `error` to `NSError` in `Response.swift` which should be done:

```
    /// Maps data received from the signal into a JSON object.
    func mapJSON() throws -> AnyObject {
        do {
            return try NSJSONSerialization.JSONObjectWithData(data, options: .AllowFragments)
        } catch {
            throw Error.Underlying(error as NSError)
        }
    }
```

As I see it won't be a problem, are you ok with that?
 In fact it needs casting when `.Underlying` have `NSError`. Bit confusing, but found an explanation [here](http://roadfiresoftware.com/2015/10/how-to-parse-json-with-swift-2/):

> First of all, everything is surrounded in a do/catch block since JSONObjectWithData:options: may throw an error. If you‚Äôre familiar with Objective-C, you‚Äôll notice that we don‚Äôt pass in an NSError pointer here ‚Äì instead, JSONObjectWithData is marked with throws, meaning it may throw an error. The error that we catch (which is called error by default) replaces the NSError pointer from Objective-C.
  Build in the base provider, available for all reactive providers. Linked with issue https://github.com/Moya/Moya/pull/229
 Good point, done that!
 @ashfurrow I've added these tests. However, I had to make the `CancellableWrapper` public to get to the cancellableToken. I'm not really happy with that change, but maybe this is a good start for someone else to continue.

I'm out of time today (end of the day in the Netherlands üëç ) Will try to create a changelog entry later this week!
 Changelog entry is added
 ## [Current coverage](https://codecov.io/gh/Moya/Moya/pull/477?src=pr) is **91.83%**

> Merging [#477](https://codecov.io/gh/Moya/Moya/pull/477?src=pr) into [master](https://codecov.io/gh/Moya/Moya/branch/master?src=pr) will increase coverage by **+0.17%**
1. File `...ource/Endpoint.swift` (not in diff) was modified. [more](https://codecov.io/gh/Moya/Moya/commit/07f26c2dcf29ac2bb960b47efe80fdbfc8cfec90/changes?src=pr#536F757263652F456E64706F696E742E7377696674) 
   - Misses `-4` 
   - Partials `0` 
   - Hits `+4`

``` diff
@@             master       #477   diff @@
==========================================
  Files            13         13          
  Lines           479        514    +35   
  Methods           0          0          
  Messages          0          0          
  Branches          0          0          
==========================================
+ Hits            439        472    +33   
- Misses           40         42     +2   
  Partials          0          0          
```

> Powered by [Codecov](https://codecov.io?src=pr). Last updated by [5a800bb...07f26c2](https://codecov.io/gh/Moya/Moya/compare/5a800bbf52f6e3484c14bdd53124ecc5a6d4f266...07f26c2dcf29ac2bb960b47efe80fdbfc8cfec90)
 @ashfurrow good find! Done that. Should be all good now.
 @ashfurrow the release of 6.5.0 should include this commits as noted with the release commits. However, checking https://github.com/Moya/Moya/blob/6.5.0/Source/Moya.swift shows there's no trackInflights included, where the master right now does. 

Which base branch is used for the release of tag 6.5.0?
 It does, I was confused as I saw my commits included in the release, but missed my changes. Thanks! 
 Is this feature available for Rx?
 Sorry I was using 6.5.0. Updating to 7.0.0 did the job.
  I have seen below code in Moya [example](https://github.com/Moya/Moya/blob/6a437938c4ac3ae1d6ffce161cfb1fb3c78c67b9/docs/Examples.md) 

```
if target.shouldRetry {
    retryWhenReachable(target, successCallback, errorCallback, failureCallback)
}
```

Are there any example code how `shouldRetry` should looks like in real case?
  Described all these . still getting error 

`public var baseURL: NSURL { get }
    public var path: String { get }
    public var method: Moya.Method { get }
    public var parameters: [String : AnyObject]? { get }
    public var sampleData: NSData { get }`
 @sunshinejr 

``` swift
extension RunnrService: TargetType {
public var baseURL: NSURL { return NSURL(string: "https://api.myservice.com") }

    public var path: String {
        switch self {
        case .CustomerSignup://
            return "auth/customer_signup"
        case .SignupVerifyOTP://
            return ""
        case .ExistingCustomer://
            return ""
        case .SigninOTP://
            return ""
        case .Signin://
            return ""
        case .ResendOTP://
            return ""
        }
    }

    public var method: Moya.Method {
        switch self {
        case .CustomerSignup,
             .SignupVerifyOTP,
             .ExistingCustomer,
             .SigninOTP,
             .Signin:
            return .POST
        case .Services,
             .AppVersion:
            return .GET
        }
    }

    public var parameter: [String:AnyObject]? {
        switch self {
        case .Something:
            return nil
        case .CustomerSignup(let phoneNo, let referelCode):
            return ["phoneNo":phoneNo,"referelCode":referelCode]
        default:
            return nil
        }
    }

    public var sampleData: NSData {
            return "Half measures are as bad as nothing at all.".dataUsingEncoding(NSUTF8StringEncoding)!
    }

    public func url(route: TargetType) -> String {
        return route.baseURL.URLByAppendingPathComponent(route.path).absoluteString
    }
}
```
 @sunshinejr : ok ..Thanks .. Will wait for reply
 @sunshinejr Basically i have removed some cases .. Don't wanna show . But i have encountered all the cases . Don't know where the problem is coming. And how we have secure tokens and refresh token .Moya does that ? How to pass header to endpoint. If this bug gets resolved 
 Added default to all the 'switch' . Same error.

'    public var baseURL: NSURL { return NSURL(string: "https://api.myservice.com")! }' its optional , is it ok
 @colinta : Thanks a lot @sunshinejr Issue solved parameter_s_ s was missing :(
  Hi,
I would like to know how can I implement this with Moya as I have no idea how to send multiple parameter separated with comma.

`curl -X GET "https://api.spotify.com/v1/albums/?ids=41MnTivkwTO3UUJ8DrqEJJ,6JWc4iAiJ9FjyK0B59ABb4,6UXCm6bOO4gFlDQZV5yL37"`

Thanks
 Hi,
Thanks for you help.
Seams that `case Albums(ids: [String])` doesn't works.
![image](https://cloud.githubusercontent.com/assets/262924/14894778/9cf4398e-0d75-11e6-95d4-a7870b1e5619.png)
 @colinta Yeah but I will not be able anymore to pass Array, right?
 @colinta But the array is passed through the `path`
 These solutions end up encoding the commas a `%2C` which isn't ideal.
 Hi, Sorry for the delay, I came back to this issue but I switch to Swift 3.
So now I'm stuck with a `Cannot call value of non-function type '((String) -> String)!'` On `.componentsJoined(",")`  
Any idea?
:/ 
 Ok, I found it, it's:
`(embedded as AnyObject).componentsJoined(by: ",")`
Let me check that it works correctly and I come back here.
 It seems to work :)
Thanks guys!
@aehlke Yeah I have the `%2C`  even adding `removingPercentEncoding` to `(embedded as AnyObject).componentsJoined(by: ",")` does not works :/
 Yeah, that's what I did :)
Thanks!
  Originally Alamofire provides both response and request as a part of Response structure. It helps with debugging and logging of incidents. Current implementation of Moya.Response has only response NSURLResponse (instead of NSHTTPURLResponse in Alamofire) and no request information at all. With such approach when error happened there is no way to find for which request it happened. There is also no way to find header fields from NSURLResponse. With all being said what would be a recommended way of analyzing and logging Moya Errors?
 To debug using Moya, I generally take advantage of the `NetworkLoggerPlugin`. See the [Providers documentation](https://github.com/Moya/Moya/blob/master/docs/Providers.md#plugins).
 NetworkLoggerPlugin  does not have correlation capabilities. It seems like logging strategy now "all or nothing" while I have a particular need in mind which I believe is common. When error happened I would like to log both response with an error and request that caused it. Does it look like a valid problem?
 Would it be a natural thing to return back correlation of request & response into Moya result? Why in Miya.swift on line 207 of Alamofire response, NSURLRequest just discarded, while the rest is propagated as result? It is common feature of networking libraries. It was in Alamofire, MKNetworkingKit etc as well as for libraries on other platforms. As I am not really familiar with details of some architecture decisions It would be interesting to understand what was a decision process for removing this feature from Moya.
 Yeah that would be awesome to have request printed such as:
`curl -X GET blablabla`
 @colinta recreating URL requests is not the same as getting a reference to the one that were sent. There could be various random identifiers attached etc, so the question to trace an exact request sent. Somehow "hard way" looks most logical one, which is very unfortunate. Thanks.
 @ashfurrow as for today we do not have a good solution. The only elegant solution is option 1 suggested by @colinta, but maintaining an own fork of Moya at the current stage of our project is killing. Having correlation logging in the plugin does not work as well since such option missing a context of the call and many other benefits of having request together in response in a place of request initialization. 
Recreating a call when needed does not work, since as I mentioned it missing parameters uniquely generated for the response. 
Do you think re-introducing request & response correlation, that was initially available in AFNetworking would be accepted as PR into Moya? I would be happy to work on it.
 @ashfurrow I provided PR. Understand a point about "no guarantees on accepting it", no worries. I am happy to discuss and provide changes if you think something is not in line with grand-plan of Moya.
    Hello,

When i use Moya i don't  see the in the charles proxy the detail of the request and the responses. if i remove Moya, all works fine ( I am using Alamofire).

Do you have any idea ? Thanks 
 Charles works fine for me with Moya without any additional configuration. Please make sure you've not excluded domain from logging.
 Very strange. I am using Moya in a sample way ( Just a target with an endpoint to add additional headers). I Will look what i am doing wrong and give you feedback very soon. Thanks
 @samirGuerdah What exactly is your problem? Actually SSL Pinning is used to prevent Man-In-The-Middle atacks with tools like Charles. Or don't you get any requests/responses regardless of whether they are encrypted or not?
 Hello,

Sorry for the retarded response. Finally it was a misuse in my side. No problem to use Moya with Charles proxy. Closing...
   :tada: :smile: 
 awesome! sounds good, thanks for the invite @ashfurrow :grin: 
  I have some API endpoints with PATCH or DELETE that just return empty body and 204 code.

¬øHow can I handle those cases?

Right now I get and Underlying error with NSCocoaErrorDomain and Code=3840 saying "No value."
 Same here :(
 @bitomule Did you use ~.mapJson()~ or something like that?
After I removed it and manually convert it to json in the handler(process error response), it worked.
 @kevin5396 I'm finally using another method for those api calls
 Those methods also do image and files uploading so I just ended using pure alamofire
 @aschuch nop, it's not fixed. Moya needs to handle 204 no-content responses
 Ok, I've managed to handle empty responses. It was my fault, I was filtering status codes but no content comes with a 204 that was reported as error. Changed filter and now works.
 The issue I still have is with multipart / uploading files with moya but there's other issues for that. I don't think we can add something to make this clearer, it was my mistake.
  I want to include some optional query parameters in my request. What's the best way to do it? Can't find any example of query parameters.

For example. How can I call:

`api/users?limit=10`

but also:

`api/users`
 But parameters is for POST parameters no? I need optional GET parameters.
 You're right. I'm going to try that way. Thanks!
 I have same question Ôºå are you fix upÔºü
 i'm wrong.  if moya  Response: Received empty network. You can check your network,then check ParameterEncoding. 
  I want to send String JSON array as parameter, but only dictionary `[String:AnyObject]` format is supported. How am I supposed to convert JSON array into [String:AnyObject]?

I'm new to Swift language and have experience in Java. I'm using [ObjectMapper](https://github.com/Hearst-DD/ObjectMapper) for JSON mapping.
 @esttorhe Actually I want to send JSON Array. I guess I have to go with `.Custom` parameter encoding. 
 Here's my solution for sending JSON array to server. Suggestions are welcome as I'm new to Moya.

Define JsonArrayEncoding closure:

``` swift
let JsonArrayEncodingClosure: (URLRequestConvertible, [String:AnyObject]?) -> (NSMutableURLRequest, NSError?) = { request, data in
    var req = request.URLRequest as NSMutableURLRequest

    do {
        let json = try NSJSONSerialization.dataWithJSONObject(data!["jsonArray"]!, options: NSJSONWritingOptions.PrettyPrinted)
        req.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
        req.HTTPBody = json
    } catch {
        return (req, nil)
    }
    return (req, nil)
}
```

Configure target :

``` swift
  var parameters: [String:AnyObject]? {
        switch self {
        case .SomeAPI:
            return ["jsonArray": ["Yes", "What", "Abc"]]
        default:
            return nil
        }
    }

    var parameterEncoding: Moya.ParameterEncoding {
        switch self {
        case .SomeAPI:
            return ParameterEncoding.Custom(JsonArrayEncodingClosure)
        default:
            return ParameterEncoding.JSON
        }
    }
```
 Thanks a lot @ealeksandrov and @ashfurrow for adding it to examples. I think we should close the issue now.
 Encountered the same problem and had maybe an obvious question - where should I put `var parameterEncoding: Moya.ParameterEncoding` ? It is not part of the `TargetType` protocol, so adding it to my endpoints struct does nothing.
Until now, I was making my own `Endpoint` in `endpointClosure`, but it seems a bit too complicated to simply have different parameter encoding.
 I thought I was missing something, thanks for clarification!
 Has anyone figured out how to do this with swift 3.0?
 ParameterEncoding is no longer an enum its a protocol. would you still like me to open an issue? 
 Thanks I did't see that.
 Here is an **UNTESTED** example that at least compiles.

``` swift
extention MyService: TargetType {
...
  var parameters: [String:AnyObject]? {
        switch self {
        case .SomeAPI:
            return ["jsonArray": ["Yes", "What", "Abc"]]
        default:
            return nil
        }
    }

  var parameterEncoding: Moya.ParameterEncoding {
        switch self {
        case .patient_Notifications_Create_Endpoint:
            return JsonArrayEncoding.default
        default:
            return JSONEncoding.default
        }
    }
...
}

struct JsonArrayEncoding: Moya.ParameterEncoding {

        public static var `default`: JsonArrayEncoding { return JsonArrayEncoding() }


        /// Creates a URL request by encoding parameters and applying them onto an existing request.
        ///
        /// - parameter urlRequest: The request to have parameters applied.
        /// - parameter parameters: The parameters to apply.
        ///
        /// - throws: An `AFError.parameterEncodingFailed` error if encoding fails.
        ///
        /// - returns: The encoded request.
        public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
            var req = try urlRequest.asURLRequest()
            let json = try JSONSerialization.data(withJSONObject: parameters!["jsonArray"]!, options: JSONSerialization.WritingOptions.prettyPrinted)
            req.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
            req.httpBody = json
            return req
        }

    }

```
 In my case, it work with below code:

```swift
public var parameterEncoding: ParameterEncoding {
    switch self {
    case .submitForm:
        return PropertyListEncoding.default
    default:
        return URLEncoding.default
    }
}
```

**update**: 
Later, my way isn't worked, i think bcz have some change in server. So now the way of @tdouglas1313 worked for me.  How should I handle an error on requestClosure? Right now it only has a `done` call, but what if my OAuth provider fails to authenticate a request?
 I currently check oauth credentials in the requestClosure and would appreciate the ability to bubble out an error back out.
  I have my provider:

```
import Foundation
import Moya
import RxSwift

extension String {
    var URLEscapedString: String {
        return self.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLHostAllowedCharacterSet())!
    }
}

func JSONResponseDataFormatter(data: NSData) -> NSData {
    do {
        let dataAsJSON = try NSJSONSerialization.JSONObjectWithData(data, options: [])
        let prettyData =  try NSJSONSerialization.dataWithJSONObject(dataAsJSON, options: .PrettyPrinted)
        return prettyData
    } catch {
        return data
    }
}

public enum NetworkService {
    case Login(username: String, password: String)
}

extension NetworkService: TargetType {
    public var baseURL: NSURL {
        return NSURL(string: Config.SERVER_URL)!
    }

    public var path: String {
        switch self {
        case .Login(_, _):
            return "/login"
        default:
            return "/"
        }
    }

    public var method: Moya.Method {
        switch self {
        case .Login(_, _):
            return .POST
        default:
            return .POST
        }
    }

    public var parameters: [String: AnyObject]? {
        switch self {
        case .Login(let username, let password):
            return [
                "email": username,
                "password": password
            ]
        default:
            return nil
        }
    }

    public var sampleData: NSData {
        switch self {
        case .Login:
            return "Success".dataUsingEncoding(NSUTF8StringEncoding)!
        default:
            return "Default".dataUsingEncoding(NSUTF8StringEncoding)!
        }
    }

    public var parameterEncoding: ParameterEncoding {
        switch self {
        case .Login:
            return .JSON
        default:
            print("default parameterEncoding: URL")
            return .URL
        }
    }
}

public func url(route: TargetType) -> String {
    return route.baseURL.URLByAppendingPathComponent(route.path).absoluteString
}

let endpointClosure = { (target: NetworkService) -> Endpoint<NetworkService> in
    return Endpoint<NetworkService>(
        URL: url(target),
        sampleResponseClosure: {
            .NetworkResponse(200, target.sampleData)
        },
        method: target.method,
        parameters: target.parameters,
        parameterEncoding: target.parameterEncoding
    )
}

```

When i try call them with follow code: 

```
    let networkService = RxMoyaProvider<NetworkService>(
        endpointClosure: endpointClosure,
        plugins: [
            NetworkLoggerPlugin(verbose: true, responseDataFormatter: JSONResponseDataFormatter)
        ]
    )
```

I have error in compile time: 

> Controllers/LoginViewModel.swift:117:26: Type 'NetworkService' does not conform to protocol 'TargetType'

Where error?
 Hello, I'm actually having this exact same issue, I even get it by copying and pasting @rmuhamedgaliev's code snippet.

How did you actually solve it?

I'm using Carthage to manage my dependencies. I've also used Cocoapods before, and this didn't happen.

Here is my Cartfile:

```
github "ReactiveX/RxSwift" ~> 2.0
github "Moya/Moya"
github "sunshinejr/Moya-ModelMapper"
```
  The following GET is submitting an invalid request to my Rails server, which is actually rejecting it outright without even processing it. It is similar to this SO request [here ](http://stackoverflow.com/questions/23834179/heroku-rails-log-error-message-on-text-field-error-invalid-body-size)

I know my setup works because it has been working fine before i added the parameters to the GET request, and it works for POST requests.

1) I would like to print and see the full request it is making to the server. Is there a way to automatically print the full network request?
2) Is there anything i can change to make the GET work?

M

```
extension Routes: TargetType {
  var baseURL: NSURL { return NSURL(string: "http://localhost:3000")! }

  var path: String {
    switch self {
    // POST REQUEST - WORKS
    case .CreateUser:
      return "/users.json"
    // GET REQUEST - FAILS WHEN THERE ARE PARAMETERS
    case .Stickers:
      return "/stickers.json"
    }
  }

  var method: Moya.Method {
    switch self {
    case .CheckUsernameAvailability, .CreateUser:
      return .POST
    default:
      return .GET
    }
  }


  var parameters: [String: AnyObject]? {
    switch self {
    case .CreateUser (let username, let phoneNumber):
      return ["username":username, "phone_number": phoneNumber ]
    case .Sticker:
      return ["test""test]
    default:
      return nil
    }
  }


let endpointClosure = { (target: Routes) -> Endpoint<Routes> in
  let epc = Endpoint<Routes>(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters,         parameterEncoding: .JSON )

  return epc.endpointByAddingParameters(target.defaultParameters)
}

```
 Hi! Let me try to help you :) 
1) When you're creating request via your MoyaProvider ‚Äî it returns you a thing conforming to Cancellable protocol.
 You can simply print it to your logs so see how you can re-create this request via curl
Example: 

```
let provider = MoyaProvider<SignInAPI>()
let cancellable = provider.request(.RestorePassword(email: email)) { result in }
print(cancellable) 
```

2) I believe you should use .URL parameters encoding for GET request, instead of .JSON 

Hope that will help. If you will have any additional questions ‚Äî feel free to ask :) 
 thanks! both works great. 

i was not aware of the need to use .URL when doing GET requests. :)
 By the way, @Austinate is there an example of using headers to pass in authentication information like tokens?
 OAuth & HTTPAuth are described [here](https://github.com/Moya/Moya/blob/master/docs/Authentication.md)

But if you need just token as header field ‚Äî i'd configure custom Alamofire.Manager with header fields as described (see "managers" section) [here](https://github.com/Moya/Moya/blob/master/docs/Providers.md).
 I'm not 100%(just 99.9% üôÉ) sure that's the best way for Moya, so maybe someone will correct me
 @mingyeow for additional fields just take a look at [Alamofire readme](https://github.com/Alamofire/Alamofire) (Advanced Usage section)
 0.01% ¬Ø_(„ÉÑ)_/¬Ø 
  ## Open up option to use other queue instead of main queue

Moya default callback is on main thread and it is not possible to assign a specific queue for the response callback.

This pull request added an option to assign a specific queue.

This is useful when we want to perform other tasks in the background thread like saving these data to database.
 I think using the same function with default parameter is better. If introduce another function like 
`requestWithQueue` is quite weird and might have duplicate code too.

I have added the test case but only able to test whether callback is at main thread as `dispatch_get_current_queue` is deprecated. should be good enough.
 Ok. I have make another function.
 What do you think about also performing the `stubRequest` in the specified queue? Getting it off of the main thread would be helpful for me for some of my requests, which include dynamically generating thumbnails of images.
 @ashfurrow It would be great to have this feature in a non breaking way in the current release @kokhong20 has worked a good enough backwards compatible solution.

@kokhong20 Can you please resolve merge issues to get this PR merged in the current release? @ashfurrow If he does not respond should I open up another PR with a backwards compatible implementation and can we start the process of merging it to the main repo?
  Hey! I'm just starting off with RxSwift/RxMoya and trying to figure out something that seems like it should be very simple. 

I have an HTTP request that returns a data array in the following format: 

``` JSON
   {data: 
       {results:  [...] 
   }
```

So, the response isn't a flat JSON Array, there's some cascading. 
So the following code would clearly not work. 

``` swift
    self.provider
        .request(Marvel.Characters(startsWidth: "Iron", limit: nil, offset: nil))
        .debug()
        .mapArrayOptional(MarvelCharacter.self)
```

So, I guess I need to some how map the response to expose just the `results` field before passing it to `mapArrayOptional` ? Or there's a more global way to define the response structure expected from the server? 

Would appreciate your help on this :)

Thanks
Shai
 Thanks @sunshinejr! 
How would that look? I need to map from one Response to a new Response and pass that? Could you help with some sample code? 
 Although I don't use RxSwift, [I have done something similar](https://github.com/aschuch/Argonaut/blob/master/Argonaut/JSONMapping%2BReactiveCocoa.swift#L55) for ReactiveCocoa and [Argo](https://github.com/thoughtbot/Argo). This might point you in the right direction. 
 Actually, thinking about it again, my solution does not really work around your problem. However, Argo has a way to extract an object [based on a root key](https://github.com/thoughtbot/Argo/blob/b0b6920e5c34591e3884a4e50a740167e6cbaf68/Argo/Functions/decode.swift#L21).
 Perfect @sunshinejr  ! That's exactly what I tried to do and started doing but thanks for refining that. 
Is there any way to do that globally? meaning, for every request? because this data structure (data->results->actual array) is global to the entire API I'm using. 

Also thanks for your attempt to assit @aschuch ! :] 

![image](https://cloud.githubusercontent.com/assets/605076/14227937/8b8c0fce-f910-11e5-8eda-63857ba2132f.png)
 Perfect! Thank you! :] 
Is there a Moya slack channel or something of sorts or all questions should be filed here? I'm sure more  questions will pop as I start digging deeper into this. 
 So another question I had is , Is there a way to merge two `maps` together ? 

e.g. , I'm mapping something likes this 

``` json
    {"thumbnail": 
        {"path": "http://some.path.to/file", 
         "extension": "jpg"}
   }
```

Right now in my `Mappable` I'm doing

``` swift
try thumbPath   = map.from("thumbnail.path")
```

but I would like `thumbPath` to include both `thumbnail.path` and `thumbnail.extension`, concatenated together. Any way to merge those? 
  Looks good. Pretty straightforward. 
    Is there any way to assign a specific queue for the callback response instead of callback on main thread.

Using Alamofire i can use the below methods to callback on another queue

```
public func response(
        queue queue: dispatch_queue_t? = nil,
        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
        -> Self
    {
        delegate.queue.addOperationWithBlock {
            dispatch_async(queue ?? dispatch_get_main_queue()) {
                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
            }
        }

        return self
    }

```

Thanks.
  Update Heimdallr references in documentation due to project [name change](https://github.com/rheinfabrik/Heimdallr.swift/commit/5ed4904cc14769fb6838d17aad10d7b76df9467a).

Thanks for all you do <3
 Oh yay! Thanks!
  Closes #455 (presuming you didn't also want any sort of artifact uploads)
 Yeah, you just need to have GH creds in `.netrc`
  I'd be down to help with releases. 
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=308b2e0cd8557a614c0729810d4a01337dcb7a8b) is `91.64%`

> Merging **#452** into **master** will not affect coverage as of [`308b2e0`](https://codecov.io/github/Moya/Moya/commit/308b2e0cd8557a614c0729810d4a01337dcb7a8b)

``` diff
@@            master    #452   diff @@
======================================
  Files           13      13       
  Stmts          479     479       
  Branches         0       0       
  Methods                          
======================================
  Hit            439     439       
  Partial          0       0       
  Missed          40      40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/a9c2bc401cf68fe82e45ecd48b37727ced1ed449...308b2e0cd8557a614c0729810d4a01337dcb7a8b) as of [`308b2e0`](https://codecov.io/github/Moya/Moya/commit/308b2e0cd8557a614c0729810d4a01337dcb7a8b)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=308b2e0cd8557a614c0729810d4a01337dcb7a8b)
1. `+2.09%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=308b2e0cd8557a614c0729810d4a01337dcb7a8b#84) 
2. `+1.05%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=308b2e0cd8557a614c0729810d4a01337dcb7a8b#54) 
3. `+1.05%` via [Source/Moya.swift#222...226](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=308b2e0cd8557a614c0729810d4a01337dcb7a8b#222) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=308b2e0cd8557a614c0729810d4a01337dcb7a8b)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=67754bc6506520ae834ae02da27a0d6f42651481) is `91.64%`

> Merging **#452** into **master** will not affect coverage as of [`67754bc`](https://codecov.io/github/Moya/Moya/commit/67754bc6506520ae834ae02da27a0d6f42651481)

``` diff
@@            master    #452   diff @@
======================================
  Files           13      13       
  Stmts          479     479       
  Branches         0       0       
  Methods                          
======================================
  Hit            439     439       
  Partial          0       0       
  Missed          40      40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/a9c2bc401cf68fe82e45ecd48b37727ced1ed449...67754bc6506520ae834ae02da27a0d6f42651481) as of [`67754bc`](https://codecov.io/github/Moya/Moya/commit/67754bc6506520ae834ae02da27a0d6f42651481)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=67754bc6506520ae834ae02da27a0d6f42651481)
1. `+2.09%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=67754bc6506520ae834ae02da27a0d6f42651481#84) 
2. `+1.05%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=67754bc6506520ae834ae02da27a0d6f42651481#54) 
3. `+1.05%` via [Source/Moya.swift#222...226](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=67754bc6506520ae834ae02da27a0d6f42651481#222) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=67754bc6506520ae834ae02da27a0d6f42651481)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  Hi, 

this pull request fixes https://github.com/Moya/Moya/issues/433

Additionally, in the last couple of days my colleagues and me experienced issues with `Moya` using `Carthage`. I guess the recent release of `ReactiveCocoa 4.1` (which points to `Result ~> 2.0`) is the reason for those issues. I removed `Result` from `Moya¬¥s` cartfile (previously pointed to `Result ~> 1.0` which may conflict with `ReactiveCocoa¬¥s` requirements), so `ReactiveCocoa` takes care of requiring `Result`. We have no more issues with this setup‚úåüèº
 Yes thx received that invite, I am just not active enough to count as organization member :)
  **\* Building scheme "Moya iOS" in Moya.xcodeproj
**\* Building scheme "ReactiveMoya iOS" in Moya.xcodeproj
*\* BUILD FAILED **

The following build commands failed:
    CompileSwift normal arm64 /Users/rmuhamedgaliev/Projects/TemplateApp/Carthage/Checkouts/Moya/Source/ReactiveCocoa/RACSignal+Moya.swift
    CompileSwift normal arm64 /Users/rmuhamedgaliev/Projects/TemplateApp/Carthage/Checkouts/Moya/Source/Error.swift
    CompileSwift normal arm64 /Users/rmuhamedgaliev/Projects/TemplateApp/Carthage/Checkouts/Moya/Source/Image.swift
    CompileSwift normal arm64 /Users/rmuhamedgaliev/Projects/TemplateApp/Carthage/Checkouts/Moya/Source/Plugins/NetworkActivityPlugin.swift
    CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
(5 failures)
: Auto-Linking supplied '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks/XCTest.framework/XCTest', '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks/XCTest.framework/XCTest' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target.
ld: warning: linking against a dylib which is not safe for use in application extensions: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphoneos/libswiftXCTest.dylib
ld: warning: Auto-Linking supplied '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks/XCTest.framework/XCTest', '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Frameworks/XCTest.framework/XCTest' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target.
ld: warning: linking against a dylib which is not safe for use in application extensions: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphonesimulator/libswiftXCTest.dylib
ld: warning: linking against a dylib which is not safe for use in application extensions: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Frameworks/XCTest.framework/XCTest
ld: warning: linking against a dylib which is not safe for use in application extensions: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphonesimulator/libswiftXCTest.dylib
ld: warning: linking against a dylib which is not safe for use in application extensions: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Frameworks/XCTest.framework/XCTest
<unknown>:0: error: unable to execute command: Segmentation fault: 11
<unknown>:0: error: compile command failed due to signal (use -v to see invocation)
A shell task failed with exit code 65:
*\* BUILD FAILED **

The following build commands failed:
    CompileSwift normal arm64 /Users/rmuhamedgaliev/Projects/TemplateApp/Carthage/Checkouts/Moya/Source/ReactiveCocoa/RACSignal+Moya.swift
    CompileSwift normal arm64 /Users/rmuhamedgaliev/Projects/TemplateApp/Carthage/Checkouts/Moya/Source/Error.swift
    CompileSwift normal arm64 /Users/rmuhamedgaliev/Projects/TemplateApp/Carthage/Checkouts/Moya/Source/Image.swift
    CompileSwift normal arm64 /Users/rmuhamedgaliev/Projects/TemplateApp/Carthage/Checkouts/Moya/Source/Plugins/NetworkActivityPlugin.swift
    CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
(5 failures)
 Wasn't sure whether to open a new issue, or add to this one? I'm experiencing trouble trying to build the dependencies with Carthage too, but a different error:
`xcodebuild timed out while trying to read Rx.xcworkspace üò≠`

---

Xcode 7.3, Carthage 0.15.2 
(Using: `carthage update --platform iOS --no-use-binaries`)
 Perhaps I'm misunderstanding how to set up the project, but I'm just trying to build the dependencies for Moya itself, using the Moya Cartfile. Was hoping to contribute towards Moya, but fell at the first hurdle üòÇ
 @alskipp So you're running with a freshly cloned version of Moya, and just trying to run `carthage update --platform iOS --no-use-binaries` in the root of the directory, and receiving the error above, right?

Also, can you give me the output of the `carthage` log file? It logs it just before it starts building, says something like "log file will be output to {{yellow file path}}"
 @justinmakaila, yep pretty much (just forked Moya).
 @alskipp Are you trying to open the `Moya.xcodeproj`, or the `Demo/Demo.xcworkspace`? Also, see my comment above. I edited it, probably after the notification was sent out.
 @justinmakaila I've been trying to open the `Moya.xcodeproj`, am I about to have a ‚ÄúD‚Äôoh!‚Äù moment?
 D‚Äôoh! So the correct way of getting started is to run `pod install` in the `Demo` folder then make any changes in the `Demo/Demo.xcworkspace`?
 @alskipp No, you should be able to edit the source in the `Moya.xcodeproj`, and then the CocoaPods implementation in `Demo` pulls that in as a Development Pod. `Demo` houses the implementation tests/examples, and the unit tests.

I just cloned the repo into a new folder, `cd`'d in, and ran `carthage update --platform iOS --no-use-binaries` with no problem.

I'm thinking your issue could be with the Carthage cache, perhaps pulling old versions of the dependencies?

`rm -rf ~/Library/Caches/org.carthage.CarthageKit/dependencies/`
 @justinmakaila, thanks for the suggestion. Just tried clearing the cache, but still no joy (same inexplicable error) : (

Perhaps things will settle down a bit once a few more people have battle tested Xcode 7.3/Swift 2.2 and the next version of Carthage is released? In the meantime, I'm going to retrain as a carpenter ‚Äì a craft that can be indulged in without fear that your tools are conspiring against you! : )
 @alskipp can you send me the output of the carthage build? the issue always lies in there, and not in the console output.
 carthage version 0.17.2
Xcode     version 10.11.6
When I run carthage update --platform iOS --no-use-binaries, I got the error :xcodebuild timed out while trying to read CoreDataLogger.xcodeproj üò≠.
 What happens if you use the most recent Carthage version. I think it's 0.18.1
  There seems no best practice for now, my solution is

``` swift
enum Articles: TargetType {
  enum Comments: TargetType {
    case .Index(articleId: Int)
    case .Show(articleId: Int, id: Int)
    case .Create(articleId: Int, comment: Comment)
    // ...
  }

  case .Index
  case .Show(id: Int)
  // ...
}

// articles provider
let providerForArticles = MoyaProvider<Articles>()
// call listing articles
providerForArticles.request(.Index) { result in
  // do sth.
}

// comments provider
let providerForComments = MoyaProvider<Articles.Comments>()
// call listing comments
providerForComments.request(.Index(articleId)) { result in
  // do sth.
}
```

the disadvantage is the provider couldn't be shared.

I think the better way is using struct-based targets which is under active discussion in PR #447 #434 and Moya has a initial support in PR #430 

Pseudo-code is

``` swift
extension RubyChinaV3 {
    struct Replies {
        static let Path = "replies"
    }
}

extension RubyChinaV3.Replies {
    struct Listing: TargetType {
        var topicId: String
        var offset: Int
        var limit: Int

        init(topicId: String, offset: Int = 0, limit: Int = 20) {
            self.topicId = topicId
            self.offset = offset
            self.limit = limit
        }

        var baseURL: NSURL { return RubyChinaV3.BaseURL }
        var path: String { return "\(RubyChinaV3.Topics.Path)/\(self.topicId)/\(RubyChinaV3.Replies.Path)" }
        var parameters: [String: AnyObject] {
            var parameters = [String: AnyObject]()

            parameters["limit"] = self.limit
            parameters["offset"] = self.offset

            return parameters
        }
    }

    struct Create: TargetType {
        var topicId: String
        var body: String

        init(topicId: String, body: String) {
            self.topicId = topicId
            self.body = body
        }

        var baseURL: NSURL { return RubyChinaV3.BaseURL }
        var path: String { return "\(RubyChinaV3.Topics.Path)/\(self.topicId)/\(RubyChinaV3.Replies.Path)" }
        var method: Moya.Method { return .POST }
        var parameters: [String: AnyObject] {
            var parameters = [String: AnyObject]()
            parameters["body"] = self.body
            return parameters
        }
    }
}

let provider = MoyaProvider()
provider.request(RubyChinaV3.Replies.Listing(topicId: topicId)) { result in
  // do sth
}

provider.request(RubyChinaV3.Users.Followers.Listing(userId: userId, page: 2)) { result in
  // do sth
}
```

There are possible to design chaining-style API like `RubyChinaV3.user(3),followers.page(2).per(20)`
 @jasl Is this still working? I am asking because I cannot create a `MoyaProvider` instance without a specified target. 
 @ealeksandrov 
Sorry I'm not working on Moya now. 

For Moya, you may consider using [StructTarget](https://github.com/Moya/Moya/blob/master/Source/Moya.swift#L27) 

Besides, you may check my [fork](https://github.com/jasl/MoyaX/tree/0.0.8) 
 @ashfurrow Can you maybe explain shortly why this issue is considered "closed"? I can't see how it is, none of the above mentioned workarounds is a real solution, they're all bad for different reasons. And I'm fighting with the fact that Moya is not supporting RESTful API endpoints nearly every second month when I write a new API client. Could we keep this open please until a real solution is there? I might even tackle this myself when I have some time ... @sunshinejr Thanks for pointing that out. Actually I have not used `MultiTarget` yet. But as far as I understood from the [example docs](https://github.com/Moya/Moya/blob/master/docs/Examples/MultiTarget.md) it's rather there to structure the targets into smaller parts. Of course, one could use that and create one target per model, but then I have to still manually add my `baseUrl`, `method` and `task` in each target, right?

As far as I understand, the only thing `MultiTarget` does is to prevent me from having to create multiple providers ‚Äì no other help is given in the TargetType. But with this issue I'd rather see something that simplifies defining the targets for RESTful APIs *a lot*. I have not worked on any details yet, but `MultiTarget` doesn't look like the real solution to me ...  - fix wrong description
- clarify `didReceiveResponse` also be called when the request is cancelled.
  After updating to Xcode 7.3 (7D175) I get these errors when running carthage update, I'm also using Carthage 0.15.2, I also tried changing xcode-select to another Xcode of 7.2.1 without any success..

`/Users/xx/Documents/Projekt/app/Carthage/Checkouts/Moya/Source/Plugins/NetworkActivityPlugin.swift:2:8: error: module file was created by an older version of the compiler; rebuild 'Result' and try again: /Users/xx/Documents/Projekt/app/Carthage/Checkouts/Moya/Carthage/Build/iOS/Result.framework/Modules/Result.swiftmodule/arm64.swiftmodule`

`The following build commands failed:
    CompileSwift normal arm64 /Users/x/Documents/Projekt/app/Carthage/Checkouts/Moya/Source/Moya+Alamofire.swift
    CompileSwift normal arm64 /Users/x/Documents/Projekt/app/Carthage/Checkouts/Moya/Source/Error.swift
    CompileSwift normal arm64 /Users/x/Documents/Projekt/app/Carthage/Checkouts/Moya/Source/Image.swift
    CompileSwift normal arm64 /Users/x/Documents/Projekt/app/Carthage/Checkouts/Moya/Source/Plugins/NetworkActivityPlugin.swift
    CompileSwift normal arm64 /Users/x/Documents/Projekt/app/Carthage/Checkouts/Moya/Source/Response.swift
    CompileSwift normal arm64 /Users/x/Documents/Projekt/app/Carthage/Checkouts/Moya/Source/Endpoint.swift
    CompileSwift normal arm64 /Users/x/Documents/Projekt/app/Carthage/Checkouts/Moya/Source/Plugins/CredentialsPlugin.swift
    CompileSwift normal arm64 /Users/x/Documents/Projekt/app/Carthage/Checkouts/Moya/Source/Plugins/NetworkLoggerPlugin.swift
    CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
(9 failures)`

Hopefully someone of you guys might have an idea why this happens.. :)
 I suggest you try removing the entire `Carthage/build` folder and run `carthage update --platform ios --no-use-binaries`. That might work ‚Äì no need to fall back to Xcode 7.2.1. ;)

Carthage by default tries to reuse an already built framework (like here `Result`) as long as the specified version didn't change. You can force Carthage to rebuild by removing the build folder. Also I've added `--platform ios` as this saves time by not building possibly existing (but in iOS-only projects unnecessary) `tvos`, `osx` and `watchos` targets. Additionally `--no-use-binaries` ensures no pre-build binaries are downloaded.
 @Dschee I have the exact same problem and tried your suggestion and unfortunately ended up with the same error.
 `carthage update --platform iOS --no-use-binaries`
 Huge thanks @justinmakaila and company, here's what finally got me fixed up on this one:
- Cleared `DerivedData`
- Deleted Carthage's `build` and `checkouts` folders
- Deleted `Cartfile.resolved`
- Ran `'carthage update --platform iOS --no-use-binaries`

I'm sure only part of that is required to fix the issue, (probably that last `--no-use-binaries` option was the _real_ fix, but building all of this takes forever so I wanted to be on a _completely_ clean state just in case).

I too am still somewhat of a Carthage novice, but my best guess is the release binary it was downloading (by default) for one of Moya's dependencies was incompatible, so specifying  `--no-use-binaries` and re-building _everything_ from source fixed it up. Just a guess though. 
 That's exactly what the problem is. Haha
 @jakemarsh I'm going to go ahead and close the issue. Feel free to reopen if this doesn't seem to work!
  Thank you for the awesome networking framework!

We have migrated to swift 2.2 and started to get this warning:

‚ñ∏ Compiling Plugin.swift

‚ö†Ô∏è  /Pods/Moya/Source/Moya.swift:192:40: curried function declaration syntax will be removed in a future version of Swift; use a single parameter list

```
public final class func DelayedStub(seconds: NSTimeInterval)(_: Target) -> Moya.StubBehavior {
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

Would it be possible to workaround curried function or avoid the warning any other way? 
Somehow it comes multiple times in our build log on [travis-ci.com](https://travis-ci.com). 

Thank you!
  This builds off of `feature/multipart-upload` a little bit, but makes it a bit more flexible. I think this one is better suited for production.

It better introduces the concept of an upload, rather than just the ability to perform multipart uploads.

This was heavily influenced by the chatter on #114, @guidohendriks and @startupthekid
 This still requires some tests for the other upload types, but multipart is working :+1: 
 Looks really good, nicely done! üòé Will have a good look at this soon, if only I had time I would have given it a shot myself. 
 @GuidoHendriks There's still time, I'm sure there are bugs I'm missing cause I've been looking at it a bit too long
 Turns out that this builds on Carthage, unlike the last one. You have to run `carthage update --no-use-binaries`, because most of the distributed binaries were built with the old compiler /facepalm
 Ya. I find that it is always better to set that on
 This looks really good to me. I think we should also consider adding a way to get progress information for uploads. Do you think an optional closure on the `request` method would be ok?
 @aschuch I'm down with that. I think it'd be coolest if we could get it like this:

``` swift
let target = API.Target.SomeUploadTarget
APIProvider.request(target)
  .progress { bytesSent, totalBytes in
    let percentage = bytesSent / totalBytes
    self.progressView.value = percentage
  }
```

But that would require some contextual knowledge of the target (mostly that it's an upload).
 I might be off base here but what about for multipart uploads, we create a `Response` subclass that has a progress method? That way all the normal methods on `Response` would work and for multipart, you'd get the progress you need.

Something like:

``` swift
func request(token: Target) -> SignalProducer<UploadResponse, Error> {}
```
 @startupthekid I think you're on to something. Do @Moya/contributors see any issues with potentially introducing a new `Response` type?
 That does mean though that `Response` can't be a `final` class. That should be ok though, makes Moya more extensible, especially if someone wants to provide a custom response class for debugging purposes or what have you.

Another interesting direction could be making a `ResponseType` protocol that `Response` provides the implementation for and then an `UploadResponseType` that conforms to `ResponseType` and adds a few handy progress methods. 

``` swift
public protocol ResponseType: CustomDebugStringConvertible, Equatable {
    var statusCode: Int { get }
    var data: NSData { get }
    var response: NSURLResponse?

   ....
}

public protocol UploadResponseType: ResponseType {
    func progress(...)
}
```
 +1 to the `ResponseType` protocol.

Not sure how to integrate the progress though, because the response type wouldn't be available until after the request completes. 
 Instead of on `Response` it could be on `Request` and then `request` could send an intermediary request object that informs progress. Not sure how to go about implementing that though.
 We may have to introduce an `UploadRequest` or something along those lines... I'm imagining we'd just  add a `.progress { ... }` closure to the `Alamofire` call site which invokes the `progress` provided by `Moya`.
 Or we may add `progress` [here](https://github.com/Moya/Moya/blob/master/Source/Plugin.swift#L19) and add a closure named `willPerformRequest(request: RequestType)` and call it before the request is sending out (for upload, we call it in `encodingCompletion`
 But I think a better solution needs a breaking change, the `ParameterEncoding` is conflict with multipart-form-data, actually multipart-form-data is a kind of parameter's encoding, but Moya currently using Alamofire's `ParameterEncoding` directly
 @jasi that's a good point. It may be better to use our own encoding that mirrors Alamofire.

@justinmakaila something else I'm concerned about is supporting parameters in an upload request.
In the scenario where someone uploads a file and needs to attach that reference to another model, that can't currently be done in Alamofire. 

For example I'm using feathersjs on my backend to supports before and after hooks:

``` javascript
blobService.before({
  all: sharedAuthHooks,
  // Verify that the postID parameter exists and that it refers to a real post.
  create(hook) {
    const { params } = hook;
    const { postID } = params;
    if (typeof postID === 'undefined') {
      return Promise.reject(new errors.BadRequest('Invalid postID parameter'));
    }
    // Find a post with that id, error will be thrown if none exists
    return postService.get(postID).then(() => hook);
  }
});


blobService.after({
  // After a blob is created, attach the id to the post.
  create(hook) {
    const { result, data } = hook;
    const { id } = result;
    const { postID } = data;
    // Update the associated post with the blob id
    return postService.patch(postID, { blob: id }, {}).then(() => hook);
  }
});
```

Before a blob (a file object) is created, it verifies that a postID parameter is sent and that that post exists. After the creation occurs, the blob id is then attached to the post. But with Alamofire, you can't attach parameters to a file upload.

The reason I'm worried about that is because in applications that will introduce multiple points of failure in similar situations. Instead of relying on a single source of truth on the backend where parameters are verified and the appropriate models are updated, each client has to ensure that post-creation, the correct updating takes place. The more we can do to mitigate that risk that better but I'm not sure how with Alamofire currently. 
 If we refactor the `ParameterEncoding`, keeping the same behaviour both with normal request and multipart upload is possible and simple
I've done this for my Moya fork, [details here](https://github.com/jasl/MoyaX/blob/master/Sources/Backends/AlamofireBackend.swift#L70-L134)
 That's may not be an issue, for Cocoapods or Charthage, we can lock the Alamofire's version, and for 3.x, Alamofire would unlikely change `ParameterEncoding` (and `ParameterEncoding` should be a stable component according to its commit logs)
  PS: I can't judge this is a bug of Moya or just a wrong usage, and this is my thought, not proving yet.

For example, I use `NetworkActivityPlugin`, and I can set a `NetworkActivityClosure` to do something about UI, like set a loading tips on sending request, and hide after received response.

In most case, that should be worked fine, but if I cancel the request, `hide after received response` may not work, because `PluginType#didReceiveResponse` invoked in [Alamofire's completion](https://github.com/Moya/Moya/blob/master/Source/Moya.swift#L210).
 @ashfurrow I'm very sorry for inappropriate words, I'm not to offensive, you know... I've edited the issue. I'm very sorry.

I'm just thinking about that, it seems if cancel the Alamofire's request, the response completion will not be triggered. 

`PluginType#didReceiveResponse` is invoked in [Alamofire's response completion](https://github.com/Moya/Moya/blob/master/Source/Moya.swift#L210)

The point is, does `PluginType#didReceiveResponse` should always be invoked for a request? if yes, that might be a bug, because if Alamofire's response completion not invoke, ``PluginType#didReceiveResponse` will not invoke too .

pseudocode for example

``` swift
// In a ViewController
let networkActivityClosure: NetworkActivityPlugin.NetworkActivityClosure = { change in
  switch change {
  case .Began:
    ShowTipBar()
  case .Ended:
    HideTipBar()
  }
}

let networkActivityPlugin = NetworkActivityPlugin(networkActivityClosure: networkActivityClosure)
let provider = MoyaProvider<GithubAPI>(plugins: [networkActivityPlugin])

// do a request
let cancellableToken = provider.request(.UserProfiles) { result in
  // do something
}
```

if networking toooo terrible, and for some reason I cancel the request by `cancellableToken.cancel()`, the `HideTipBar` may not be triggered (which is unexpected).
 have read the doc again,
in https://github.com/Moya/Moya/blob/master/docs/Providers.md#plugins

``` swift
    /// Called by the provider as soon as a response arrives
    public func didReceiveResponse(data: NSData?, statusCode: Int?, response: NSURLResponse?, error: ErrorType?, target: TargetType) {
        networkActivityClosure(change: .Ended)
    }
```

the comment and the functional naming is clear and point out that will be called when response arrives

but, as the doc tips `This is useful for working with the network activity indicator`, if the response not arrives (the request be canceled or some other reasons), the `.Ended` state would not be reached, and if developer not consider this possibility, that would have issue.
 My mistake, just do some experiment, when cancel a request, the callback will be triggered but got `Error Domain=NSURLErrorDomain Code=-999 "cancelled"`

Sorry for my inappropriate words again @ashfurrow , just closing the issue.
 Yes!
- https://github.com/Moya/Moya/blob/master/Source/Plugins/NetworkActivityPlugin.swift#L9 wrong description here.
- https://github.com/Moya/Moya/blob/master/Source/Plugins/NetworkActivityPlugin.swift#L26 the `didReceiveResponse` not only triggered by the response arrives but also the request be cancelled (with a "cancelled" error), notice here may be better.
 No problem! I'll give a PR later.
  Added the ability for multipart uploads. It's not _really_ sick because of the ugly button on the toolbar, but it works. Let's get this baby reviewed, refined, and into rotation ;)
 This doesn't build on Carthage for the same reason master doesn't (Something about "Result" being built with a different version of the compiler). Looking into it now. 
 Uhh, strange issue... The project doesn't build if `Demo/` is present, probably due to the shared schemes in the `xcworkspace`. @ashfurrow, @orta, Do they have to be shared for Cocoapods?

**Edit:** nvm, there was a rogue scheme floating around. Everything's looking good now.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=9fd8cf60e5236c33516cf33a7cf8193b4f730301) is `91.64%`

> Merging **#438** into **master** will not affect coverage as of [`9fd8cf6`](https://codecov.io/github/Moya/Moya/commit/9fd8cf60e5236c33516cf33a7cf8193b4f730301)

``` diff
@@            master    #438   diff @@
======================================
  Files           13      13       
  Stmts          479     479       
  Branches         0       0       
  Methods          0               
======================================
  Hit            439     439       
  Partial          0       0       
  Missed          40      40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/4d62aaf04f137cddf00ce0ab2d194130b9d384ee...9fd8cf60e5236c33516cf33a7cf8193b4f730301) as of [`9fd8cf6`](https://codecov.io/github/Moya/Moya/commit/9fd8cf60e5236c33516cf33a7cf8193b4f730301)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=9fd8cf60e5236c33516cf33a7cf8193b4f730301)
1. `+2.09%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=9fd8cf60e5236c33516cf33a7cf8193b4f730301#84) 
2. `+1.05%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=9fd8cf60e5236c33516cf33a7cf8193b4f730301#54) 
3. `+1.05%` via [Source/Moya.swift#222...226](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=9fd8cf60e5236c33516cf33a7cf8193b4f730301#222) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=9fd8cf60e5236c33516cf33a7cf8193b4f730301)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 I've answered all your inline comments and tried to update the code accordingly. I hope all issues are fixed now. Thanks for considering this PR and looking at is so swiftly, @ashfurrow! :tada: 
  Moya has it's own Error type. When you try to cast it to NSError inside .Failure case, switch suddenly becomes non-exhaustive forcing you to add:

``` swift
default:
    break
```
 @ashfurrow This causes associated type to be gone and only basic info is preserved, just like @sunshinejr said. Making my own extension to be future safe seems like a good idea, thanks!
  There is this error at this part of the extension that is in example.mp 

```
var method: Moya.Method {
        // all requests in this example will use GET.  Usually you would switch
        // on the enum, like we did in `var path: String`
        return .GET
    }
```

`'Method' is not a member of Moya`

Any help? 

And seperately, Can I use Moya with Heimdallr? As I understand Moya can make requests and using Alamofire for this. But I found Heimdallr and the author claims that Heimdallr can refresh tokens by itself. I have issues with task in Alamofire. This is whay I am asking this. 
 Solved the main question. A simple mistake. But second question is still valid
 Thank you for the information. Alamofire is brilliant framework I know that. But like I said, I am not able to handle 401 http code and I don't know iOS development to solve it. The reason why I want to use Heimdallr is the author of it claims that the Heimdallr will handle it by itself. 
However I will consider your suggestion. Time will show me how I am gonna do :)

And about the first question. Before using `Moya` it turned out I had created a class and called it 'Moya'. When the code tried to reach `Moya.Method`, it threw an error because the class which I called 'Moya' had not a member called `Method`. So It wasn't about the actual `Moya`. :)
  Love the concept of Moya, just reading the docs and struggling to see the benefits of it compared to just using vanilla Alamofire with an enum that conforms to URLRequestConvertible: https://github.com/Alamofire/Alamofire#api-parameter-abstraction

I like that Moya formalizes the pattern, as it does seem like a side thought in the Alamofire readme. But are there other intentions/benefits compared to it?

_Moya_:

```
provider.request(.UserProfile("ashfurrow")) { result in
    // do something with the result
}
```

_Alamofire_:

```
Alamofire.request(Router.UserProfile(name: "ashfurrow"))
    .responseJSON { response in
        // do something with the result
    }
```
 That makes sense, thanks! I'd love if that was in the readme, but I see it in action in the demo. I'm going to close this.
  Seems `Backend` should be `Strategy` more clearly.

The Moya current data flow is
`TargetType - endpointClosure -> Endpoint<T> - requestClosure -> NSURLRequest - plugins -> Alamofire's Request -> Cancellable`
Because of generic Endpoint, we can do some things like adding authentication headers for specified targets in `endpointClosure`, [for example](https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/Networking.swift#L130). I think that's why `Endpoint` needs be generic. @ashfurrow is this right?

If `Endpoint` becoming non-generic, how do we do the same thing? maybe moving this job into `TargetType` itself is a good choice, so MoyaX's flow is
`TargetType - TargetType#endpoint-> Endpoint -> Provider#willTransformToRequest -> NSMutableURLRequest - plugins - Backend -> Cancellable`

Besides, `Endpoint` is a Moya internal presentation of `TargetType`, I think there is no side effect and should keeping in a single thread, so changing `Endpoint` is no need returns a new instance and It could be a `struct`, that's may good for performance slightly.

After this change, I think generic Provider become just for convenient.

I admit non-generic provider is a little radical, but If we have non-generic Provider first, we can easily wrapping it as generic provider but harder the other way.
In MoyaX, the generic Provider reused most of non-generic provider, so It's only [10 lines](https://github.com/jasl/MoyaX/blob/master/Source/Provider.swift#L53-L63).
  Hi!

I just hit the situation that I have to use  `Alamofire` / `AlamofireImage` directly for specific requests. I am using `ReactiveMoya` and would like to integrate those specific calls into my chains of Signals without mapping the Values and Errors to ReactiveMoya¬¥s equivalents manually. Therefore it would come in handy if `convertResponseToResult`would be accessible from outside the module.

https://github.com/Moya/Moya/blob/master/Source/Moya.swift#L249-L262

Any thoughts / concerns on this?
  I would appreciate more detailed examples a lot.

I'm currently trying to implement an API the Moya way but I'm struggling with all the options and plugins and how to actually integrate them. Specifically it's not clear to me from reading the current docs which parts are required and what the default behavior of Moya is if only the required things are implemented. Also I can't figure out how to add a logging plugin right now ‚Äì seems like I have to dig much deeper into Moya than I wanted to. I think things would be much easier if multiple examples were provided.

Also it would be nice if the documentation explicitly explained how Moya brings all the parts together to make a request. Right now I have to search everything one by one.
 Thank you @sunshinejr for getting back to me so quickly.

I think the **best way to answer your question** and clarify what I mean is to **provide a PR** with updated Docs ‚Äì please take a look at #438. I hope that helps and makes clear what kind of explanations I was missing.
  I'm new to iOS development with Swift, Moya, Alamofire, Argo, et al, so please be lenient with my ignorance.
I have read the documentation and searched the issues/questions but I'm still clueless as how to set the body of the HTTP request for a POST/PUT.
I have read about the endpoint closures (which don't seem the correct place for this) and about the request closures, but I still can't find an example of how to do it.
Forget for a second that I'm using other stuff for converting structs to/from json, and imagine that I already have a JSON string ready to set as the request body. Where/how should I set it?
I find it very strange that it is not prominently stated in the documentation, and that the only examples are for simple GET requests.
I appreciate any help.
 Ok, I tried something like this: https://github.com/Moya/Moya/issues/403#issuecomment-182465029
and yes, the `parameters` are converted to JSON and used as the http body.
The thing is that I need to send a json body AND request parameters (as url query string).
Do you have any suggestions on how to achieve this?
Am I doing something fundamentally wrong that I'm the only one doing this?
 I stumbled across this issue trying to do something similar, we have an API where there are 'additional' params (sort, number of results to return etc) that are not part of the 'body'.

So we needed both URL parameter encoding for the query string, and a json body on the POST request.

Here is my solution for using the [`ParameterEncoding.CUSTOM`,](https://github.com/Alamofire/Alamofire/blob/fad7390adcaa38480cd44cd62dfbd8506af92151/Source/ParameterEncoding.swift#L67) once I take a look at the Moya docs and find a good place for an example, I'll put in a pull request.

Define a typealias that adheres to Custom Encoding:

``` swift
typealias MyAPICallCustomEncoding = (URLRequestConvertible, [String:AnyObject]?) -> (NSMutableURLRequest, NSError?)
```

Create a closure that implements Custom Encoding

``` swift
let MyAPICallCustomEncodingClosure: MyAPICallCustomEncoding = { request, data in
    let sort = NSURLQueryItem(name: "sort", value: "distance")
    var req = request.URLRequest as NSMutableURLRequest

    guard var components = NSURLComponents(string: req.URL!.absoluteString)
    else {
        // even though this is an error, Alamofire ignores the returned error.
        return (req, nil)
    }
    //Create our query string params
    components.queryItems = [sort]
    req.URL = components.URL

    //Add our JSON body
    do {
        let json = try NSJSONSerialization.dataWithJSONObject(data!, options: .PrettyPrinted)
        req.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
        req.HTTPBody = json
    } catch {
        return (req, nil)
    }
    return (req, nil)
}
```

Add the custom encoding to your API:

``` swift
extension AuthedApi: TargetType {
    var path: String {
        case .MyAPICall:
            return "/api/search"
    }
    var parameterEncoding: Moya.ParameterEncoding {
        switch self {
        case .MyAPICall:
            return ParameterEncoding.Custom(MyAPICallCustomEncodingClosure)
    }
}
```

As always, your milage may vary.
 I have a similar question, how can I send an array as parameters? 

```
[
  "Foo",
  "Bar"
]
```
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=217f9f74450bac481ee2177f85e76772a0fca5d3) is `91.64%`

> Merging **#430** into **master** will not affect coverage as of [`217f9f7`](https://codecov.io/github/Moya/Moya/commit/217f9f74450bac481ee2177f85e76772a0fca5d3)

``` diff
@@            master    #430   diff @@
======================================
  Files           13      13       
  Stmts          479     479       
  Branches         0       0       
  Methods                          
======================================
  Hit            439     439       
  Partial          0       0       
  Missed          40      40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/f33f7ae30bb10a3353e7d3c3021d50c55a14aabe...217f9f74450bac481ee2177f85e76772a0fca5d3) as of [`217f9f7`](https://codecov.io/github/Moya/Moya/commit/217f9f74450bac481ee2177f85e76772a0fca5d3)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=217f9f74450bac481ee2177f85e76772a0fca5d3)
1. `+2.09%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=217f9f74450bac481ee2177f85e76772a0fca5d3#84) 
2. `+1.05%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=217f9f74450bac481ee2177f85e76772a0fca5d3#54) 
3. `+1.05%` via [Source/Moya.swift#222...226](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=217f9f74450bac481ee2177f85e76772a0fca5d3#222) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=217f9f74450bac481ee2177f85e76772a0fca5d3)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=d8c017582e3930e54b0f84efeb3c30a329799c1d) is `91.64%`

> Merging **#427** into **master** will increase coverage by **+0.27%** as of [`d8c0175`](https://codecov.io/github/Moya/Moya/commit/d8c017582e3930e54b0f84efeb3c30a329799c1d)

``` diff
@@            master    #427   diff @@
======================================
  Files           13      13       
  Stmts          464     479    +15
  Branches         0       0       
  Methods                          
======================================
+ Hit            424     439    +15
  Partial          0       0       
  Missed          40      40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/548fee15cede8c2998e82ebe9e4366b29e243478...d8c017582e3930e54b0f84efeb3c30a329799c1d) as of [`d8c0175`](https://codecov.io/github/Moya/Moya/commit/d8c017582e3930e54b0f84efeb3c30a329799c1d)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=d8c017582e3930e54b0f84efeb3c30a329799c1d)
1. `+2.09%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=d8c017582e3930e54b0f84efeb3c30a329799c1d#84) 
2. `+1.05%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=d8c017582e3930e54b0f84efeb3c30a329799c1d#54) 
3. `+1.05%` via [Source/Moya.swift#222...226](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=d8c017582e3930e54b0f84efeb3c30a329799c1d#222) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=d8c017582e3930e54b0f84efeb3c30a329799c1d)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=e97f2bc2476b6873c922ea0e44ba3591306cbc54) is `91.37%`

> Merging **#426** into **master** will not affect coverage as of [`e97f2bc`](https://codecov.io/github/Moya/Moya/commit/e97f2bc2476b6873c922ea0e44ba3591306cbc54)

``` diff
@@            master    #426   diff @@
======================================
  Files           13      13       
  Stmts          464     464       
  Branches         0       0       
  Methods                          
======================================
  Hit            424     424       
  Partial          0       0       
  Missed          40      40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/61ee8562f60f75345da16a54b5d8f54fe32f9d9f...e97f2bc2476b6873c922ea0e44ba3591306cbc54) as of [`e97f2bc`](https://codecov.io/github/Moya/Moya/commit/e97f2bc2476b6873c922ea0e44ba3591306cbc54)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=e97f2bc2476b6873c922ea0e44ba3591306cbc54)
1. `+2.16%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=e97f2bc2476b6873c922ea0e44ba3591306cbc54#84) 
2. `+1.08%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=e97f2bc2476b6873c922ea0e44ba3591306cbc54#54) 
3. `+1.08%` via [Source/Moya.swift#189...193](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=e97f2bc2476b6873c922ea0e44ba3591306cbc54#189) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=e97f2bc2476b6873c922ea0e44ba3591306cbc54)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  It seems Moya is encouraging the stubbed responses to be part of the production app (this seems to be the case in [Eidolon](https://github.com/artsy/eidolon) as well).

I'm wondering why this is and if there's a way not include unnecessary json files in the production app? 

I thought about having a `stubbedResponseProvider` that would simply return empty `NSData`s in production but figured I'd try to understand why Moya is encouraging the other way first.

Thanks!
 Thanks for the great response!

I asked this question because I was trying to keep test code/data completely out of the main code, so anything I suggest may not fit well with the "encourage testing" goal.

My initial hunch on this was that it has dependency injection written all over it. We need something to provide stubbed data. That can be empty in production, but must be available for tests - therefore, different dependencies.

Keeping in mind that I haven't _actually_ used Moya yet (so I don't know how this meshes with it), my first idea was this: 

``` swift
struct MyAPI {
    enum Target {
        case GetUser, GetFiles
    }

    private let target: Target
    private let sampleDataProvider: (Target -> NSData)

    private static func DefaultDataProvider(t: Target) -> NSData {
        return NSData()
    }

    init(_ aTarget: Target, sampleDataProvider provider: (Target -> NSData) = MyAPI.DefaultDataProvider) {
        target = aTarget
        sampleDataProvider = provider
    }
}

extension MyAPI: TargetType {
    /* These would all switch on self.target */
    var path: String { ... }
    var baseURL: NSURL { ... }
    var parameters: [String: AnyObject]? { ... }
    var method: Moya.Method { ... }

    var sampleData: NSData {
        return sampleDataProvider(self.target)
    }
}

let target = MyAPI(.GetUser)

let testTarget = MyAPI(.GetUser, sampleDataProvider: /* a closure that actually returns stubbed data */)
```

It's using a `struct` just because the `sampleDataProvider` needs to get stored somewhere. That's a drawback, along with the fact that, in tests, every instance of an API target needs to get its own `sampleDataProvider` at `init`.

Reading through the docs more (including the ["Advanced Use" section on Providers](https://github.com/Moya/Moya/blob/master/docs/Providers.md#advanced-use)), it seems to me that this kind of behaviour belongs in the provider itself (as opposed to the `TargetType`). We're already injecting all sorts of stuff in there - custom endpoint mapping, request mapping, etc. The provider could also take something like a `sampleDataProvider` and default it to return an empty `NSData` in production, but in tests, the user can provide their own `sampleDataProvider`.

I think with this all the test code can stay in tests, and the production code doesn't need to know about any stubbed responses.

Thoughts? Am I off my rockers?
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=d258c2f3027ec42b1c0576650ffb19c44c001535) is `90.31%`

> Merging **#424** into **master** will decrease coverage by **-1.06%** as of [`d258c2f`](https://codecov.io/github/Moya/Moya/commit/d258c2f3027ec42b1c0576650ffb19c44c001535)

``` diff
@@            master    #424   diff @@
======================================
  Files           13      13       
  Stmts          464     475    +11
  Branches         0       0       
  Methods                          
======================================
+ Hit            424     429     +5
  Partial          0       0       
- Missed          40      46     +6
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/61ee8562f60f75345da16a54b5d8f54fe32f9d9f...d258c2f3027ec42b1c0576650ffb19c44c001535) as of [`d258c2f`](https://codecov.io/github/Moya/Moya/commit/d258c2f3027ec42b1c0576650ffb19c44c001535)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=d258c2f3027ec42b1c0576650ffb19c44c001535)
1. `+2.11%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=d258c2f3027ec42b1c0576650ffb19c44c001535#84) 
2. `+1.05%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=d258c2f3027ec42b1c0576650ffb19c44c001535#54) 
3. `+1.05%` via [Source/Moya.swift#215...219](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=d258c2f3027ec42b1c0576650ffb19c44c001535#215) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=d258c2f3027ec42b1c0576650ffb19c44c001535)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 I must say I like this solution. Haven't checked into this a while. But this looks promising. 
  Hello guys, I need that the Observable be observed on a background thread, I know this is no the right way to do it but this is my approach:

https://gist.github.com/robertofrontado/475787b538d3d4c9f90d

From the RxSwift documentation: https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Schedulers.md

"In case observeOn isn't explicitly specified, work will be performed on which ever thread/scheduler elements are generated."

So when I received an Observable form Moya, which has been subscribed on (subscribeOn) a background thread,  I'll expect that the whole observable chain (map, flatMap...) will be performed in that thread (not the main), until I change it eventually using observeOn

Thanks
 Not the behaviour itself, what I'm suggesting is that I want to perform some operations, such map or flatMap, in the same Scheduler (background thread) which I'm subscribing it (subscribeOn). But Moya seems to not to follow the convention declared on RxSwift docs:

> In case observeOn isn't explicitly specified, work will be performed on which ever thread/scheduler elements are generated.

So the observable do not observe (map, flatmap) in the thread specified when calling subscribeOn
 Hi @ashfurrow!

I think subscribeOn matters (or should do it). Take for example the changed performed in [Retrofit 2 (after released beta-2)](https://github.com/square/retrofit/releases/tag/parent-2.0.0-beta2).  

> Fix: Observable and Single-based execution of requests now behave synchronously (and thus requires subscribeOn() for running in the background). 

They changed this because the library was modifying the thread on which the request was performed. And this responsibility should belong to the users of the library, not the library itself. I think Moya should do the same, because in the end is the user who consumes the observable who will know better in which thread subscribe or observe. 

Nevertheless, I think the issue reported by @robertofrontado is related to this, but it is not the problem itself. 

It seems to me like the underlying request performed by Alamofire is changing the thread to the Main thread, after the callback request is called. But I‚Äôm just guessing here. 

Anyway, thanks for this amazing library!
 That‚Äôs the point :)

> I'm kind of curious why you would want the callbacks on a separate thread for all requests ‚Äì is it a performance issue?

Yes, because I usually chain multiple operations after the request -using map or flatmap, like persisting data in disk or whatever. 

But I‚Äôm not asking Moya to behave like that. I mean, **_I don‚Äôt wanna the callbacks on a separate thread per se, I just want to Moya does not change the thread which I choose when using subscribeOn and ObserveOn**_. 

Because Moya sticks to the Alamofire procedure on threading synchronization (which makes a lot of sense outside the rx world), Moya does not follow the standards of reactive family. 

Like @robertofrontado pointed out before:

> In case observeOn isn't explicitly specified, work will be performed on which ever thread/scheduler elements are generated.

So, to sum up, I think Moya rx version should not set the thread on which to observe, neither the thread on which to subscribe. Moya should respect in which thread the user choose to be performed the requested, by modifying internally nothing. Moya should not call internally observerOn or subscribeOn (plus Moya should take care of that synchronisation issue related with the fact that Alamofire synchronizes callbacks to the main thread by default).

But this is my opinion. And of course, yes, it could potentially break someone‚Äôs code. Retrofit broke mine when I upgraded to the last version. But it was for the better, because that way I was able to understand deeper the topic of scheduling. 
 The issue happens in the class RxMoyaProvider.

Observable starts to work in a background thread. That‚Äôs right:

<img width="1020" alt="background_thread" src="https://cloud.githubusercontent.com/assets/2614726/13707361/928b93bc-e7a9-11e5-99c9-0c0ab0d6af8a.png">

But after the callback, the actual thread becomes the Main thread:

<img width="1019" alt="main_thread" src="https://cloud.githubusercontent.com/assets/2614726/13707341/785a2ab2-e7a9-11e5-9260-84ac270d54f5.png">

And after that point, every observable operation (flatmap, map, subscribe) will be performed in the main thread, unless I call explicitly obserberOn to observe in a particular thread. 
 I don't think so. 

Rx knows nothing about the underlying task executed. Rx just knows that this "anonymous" task will be performed in some thread thanks to the configuration made to observable's state using subscribeOn and obserberOn. 

And, as the official docs [points out](http://reactivex.io/documentation/operators/subscribeon.html), subscribeOn specifies the Scheduler on which an Observable will operate. 

So, if I subscribeOn in a background thread, and I never specify in what thread the observable should observe, the convention is to observe in the thread specified when calling subscribeOn. But Moya changes that, and it is due to the underlying task of Alamofire -or at least I think that's the problem. 
 I don't see any different. I think it says the same thing. Indeed, you can create an observable with RxSwift and call subscribeOn and you will see that it behaves like already told you. 

The real problem is that Moya is changing the scheduler in the middle of the task which performs the observable. Like I pointed out before, with the screenshot. 

But we can wait to see what they have to say about that. Maybe I'm wrong after all ;)
 Don‚Äôt worry :) I can see your point. 

It‚Äôs just that for me I see it from the other side. I‚Äôm a user of Moya, and I expect that its tasks would be performed in whatever scheduler I would set calling onSubscriber. I think Moya should give complete freedom to the user, not forcing the scheduler to be the Main thread, just because Alamofire do that. It‚Äôs something common for no rx users, but I think most rx people would expect full control over the observable‚Äôs threading.    

Thanks anyway!
 With observeOn I can't change in which scheduler Moya performs its tasks. I just can change it using subscribeOn. In fact, it changes it until the code execution hits the 22 line, when unexpectedly -for me, as a user- Moya changes its scheduler.  
 @ashfurrow is right. In the Rx world, Moya's behaviour is correct. There's a fundamental misconception on the first assumption that seems to be the root of this discussion and is Scheduler = Thread. In a first instance I got tricked as well, but then re-reading the whole discussion I understood what the original issue was about and I can say that Moya is behaving in a more than reasonable way. 

The fact that is changing the thread is something natural if considering that Moya is a helper to talk with an api, perform the work in the background and call the callback in the main scheduler to update the UI in most of the times. Changing Moya's behaviour would be more a design decision, rather than a real solution for a bug or the necessity to comply to a guideline. 

I would also like to point to the chapter about Schedulers in [introtorx.com](http://www.introtorx.com/Content/v1.0.10621.0/15_SchedulingAndThreading.html#SchedulingAndThreading):

> Being free-threaded means that you are not restricted to which thread you choose to do your work. For example, you can choose to do your work such as invoking a subscription, observing or producing notifications, on any thread you like.

We should remember that in the Rx world there's no `thread` concept, considering its "threat agnostic" nature, but we have the scheduler abstraction that is the entity taking care of scheduling the work. 

The referenced documentation is more for RxSwift itself, rather than for a third party library relying on it. So the discussion about how Moya should behave, has to be done with @ashfurrow, in my opinion it shouldn't be changed, but I am happy to follow the discussion and help if necessary. 
 Hi @bontoJR :)

If you think of Moya like a wrapper of Alamofire, it makes sense that Moya returns an observable which by default observe on the Main thread. But we are talking about the rx extension part of Moya, which I don‚Äôt see anymore like a wrapper for Alamofire. Instead, I see it just like a rx resource which performed certain task. So if I don‚Äôt specify any scheduler, I would expect -just like any other observable, its task will be performed in the same scheduler-thread from where I‚Äôm calling it.

But that‚Äôs only my opinion.
 Hello @VictorAlbertos. I really like this part of your post: `I see it just like a rx resource which performed certain task`, you're right, RxMoya is a resource. I just added my 2 cents because the original documentation for RxSwift has been referenced, alongside the ReactiveX official documentation, to justify and promote a change in the default behaviour of RxMoya, which I think they should not be related. RxMoya is using RxSwift, but it's not part of the original RxSwift framework. :)

I see your point and I would definitely agree in case the error would have been in the RxSwift code, but in this case it's a matter of design specific decision rather than a design error. I don't see any issue keeping the current behaviour, but I would like to know in which case you would prefer to have the callback called in a scheduler working in a background thread, rather than the main one, just to better picture a potential scenario and see if the change would add more value than problems. :)
 Of course!

We are (@robertofrontado and me) just finishing the port of this [android base project](https://github.com/RefineriaWeb/base_app_android) to the iOS ecosystem. It splits the responsibilities into 3 layers. Data, domain and presentation. Every operation performed in the data layer is an i/o operation. The data retrieved from Moya needs to be cached eventually using [RxCache](https://github.com/VictorAlbertos/RxCache) (I‚Äôll release the port for iOS next week and I think it will be work almost (xD) perfectly with Moya and ObjectMapper), so the next actions upon the observable chain keep being i/o operations. So it does not make sense to me that Moya, which is a library focused on i/o operations, suddenly changes the current thread to the main thread, especially if I‚Äôve called subscribeOn to ensure that the underlying task -as such the observable operations, will be performed in another thread.

This puristic complain has also a practical implication xD

In the domain layer resides the base class [Presenter](https://github.com/RefineriaWeb/base_app_android/blob/master/domain/src/main/java/domain/foundation/Presenter.java). This method [schedulers](https://github.com/RefineriaWeb/base_app_android/blob/master/domain/src/main/java/domain/foundation/Presenter.java#L100) specify the Scheduler on which the observable coming from the data layer (Moya) will operate using an Scheduler of type i/o, and its items emitted will be observed in the UI thread. But only when the observable reaches this point in the chaining operation, not before! And because Moya changes this (I think standard behaviour in rx ecosystem) the scheduling configuration is messed up and now it is required to be called obserbeOn in the data layer in order to prevent this -for me, again- unexpected behaviour. 
 Hi guys, I'm sorry for opening this again but I think my network calls are happening in UI Thread. I'm experiencing UI freezes when performing calls, so I started to dig around, I found this issue and noticed that on @VictorAlbertos 's screenshots RxMoyaProvider's request function starts in thread 4 and then switch to Main thread. This doesn't happen in my case. Everithing happens in UI thread and I really don't know why. 
![screen shot 2017-01-19 at 17 16 04](https://cloud.githubusercontent.com/assets/1080149/22114974/8e26e0c4-de6b-11e6-9785-4b845c4168db.png)
![screen shot 2017-01-19 at 17 16 52](https://cloud.githubusercontent.com/assets/1080149/22114972/8e2297b2-de6b-11e6-9bb2-69ce13840e16.png)
![screen shot 2017-01-19 at 17 17 09](https://cloud.githubusercontent.com/assets/1080149/22114975/8e2d7eca-de6b-11e6-8242-96a0c2a5aded.png)
![screen shot 2017-01-19 at 17 17 26](https://cloud.githubusercontent.com/assets/1080149/22114973/8e237fec-de6b-11e6-8176-cbd404530af5.png)
this is the way im subscribing (its on main thread)
`    func getApp() {
        return providerCert.request(RestAPI.getApp)
            .filterSuccessfulStatusCodes()
            .mapJSON().subscribe(onNext: { result in
                print(result)
            })
    }`
 @beretis We added this extension, and using it every time we use moya

```swift
// Fixed Moya scheduler issue
extension RxMoyaProvider {
    
    func requestBackground(target: Target) -> Observable<Response> {
        return request(target).observeOn(SerialDispatchQueueScheduler(globalConcurrentQueueQOS: .Background))
    }
}
```

like `provider.requestBackground({{Target}})`, so with `.observeOn(SerialDispatchQueueScheduler(globalConcurrentQueueQOS: .Background))` we force the `Observable chain` to perform the `api call` on background Thank you, for swift 3 compatibility if anyone is interested

```swift
extension RxMoyaProvider {
    
    func requestBackground(target: Target) -> Observable<Response> {
        return request(target).observeOn(SerialDispatchQueueScheduler(qos: DispatchQoS.background))
    }
}
```  Ihave two requests that I concat its Observables and when I try to to stub them sending `MoyaProvider.ImmediatelySub` to te provider, the `subscribe` to the concat only receives the first request. However, if I send `MoyaProvider.DelayedStub` even with 0.1s of delay, they behave correctly.

I'm 100% sure it's an issue with the stubbing and not with our implementation because if I stop stubbing the tests (making them access the network) the code runs as expected.

I know this may be hard to reproduce and, if so, tell me and I'll try to create an example project with the steps to replay this issue.
 We have implemented a datasource for our services to paginate the HTTP responses. The datasource receives a "fetch" closure that receives an `offset` and a `limit` and must return an Observable with the request. Also, we've implemented the `subscript` method so when an element with index >= `count-5` is accessed, we try to load the next page:

``` swift
struct FriendsService {
  private let dataSource = PaginatedDataSource<User>(limit: 30)

  func loadFriends() -> Observable<Range<Int>> {
    dataSource.fetch = { offset, limit in
      provider.request(.Friends(APIRange(offset, limit)))
        .mapArray(User.self, rootKey: "users")
    }

    return dataSource.load()
  }
}


struct PaginatedDataSource<T> {
  private(set) items = [T]()
  private let loadMore = PublishSubject<Range<Int>>()

  func load() -> Observable<Range<Int>> {
    let firstLoad = fetch(0, limit)
      .doOnNext { [weak self] items in
        self?.items = items
      }
      .map { Range(start: 0, end: $0.count) }

    return Observable.of(firstLoad, loadMore).concat()
  }

  subscript(index: Int) -> T {
    guard let index >= items.count - 5 else { return items[index] }

    fetch(items.count, limit)
      .subscribeNext { [weak self] items in
        guard let weakSelf = self else { return }

        let range = Range(start: weakSelf.items.count, end: weakSelf.items.count + items.count
        weakSelf.items += items
        weakSelf.loadMore.onNext(range)
      }
      .addDisposableTo(disposeBag)
  }

  return items[index]
}
```

Please, notice that I've stripped down the code to the relevant parts, if you think this is confusing or something don't add up, please ask me, and I'll try to improve it.
 Thanks @ashfurrow. This is my test:

``` swift
it("loads next page") {
  var didLoadFirstPage = false
  var didLoadNextPage = false

  _ = screen.loadFriends()
    .subscribeNext { _ in
      if !didLoadFirstPage {
        let initialCount = screen.dataSource.count
        screen.dataSource[initialCount - 5]

        didLoadFirstPage = true
      }
      else {
        didLoadNextPage = true
      }
    }

  expect(didLoadNextPage).toEventually(beTrue(), timeout: 10)
}
```

To clarify: the first element the Observable receives is the "firstLoad" from the datasource, and the following should be triggered by accessing the last elements from the array.

When we tell Moya to `StubImmediately`, the Observable only receives one element, causing `didLoadNextPage` to be false. However, without stubbing or by adding some delay, it does comply to the test and its value is true in the end.
  That PR fixed #419. Apparently, set an empty array as an endpoint parameters creates all this weird bugs. I have strictly no idea why, and if one you has an answer, I'd love to hear it! :monkey_face: 

The small changes I did to fix my both issues (related to #419) is just to let the current parameters / headers if we aren't adding any values to them.

I make some tests, didn't find anything that could break. What do  you think?
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=ad8578b3136fcf89df12d7bf5fc6120dfe6a8be7) is `91.37%`

> Merging **#420** into **master** will increase coverage by **+0.17%** as of [`ad8578b`](https://codecov.io/github/Moya/Moya/commit/ad8578b3136fcf89df12d7bf5fc6120dfe6a8be7)

``` diff
@@            master    #420   diff @@
======================================
  Files           13      13       
  Stmts          455     464     +9
  Branches         0       0       
  Methods                          
======================================
+ Hit            415     424     +9
  Partial          0       0       
  Missed          40      40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/40461d2d88a2dda2f1d486ae3de2ef26b5d065b2...ad8578b3136fcf89df12d7bf5fc6120dfe6a8be7) as of [`ad8578b`](https://codecov.io/github/Moya/Moya/commit/ad8578b3136fcf89df12d7bf5fc6120dfe6a8be7)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=ad8578b3136fcf89df12d7bf5fc6120dfe6a8be7)
1. `+2.16%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=ad8578b3136fcf89df12d7bf5fc6120dfe6a8be7#84) 
2. `+1.08%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=ad8578b3136fcf89df12d7bf5fc6120dfe6a8be7#54) 
3. `+1.08%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=ad8578b3136fcf89df12d7bf5fc6120dfe6a8be7#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=ad8578b3136fcf89df12d7bf5fc6120dfe6a8be7)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Just edited following your comments. Let me know if you need anything else!
 Thanks! Loved to join your great project :tada: 
  After updating to Moya 6.2, I'm getting some really weird issues:
- Some requests never come back (Charles, a HTTP tracker, get a response 200), but Moya never call the completion. Apparently, that happens only with the GET method, the POST request is responding well
- The request duration has increased a lot: 58ms (6.1.3) -> 10s (6.2). These numbers are from Charles

I confirm that these both bugs has been creating in the 6.2. Rolling back to v6.1.3 solve both of them.
I also look at the CHANGELOG, but didn't see any breaking changes that could create these weird behaviours. 

Any ideas?
 Sure. Moya and Alamofire are installed using CocoaPods, but not using `RxSwift`, or `ReactiveCocoa`.
Moya setup is completely inspired from your project `Eidodolon`, it's following exactly the same pattern, with some adaptations following the needs of my project.

I really don't get what could make this errors. I also tried to track them, but I got nothing yet. The only tips I got is that's working well with the version 6.1.3...
 That's a great idea @sunshinejr. I will try that tomorrow at work and keep you in touch! 
 I retried the v6.2.0 to make sure that the bug was always happening (who knows what's happening during the night...), and sadly, I encountered the same bugs.

Finally, I tracked the commit which _might introduced_ these issues as suggested by  @sunshinejr. The guilty commit would be fe7d25c: _Add endpointByAdding method and refactor others._ :smiling_imp: 
Before this commit, everything is working as expected, but starting at this one, I'm getting these both issues.

I'm using `endpointByAddingHTTPHeaderFields` to add the authorisation token in my project, which is the main change fro the commit. I think we can say that the range of research is reduced to the this method :dancer: 

I'm gonna take a deep look at this commit this afternoon if I have enough time. Let's track this down! :tada: 

Not sure if that can help, but here my endpoint closure implementation:

``` swift
    static func endpointsClosure<T where T: TargetType, T: QuizAPIType>()(_ target: T) -> Endpoint<T> {
        var endpoint: Endpoint<T> = Endpoint<T>(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters, parameterEncoding: .JSON)
        if target.addToken {
            endpoint = endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Token \"\(TokenManager().token ?? "")\""])
        }
        return endpoint
    }
```
 I think I got it. I will confirm that, if everything ok, I will create a PR.
 Seems we are not completely done with that one :laughing: 
I reproduced the exactly same bugs, and this time, they are easy to reproduce (now I know why am I getting them :see_no_evil:)
- Create a provider by using a custom endpoint closure  / resolver
- In your closure / resolver, do nothing
- Send a request 

Something like: 

``` swift
let provider = MoyaProvider(endpointClosure: Networking.endpointsClosure(),
        requestClosure: Networking.endpointResolver(),
        manager: Networking.defaultAlamofireManager(),
        plugins: plugins)
}

static func endpointResolver<T where T: TargetType>() -> MoyaProvider<T>.RequestClosure {
    return { (endpoint, closure) in
        let request: NSMutableURLRequest = endpoint.urlRequest.mutableCopy() as! NSMutableURLRequest
        closure(request)
    }
}

static func endpointsClosure<T where T: TargetType, T: QuizAPIType>()(_ target: T) -> Endpoint<T> {
    var endpoint: Endpoint<T> = Endpoint<T>(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters, parameterEncoding: .JSON)
    }
    return endpoint
}
```

In my case, I had an error in my implementation (didn't need a closure / resolver in this context), but I do think that is some bugs case left.

Don't have the time to go deeper right now, but let me know if I can help!
 The remaining issues are the same as the first ones but with another implementation:
- Some requests never come back (Charles, a HTTP tracker, get a response 200), but Moya never call the completion. Apparently, that happens only with the GET method, the POST request is responding well
- The request duration has increased a lot: 58ms (6.1.3) -> 10s (6.2). These numbers are from Charles

The first time, I was getting these issues by using a headers without params (that one was fixed in #420), but I reproduce these case by setting an endpoint / resolver, but without doing nothing in (like in my above example). 

Sadly, I don't have time to look for a fix, but let me know if I can help!
 Think so, I mean, I reproduce it easily in my own project, so it shouldn't be hard to have it with the demo project.

Anyway, it's not that serious since we can easily has a workaround this time! 
 Hmm, I'm gonna make a try next week using the demo project. 
I will reopen it if I reproduce that issue again
 Sorry for the delay, but I try it again, and there is definitely a bug, when I'm using an `endpointClosure`, the request makes 10s to come back, without it, it takes 50ms.

The endpoint has no parameters, and no headers. It's like an empty endpoint. Here the closure:

```
    static func endpointsClosure<T where T: TargetType, T: QuizAPIType>()(_ target: T) -> Endpoint<T> {
        var endpoint: Endpoint<T> = Endpoint<T>(URL: url(target),
                                                sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
                                                method: target.method,
                                                parameters: target.parameters,
                                                parameterEncoding: .JSON)
        if target.addAuth {
            endpoint = endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Token \"\(UserManager().apiAuth ?? "")\""])
        }
        return endpoint
    }
```

When initialise my provider without endpoint, it's working as expected:

```
    static func newDefaultNetworking() -> Networking {
        let provider: APIProvider<QuizAPI> =  APIProvider(manager: Networking.defaultAlamofireManager(), plugins: plugins)
        return Networking(provider: provider)
    }
```

but when setting an endpoint, the request is really longer:

```
    static func newDefaultNetworking() -> Networking {
        let provider: APIProvider<QuizAPI> =  APIProvider(manager: Networking.defaultAlamofireManager(), endpointClosure: Networking.endpointsClosure(), plugins: plugins)
        return Networking(provider: provider)
    }
```

After some more checks, the issue is related to the `parameterEncoding`, if I removed it from the `endpoint`, it works well, with it, it's really slower.
 A workaround: `parameterEncoding: target.parameters?.count > 0 ? .JSON : .URL`
I will try to go deeper when I will have more time.
 Are you sure that `UserManager().apiAuth` isn't taking a long time to execute?
 Yes, it's working well for all the others request, with or without apiAuth. The only change is that they are taking parameters.
Moreover, if I don't set `parameterEncoding` to `.JSON`, it's working well.
 Just found my error, I was passing an empty dictionary `[:]` in parameters instead of `nil`. Is that normal it takes longer just because I set `parameterEncoding` to `.JSON` and passing an empty dictionary?
  To resolve ambiguousness due to duplicated declaration of `NoError` in ReactiveCocoa 4.0.0 and Result 1.0.2
 I think we should specify the dependency as `~> 4.0`, this will always pick the current RAC version.
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=d72e284d1092e65021b075fb40a9e6ef34407184) is `91.20%`

> Merging **#418** into **master** will not affect coverage as of [`d72e284`](https://codecov.io/github/Moya/Moya/commit/d72e284d1092e65021b075fb40a9e6ef34407184)

``` diff
@@            master   #418   diff @@
=====================================
  Files           13     13       
  Stmts          455    455       
  Branches         0      0       
  Methods                         
=====================================
  Hit            415    415       
  Partial          0      0       
  Missed          40     40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/40461d2d88a2dda2f1d486ae3de2ef26b5d065b2...d72e284d1092e65021b075fb40a9e6ef34407184) as of [`d72e284`](https://codecov.io/github/Moya/Moya/commit/d72e284d1092e65021b075fb40a9e6ef34407184)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=d72e284d1092e65021b075fb40a9e6ef34407184)
1. `+2.20%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=d72e284d1092e65021b075fb40a9e6ef34407184#84) 
2. `+1.10%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=d72e284d1092e65021b075fb40a9e6ef34407184#54) 
3. `+1.10%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=d72e284d1092e65021b075fb40a9e6ef34407184#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=d72e284d1092e65021b075fb40a9e6ef34407184)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 I think its good to do so. I'll fix it.
  I found how this working by debugging. There is no information in docs.
When I pass one parameter like id it just works

``` swift
    case DELETEApiActivitiesIdJson(let id):
      return "/api/activities/\(id)"
```

But when I pass multiple parameters it behaves like object

``` swift
    case PATCHApiActivitiesIdJson(let activity):
      return "/api/activities/\(activity.id)/"
```

A little bit confusing don't you think? Thanks.
 @sunshinejr thanks for quick reply. Yeah it helps. The problem though, is why id is not a tuple? I guess it is a language feature, I need to learn a bit more swift :)
 @sunshinejr got it, thank you very much for explanation!
  Fixed a typo in [Cartfile](https://github.com/Moya/Moya/blob/master/Cartfile);
Updated [Cartfile.resolved](https://github.com/Moya/Moya/blob/master/Cartfile.resolved) after doing a local `carthage update`;
 Not sure why, but Carthage still checks out older version of Moya. `/Carthage/Checkouts/Moya/Cartfile` is as [was before merge](https://github.com/Moya/Moya/blob/e80519dfc31582f78459ffe7a754440bb9beb79e/Cartfile).
Cartfile contents:

```
github "Moya/Moya"
```

Any clues? Is there some sort of cache? Are there any other places that need to be changed (like semantic version)?
Can't find anything at [their issues](https://github.com/Carthage/Carthage/issues?utf8=‚úì&q=is%3Aissue+old).
 :tada: 
 Like a charm :+1: 
  Moya.podspec already has RxSwift dependancy of ~> "2.0"
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=a8d9fba006ce5bcd0692ef4d7f9cdb91f0d099ec) is `91.20%`

> Merging **#414** into **master** will not affect coverage as of [`a8d9fba`](https://codecov.io/github/Moya/Moya/commit/a8d9fba006ce5bcd0692ef4d7f9cdb91f0d099ec)

``` diff
@@            master   #414   diff @@
=====================================
  Files           13     13       
  Stmts          455    455       
  Branches         0      0       
  Methods                         
=====================================
  Hit            415    415       
  Partial          0      0       
  Missed          40     40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/1a9da54f3d2616ed5174f9c4e95f561ed715df39...a8d9fba006ce5bcd0692ef4d7f9cdb91f0d099ec) as of [`a8d9fba`](https://codecov.io/github/Moya/Moya/commit/a8d9fba006ce5bcd0692ef4d7f9cdb91f0d099ec)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=a8d9fba006ce5bcd0692ef4d7f9cdb91f0d099ec)
1. `+2.20%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=a8d9fba006ce5bcd0692ef4d7f9cdb91f0d099ec#84) 
2. `+1.10%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=a8d9fba006ce5bcd0692ef4d7f9cdb91f0d099ec#54) 
3. `+1.10%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=a8d9fba006ce5bcd0692ef4d7f9cdb91f0d099ec#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=a8d9fba006ce5bcd0692ef4d7f9cdb91f0d099ec)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Apparently I had to also update [Cartfile.resolved](https://github.com/Moya/Moya/blob/master/Cartfile.resolved) + left a typo in [Cartfile](https://github.com/Moya/Moya/blob/master/Cartfile).
[This](https://github.com/Moya/Moya/pull/415) fixes both.
  Hi, I have few questions :grey_question: about the Provider.
- Is it only **1 Provider** per endpoint, and then per request ?
- If I have several request to do in my controller, **do I need several Provider** ? 

ü§î:thought_balloon: 
 @colinta Thanks for your answer, makes sens.
But how can I execute several request with only 1 provider ?
 I was also wondering, if I have to change my header, depending of the request, do I have to recreate the Provider ?
  Hello, I use Mayo to wrap my network in my swift app.
I want to connect with my own API.

I first created a test a User case : 

``` swift
public enum UserAPI {
    case Information
}

extension UserAPI: TargetType {
    public var baseURL: NSURL { return NSURL(string: "http://127.0.0.1:3000/user")!}

    public var path: String {
        switch self {
        case .Information:
            return "/"
        }
    }

    public var method: Moya.Method {
        return .GET
    }

    public var parameters: [String: AnyObject]? {
        return nil
    }

    public var sampleData: NSData {
        switch self {
        case .Information():
            return "{}".dataUsingEncoding(NSUTF8StringEncoding)!
        }
    }

    public func constructProvider(target: UserAPI) -> Endpoint<UserAPI> {
        let token = TokenAccess.sharedInstance.token!
        let endpoint: Endpoint<UserAPI> = Endpoint<UserAPI>(URL: "\(target.baseURL)\(target.path)", sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
        return endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Bearer \(token)"])
    }
}
```

Then the call : 

``` swift
let provider = MoyaProvider<UserAPI>()
provider.request(UserAPI.Information) { (result) -> () in
    print("result request : \(result)")
}
```

And then the result : 

```
result request : .Failure(Underlying(Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLKey=http://127.0.0.1:3000/user/, NSLocalizedDescription=cancelled, NSErrorFailingURLStringKey=http://127.0.0.1:3000/user/}))
```

The base URL is okay. I am making a transition, in a network abstraction, I used **Alamofire** previously, and it worked well. I am trying to move my code to **Moya**.

Thanks in advance for your help. :+1: 
 If you are using rails. Try start rails with -b 0.0.0.0 like "rails s -b 0.0.0.0". Thats way it will be accessible. 999 errors is indeed confusing.
 @wattson12 it was the problem. Thanks for you help !
 Thank you @wattson12 !
 @remirobert can you show a snippet of your solution provided by @wattson12 please?  
 @sunshinejr so simple and so common i didn't think about it...thank's! 
 But why retaining the Provider would solve this problem? 
 @PhilCai1993 because you need to keep a reference on it.
 @remirobert What I don't understand is that Why should I keep a reference on it? If I don't, will the provider be released outside the scope(For example, I make the request in viewDidLoad, and don't keep a reference.)? I didn't inspect the implementation of Moya...
 @ashfurrow Shouldn't this crash however? It is very hard to trace these kind of bugs.
 I ran into this issue too after following the [Basic Setup](https://github.com/Moya/Moya/blob/master/docs/Examples/Basic.md) and not retaining the provider.  Happy to put in a PR to the docs to highlight how you need the retain (as I reckon I might not be the first üòâ ).

ps: great library!  Thanks @ashfurrow üòÑ 
 @tomj  because you need to keep a reference on it.
 @remirobert - you bet! üòÑ 

I just wanted to point out that the Basic Setup docs don't 100% allude to the fact that you need to keep a reference to the provider, which I'm guessing is what's responsible for (at least some of) the responses to the issue above.
    Tiny but I got a bit confused while reading this.
 Joined! Thanks :)
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=8637f086f7cfa225629c77c45376e1b7030f1c7d) is `91.20%`

> Merging **#409** into **master** will decrease coverage by **-0.23%** as of [`8637f08`](https://codecov.io/github/Moya/Moya/commit/8637f086f7cfa225629c77c45376e1b7030f1c7d)

``` diff
@@            master   #409   diff @@
=====================================
  Files           13     13       
  Stmts          467    455    -12
  Branches         0      0       
  Methods                         
=====================================
- Hit            427    415    -12
  Partial          0      0       
  Missed          40     40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/39b5489d9956718fdf8da29323829bde583f93ea...8637f086f7cfa225629c77c45376e1b7030f1c7d) as of [`8637f08`](https://codecov.io/github/Moya/Moya/commit/8637f086f7cfa225629c77c45376e1b7030f1c7d)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=8637f086f7cfa225629c77c45376e1b7030f1c7d)
1. `+2.20%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=8637f086f7cfa225629c77c45376e1b7030f1c7d#84) 
2. `+1.10%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=8637f086f7cfa225629c77c45376e1b7030f1c7d#54) 
3. `+1.10%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=8637f086f7cfa225629c77c45376e1b7030f1c7d#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=8637f086f7cfa225629c77c45376e1b7030f1c7d)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  First of, `Moya` looks great. At least most of it does. But the one single `enum` bugs me a bit. You have to define a single `API endpoint` in multiple parts of the same file. When the `API` grows, the `enum` gets really big since it is hard to divide it into multiple files. 

I've made some changes in my [fork of Moya](https://github.com/Matthijn/Moya), and perhaps this idea can be discussed here and maybe (when the idea is liked) it can be integrated in `Moya` itself. But it would break existing code using `enums` in the way I've implemented it currently.

The benefits of using `structs` are:
- You can easily divide your `API` definition accros multiple files
- All information regarding one single `API Endpoint` is contained within one place

Also I've made some extra changes which makes using the structs even nicer. 
- Automatic generating of the `parameters` in the request based on the structure of the `struct` using `reflection` (optional, you can still define your own parameters if you choose so)
- Easy support for urls with formatting like: /user/{id}

I've got a full [README.md](https://github.com/Matthijn/Moya) on the Github page with some example code. I'd love to hear all of your opinions on it. 

The biggest change in regard to the original version of `Moya` is the addition of the [Smoya.swift](https://github.com/Matthijn/Moya/blob/master/Source/Smoya.swift) file. Which is short for `StructuredMoya`. In there some `protocols` and `extensions` have been defined.

Next to that most of `Moya` remains the same. But there are some changes regarding `generics` to hook up the right `enum`. This has been removed and it accepts any `TargetType` now.

Also the `baseURL` has been removed from the `TargetType` and you must add that in your own `endpoint`. (The default `endpoint` has been removed). Since defining the `baseURL` in every `struct` seemed odd to me.

Again, I'd love to get some feedback. And am curious if people like this approach.
 Yeah, I can understand that it would be quite a breaking change to move from the current enum structure to using structs. Nice to hear that you like the idea. Love to hear what you have to say when you've taken a closer look. 

And yeah, feel free to borrow whatever you like. Maybe a separate project is an idea. But perhaps we can think of something else. 
 @colinta That is a nice approach to the baseUrl. But since it is already part of the enum itself that would be kinda duplicate if you use the enum. 

Also, In my current implementation the enum does not work anymore. Since with the enum you use generics to determine which enum cases can be passed. E.g: `let service = new MoyaService<MyServiceEnum>();` and then `service.request(.somethingInTheEnum())`.

In my Struct based solution there is no generic MoyaService. You just create an instance like: `let service = MoyaService();` and then you can pass _any_ `TargetType` into the `.request()` method. 

---

You could make a "StructMoyaService" which is not generic and an "EnumMoyaService" which is. Where they both inherit from (a non generic) "MoyaService" which will contain the bulk of the code which can be shared (which is most). But I don't think that is the way you want to go. 

But I can't think of any way from the top of my head to support both in an elegant way.

@sunshinejr Thanks!
 @watson You could of course use container structs to group certain targets together if you so choose.
 I think I would love to see this kind of implementation too. For me personally, it makes it possible to fix my issue [#383](https://github.com/Moya/Moya/issues/383).

To make it more flexible, I mis an option to add other parameters to the struct which will not be automatically included in the query because of the reflection implementation. 
 @AvdLee If you don't add the `ReflectiveParameters` protocol extension to your Struct you can of course still define your own `parameters` variable within your struct, fine tuning on how you would like it to behave for that request.

---

Or maybe you meant that you would like to have some `properties` within the struct for other uses than generating the `parameters` then something like a `parameterKeys` could be introduced. That way you will have something like:

``` swift
struct Foo: TargetType, ReflectiveParameters
{
    // The required properties for TargetType
    let path = "/foo"
    let method = Moya.Method.GET
    let sampleData = NSData();

    // Defines which properties must be added to the parameters through reflection
    let parameterKeys = ["baz", "bar"] // And for example when this is [ ] (default value) all properties will be added.

    // Will be added to the parameters
    var baz: String
    var bar: String

    // Will never be added
    var bak: Int
}
```

Instead of `whitelisting` `blacklisting` could be a possibility as wel.
 Can't wait for something like this to be added to Moya, or to see the project switch to something like this in a new major release. The monolith enum and the scattered stuff never made sense to me either, it just felt... 'bad' and that's a shame, because Moya is really nice and for the rest it actually tries to prevent ugly boilerplate code. I'd love to group relevant (self-containing) endpoint/target structs into .swift source files.

The use of Swift reflection is very interesting as well.

_subscribes to notifications for this issue_ . :shipit: 
 Its been interesting watching this discussion. As @colinta and I work on the same project that uses Moya I haven't commented because we share a similar love for enums and I share his perspective. The possibility of the project ditching them concerns me though so I figured I better speak up. 

The `enum` pattern introduced to us by Moya very early on has helped guide a lot of our decisions in our large and mature swift app. We love using enums for just about everything we can. They express a large (and complete) set of information in a very concise package. 

However, we ran into the same issue that @ashfurrow mentions, they don't scale very well when there are a lot of endpoints. We haven't had a great solve until now. I like @colinta's `struct` in an `enum` suggestion. Its something that works within the existing Moya paradigm and may help solve the scale issue. I see a refactor to `ElloAPI` in the near future. :metal: 
 I adopted Moya for a new project back in November, and quickly found `enums` to not scale very well, also. 

I came up with a solution similar to what @colinta and others have shared, with a `struct` wrapping a single (internal) `TargetType` adopter. I also extend the `struct` as a `SignalTypeProducer`, with magnificent results!

Here is an example taken from my playground file:

``` swift
XCPlaygroundPage.currentPage.needsIndefiniteExecution = true

// http://jsonplaceholder.typicode.com
CurrentAPIHost = APIHost(serverContext: .PlaceholderTest)
JSONRequest("users")
    .startWithNext {
        print($0) // Individually prints each 'user' JSON object
}

// https://api.guildwars2.com/v2
CurrentAPIHost = APIHost(serverContext: .GuildWars2)
JSONRequest("colors", parameters: ["ids":"all"])
    .startWithNext {
        print($0)  // Individually prints each 'color' JSON object
}
```

<hr/>

`JSONRequest` looks like this:

``` swift
public func JSONRequest<T>(endpointPath: EndpointPath, method: ReactiveMoya.Method = .GET, parameters: [String:AnyObject]? = nil) -> JSONTarget<T> {
    let endpoint = JSONEndpoint.Request(endpointPath: endpointPath, method: method, parameters: parameters)
    return JSONTarget(endpoint: endpoint)
}
```

<hr/>

EDIT: `EndpointPath` is this:

``` swift
// MARK: -
// MARK: Endpoint Path
// MARK: -
public protocol EndpointPath {
    var endpointPath: String { get }
}

public extension RawRepresentable where RawValue == String {
    public var endpointPath: String {
        return self.rawValue
    }
}

public extension String {
    public var endpointPath: String {
        return self
    }
}
extension String: EndpointPath { }
```
 I had a scheduling conflict, and so I appreciate the summary, @ashfurrow. 

Having missed my opportunity to participate, I understand things are in motion; however, I'd still like to share my `struct` [solution (KevinVitale/Shelley)](https://github.com/KevinVitale/Shelley/tree/master/Shelley). It's promising to read so much of what motivated me reflected in the meeting notes, and as such, I'm looking forward to seeing what comes of it.

Thanks for such a great project, all.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=a0c8ac40033fcb9d72f31faf733162f98fddf8ea) is `91.37%`

> Merging **#406** into **master** will increase coverage by **+0.05%** as of [`a0c8ac4`](https://codecov.io/github/Moya/Moya/commit/a0c8ac40033fcb9d72f31faf733162f98fddf8ea)

``` diff
@@            master    #406   diff @@
======================================
  Files           13      13       
  Stmts          461     464     +3
  Branches         0       0       
  Methods                          
======================================
+ Hit            421     424     +3
  Partial          0       0       
  Missed          40      40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/90de795ecd62260d0cecea6014c45432ffa4665b...a0c8ac40033fcb9d72f31faf733162f98fddf8ea) as of [`a0c8ac4`](https://codecov.io/github/Moya/Moya/commit/a0c8ac40033fcb9d72f31faf733162f98fddf8ea)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=a0c8ac40033fcb9d72f31faf733162f98fddf8ea)
1. `+2.16%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=a0c8ac40033fcb9d72f31faf733162f98fddf8ea#84) 
2. `+1.08%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=a0c8ac40033fcb9d72f31faf733162f98fddf8ea#54) 
3. `+1.08%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=a0c8ac40033fcb9d72f31faf733162f98fddf8ea#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=a0c8ac40033fcb9d72f31faf733162f98fddf8ea)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  The `stringByAddingPercentEncodingWithAllowedCharacters` method of `String` returns an optional, thus the compilation fails using the provided example. Changed the `URLEscapedString` property to also return an optional.
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=15030a21f382fbfc99cc925d10521878a2237118) is `91.32%`

> Merging **#405** into **master** will decrease coverage by **-0.40%** as of [`15030a2`](https://codecov.io/github/Moya/Moya/commit/15030a21f382fbfc99cc925d10521878a2237118)

``` diff
@@            master    #405   diff @@
======================================
  Files           13      13       
  Stmts          459     461     +2
  Branches         0       0       
  Methods                          
======================================
  Hit            421     421       
  Partial          0       0       
- Missed          38      40     +2
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/4a834fcc96ed239d1f8da621c0ca4d16162d0a9d...15030a21f382fbfc99cc925d10521878a2237118) as of [`15030a2`](https://codecov.io/github/Moya/Moya/commit/15030a21f382fbfc99cc925d10521878a2237118)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=15030a21f382fbfc99cc925d10521878a2237118)
1. `+2.17%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=15030a21f382fbfc99cc925d10521878a2237118#84) 
2. `+1.08%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=15030a21f382fbfc99cc925d10521878a2237118#54) 
3. `+1.08%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=15030a21f382fbfc99cc925d10521878a2237118#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=15030a21f382fbfc99cc925d10521878a2237118)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Updated to match the Demo.
  POST requests were forced to insert parameters in the body and did not have the option to encode them in the query string.
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=62e90a7cb91dcd8855f3334bb16020548c9950fe) is `91.37%`

> Merging **#404** into **master** will decrease coverage by **-0.35%** as of [`62e90a7`](https://codecov.io/github/Moya/Moya/commit/62e90a7cb91dcd8855f3334bb16020548c9950fe)

``` diff
@@            master    #404   diff @@
======================================
  Files           13      13       
  Stmts          459     464     +5
  Branches         0       0       
  Methods                          
======================================
+ Hit            421     424     +3
  Partial          0       0       
- Missed          38      40     +2
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/4a834fcc96ed239d1f8da621c0ca4d16162d0a9d...62e90a7cb91dcd8855f3334bb16020548c9950fe) as of [`62e90a7`](https://codecov.io/github/Moya/Moya/commit/62e90a7cb91dcd8855f3334bb16020548c9950fe)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=62e90a7cb91dcd8855f3334bb16020548c9950fe)
1. `+2.16%` via [...ource/Response.swift#84...93](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=62e90a7cb91dcd8855f3334bb16020548c9950fe#84) 
2. `+1.08%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=62e90a7cb91dcd8855f3334bb16020548c9950fe#54) 
3. `+1.08%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=62e90a7cb91dcd8855f3334bb16020548c9950fe#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=62e90a7cb91dcd8855f3334bb16020548c9950fe)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Cheers üçª! On in üëç
  I have an endPoint:

``` swift
var endpointClosure = { (target: MyCustomApi) -> Endpoint<MyCustomApi> in
    let endpoint: Endpoint<MyCustomApi> = Endpoint<MyCustomApi>(
        URL: url(target),
        sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
        method: target.method,
        parameters: target.parameters
    )
    switch target {
    case .Person(let json):
        //How to add HTTPBody here?  endpoint.urlRequest is not mutable, so i can't change the request.
    default:
        return endpoint
    }
}

enum NextVisitApi {
    case Person(someJSON: JSON)
}
```
 This is correct?

```
var endpointClosure = { (target: NextVisitApi) -> Endpoint<NextVisitApi> in
    let endpoint: Endpoint<NextVisitApi> = Endpoint<NextVisitApi>(
        URL: url(target),
        sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
        method: target.method,
        parameters: target.parameters
    )
    switch target {
    case .VisitsPUT:
        return endpoint.endpointByAddingParameterEncoding(.URL).endpointByAddingHTTPHeaderFields(["Content-Type":"application/x-www-form-urlencoded; charset=UTF-8"])
    default:
        return endPointWithAuthHeader(endpoint)
    }
}
```
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=9ac593d7068f4f584f8363f40af73cf140052fa8) is `91.72%`

> Merging **#401** into **master** will increase coverage by **+0.56%** as of [`9ac593d`](https://codecov.io/github/Moya/Moya/commit/9ac593d7068f4f584f8363f40af73cf140052fa8)

``` diff
@@            master    #401   diff @@
======================================
  Files           13      13       
  Stmts          453     459     +6
  Branches         0       0       
  Methods                          
======================================
+ Hit            413     421     +8
  Partial          0       0       
+ Missed          40      38     -2
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/0d431362e67534788bd3a8f85d78937956534759...9ac593d7068f4f584f8363f40af73cf140052fa8) as of [`9ac593d`](https://codecov.io/github/Moya/Moya/commit/9ac593d7068f4f584f8363f40af73cf140052fa8)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=9ac593d7068f4f584f8363f40af73cf140052fa8)
1. `+1.30%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=9ac593d7068f4f584f8363f40af73cf140052fa8#76) 
2. `+1.09%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=9ac593d7068f4f584f8363f40af73cf140052fa8#54) 
3. `+1.09%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=9ac593d7068f4f584f8363f40af73cf140052fa8#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=9ac593d7068f4f584f8363f40af73cf140052fa8)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  How can Moya apply http level cache ?
 In Alamofire page : "Caching is handled on the system framework level by NSURLCache."
https://github.com/Moya/Moya/tree/master/docs : "You should not have to reference Alamofire directly."
Can I apply NSURLCache in Moya directly ?
(Thank wattson12)
  I couldn't understand network layer in the examples of moya ([here](https://github.com/Moya/Moya/blob/6a437938c4ac3ae1d6ffce161cfb1fb3c78c67b9/docs/Examples.md) )

I tried to create my own network layer but from example, 

```
struct Network {
    static let provider = MoyaProvider(endpointClosure: endpointClosure)

    static func request(
        target: Github,
        success successCallback: (JSON) -> Void,
        error errorCallback: (statusCode: Int) -> Void,
        failure failureCallback: (Moya.Error) -> Void
    ) {
        provider.request(target) { result in
            switch result {
            case let .Success(response):
                do {
                    try response.filterSuccessfulStatusCodes()
                    let json = try JSON(response.mapJSON())
                    successCallback(json)
                }
                catch error {
                    errorCallback(error)
                }
            case let .Failure(error):
                if target.shouldRetry {
                    retryWhenReachable(target, successCallback, errorCallback, failureCallback)
                }
                else {
                    failureCallback(error)
                }
            }
        }
    }
}

// usage:
Network.request(.Zen, success: { zen in
    showMessage(zen)
}, error: { err in
    showError(err)
}, failure: { _ in
    // oh well, no network apparently
})
```

I use object mapper to map objects and Moya_ObjectMapper with using moya. I use moya like this, 

```
ApiaryProvider.request(Apiary.Home) { (result) -> () in

            var success = true
            var message = "Unable to fetch results"



            switch result {
            case let .Success(response):

                do {
                    var h : HomeRoot = try! response.mapObjectMapper()
                    self.home = h
                    self.loadData()
                    break;

                }catch{

                }

            case let .Failure(error):
                guard let error = error as? CustomStringConvertible else {
                    break
                }
                message = error.description
                success = false
            }
        }
```

But I'm using this code block for every different request. So my question is how can I improve this to add extra network layer in every request? or what is the best practice?  

Thanks in advance.. 
 Yes you're right I'm using Moya-ObjectMapper but what I couldn't do is creating a network layer to gather all responses in one place. So as you say I need a Network struct on top of Moya, but I have problems with generic parameters T. 
My unfinished network layer is [here](https://gist.github.com/mertnesvat/c98d65c4d9c357ca1ade) problem is when I try to map object returns empty. 
 @sunshinejr thanks for your answer but I couldn't find mapObject() method? Which library has it? 
 @sunshinejr @ashfurrow  your're life saver many thanks :) I wasn't aware of the new updates at Moya-ObjectMapper, I implemented it when it was **1.0.0** version and now it is *_1.1.2 *_so I typed pod update and its working now. :+1:   
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=53c66d46f3b3a42fc25d6bd8a1b1735dee9c9098) is `91.16%`

> Merging **#398** into **master** will not affect coverage as of [`53c66d4`](https://codecov.io/github/Moya/Moya/commit/53c66d46f3b3a42fc25d6bd8a1b1735dee9c9098)

``` diff
@@            master    #398   diff @@
======================================
  Files           13      13       
  Stmts          453     453       
  Branches         0       0       
  Methods          0               
======================================
  Hit            413     413       
  Partial          0       0       
  Missed          40      40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/86b03a0b348b97af3a9d32cb98a76929cfa46886...53c66d46f3b3a42fc25d6bd8a1b1735dee9c9098) as of [`53c66d4`](https://codecov.io/github/Moya/Moya/commit/53c66d46f3b3a42fc25d6bd8a1b1735dee9c9098)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=53c66d46f3b3a42fc25d6bd8a1b1735dee9c9098)
1. `+1.33%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=53c66d46f3b3a42fc25d6bd8a1b1735dee9c9098#76) 
2. `+1.11%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=53c66d46f3b3a42fc25d6bd8a1b1735dee9c9098#54) 
3. `+1.11%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=53c66d46f3b3a42fc25d6bd8a1b1735dee9c9098#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=53c66d46f3b3a42fc25d6bd8a1b1735dee9c9098)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=b24960610db536e0586e901d1aaf793bcfe5886f) is `91.16%`

> Merging **#396** into **master** will not affect coverage as of [`b249606`](https://codecov.io/github/Moya/Moya/commit/b24960610db536e0586e901d1aaf793bcfe5886f)

``` diff
@@            master    #396   diff @@
======================================
  Files           13      13       
  Stmts          453     453       
  Branches         0       0       
  Methods                          
======================================
  Hit            413     413       
  Partial          0       0       
  Missed          40      40       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/633741f230726df7fe1d25d6d082cc3b1abb0aa9...b24960610db536e0586e901d1aaf793bcfe5886f) as of [`b249606`](https://codecov.io/github/Moya/Moya/commit/b24960610db536e0586e901d1aaf793bcfe5886f)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=b24960610db536e0586e901d1aaf793bcfe5886f)
1. `+1.33%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=b24960610db536e0586e901d1aaf793bcfe5886f#76) 
2. `+1.11%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=b24960610db536e0586e901d1aaf793bcfe5886f#54) 
3. `+1.11%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=b24960610db536e0586e901d1aaf793bcfe5886f#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=b24960610db536e0586e901d1aaf793bcfe5886f)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
    Adding response data formatter for NetworkLoggerPlugin, also changed print to work line by line 

discussion at #392 
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=2910a073953bcf0cbb3453afc4e7ecd402d68083) is `91.16%`

> Merging **#394** into **master** will decrease coverage by **-0.31%** as of [`2910a07`](https://codecov.io/github/Moya/Moya/commit/2910a073953bcf0cbb3453afc4e7ecd402d68083)

``` diff
@@            master    #394   diff @@
======================================
  Files           13      13       
  Stmts          446     453     +7
  Branches         0       0       
  Methods                          
======================================
+ Hit            408     413     +5
  Partial          0       0       
- Missed          38      40     +2
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/bd4f36bd958eaadd01d5266db61b8705d5e02447...2910a073953bcf0cbb3453afc4e7ecd402d68083) as of [`2910a07`](https://codecov.io/github/Moya/Moya/commit/2910a073953bcf0cbb3453afc4e7ecd402d68083)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=2910a073953bcf0cbb3453afc4e7ecd402d68083)
1. `+1.33%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=2910a073953bcf0cbb3453afc4e7ecd402d68083#76) 
2. `+1.11%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=2910a073953bcf0cbb3453afc4e7ecd402d68083#54) 
3. `+1.11%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=2910a073953bcf0cbb3453afc4e7ecd402d68083#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=2910a073953bcf0cbb3453afc4e7ecd402d68083)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  As I mention at the end of the discussion of  #391 , I found that the [ReactiveMoya ReadMe example](https://github.com/Moya/Moya#reactivecocoa) doesn't work. The Demo project is only using [Moya framework](https://github.com/Moya/Moya/blob/master/Demo/Demo/GitHubAPI.swift#L2) and the [Unit Test](https://github.com/Moya/Moya/blob/master/Demo/Tests/ReactiveCocoaMoyaProviderTests.swift) doesn't test "start" method. I noticed that they are all "startWithSomething". So I guess maybe the ReadMe is outdated?
 @yinanfang Can you post an example of what you're trying to do? The example should be accurate.
 @justinmakaila Here's a screen shot of what I'm trying to do. I've correctly set up the Moya framework and the first example is working. However, when I'm trying to use the ReactiveCocoa extension, it doesn't work and gives an error. 
![gcappdependencies_swift_ _edited](https://cloud.githubusercontent.com/assets/4115566/12739032/bfdde066-c933-11e5-889a-bd7f8601a7e3.png)
 I would assume that your provider is not of type `ReactiveCocoaMoyaProvider`
 @petester42 Oh! That's it! Thank you so much. I felt like Swift's error message is sometimes irrelevant to the actually problem. If the error message were to be something like "there's no such method as start" then I would probably think about I'm inheriting the wrong type. Or maybe it was just that I misunderstood Swift's error message.
 The error message is correct. The problem is that he normal provider and the reactive provider have the same `request` method. The code up to `start` would be correct for the normal provider so that's why you don't get a type mismatch error. 
 Thanks for explanation! I'm new to Swift and I think I misunderstood its error message!
  I'd be happy to help on this one. I took a quick look and first thoughts are to add an optional response data formatter function to the logger (called only in verbose mode). This way a user can format data however they want, maybe with the demo updated to include a formatter closure 

In testing I was using a quick and dirty data -> NSJSONSerialiazation object -> NSJSONSerialiazation  pretty printed data function

The other problem is that even formatted strings are printed without formatting when printing as part of the array, so the output function will need to print item by item rather that array as a whole (probably only in verbose mode since it increases the console real estate used)

I can open up a pull request if that sounds good
 Cool, will put something up later today.

To give an example this is some simple JSON as a string returned by NSJSONSerialiazation with .PrettyPrinted as an option:

```
{
  "id" : 1,
  "name" : "first object"
}
```

And this is the same object when printed inside an array (i.e. the way response components are printed in NetworkLoggerPlugin):

```
["{\n  \"id\" : 1,\n  \"name\" : \"first object\"\n}"]
```
 I tried printing the `logNetworkResponse` array item by item, and overall its an improvement (it breaks up headers and becomes a lot more readable), but the response JSON component is still unformatted (or i guess more accurately it matches the formatting returned from the server)
  I've got Moya up and running. But I notice that there's some problem with the newline of NetworkLoggerPlugin. Would you be able to fix the default separator and terminator?
Or could you provide a working example about how to modify the existing logger? 
![image](https://cloud.githubusercontent.com/assets/4115566/12688539/e1bb78b0-c6a4-11e5-882d-412c71ecbbb0.png)
 @ashfurrow Thanks for the quick response! Yes, I just want to log JSON in this case. I saw that Alamofire let me log out a nicely formatted JSON. Maybe you can borrow their formatter? I'm not sure how their's formatter works though. 
Also, It would be great if Moya can let the user specify which specific request their want to log out. The current plugin will show verbose log output for all requests. Once the app grows, the log may not be readable.
 I think that solution is great for requests of some TargetType but not individual requests. What I wanted is to separate the Moya request and response closure like Alamofire does so that we can log out only one outgoing request or one incoming response. I just want to clarify my thoughts. I know that's not the most important feature now. I can just use search and find to dig through the logger. 

By the way, I just tried the ReactiveCocoa example on the ReadMe and it doesn't work. Xcode points to my target and says "... has no member MyTarget". Maybe you forgot the update the ReactiveCocoa part of the ReadMe? Is there an working example somewhere?
https://github.com/Moya/Moya#reactivecocoa
 Thanks! @ashfurrow @sunshinejr 
 Hi, guys, I recently updated to swift 3, and now the `JSONResponseDataFormatter` prints data with brake line characters and quotes are escaped. Before swift 3, it was OK. Any idea how to solve this?
  Suppose I want to do this: 

``` swift
provider.request(.UserProfile(1)) { result in
    // do something with the result
}
provider.request(.UserProfile(2)) { result in
    // do something with the result
}
provider.request(.UserProfile(3)) { result in
    // do something with the result
}
```

Suppose further that I'd like these 3 requests to be coalesced into one request: `/UserProfile?ids=[1,2,3]` perhaps based on the runloop; i.e. if I make 4 requests to the UserProfile route in one turn of the loop, coalesce them into one request.
is this possible? In the Web Version of the App that I'm writing, i'm able to accomplish this with Ember data (another Network abstraction layer) 
  Adding another mapping community extension to the readme: this time for [Argo](https://github.com/thoughtbot/Argo)
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=48b14022e43c720dca6de6087e5c9a87008b2f21) is `91.47%`

> Merging **#389** into **master** will not affect coverage as of [`48b1402`](https://codecov.io/github/Moya/Moya/commit/48b14022e43c720dca6de6087e5c9a87008b2f21)

``` diff
@@            master    #389   diff @@
======================================
  Files           13      13       
  Stmts          446     446       
  Branches         0       0       
  Methods                          
======================================
  Hit            408     408       
  Partial          0       0       
  Missed          38      38       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/6a437938c4ac3ae1d6ffce161cfb1fb3c78c67b9...48b14022e43c720dca6de6087e5c9a87008b2f21) as of [`48b1402`](https://codecov.io/github/Moya/Moya/commit/48b14022e43c720dca6de6087e5c9a87008b2f21)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=48b14022e43c720dca6de6087e5c9a87008b2f21)
1. `+1.35%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=48b14022e43c720dca6de6087e5c9a87008b2f21#76) 
2. `+1.13%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=48b14022e43c720dca6de6087e5c9a87008b2f21#54) 
3. `+1.13%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=48b14022e43c720dca6de6087e5c9a87008b2f21#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=48b14022e43c720dca6de6087e5c9a87008b2f21)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 No worries, thanks for merging
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=666bac660a814bf5fcd5dd3d367652fae3fdd9ce) is `91.47%`

> Merging **#388** into **master** will not affect coverage as of [`666bac6`](https://codecov.io/github/Moya/Moya/commit/666bac660a814bf5fcd5dd3d367652fae3fdd9ce)

``` diff
@@            master    #388   diff @@
======================================
  Files           13      13       
  Stmts          446     446       
  Branches         0       0       
  Methods          0               
======================================
  Hit            408     408       
  Partial          0       0       
  Missed          38      38       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/a78b32e78c3db401c1038e3e819fca6105d9e830...666bac660a814bf5fcd5dd3d367652fae3fdd9ce) as of [`666bac6`](https://codecov.io/github/Moya/Moya/commit/666bac660a814bf5fcd5dd3d367652fae3fdd9ce)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=666bac660a814bf5fcd5dd3d367652fae3fdd9ce)
1. `+1.35%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=666bac660a814bf5fcd5dd3d367652fae3fdd9ce#76) 
2. `+1.13%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=666bac660a814bf5fcd5dd3d367652fae3fdd9ce#54) 
3. `+1.13%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=666bac660a814bf5fcd5dd3d367652fae3fdd9ce#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=666bac660a814bf5fcd5dd3d367652fae3fdd9ce)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 @colinta @ashfurrow Thank you so much for the update! I just came across another problem. I got `kCFStreamErrorDomainSSL, -9843` error. I found that this happened because the Apple ATS which doesn't allows insecure HTTPS call. Alamofire suggested an solution here: https://github.com/Alamofire/Alamofire#app-transport-security & https://github.com/Alamofire/Alamofire/issues/977#issuecomment-167925391 
Do you know how I can configure the network manager in Moya similarly? Should I open another issue for this?
 Oops... I just found the documentation here: https://github.com/Moya/Moya/blob/master/docs/Providers.md#advanced-use Sorry about that. It's not a very smart question. 
  Fixes #386
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=831cc03a7d7045be6c50f9d82061681b4d326721) is `91.47%`

> Merging **#387** into **master** will not affect coverage as of [`831cc03`](https://codecov.io/github/Moya/Moya/commit/831cc03a7d7045be6c50f9d82061681b4d326721)

``` diff
@@            master    #387   diff @@
======================================
  Files           13      13       
  Stmts          446     446       
  Branches         0       0       
  Methods          0               
======================================
  Hit            408     408       
  Partial          0       0       
  Missed          38      38       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/a78b32e78c3db401c1038e3e819fca6105d9e830...831cc03a7d7045be6c50f9d82061681b4d326721) as of [`831cc03`](https://codecov.io/github/Moya/Moya/commit/831cc03a7d7045be6c50f9d82061681b4d326721)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=831cc03a7d7045be6c50f9d82061681b4d326721)
1. `+1.35%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=831cc03a7d7045be6c50f9d82061681b4d326721#76) 
2. `+1.13%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=831cc03a7d7045be6c50f9d82061681b4d326721#54) 
3. `+1.13%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=831cc03a7d7045be6c50f9d82061681b4d326721#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=831cc03a7d7045be6c50f9d82061681b4d326721)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Cool, thanks! Since I have never published a cocoapod before: Does this change require a new release to cocoapods?
 It works, thanks a lot!
  You state that Moya `6.1.1` has obtained compatibility with RxSwift `2.1.x`, however, the subspec still states it needs `~> 2.0.0`
 `~> 2.0` :+1:
 We use hard versioning, so that's not really an option for us. I'll submit a PR.
 That's correct. But allowing 2.x might be a little too agressive.
 It's fine by me. I just wanted to allow for the Moya community to test new 2.x features before officially supporting them.
  I'm struggling to get started because it seems like Result framework updated their syntax and the ReadMe example no longer works. So I was using the following code from the ReadMe but I got this error: "contextual type for closure argument list expects 1 argument but 4 were specified"

```
provider.request(.Test) { (data, statusCode, response, error) in
      if let data = data {
        // do something with the data
      }
    }
```
 No problem. Thanks for point out! 
Do we have to use try and catch? I was usually told not to use try and catch in ObjC but now I see many try and catch statements in the swift, for example in this demo code. Is it a different code style or just a lazy way for making a simple demo app?
 That makes sense! Thank you for the explanation. Moya is a great framework. Thank you for maintaining this!
  I'm struggling with a solution for our internal networking library.
We're using Moya ReactiveCocoa, together with [Moya-SwiftyJSONMapper](https://github.com/AvdLee/Moya-SwiftyJSONMapper), which makes it possible create calls like this:

``` swift
RCStubbedProvider.request(ExampleAPI.GetObject).mapObject(GetResponse).on(failed: { (error) -> () in
    print(error)
}) { (response) -> () in
    print(response)
}.start()
```

This makes mapping to models quite easy, but the disadvantage is that we have to know the type for mapping on the implementation level.

We could solve this by creating wrappers for each defined method, like this:

``` swift
extension ExampleAPI {
    static func getObjectCall() -> SignalProducer<GetResponse, Moya.Error> {
        return RCStubbedProvider.request(ExampleAPI.GetObject).mapObject(GetResponse)
    }
}
```

This makes it clear on implementation level that the method will return a GetResponse object.

I'm looking for a generic way to define this within the Enum, which seems to be impossible (based on my Swift knowledge). That's why I'm here to open this issue, maybe you guys have an idea for this.

My "everything is possible" way of doing this would be to add an extra requirement to the `TargetType` protocol:

``` swift
var responseType:ALSwiftyJSONAble { get }
```

Where this part would automatically return a `GetResponse` model:

``` swift
RCStubbedProvider.request(ExampleAPI.GetObject)
```

Curious about your ideas guys!
 Yeah, but the problem remains, as I still have to know the model type on implementation level (User in your example).

In my ViewModel / ViewController etc. I simply want to call `Provider.request(.Profile)` which then should return a `SignalProducer<User, Moya.Error>`.
 Yep. I was gonna suggest something like that. 
 Alright, interesting. I've implemented your suggestion and encountered some issues. You can check the example project here:
https://github.com/AvdLee/Moya-SwiftyJSONMapper/tree/ObjectMapper_from_enum

Problems encountered:
<img width="783" alt="screen shot 2016-01-29 at 20 52 11" src="https://cloud.githubusercontent.com/assets/4329185/12686712/9c85474a-c6cb-11e5-8f53-97335b0a311a.png">

After rewriting, the project compiled:

``` swift
// Works but has al the mapping logic in it, I don't want that!
func requestType<T:ALSwiftyJSONAble>(target: ExampleAPI) -> SignalProducer<T, Moya.Error> {
    return RCStubbedProvider.request(target).flatMap(FlattenStrategy.Latest, transform: { (response) -> SignalProducer<T, Moya.Error> in
        do {
            let jsonObject = try response.mapJSON()

            guard let mappedObject = T(jsonData: JSON(jsonObject)) else {
                throw Error.JSONMapping(response)
            }

            return SignalProducer(value: mappedObject)
        } catch let error {
            return SignalProducer(error: Moya.Error.Underlying(error))
        }
    })
}
```

However, on the implementation level, where I want this to work:

``` swift
    func exampleRequestDirectMapping(){
        requestType(ExampleAPI.GetObject).on { (object) -> () in
            print("Example origin \(object.origin)")
        }.start()
    }
```

It still doesn't. When I explicit cast to the given return type, it does work:

``` swift
    func exampleRequestDirectMapping(){
        // This instead works, with type definition
        let producer:SignalProducer<GetResponse, Moya.Error> = requestType(ExampleAPI.GetObject).on { (object) -> () in
            print("Example origin \(object.origin)")
        }
        producer.start()
    }
```

I would suggest to open the Example project yourself and see the problem in action. Hoping we can find the solution for this!
  Update RxSwift 2.1.0
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=778a02fdfa060bfff0680c2eb14886487fcb64c3) is `91.47%`

> Merging **#382** into **master** will not affect coverage as of [`778a02f`](https://codecov.io/github/Moya/Moya/commit/778a02fdfa060bfff0680c2eb14886487fcb64c3)

``` diff
@@            master    #382   diff @@
======================================
  Files           13      13       
  Stmts          446     446       
  Branches         0       0       
  Methods                          
======================================
  Hit            408     408       
  Partial          0       0       
  Missed          38      38       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/059c7eae68f6465fea53a17665ab26e44d3ebff8...778a02fdfa060bfff0680c2eb14886487fcb64c3) as of [`778a02f`](https://codecov.io/github/Moya/Moya/commit/778a02fdfa060bfff0680c2eb14886487fcb64c3)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=778a02fdfa060bfff0680c2eb14886487fcb64c3)
1. `+1.35%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=778a02fdfa060bfff0680c2eb14886487fcb64c3#76) 
2. `+1.13%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=778a02fdfa060bfff0680c2eb14886487fcb64c3#54) 
3. `+1.13%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=778a02fdfa060bfff0680c2eb14886487fcb64c3#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=778a02fdfa060bfff0680c2eb14886487fcb64c3)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Thanks for letting me contribute in the amazing Moya :tada: . and I hope I can help :)
  I've added my library which makes it really easy to combine Moya with [SwiftyJSON](https://github.com/SwiftyJSON/SwiftyJSON)

It's based on the ObjectMapper, which is already listed.
 It's a true honour to join this great project. Thanks Ash, hoping some people enjoy my extension! 
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=9ac7da262ae37a48ef7c7eed176ed029e2cac8ee) is `91.47%`

> Merging **#380** into **master** will not affect coverage as of [`9ac7da2`](https://codecov.io/github/Moya/Moya/commit/9ac7da262ae37a48ef7c7eed176ed029e2cac8ee)

``` diff
@@            master    #380   diff @@
======================================
  Files           13      13       
  Stmts          446     446       
  Branches         0       0       
  Methods          0               
======================================
  Hit            408     408       
  Partial          0       0       
  Missed          38      38       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/0e41b9d4fd6bc4b01da4c3e3e7cab115399fc1af...9ac7da262ae37a48ef7c7eed176ed029e2cac8ee) as of [`9ac7da2`](https://codecov.io/github/Moya/Moya/commit/9ac7da262ae37a48ef7c7eed176ed029e2cac8ee)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=9ac7da262ae37a48ef7c7eed176ed029e2cac8ee)
1. `+1.35%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=9ac7da262ae37a48ef7c7eed176ed029e2cac8ee#76) 
2. `+1.13%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=9ac7da262ae37a48ef7c7eed176ed029e2cac8ee#54) 
3. `+1.13%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=9ac7da262ae37a48ef7c7eed176ed029e2cac8ee#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=9ac7da262ae37a48ef7c7eed176ed029e2cac8ee)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  I noticed that responses such as a 400, 422, 503, etc. are being returned in the Result as a .Success. This requires the .Success case to have additional logic to handle errors in addition to the .Failure case.

I'm wondering if this was by design? If so, are there best practices for handling errors returned from a server? The API for handling responses in Moya is fantastic, it is incredibly clean. This particular case is  where my code organization breaks a bit.

Any input would be appreciated, thanks.
 Thanks for the quick input @colinta. Extremely valid points.

What's your scenario like for a 5xx response? In that case do you attempt any retries?
 Thanks. I would say that answers my question. Appreciate it.
 @colinta How do you handle the the response in your provider, with a plugin?
 @colinta Hey, how do queue the requests while the refreshing request is on the air, then when it is done executing the queued ones?  @mrfarukturgut All requests are sent via a class we called `ElloProvider`, and in that `request` method we check to see if the request needs authentication, and if so we make sure we are in the appropriate state.  If the auth state is "attempting to log in" we add the request to a queue.  If the auth state is "anonymous" or "none" we send back an error.

The auth state transitions are handled outside this request cycle, so when we get back a success after sending credentials we can change the auth state from "attempting" to "logged in" and then we send out all the pending requests.

Our code is open source, so you can check this out at <https://github.com/ello/ello-ios>  Hi, I just detected that Moya 6.0.0 uses ReactiveCocoa RC1 as dependency. Updated to RC2 -> https://github.com/ReactiveCocoa/ReactiveCocoa/releases/tag/v4.0.0-RC.2 

I think those changes in ReactiveCocoa don¬¥t affect related code in Moya, but would be happy if anyone could confirm that. (At least I was able to build ReactiveMoya with RC2) 
 hm it seems something went wrong with the ReactiveCocoa dependency within the podspec file. Not sure what causes the issue - I¬¥m rather less experienced with cocoa pods..
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=b8f895592bcba8c33afbba03758a1dbe732f2a49) is `91.47%`

> Merging **#377** into **master** will not affect coverage as of [`b8f8955`](https://codecov.io/github/Moya/Moya/commit/b8f895592bcba8c33afbba03758a1dbe732f2a49)

``` diff
@@            master    #377   diff @@
======================================
  Files           13      13       
  Stmts          446     446       
  Branches         0       0       
  Methods                          
======================================
  Hit            408     408       
  Partial          0       0       
  Missed          38      38       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/6b477fc01523cd2d0af5070e9885f634bc03b60b...b8f895592bcba8c33afbba03758a1dbe732f2a49) as of [`b8f8955`](https://codecov.io/github/Moya/Moya/commit/b8f895592bcba8c33afbba03758a1dbe732f2a49)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=b8f895592bcba8c33afbba03758a1dbe732f2a49)
1. `+1.35%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=b8f895592bcba8c33afbba03758a1dbe732f2a49#76) 
2. `+1.13%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=b8f895592bcba8c33afbba03758a1dbe732f2a49#54) 
3. `+1.13%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=b8f895592bcba8c33afbba03758a1dbe732f2a49#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=b8f895592bcba8c33afbba03758a1dbe732f2a49)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 üëçüèª
  @ashfurrow here's the codes to answer #358  but it's including some other changes. that's change nothing interfaces for end-users but `stubClosure`.

PS: codes may rough, and I'm just test the Demo and pass all cases

This PR including:
- [Break] Pass `StubBehavior` value to provider directly, no need by `stubClosure`
- [Break] `Endpoint` now non-generic
- [Break] Introducing backends for provider. Now provider itself become lightweight, backend do the really job.
- [Break] add toNSMutableRequest() method to Endpoint, deprecate urlRequest property
- [Break] use `ConvertToEndpoint` function to build `Endpoint`, remove `Provider#endpoint`
- Add a non-generic version provider
- `Endpoint` has `parameterEncoding` property but can not be setting except in endpointClosure, let's made it into TargetType, and set a default `.URL` as Moya current does
 This PR mainly extract duties from `Provider`, it's has too many jobs before: build `Endpoint`s, do requests, decide how to mock requests, that's made things complex, like mock requests, it's no need in production.

Now, Provider only handle build `Endpoint` and as a interface to end-user to requesting targets, let backend do the really job, it's a protocol `MoyaProviderBackendType` so we can replace it easily.
There an additional advantage, we separate the really requests and mock requests to specified backends. In test env, use mock backend, use normal backend in production. and Moya now could decoupling with Alamofire.

Then, the provider become lightweight, so maintain a non-generic version become possible.
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=21f352b593211e0ca716a3c267be9b5fafffaa7e) is `86.57%`

> Merging **#376** into **master** will decrease coverage by **-4.90%** as of [`21f352b`](https://codecov.io/github/Moya/Moya/commit/21f352b593211e0ca716a3c267be9b5fafffaa7e)

``` diff
@@            master    #376   diff @@
======================================
  Files           13      15     +2
  Stmts          446     484    +38
  Branches         0       0       
  Methods                          
======================================
+ Hit            408     419    +11
  Partial          0       0       
- Missed          38      65    +27
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/6b477fc01523cd2d0af5070e9885f634bc03b60b...21f352b593211e0ca716a3c267be9b5fafffaa7e) as of [`21f352b`](https://codecov.io/github/Moya/Moya/commit/21f352b593211e0ca716a3c267be9b5fafffaa7e)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=21f352b593211e0ca716a3c267be9b5fafffaa7e)
1. `+2.68%` via [...ource/Provider.swift#93...105](https://codecov.io/github/Moya/Moya/Source/Provider.swift?ref=21f352b593211e0ca716a3c267be9b5fafffaa7e#93) 
2. `+1.23%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=21f352b593211e0ca716a3c267be9b5fafffaa7e#76) 
3. `+1.23%` via [...ource/Endpoint.swift#80...85](https://codecov.io/github/Moya/Moya/Source/Endpoint.swift?ref=21f352b593211e0ca716a3c267be9b5fafffaa7e#80) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=21f352b593211e0ca716a3c267be9b5fafffaa7e)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Endpoint is intermediate product from `Target` to `Request`, when building `Endpoint` by `Target`, all job relates Target should be done in `endpointClosure`, like add authenticate header as your mentioned, so in `requestClosure` no need to know the `Endpoint` where's from, so Endpoint no need to generic.
 @colinta 
I'm a new guy to learning Swift and iOS developing, my project using Moya and I feel a little inconvenient, have described at #358 

Please don't merge it, I'm no confident in my Swift skill, and it's not polish yet.

This PR is mainly to prove, It's possible to make a non-generic provider and keeping interfaces compatible, and is it keeping Moya's philosophy? does the new provider design more reasonable? the refactor isn't do things right?
 @colinta No matter, after discussion I can cherry-pick the good part
 just adding a changes:
- `TargetType` has `toEndpoint()` to build `Endpoint`, `Provider#endpoint` is no used and has removed
 And, I have a question: Why `Endpoint` needs immutable? is it possible to mutate itself when we change something?
 @ashfurrow 
Here is the last wave I can imagine at this time:
- `Endpoint` has `parameterEncoding` property but can not be setting except in `endpointClosure`, let's made it into `TargetType`, and set default is `.URL` as Moya currently does
- [Break] add `toNSMutableRequest()` method to `Endpoint`, deprecate `urlRequest` property

Here I have another question:
[How does it work to make Endpoint to Request asynchonous?](https://github.com/Moya/Moya/commit/847bf33f76e9743dc2e04df629bbe9803de92c24#diff-ab556bf607d84c3809645f443db9b8ceR151)

Now data flow is clear: `TargetType#toEndpoint` -> `Endpoint` -> `Endpoint#toNSMutableRequest` -> `NSMutableRequest`

Moya's provider just combine this flow and adding some hooks (such as `endpointClosure`, `requestClosure`) and plugins, then pass request to `Backend` to handle
 Currently backend (stub backend, clear to say) still needs to know plugins, target and endpoint
 @colinta 
could you tell me when we need to customize `stubClosure`?
I'm trying to keeping `stubClosure` as current Moya does, but I found it seems impossible.
If you can told me usage of `stubClousure` I may find another way to keep that
 @ashfurrow 
I've consider `stubClosure`, This behavior can be moved to `StubBehavior`, even we can enhence it like `mockEndpoint(Endpoint, response)` I think that's more flexible on testing, better than 'sampleDate` (I don't have critical reason, but testing code in releasing codebase seem weird to me)
 @ashfurrow 
`StubBackend` could do stubbing responses, just using it in _testing_ and _development_, and I've an idea could move all codes for stubbing, but that's another discussion.

At last, thank you for reviewing my huge PR, and thank for your blog and other open source works!
 First, I apologize for my terrible English, I'll try my best to explain my motivation and my idea.

## Motivation

I'm looking for a solution to build a Restful endpoints abstraction for [my learning project](https://github.com/jasl/RubyChinaAPP) which is a forum's client, by read many articles and libraries I found Moya seems to fit my needs.

When I progressing my plan, I meet some difficulties:
- There are 38 endpoints need to declare
- Some endpoints are complex that may has optional value, mutually exclusive field, required fields
- too many endpoints in ONE enum made it to long, difficult to organize

(PS: My company's app has about 100+ endpoints, and more complex than mine)

So, I tried to using `struct` to [organize endpoints](https://github.com/jasl/RubyChinaAPP/blob/master/RubyChinaApp/Libraries/Endpoints/Topics.swift), It looks better, I use nested struct to simulate namespace (that mapping Restful resources), and resources' path can [reusable](https://github.com/jasl/RubyChinaAPP/blob/master/RubyChinaApp/Libraries/Endpoints/Topics.swift#L12).

But, there is an another problem, Moya's provider is generic, and it's designed for endpoints which declared in a enum, like [Eidolon](https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/ArtsyAPI.swift). If I still using `struct`, the code should like:

``` swift
let provider = MoyaProvider<TheSite.Topics.Listing>()
provider.request(TheSite.Topics.Listing) { res in
  // callback
}
```

That's weird, can't be reused, and difficult to building a higher abstraction for provider to encapsulating OAuth2 signing and some configuration for Request [[sample]](https://github.com/jasl/RubyChinaAPP/blob/master/RubyChinaApp/Libraries/Provider.swift)

The only problem is the Provider's generic contraint, and I consider it's possible to remove without side effect, so I copy Moya 5.3 to my project, and [just remove the generic contraint](https://github.com/jasl/RubyChinaAPP/blob/master/NetworkAbstraction/NetworkAbstraction/APIProvider.swift#L52), all problem solved perfectly!

Then, I wrote my thinking in #358, and @ashfurrow replied me.

## The goal

The goal is simple, but complex to reach, that **making a non-generic Provider possible**.

## How to

By theory, most of Provider's codes should be shared, but I tried many ways, failed.

Finally, I found a way, to short:
- Clearify data flow that how Provider sending a request
- Made Provider light-weight
- Introducing Backend to handle request

## About StubClosure

That's my mistake, because I promise keeping current APIs, In new Provider design [I need to decide what backend should be use](https://github.com/Moya/Moya/pull/376/files#diff-b96c1bf37472f8e8d65f16aaf540ed10R35), and `stubClosure` can't be evaluate here.

Actually, `stubClosure` should be setting to `StubBackend` directly like `StubBackend(stubClosure: {})`, that's make sense.

Anyway, It's should break current Provider's initializer.

## Answer questions

### What does MoyaCommonProvider do? I don't see this class used anywhere, but it is defined in Provider.swift.

`MoyaCommonProvider` is a non-generic Provider, you can use it when you using struct or class to organizing your endpoints.

### DefaultCommonEndpointMapping and DefaultEndpointMapping do the same thing, can this be simplified to just having DefaultEndpointMapping?

DefaultCommonEndpointMapping and DefaultEndpointMapping is do the same thing, but DefaultEndpointMapping can't be used for non-generic Provider, and some people want [do something works which needs to know TargetType's type](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-)

But, I think `DefaultEnpointMapping` is no need, you can just override `toEndpoint` (It's declared in `TargetType`) to do the same job.

### I see that CancellableToken has been made public, but I think it can remain private if you change the return type to Cancellable in MoyaProviderBackend

I don't have idea about this, I think made its public may help for create new Backend in project?
 ping @colinta 
 It seems still made `MoyaProvider` can't be reused, it specify **the** struct type

Actually we can do the same thing before that PR

``` swift
let provider = MoyaProvider<StructAPI>()
provider.request(StructAPI()) { res in
  // callback
}
```

now

``` swift
let provider = MoyaProvider<StructTarget<StructAPI>>()
provider.request(StructTarget(StructAPI())) { res in
  // callbace
}
```

That's not simplify our codes, but make the things complex(wrap `StructAPI` into `StructTarget`)

https://github.com/Moya/Moya/tree/structs this branch is a good try, but the implement too tricky(use `Mirror`)
 @ashfurrow 

My English speaking quite badly :scream:  My Skype is my email `jasl9187 at hotmail.com`, I'll try to explain my thoughts as I can.

Actually, after this PR, I forked Moya and build my own version for research [MoyaX](https://github.com/jasl/moyax)  (I'm sorry to renaming the project, I'm not want to divide, just because that's can made me away from compatibility concerns).
 I polished this PR in my fork, and I fork eidolon with MoyaX works quite well, [codes here](https://github.com/jasl/eidolon/tree/MoyaX).
PS: It's may not pass compiling because I force push MoyaX master, and not change test cases, they're too big.
  I'm getting errors when trying to run my app after upgrading Moya to 6.0.0 using Carthage on both my simulator and device.

Logs spits out:

``` sh
dyld: Library not loaded: @rpath/Result.framework/Result
  Referenced from: /Users/.../Library/Developer/CoreSimulator/Devices/BE2AC542-454F-42EB-AE64-B40BB3F1F49F/data/Containers/Bundle/Application/63470171-C041-4DB6-8F0D-6FD1CD9C5F99/....app/Frameworks/Moya.framework/Moya
  Reason: image not found
(lldb) 
```

Tried this after running `carthage update --platform iOS` (and tried with `--use-no-binaries`). I've also reset the simulators and cleaned my build.

The framework seems to build just fine in my app's `Carthage/Build` directory, but downgrading back to 5.1.0 and rebuilding immediately fixes the problem.

I apologize if this is a common problem and if I'm just using Carthage incorrectly, as I'm new to the Carthage ecosystem. Though after searching around, it doesn't feel like I'm using Carthage incorrectly as my app is already set up for it. 

And unfortunately, I cannot use pods on this app :(.
 Yup. Even tried redoing the Run Script but still no luck.
 Ohhh, I had no idea about Result. Didn't seem to run into that issue before now, but I'll give it a shot and report back.
 Yep. Result has been added to replace Moya's own result type because some users where having issues with it. 
 !! Worked! Upgraded to 6.0.0 successfully after adding `Result.framework` to the Embedded Binaries of the target.

Closing :) Thank you @Austinate and @petester42 for the help!
   ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=b5f1e7b41a7a60760e83d066ddbd98ab434f0107) is `91.47%`

> Merging **#372** into **master** will not affect coverage as of [`b5f1e7b`](https://codecov.io/github/Moya/Moya/commit/b5f1e7b41a7a60760e83d066ddbd98ab434f0107)

``` diff
@@            master    #372   diff @@
======================================
  Files           13      13       
  Stmts          446     446       
  Branches         0       0       
  Methods          0               
======================================
  Hit            408     408       
  Partial          0       0       
  Missed          38      38       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/464d2beb9d558dbfbd2098daa09be932389d078a...b5f1e7b41a7a60760e83d066ddbd98ab434f0107) as of [`b5f1e7b`](https://codecov.io/github/Moya/Moya/commit/b5f1e7b41a7a60760e83d066ddbd98ab434f0107)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=b5f1e7b41a7a60760e83d066ddbd98ab434f0107)
1. `+1.35%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=b5f1e7b41a7a60760e83d066ddbd98ab434f0107#76) 
2. `+1.13%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=b5f1e7b41a7a60760e83d066ddbd98ab434f0107#54) 
3. `+1.13%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=b5f1e7b41a7a60760e83d066ddbd98ab434f0107#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=b5f1e7b41a7a60760e83d066ddbd98ab434f0107)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Thanks!
 Well thank you üòä I'd be more than happy to accept.
  ```
        case let .Failure(error):

            print((error as NSError).localizedDescription)
            print(Moya.Error.Underlying(error))
            guard let error = error as? CustomStringConvertible else {
                break
            }
```

This is how my failure block looks.
On the first print as `NSError`, I get the following response:
**The operation couldn‚Äôt be completed. (Moya.Error error 5.)**
For the second print, underlying error:
**Underlying(Moya.Error.Underlying(Error Domain=NSURLErrorDomain Code=-1 "(null)"))**

I'm not sure what happened, it was working fine just few minutes back.
Any help is much appreciated! Thanks.
 Again, not sure what happened. It is working fine now!! I have done no changes.
Might be some network connection issue??
 I've been having the same problem. If a network error happens, I display the localized description to the user. But it always have the same error (The operation couldn‚Äôt be completed. (Moya.Error error 5.)). 

Is there a way to Moya.Error provide the original network error? (e.g. Network seems to be down)
 Oh. Thank you. This method is marked as deprecated. Will it have a replaced method? I'm using with rxSwift
  Looks like plugin does not allow to modify response. I expected that ObjectMapper or alternative mapping for result/error should be done on a plugin level. Is it a fair expectation or there some other place for doing this in the current architecture? Thanks.
 @ashfurrow I did review ObjectMapper. It is a nice work, but the way how it is integrated into Moya makes me worry. My expectation that Plugins should be integratabtle through plugin system. The fact that it just an extension on some types of results limits an option to vary capabilities depends on the end point. So here is another example to make my idea a little bit more clear. This is the real production scenario that I am experiencing now. We have different endpoints, all of them return status 200 independently of result. One of outcomes actually can be error and it will be explained in the body. It would be nice to have an option to redefine mapping rules for result/error as a Plugin, so the rest of routine of work with Moya will be kept the same.
 Got it. Thanks. Just want to be sure that I didn't miss a built-in extension point.
  Hi All,

I m struggling to extend the MoyaProvider so I dont have to explicitly pass the endpoint block to the initialiser.

Can we include an example of how to extend the MoyaProvider class in the Demo for example? I think that would really decrease the learning curve for most of the newer users. Otherwise would you suggest me a better implementation? 

this is what im doing

```
class MyProvider<Target where Target: TargetType>: MoyaProvider<MyAPI> {

    override init(endpointClosure: EndpointClosure = MyProvider.MyEndpointMapping,
        requestClosure: RequestClosure = MoyaProvider.DefaultRequestMapping,
        stubClosure: StubClosure = MoyaProvider.NeverStub,
        manager: Manager = MoyaProvider<Target>.DefaultAlamofireManager(),
        plugins: [PluginType] = []) {

            super.init(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, manager: manager, plugins: plugins)
    }

    internal final class func MyEndpointMapping(target: FreelancerAPI) -> Endpoint<MyAPI> {
        let endpoint: Endpoint<MyAPI> = Endpoint<MyAPI>(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)

        // Sign all non-authenticating requests
        switch target {
        case .ListOfJobs:
            return endpoint
        default:
            return endpoint
        }
    }

}
```

Thanks
 Thanks Ash!

Yea I was looking forward to create a clean implementation, not having to pass the closure all the times.
I kinda reached that point with the code above, not sure if I will keep it in my code.

If you had some spare time I would suggest you to include another Demo project that explores other advanced customisations. Everything is already pretty much explained in the docs, but having other examples to wrap up all the concepts would not hurt. Imagine that I ended up here after I started to study your Kiosk app... :) OnlineProvider is a subclass and I struggle to understand how to compose my provider implementation (without Rx and all the rest).. Now its definitely clear!

Thanks again!
 Who knows how to post a json string use Moya?
 Great question @offbye I was wondering that too. I would like to send my requests with JSON and I found that I need to change Parameter Encoding like below

```
   public var parameterEncoding : Moya.ParameterEncoding {
        return .JSON
    }
```

what else should I do? 
 @offbye I found the solution among the other issues #188 check it out :+1:  
  I think `Moya.Response` and `Alamofire.Response` are the most responsible ways to access the types. I don't think we should be forced to prefix our types due to external collisions, especially when the solution is as simple as saying `Module.SomeType`
  I need to add activity indicator before response came. Is there any way to access all request from one place?
 May `NetworkActivityPlugin` can do this. See end of the [Providers Doc](https://github.com/Moya/Moya/blob/master/docs/Providers.md)
 Thanks @alfredcc I tried to add plugins but couldn't. Can you give me an example code or some more detailed link about plugins? 
 You add the plugins as part of the initialization for your `provider`. It is passed in as an array. As an example, to add the `NetworkLoggerPlugin` to your provider, use the following sample code:

``` swift
let plugins: [PluginType] = [NetworkLoggerPlugin(verbose: true)]
let myProvider = MoyaProvider<MyTarget>(plugins: plugins)
```

Here is [the full spec](https://github.com/Moya/Moya/blob/464d2beb9d558dbfbd2098daa09be932389d078a/Source/Moya.swift#L54-L58) for the `init` of a `MoyaProvider`.
 thanks @aamctustwo :+1: 
  I'm upgrading from 4.5.0 to 6.0.0 and have one last compilation error that's stumping me. My code was inspired from a combination of Moya docs and the Eidolon source from a year or so ago. Any help is most appreciated - I'm having a rough time since the error message is quite opaque to me (it sounds like a contradiction). It should be pretty familiar to how Eidolon's API was structured a while back, though it seems to have had a lot of new abstraction added since then.

Here's where compilation fails:

```
static func DefaultProvider() -> ReactiveManabiAPIProvider<ManabiAPI> {
        return ReactiveManabiAPIProvider(endpointClosure: endpointsClosure,
            requestClosure: endpointResolver(),
            stubClosure: StubBehaviour,
            plugins: APIProvider.plugins)
    }
```

```
error: cannot convert value of type '(ManabiAPI) -> Endpoint<ManabiAPI>' to expected argument type '_ -> Endpoint<_>'
        return ReactiveManabiAPIProvider(endpointClosure: endpointsClosure,
                                                          ^~~~~~~~~~~~~~~~
```

And here are the relevant bits referenced above:

```
enum ManabiAPI {
[...]
}

extension ManabiAPI : TargetType {
    var baseURL: NSURL { return NSURL(string: "[...]")! }    
    var path: String {
    [...]
    }
    var parameters: [String: AnyObject]? {
    [...]
    }
    var method: ReactiveMoya.Method {
    [...]
    }
    [...]
}

public class ReactiveManabiAPIProvider<Target where Target: TargetType> : ReactiveCocoaMoyaProvider<Target> {
    var appController: AppController
    var requestErrors: RACSubject

    override init(endpointClosure: MoyaProvider<Target>.EndpointClosure = MoyaProvider.DefaultEndpointMapping,
        requestClosure: MoyaProvider<Target>.RequestClosure = MoyaProvider.DefaultRequestMapping,
        stubClosure: MoyaProvider<Target>.StubClosure = MoyaProvider.NeverStub,
        manager: Manager = Alamofire.Manager.sharedInstance,
        plugins: [PluginType] = [], stubScheduler: DateSchedulerType? = nil) {
            let appDelegate = (UIApplication.sharedApplication().delegate as! AppDelegate)
            appController = appDelegate.appController!

            requestErrors = RACSubject()

            super.init(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, manager: manager, plugins: plugins)
    }
[...]
}
```

Please let me know if it'd be helpful to see anything else. Thanks!
 I've posted the question on StackOverflow since it's not particularly Moya-specific: http://stackoverflow.com/questions/34707426/what-does-this-swift-type-error-mean-it-reads-like-whats-expected-is-already-t
 Just realized I didn't post the actual implementation of `endpointsClosure`, at the top of this:

```
struct APIProvider {
    static var username: String? = nil
    static var password: String? = nil

    static var endpointsClosure = { (target: ManabiAPI) -> Endpoint<ManabiAPI> in
        var base64Login: NSString?

        if let username = username {
            if let password = password {
                let login = NSString(format: "%@:%@", username, password)
                let loginData: NSData = login.dataUsingEncoding(NSUTF8StringEncoding)!
                base64Login = loginData.base64EncodedStringWithOptions([])
            }
        }

        let parameterEncoding: ReactiveMoya.ParameterEncoding = target.method == .GET ? .URL : .JSON

        let endpoint: Endpoint<ManabiAPI> = Endpoint<ManabiAPI>(
            URL: url(target),
            sampleResponseClosure: {.NetworkResponse(200, target.sampleData)},
            method: target.method,
            parameters: target.parameters,
            parameterEncoding: parameterEncoding)

        if let base64Login = base64Login {
            let headerFields = ["Authorization": "Basic \(base64Login)"]
            return endpoint.endpointByAddingHTTPHeaderFields(headerFields)
        } else {
            return endpoint
        }
    }

    static func StubBehaviour(_: ManabiAPI) -> ReactiveMoya.StubBehavior {
        return .Never
    }

    static func DefaultProvider() -> ReactiveManabiAPIProvider<ManabiAPI> {
        return ReactiveManabiAPIProvider(endpointClosure: endpointsClosure,
            requestClosure: endpointResolver(),
            stubClosure: StubBehaviour,
            plugins: APIProvider.plugins)
    }

    private struct SharedProvider {
        static var instance = APIProvider.DefaultProvider()
    }

    static var sharedProvider: ReactiveManabiAPIProvider<ManabiAPI> {
        get {
            return SharedProvider.instance
        }

        set (newSharedProvider) {
            SharedProvider.instance = newSharedProvider
        }
    }
}
```
 Thanks @gregpardo that may help. But I've disabled plugins in an attempt to narrow down this issue. Glad you found your fix.
 Ah I think I've solved it, something stupid - I specify `plugins: APIProvider.plugins` despite having commented out `APIProvider.plugins` - it gave that unrelated error for that static var not existing. I don't know if this is related to what you ran into, but at least your problem led me to it.
 Yep, all resolved now... Sorry for the noise, thanks.
 I'd just like to note for posterity that if anyone lands here I had the exact same issue and the fix was being more explicit about the types.

I had something like

``` swift
static var sharedProvider = ...
```

That then returned my provider.

I fixed the issue by switching to

``` swift
static var sharedProvider: MoyaProvider<EtherAPI> = ...
```
 Seems like a very similar issue. The swift compiler sometimes needs to be explicit but does not properly hint on where the problem is. I'm going to keep this in mind for this and other projects.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=719bd2250414400dbde1ab61ac816a0ca653554d) is `91.47%`

> Merging **#364** into **master** will not affect coverage as of [`719bd22`](https://codecov.io/github/Moya/Moya/commit/719bd2250414400dbde1ab61ac816a0ca653554d)

``` diff
@@            master    #364   diff @@
======================================
  Files           13      13       
  Stmts          446     446       
  Branches         0       0       
  Methods                          
======================================
  Hit            408     408       
  Partial          0       0       
  Missed          38      38       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/aece4ebe3ad3cab946d8df93de4ee72c7024c8e7...719bd2250414400dbde1ab61ac816a0ca653554d) as of [`719bd22`](https://codecov.io/github/Moya/Moya/commit/719bd2250414400dbde1ab61ac816a0ca653554d)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=719bd2250414400dbde1ab61ac816a0ca653554d)
1. `+1.35%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=719bd2250414400dbde1ab61ac816a0ca653554d#76) 
2. `+1.13%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=719bd2250414400dbde1ab61ac816a0ca653554d#54) 
3. `+1.13%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=719bd2250414400dbde1ab61ac816a0ca653554d#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=719bd2250414400dbde1ab61ac816a0ca653554d)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  pod update...
Installing Moya 5.1.0 (was 5.2.1)
And now since RxSwift updated i get errors "Use of unresolved identifier 'just'".
My pods are:
pod 'Moya'
pod 'Moya/RxSwift'
 I solved by manually setting the version in Cocoapod:
pod 'Moya/RxSwift', '5.3.0'
  Fixes #360 
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=c972fdd687fb0c6d3c72e85fa4a9e4c50cb2d40a) is `91.30%`

> Merging **#361** into **master** will not affect coverage as of [`c972fdd`](https://codecov.io/github/Moya/Moya/commit/c972fdd687fb0c6d3c72e85fa4a9e4c50cb2d40a)

``` diff
@@            master   #361   diff @@
=====================================
  Files           13     13       
  Stmts          437    437       
  Branches         0      0       
  Methods                         
=====================================
  Hit            399    399       
  Partial          0      0       
  Missed          38     38       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/9b0066bffbb6c7d40a2070dcaa832a6f6d38ba44...c972fdd687fb0c6d3c72e85fa4a9e4c50cb2d40a) as of [`c972fdd`](https://codecov.io/github/Moya/Moya/commit/c972fdd687fb0c6d3c72e85fa4a9e4c50cb2d40a)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=c972fdd687fb0c6d3c72e85fa4a9e4c50cb2d40a)
1. `+1.37%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=c972fdd687fb0c6d3c72e85fa4a9e4c50cb2d40a#76) 
2. `+1.14%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=c972fdd687fb0c6d3c72e85fa4a9e4c50cb2d40a#54) 
3. `+1.14%` via [Source/Moya.swift#177...181](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=c972fdd687fb0c6d3c72e85fa4a9e4c50cb2d40a#177) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=c972fdd687fb0c6d3c72e85fa4a9e4c50cb2d40a)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  I am getting deeper into this library and I must say love it. 

I am trying to solve the following issue. Every request I make must be authenticated (except for the authentication endpoint) and if I am missing the authentication information I want to intercept the request, ask for new `identity` and when it responds then continue with the original request.

I was thinking about using using `endpointClosure` (or `requestClosure` but sadly I wasn't able to check the request `TargetType` here) but it isn't possible to use the same `Provider` within its own type to call for this new `identity`.

Another solution I am thinking about is writing custom `Plugin` or am I missing some easier way?

Thanks :)
 Checking against the Endpoint's URL seems like a solution but it is not possible to call the same Provider request within it's own init method (getting `'requestClosure'` used within its own type) error. 

Does it mean that it's necessary to create new Provider which will serve only for Authetication to be able to call it within `requestClosure`?
 @skornos A couple of questions to help me understand your situation. I want to make sure I'm not missing anything!
1. Why are you waiting till the call is made to check if the request is authenticated? Why not have a `bool` that is checked prior to preparing any network requests that would need to be authenticated?
2. Why are you concerned about checking the authentication at the time of the request? You will need to implement handling for a failed authentication response anyway in case their token/sessions/etc. has expired. This handling would include re-authentication and re-making the original (now properly authenticated) request.

In the end it may not be such a bad idea in the end to separate out your authentication endpoint from your other endpoints. There are a number of Moya regulars who use multiple `TargetType`s and `Provider`s to separate out categories of endpoints.
  I have a couple of endpoints with optional parameters specified like this

```
public enum MyAPI {
    ...
    case Content(Int, Int?, String?)
    ...
}
```

The problem is that `public var parameters` expects a type `[String: AnyObject]?` so if I pass optional value I have to unwrap it with `!` operator which causes Exception if the parameter is `nil`.

I was thinking about filtering all the params from the dictionary where the value is `nil` or is there any other way? Like for example specifying `parameters` as `[String: AnyObject?]?`

Thanks.
 Thanks for such quick answer.

I have found another workaround. Assigning `nil` to initialized dictionary is equal to removing the key from the dictionary so instead of naming all the params in the initializer you create new empty dictionary of type `[String: AnyObject]?` and than you assign each parameter like `parameters["foo"] = nil`.
 I will have time for PR hopefully anytime soon :+1: 
 I've an idea, but may break design goal of Moya: Providing a non-generic `MoyaProvider`

## `enum` isn't a good way for complex endpoints

For example, there is an endpoint

`api/v1/topics`

| param | type | optional | sample | desc |
| --- | --- | --- | --- | --- |
| offset | Integer | Yes | 20 |  |
| limit | Integer | Yes | 20 |  |
| type | String | Yes | recent | should in `last_actived`, `recent`, `no_reply`, `popular`, `excellent` |
| node_id | Int | Yes | 1 |  |

In Moya flavour, I must define a case like `Topics(Int?, Int?, String?, Int?)`, that's unreadable and uneasy to use.

## How about `struct` or `class` ?

For complex endpoints, `struct` or `class` has definitly advantage than `enum`, and Moya can use it actually (if they adopt the `TargetType` protocol).

``` swift
struct ListingTopics: TargetType {
    enum TypeFieldValue: String {
        case LastActived = "last_actived"
        case Recent = "recent"
        case NoReply = "no_reply"
        case Popular = "popular"
        case Excellent = "excellent"
    }

    var type: TypeFieldValue?
    var nodeId: String?
    var offset: Int?
    var limit: Int?

    init(type: TypeFieldValue? = nil, nodeId: String? = nil, offset: Int? = nil, limit: Int? = nil) {
        self.type = type
        self.nodeId = nodeId
        self.offset = offset
        self.limit = limit
    }

    var baseURL: NSURL { return Global.baseURL }
    var path: String { return "api/v1/topics" }
    var method: Moya.Method { return .GET }
    var parameters: [String: AnyObject]? {
        var parameters = [String: AnyObject]()

        if let type = self.type {
            parameters["type"] = type.rawValue
        }
        if let nodeId = self.nodeId {
            parameters["nodeId"] = nodeId
        }
        if let offset = self.offset {
            parameters["offset"] = offset
        }
        if let limit = self.limit {
            parameters["limit"] = limit
        }

        return parameters
    }
}
```

BUT, there's a little STRANGE when using:

``` swift
provider = MoyaProvider<ListingTopics>()
provider.request(ListingTopics(nodeId: 1, type: .Recent)) { ... }
```

The `provider` rely on `ListingTopics` so that can't be reuse.

## Conclusion

Moya is limiting by generic `MoyaProvider`

## One More Thing

For simple endpoints, `struct` or `class` still works well

``` swift
struct GetTopic: TargetType {
    var id: String

    init(id: String) {
        self.id = id
    }

    var baseURL: NSURL { return RubyChinaV3.BaseURL }
    var path: String { return "\(RubyChinaV3.Topics.Path)/\(self.id)" }
    var method: NetworkAbstraction.Method { return .GET }
    var parameters: [String: AnyObject]? { return nil }
}
```

Not too much longer than `enum`'s, and there's another advantage for RESTful-flavour: namespace

``` swift
struct MySiteAPI {
    static let baseURL = NSURL("http://mysite.fake")!
}

extension MySiteAPI {
    struct Topics {
        static let path = "topics"
    }
}

extension MySiteAPI.Topics {
    struct Listing: TargetType { ... }
    struct Get: TargetType { ... }
}
```

That's all I thought.
 Actually I'm doing some researching.

(PS: I'm a full stack Ruby on Rails developer but still a new guy to learning Swift and iOS development about 1 month)
(PS2: I really appreciate Moya and SwiftyJSON)

Here's my project for learning (a client for Ruby-China community):https://github.com/jasl/RubyChinaAPP

It's not done yet, but I've done some interesting works about invoking endpoints.
- https://github.com/jasl/RubyChinaAPP/blob/ui/topics/NetworkAbstraction/NetworkAbstraction/APIProvider.swift#L52 
  - cheated from Moya 5.3.0
  - removing generic by deleting `<Target: TargetType>` and replace `Target` to `TargetType`
- https://github.com/jasl/RubyChinaAPP/blob/ui/topics/NetworkAbstraction/NetworkAbstraction/Endpoint.swift#L57
  - `Endpoint` can return a `NSMutableRequest` that I can process it more easily, like signing the request with OAuth2 bearer header https://github.com/jasl/RubyChinaAPP/blob/ui/topics/RubyChinaApp/Libraries/Provider.swift#L49-L53
  - removing generic, I think generic is no use here
- https://github.com/jasl/RubyChinaAPP/blob/ui/topics/RubyChinaApp/Libraries/APIResult.swift
  - wrapping the Moya's Result, this concern the next point, also, I'm thinking about UI only concern 4 cases: request successfully and no data response, request successfully with data, invoking endpoint error(like given wrong values), networking or other errors
- https://github.com/jasl/RubyChinaAPP/blob/ui/topics/RubyChinaApp/Libraries/EndpointType.swift
  - here is the magic I think, when I invoking an endpoint like `RubyChinaV3.Topics.Get(id: "28725").doRequest()` in its callback, it's will returns me the parsed `Topic` entity, so I can use it directly
 @jasl You can used labeled parameters with an `enum` in Swift, they're just not required. So for longer endpoints such as in your example, I would definitely use labeled parameters to improve readability.

So your endpoint would become:

``` swift
enum MyTarget {
  case Topics(offset: Int?, limit: Int?, type: String?, nodeID: Int?)
}
```

And using your provider, it would be:

``` swift
let provider = MoyaProvider<MyTarget>()
provider.request(.Topics(offset: 20, limit: nil, type: nil, nodeID: nil), completion { ... })
```
 @aamctustwo but you can't give them default vaules
 Besides, when the APIs growth big (consider there have hundreds endpoints), organizing them by `enum` seem to be difficult.

For example:
https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/ArtsyAPI.swift
We need `switch ... case` on every properties, just for `path` we have 55 lines in https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/ArtsyAPI.swift#L51-L106, and if I ask you: what `path` is the `AuctionListings` used for? first you need find the definition of `path` then search `AuctionListings`

But for `struct` or `class`, that will be fine.

Anyway, I admit in usual case, `enum` might be a good way.
 @jasl You can provide default parameter values in your definition of the `parameters` variable by using the nil coalescing operator. Example:

``` swift
var parameters: [String: AnyObject]? {
  switch self {
    case let .Topics(offset, limit, type, nodeID):
      return ["offset" : offset ?? 20,
                 "limit" : limit ?? 20,
                 "type" : type ?? "recent",
                 "node_id" : nodeID ?? 1]
  }
}
```

Also, for cases where you have hundreds of endpoints, it may be better to categorize them into separate enums anyway for organization. It'd be messy for than many endpoints in any type structure - enum, struct, or class.
 @aamctustwo sorry I'm misled by `struct` and `enum`, actually choose what is no mattar

My point is, generic Provider limiting its flexible.
- It should be reused, as your said endpoints can be categorized into separate enums, that's really solved endpoints management, **but** Providers still need to be initialized for every `enums` with the same configuration but with different type, if a Provider can be reused for a specified type, why can not be reused for all types?
- There is little benefit from generic **except** made easier invoking `request` when give it an `enum` (`provider.request(MySiteAPI.Topics)` to `provider.request(.Topics)`)
 @ashfurrow 
Without generic `Endpoint` [your example](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md#from-target-to-endpoint-) still work with a small refactor, the key is protocol contravariance.

the refactored codes should looks like:

``` swift
let endpointClosure = { (target: TargetType) -> Endpoint in
    let endpoint: Endpoint = Endpoint(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)

    // Here's the magic
    guard let myTarget = target as? MyTarget else {
        return endpoint
    }

    // Sign all non-authenticating requests
    switch myTarget {
    case .Authenticate:
        return endpoint
    default:
        return endpoint.endpointByAddingHTTPHeaderFields(["AUTHENTICATION_TOKEN": GlobalAppStorage.authToken])
    }
}
```
 @ashfurrow I understand, and I'm still researching how to refactor but keeping interfaces stable, maybe I could PR some proving codes to discuss few days later.
 @ashfurrow 
Let's close this
  When I use carthage install the ArgoÔºåIt‚Äòs spent a lot of time to Fetching LlamaKitÔºåAnd finally, it's failure
 Sorry, my description of the problem is wrongÔºåI mean the Moya‚Äôs dependencies is too muchÔºåWhen I use carthageÔºåI failed in Fetching LlamaKitÔºåBut sometimeÔºåsuccess. The causes of the network?
 Moya‚Äôs dependencies is too much? See here [Checkouts](https://github.com/Moya/Moya/blob/master/Cartfile)  
And i think your problem is your network.
 OK, thx
 Moya is so great, I love it
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=161f527bda5399aea812da4966379bdd74f0dd79) is `91.47%`

> Merging **#354** into **master** will increase coverage by **+0.17%** as of [`161f527`](https://codecov.io/github/Moya/Moya/commit/161f527bda5399aea812da4966379bdd74f0dd79)

``` diff
@@            master    #354   diff @@
======================================
  Files           13      13       
  Stmts          437     446     +9
  Branches         0       0       
  Methods          0               
======================================
+ Hit            399     408     +9
  Partial          0       0       
  Missed          38      38       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/cf9fb911c900ef42ef52f47cd88f8ec1f6cd3a31...161f527bda5399aea812da4966379bdd74f0dd79) as of [`161f527`](https://codecov.io/github/Moya/Moya/commit/161f527bda5399aea812da4966379bdd74f0dd79)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=161f527bda5399aea812da4966379bdd74f0dd79)
1. `+1.35%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=161f527bda5399aea812da4966379bdd74f0dd79#76) 
2. `+1.13%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=161f527bda5399aea812da4966379bdd74f0dd79#54) 
3. `+1.13%` via [Source/Moya.swift#188...192](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=161f527bda5399aea812da4966379bdd74f0dd79#188) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=161f527bda5399aea812da4966379bdd74f0dd79)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
   I am very pleased to accept.üò¨
  I hope, it is allowed to ask queries here. I couldn't get `Moya` tag on stackoverflow site.
And thank you very much for creating such a wonderful library.

Question:
I want to make a API call - the URL looks in this format
`BaseURL/MethodName?ParameterName=valueToPass`

And when I pass it like '/MethodName?ParameterName=valueToPass' in the `public var path: String {}` method, it percent encodes '?' to %235F. Thus, always returning error in response.

Can you please let me know the procedure to make such API calls?
 Thank you for the help :)
The solution was to use `EndPoint` :+1: 
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=458a6719ef23343c6e9fca2358166deeb9d580a3) is `85.20%`

> Merging **#351** into **master** will not affect coverage as of [`458a671`](https://codecov.io/github/Moya/Moya/commit/458a6719ef23343c6e9fca2358166deeb9d580a3)

``` diff
@@            master   #351   diff @@
=====================================
  Files           13     13       
  Stmts          473    473       
  Branches         0      0       
  Methods                         
=====================================
  Hit            403    403       
  Partial          0      0       
  Missed          70     70       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/f3cb2b6d17f65b37bdc17e98bca1474f3b4ffe9b...458a6719ef23343c6e9fca2358166deeb9d580a3) as of [`458a671`](https://codecov.io/github/Moya/Moya/commit/458a6719ef23343c6e9fca2358166deeb9d580a3)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=458a6719ef23343c6e9fca2358166deeb9d580a3)
1. `+1.69%` via [Source/Result.swift#48...55](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=458a6719ef23343c6e9fca2358166deeb9d580a3#48) 
2. `+1.26%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=458a6719ef23343c6e9fca2358166deeb9d580a3#76) 
3. `+1.26%` via [Source/Result.swift#93...98](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=458a6719ef23343c6e9fca2358166deeb9d580a3#93) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=458a6719ef23343c6e9fca2358166deeb9d580a3)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Everything looks good aside of a couple syntax fixes. Let's hope it fixes the CI problems. 
 From what I understood from @orta's comment is that we will be able to set the `COCOAPODS_DISABLE_DETERMINISTIC_UUIDS` environment variable in the podfile with cocoapods 1.0. So I'll merge this and open an issue to fix the `COCOAPODS_DISABLE_DETERMINISTIC_UUIDS` issue when cocoapods reaches 1.0.

Good job :100: 
  When I stub a provider, like

``` swift
let SomeProvider = MoyaProvider<SomeAPI>(stubClosure: MoyaProvider.ImmediatelyStub)
```

the code in my app is stubbed fine, however it still calls the API. 

Is there an easy and clear way to not have stubbed responses make any network calls? 

These are typically backends that I'm building simultaneously with the app, so these stubbed calls are now creating unwanted data on my endpoint or creating strange glitches for endpoints that are still under development.

Apologies if this has already been addressed -- I just couldn't find a clear answer in the issues or docs.
  I personally like the enum syntax better but there is nothing wrong with this, that is why protocols are cool. In an application I am working on, there are 2 APIs that I need to talk to so I just created 2 different enums for each one. You don't have to only use 1 enum you can have one per API, or even one per endpoint.

One per endpoint would be particularly interesting since you could implement all the different methods on that object (GET, POST, etc..) and have it encapsulated. 

Would love to hear what others have been doing. It is giving me ideas :tada: 
 @mpurland: thank you for sharing! I'm _just_ dipping into `Moya`, and while it's probably not the feedback you're asking for exactly, seeing an example like this has been valuable for someone who is trying to move from `RAC2`, `ObjC`, and `AFNetworking`.
 Any suggestions on how to best decouple `baseURL` from `TargetType`? Perhaps I'm not familiar enough with Moya yet, but having `TargetType` be responsible for providing an API service's _root_ path feels strange.

I'd like to have `TargetType` adopters defer to another object for its `baseURL`, but in the case of `enums`, I can't have stored properties. Even the `Artsy` repo [internalizes](https://github.com/artsy/eidolon/blob/master/Kiosk/App/Networking/ArtsyAPI.swift#L134) its `baseURL` value via global state.

Am I missing something? And if this is off topic, let me know and I'll create a new issue instead.
 @mpurland: thanks again for the thread. After more than a few long nights, I've achieved a setup similar to yours. My goal was to create a system whereby `TargetType` enums could associate with the native types their JSON results should be parsed into, as well as create signal producers from `TargetType` enums without much boilerplate. 

The result: 

```
// Sends only `Cart` structs
APITarget<CartAPI>(.Create(treeID: 77))
    .on( next: { print($0.id) } )
    .start()

// Sends only `Product` structs
APITarget<ProductsAPI>(.InCategory(treeID: 77, categoryID: 40))
    .on( next: { print($0.name) } )
    .start()
```

<hr/>

Like you I created a struct, `APITarget`, that mirrors my own `APITargetType: TargetType` protocol. Then, `APITarget` adopts `SignalProducerType`.

I extended `ReactiveCocoaMoyaProvider` with `mapDecodable()` (similar to `mapJSON()`) for targets which are `APITargetType`, and I'm able to parse results using the associated type on `APITargetType` (`typealias ParsedType`). `APITarget` creates instances of `ReactiveCocoaMoyaProvider` based on the `APITargetType` it's given.

```
public struct APITarget<T: APITargetType where T.ParsedType: Decodable, T.ParsedType.DecodedType == T.ParsedType> {
    let provider: ReactiveCocoaMoyaProvider<T> = ReactiveCocoaMoyaProvider()
    let target: T
    public init(_ target: T) {
        self.target = target
    }
}
```

<hr/>
  This is very interesting but wouldn't this mean that a Target could only map to one type of response. Wouldn't you need to create an extension for every single endpoint?
 I think the best way to handle response parsing is by extending the SignalProducerType, similarly to what we do in [SignalProducer+Moya](https://github.com/Moya/Moya/blob/master/Source/ReactiveCocoa/SignalProducer%2BMoya.swift), or by creating a global function.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=45f8c18e0ec8ff7874e249eab057818fb6412912) is `85.20%`

> Merging **#346** into **master** will increase coverage by **+85.20%** as of [`45f8c18`](https://codecov.io/github/Moya/Moya/commit/45f8c18e0ec8ff7874e249eab057818fb6412912)

``` diff
@@            master   #346   diff @@
=====================================
  Files            3     13    +10
  Stmts           51    473   +422
  Branches         0      0       
  Methods                         
=====================================
+ Hit              0    403   +403
  Partial          0      0       
- Missed          51     70    +19
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/d4e551b32cea3e8377a1e3da6b5a339247d1dd8f...45f8c18e0ec8ff7874e249eab057818fb6412912) as of [`45f8c18`](https://codecov.io/github/Moya/Moya/commit/45f8c18e0ec8ff7874e249eab057818fb6412912)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=45f8c18e0ec8ff7874e249eab057818fb6412912)
1. `+1.69%` via [Source/Result.swift#48...55](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=45f8c18e0ec8ff7874e249eab057818fb6412912#48) 
2. `+1.26%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=45f8c18e0ec8ff7874e249eab057818fb6412912#76) 
3. `+1.26%` via [Source/Result.swift#93...98](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=45f8c18e0ec8ff7874e249eab057818fb6412912#93) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=45f8c18e0ec8ff7874e249eab057818fb6412912)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  Sadly there is not notion of sub-libraries for Carthage so we can't do the same thing as cocoapods. There is, as far as I know, no way around not building all schemes in a project with Carthage. The solutions you bring up do work but as you indicated they are not ideal. 

It is time consuming to build but you can version control it to not have to build it everytime you checkout your repo. 
 Hey @petester42 -- curious if this could be re-evaluated (though not opening a new issue for it).

I understand that carthage has submodule limitations, but my last `carthage bootstrap --platform iOS` build took `15m11.546s` as it built schemes for:
- `Alamofire iOS`
- `RxBlocking-iOS`
- `RxTests-iOS`
- `RxCocoa-iOS`
- `RxSwift-iOS`
- `Moya iOS`
- `ReactiveMoya iOS`

but, as our app only uses vanilla Moya, we only needed to build schemes for:
- `Alamofire iOS`
- `Moya iOS`

and I imagine skipping the other 5 frameworks would reduce this time significantly.

Adding version control to not build is only a work around for `carthage update` (and, not ideal to ignore on our repo).
So version control or not, a 15 minute build time makes [Fastlane](https://fastlane.tools/) completely unusable on dev machines, as it doesn't use `carthage update` to build.

I have yet to play around with forks, but is there still no solution to this? Would removing `ReactiveCocoa/ReactiveCocoa` and `ReactiveX/RxSwift` from the `Cartfile` (and letting users add them when they need it) completely break the vanilla build?

I'd love more insight on this, and to be able to help out with finding a solution. Otherwise, our alternative is either managing a private fork of Moya, or dropping it entirely (as Pods is not a technical option for this app).
 Sadly there is no way to build only certain targets using Carthage. You could just do `carthage checkout` and manually link your dependencies. This is what reactive cocoa does for their project I believe. Might reduce build times. 

Why are pods not an option? (Just curious)
 The only "real" fix for this is to have separate repos but we decided to not go that way in the past since it adds a lot of complexity for 2 extra files. 
 Yeah -- multiple repos is way out of the question.

Thanks for the quick responses, y'all. You're all a super friendly and
helpful bunch :)

I'll be looking at other ways to bring moya in before going with more
drastic measures.

And we can't use pods with any swift libraries at the moment. We have a
required dependency that's very pick with who it plays with. Though, moving
that around might be a solution we will look more into.
On Fri, Feb 12, 2016 at 4:30 PM Ash Furrow notifications@github.com wrote:

> Correct ‚Äì we tried multiple repos but it got out of hand, quickly. Moya
> was created as a CocoaPod, and the Carthage support we have today was added
> after the fact by volunteer contributors (we're very grateful). The
> Carthage team has been asked for a subspec-like feature to accommodate
> this, but they have decline (it's antithetical to how they believe
> libraries should be built).
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Moya/Moya/issues/345#issuecomment-183494797.
  The update to ReactiveCocoa 4 RC1 fixes the reactive cocoa issues. The RxSwift issue still happens but I'm pretty sure its on their side now.
 @mpurland yes it did. thanks. The same issue is happening with RxSwift but I sent them a fix.
 This should be good to go with the update to rxswift :tada: 
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=b9d6799abb6de2a1dfd4a4afbf2b584f4ac69bf3) is `91.30%`

> Merging **#344** into **master** will increase coverage by **+6.10%** as of [`b9d6799`](https://codecov.io/github/Moya/Moya/commit/b9d6799abb6de2a1dfd4a4afbf2b584f4ac69bf3)

``` diff
@@            master   #344   diff @@
=====================================
  Files           13     13       
  Stmts          473    437    -36
  Branches         0      0       
  Methods                         
=====================================
- Hit            403    399     -4
  Partial          0      0       
+ Missed          70     38    -32
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/2d2b0ae8fdcaafc0d08e78e42dc2854d13de560a...b9d6799abb6de2a1dfd4a4afbf2b584f4ac69bf3) as of [`b9d6799`](https://codecov.io/github/Moya/Moya/commit/b9d6799abb6de2a1dfd4a4afbf2b584f4ac69bf3)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=b9d6799abb6de2a1dfd4a4afbf2b584f4ac69bf3)
1. `+1.37%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=b9d6799abb6de2a1dfd4a4afbf2b584f4ac69bf3#76) 
2. `+1.14%` via [...+ReactiveCocoa.swift#54...58](https://codecov.io/github/Moya/Moya/Source/ReactiveCocoa/Moya+ReactiveCocoa.swift?ref=b9d6799abb6de2a1dfd4a4afbf2b584f4ac69bf3#54) 
3. `+1.14%` via [Source/Moya.swift#177...181](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=b9d6799abb6de2a1dfd4a4afbf2b584f4ac69bf3#177) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=b9d6799abb6de2a1dfd4a4afbf2b584f4ac69bf3)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=7e37680a7adab755db8df3309cec6bd2f45c9a3d) is `85.20%`

> Merging **#343** into **master** will increase coverage by **+85.20%** as of [`7e37680`](https://codecov.io/github/Moya/Moya/commit/7e37680a7adab755db8df3309cec6bd2f45c9a3d)

``` diff
@@            master   #343   diff @@
=====================================
  Files            3     13    +10
  Stmts           51    473   +422
  Branches         0      0       
  Methods                         
=====================================
+ Hit              0    403   +403
  Partial          0      0       
- Missed          51     70    +19
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/d4e551b32cea3e8377a1e3da6b5a339247d1dd8f...7e37680a7adab755db8df3309cec6bd2f45c9a3d) as of [`7e37680`](https://codecov.io/github/Moya/Moya/commit/7e37680a7adab755db8df3309cec6bd2f45c9a3d)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=7e37680a7adab755db8df3309cec6bd2f45c9a3d)
1. `+1.69%` via [Source/Result.swift#48...55](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=7e37680a7adab755db8df3309cec6bd2f45c9a3d#48) 
2. `+1.26%` via [...ource/Response.swift#76...81](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=7e37680a7adab755db8df3309cec6bd2f45c9a3d#76) 
3. `+1.26%` via [Source/Result.swift#93...98](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=7e37680a7adab755db8df3309cec6bd2f45c9a3d#93) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=7e37680a7adab755db8df3309cec6bd2f45c9a3d)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  great. thanks
  Having an empty path is fine. Wouldn't it be better to set "rest" as the path and "https://api.flickr.com/services" as the base url. That seems to be the intent that you want to describe. 
 I like to define my API as explicitly has possible. If I have to make an empty path then maybe I didn't use the proper baseURL. Hope that helps.
  Now that Moya has a Result type, it isn't possible to use Result's Result type in a file that imports Moya
Same thing as happened when Alamofire added a Result type

Might it be better to just add Result as a dependency? It's quite a small/stable one, and unlike usual dependencies, it's _less_ troublesome to the end user..
 There is a technical reason we can't. Since alamofire uses its own result we can't use the standard result library because we need to namespace it. Sadly you can't do `Result.Result` as a type for the completion block. Compiler no like. 

Is there a thing like `hiding` in Haskell for swift that I don't know of?
 Unfortunately as @petester42 mentions, Result.Result doesn't work because of an ongoing Swift quirk where you cant explicitly access a type that has the same name as its module.

So, Moya.Result can be access inferred or explicitly, but if Moya is imported in a file, inferred use of Result is ambiguous/won't compile, but Result.Result can't be accessed either.

And there's no `hiding` or such, as far as I know :(

It's a weird position to be in, because this could be fixed in the language tomorrow, or.. not tomorrow. I personally think it's worth integrating the defacto Result.Result, but I haven't been bitten by adding a dep to a large OSS library before.
 As for your original issue. You can use Result's Result type just prefix the Moya one like so `Moya.Result` where the two clash. 
 Moya.Result makes it so _those_ uses are unambiguous. It doesn't make it so I can use Result.Result. Those instances are still ambiguous (because can't prefix).
 Little busy atm, but should be able to some time this week. Perhaps that will also give some time for others (@Moya/contributors), if anyone has strong opinions about additional dependencies, to chime in.
 You might need to do some hacks to make it work. I tried added this dependency when we moved to result but the compiler was not happen. Maybe moving the completion typealias to another file would work. Any file with `import Alamofire` will cause issues. 
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=3bbd0e9c60ab54f2149b4e815de335f971a93945) is `84.84%`

> Merging **#337** into **master** will not affect coverage as of [`3bbd0e9`](https://codecov.io/github/Moya/Moya/commit/3bbd0e9c60ab54f2149b4e815de335f971a93945)

``` diff
@@            master    #337   diff @@
======================================
  Files           13      13       
  Stmts          640     640       
  Branches         0       0       
  Methods          0               
======================================
  Hit            543     543       
  Partial          0       0       
  Missed          97      97       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/e069bc22e28b2d69cfcfbbae3cb15304d112fbd6...3bbd0e9c60ab54f2149b4e815de335f971a93945) as of [`3bbd0e9`](https://codecov.io/github/Moya/Moya/commit/3bbd0e9c60ab54f2149b4e815de335f971a93945)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=3bbd0e9c60ab54f2149b4e815de335f971a93945)
1. `+2.50%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=3bbd0e9c60ab54f2149b4e815de335f971a93945#53) 
2. `+1.72%` via [Source/Result.swift#38...48](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=3bbd0e9c60ab54f2149b4e815de335f971a93945#38) 
3. `+1.25%` via [...ource/Response.swift#75...82](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=3bbd0e9c60ab54f2149b4e815de335f971a93945#75) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=3bbd0e9c60ab54f2149b4e815de335f971a93945)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 ![Giphy](http://media4.giphy.com/media/79elBnxwhhF4s/giphy.gif) ![Giphy](http://media4.giphy.com/media/11Tt46u0HZUNzi/giphy.gif) ![Giphy](http://media2.giphy.com/media/ssbwG56QXnppm/giphy.gif) ![Giphy](http://media0.giphy.com/media/veWnAHJh8007K/giphy.gif)
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=47bc7264b1f92e967e279c673fad405d3ef2ef9e) is `84.84%`

> Merging **#336** into **master** will not affect coverage as of [`47bc726`](https://codecov.io/github/Moya/Moya/commit/47bc7264b1f92e967e279c673fad405d3ef2ef9e)

``` diff
@@            master    #336   diff @@
======================================
  Files           13      13       
  Stmts          640     640       
  Branches         0       0       
  Methods          0               
======================================
  Hit            543     543       
  Partial          0       0       
  Missed          97      97       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/e069bc22e28b2d69cfcfbbae3cb15304d112fbd6...47bc7264b1f92e967e279c673fad405d3ef2ef9e) as of [`47bc726`](https://codecov.io/github/Moya/Moya/commit/47bc7264b1f92e967e279c673fad405d3ef2ef9e)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=47bc7264b1f92e967e279c673fad405d3ef2ef9e)
1. `+2.50%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=47bc7264b1f92e967e279c673fad405d3ef2ef9e#53) 
2. `+1.72%` via [Source/Result.swift#38...48](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=47bc7264b1f92e967e279c673fad405d3ef2ef9e#38) 
3. `+1.25%` via [...ource/Response.swift#75...82](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=47bc7264b1f92e967e279c673fad405d3ef2ef9e#75) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=47bc7264b1f92e967e279c673fad405d3ef2ef9e)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Want to hit that merge button @mpurland?
  my cartfile:

```
github "Alamofire/Alamofire"
github "ReactiveX/RxSwift" "2.0.0-beta.4"
github "Moya/Moya" "5.1.0"
```

When I update carthage, it shows:

```
Could not pick a version for github "ReactiveX/RxSwift", due to mutually incompatible requirements:
    "2.0.0-beta.4"
    "2.0.0-beta.2"
```

However, if I remove `"5.1.0"` of Moya, it will checkout `Moya 4.1.0`
 Hi ashfurrow,

It still doesn't work. I've tried these cases so far

```
cartfile:
github "Moya/Moya"

*** Checking out RxSwift at "2.0.0-beta.2"
*** Checking out Moya at "5.1.0"
```

```
cartfile:
github "Alamofire/Alamofire"
github "ReactiveX/RxSwift" "2.0.0-beta.4"
github "Moya/Moya"

*** Checking out Alamofire at "3.1.3"
*** Checking out Moya at "4.1.0"
*** Checking out RxSwift at "2.0.0-beta.4"
```

```
cartfile:
github "Alamofire/Alamofire"
github "ReactiveX/RxSwift" "2.0.0-beta.4"
github "Moya/Moya" "5.1.0"

Could not pick a version for github "ReactiveX/RxSwift", due to mutually incompatible requirements:
    "2.0.0-beta.4"
    "2.0.0-beta.2"
```
  We're using Moya throughout most of our apps. One feature we're missing is sending extra parameters together with the token.

We're using the `ReactiveCocoaMoyaProvider`, which simply accepts sending a token conform the MoyaTarget protocol.

It would be great to send the request with an extra value parameters, in which we can sending optional parameters specific for some of the API calls.

The scenario we're using it for is pagination. Some API calls accept pagination with parameters "offset" and "limit", which we want to send like this:

`MyProvider.request(token: Target, extraParameters: ["offset": 0, "limit": 15])`

Any suggestion in how to set this up with the current version of Moya is welcome, else we would like to send this as a feature request.
 The thing is, we're using Moya the same as the Artsy project, using Enums. These can't contain stored properties.

The way I'm now doing this is by creating a seperated class conforming the MoyaTarget protocol, in which I'm copying the properties of the Enum and adding the extra parameters as you describe.

It just doesn't feels like the way it should be done.
 I agree, this should be the way to do this. Downside of this, is that I have multiple calls like:

`case getMovies
case getSeries
case getCollection(collectionId:Int)`

Which are all `pageable`. 

I was hoping to create a generic solution to call these targets, with the paging logic handled by a seperated paging class:

```
final class PageableOperation {

    private let endpoint:ExampleAPI

    init(endpoint:ExampleAPI){
        self.endpoint = endpoint
    }

    func pagingSignalWithOffset(offset:Int, limit:Int) -> RACSignal {

        var parameters = self.endpoint.parameters as [String : AnyObject]

        parameters["offset"] = offset
        parameters["limit"] = limit

        return TIFProvider.request(self.endpoint, parameters: parameters)
    }
}
```

But I guess I'll go for a datasource implementation, which should send back a new paging signal based on the given offset and limit. Seems to be OK for this as well.

If you have any other suggestions, feel free to let me know!
 @AvdLee i am having very similar issues / concerns. i am currently a struct called pagination that encapsulates the page # calculation based on current offset/perpage, amongst other things.

Do you mind sharing a gist of your datasource implementation when you are done? I would love to get some inspiration.
  Since all my calls to the API needs to add custom headers, theres an easy way to avoid this?

``` swift
var endpointClosure = { (target: TestApi) -> Endpoint<TestApi> in
    let endpoint: Endpoint<TestApi> = Endpoint<TestApi>(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
    switch target {
    case .Customers(let u, let p):
        let credentialData = "\(u):\(p)".dataUsingEncoding(NSUTF8StringEncoding)!
        let base64Credentials = credentialData.base64EncodedStringWithOptions([])
        return endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Basic \(base64Credentials)"])
    case .Properties(let u, let p):
        let credentialData = "\(u):\(p)".dataUsingEncoding(NSUTF8StringEncoding)!
        let base64Credentials = credentialData.base64EncodedStringWithOptions([])
        return endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Basic \(base64Credentials)"])
    }
   case .Other(let user, password):
      //repeat the same... :-1: 
}
```
 <img width="891" alt="captura de pantalla 2015-12-07 a las 16 14 43" src="https://cloud.githubusercontent.com/assets/15628215/11630399/a8a652d2-9cfd-11e5-83b3-8bfa42be759c.png">
 For now i can leave like this: :-1:    

``` swift
switch target {
    case .Customers(let u, let p):
        return endPointWithAuthHeader(u, p: p, endpoint: endpoint)
    case .Properties(let u, let p):
        return endPointWithAuthHeader(u, p: p, endpoint: endpoint)
    case .Login(let u, let p):
        return endPointWithAuthHeader(u, p: p, endpoint: endpoint)
    }
}

func endPointWithAuthHeader(u: String, p:String, endpoint: Endpoint<NextVisitApi>) -> Endpoint<NextVisitApi> {
        let credentialData = "\(u):\(p)".dataUsingEncoding(NSUTF8StringEncoding)!
        let base64Credentials = credentialData.base64EncodedStringWithOptions([])
        return endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Basic \(base64Credentials)"])
}
```
 How can i add it without retreiving the username/password?
 When i call the endPoint i pass a username/password stored in disk. Then i add those to the header. I dont want to retreive those directly from here. I have a  'user repository' where i store them.
 Ok thx you!
  ``` Cartfile
github "moya/moya"
```

installs 4.0.2

expected: 5.1.0

I want a warning message at README.md.
 Resolved!!! Thanks All!
  I want to parse the response of Moya into a Model with objectmapper.
Basically i want to transform this:

```
func getCustomers(user: User, callback: Result<[Customer], NetworkStatus> -> ()) {
    _ = apiProvider.request(Api.Customers(userString: user.userName, passwordString: user.password)).subscribe { (event) -> Void in
        switch event {
        case .Next(let response):
            if let customersJSON = (try? response.mapJSON() as? NSArray) {
                let customers = Mapper<Customer>().mapArray(customersJSON)!
                callback(Result(success: customers))
                return
            }
            callback(Result(failure: NetworkStatus.Other))
        case .Error(_):
            callback(Result(failure: NetworkStatus.Server))
        case .Completed:
            break
        }
    }
}
```

Into this:

```
    func getCustomersRx(user: User) -> Observable<[Customer]> {
    let apiResponse = apiProvider.request(Api.Customers(userString: user.userName, passwordString: user.password))
    apiResponse.map { response in
        do {
            if  let customersJSON: NSArray? = try response.mapJSON() as? NSArray {
                return Mapper<Customer>().mapArray(customersJSON)!
            }
        } catch {
            fatalError()
        }
    }
```

And i get this error in the .map line:
Cannot invoke 'map' with an argument list of type '(Response throws -> _)'
The problem seems with .mapJSON wich can throw an error, but i dont know how to continue
 And its weird to me that if i do in one line forcing everything seems working:
Works:
![captura de pantalla 2015-12-04 a las 11 51 58](https://cloud.githubusercontent.com/assets/15628215/11587985/a68bbde8-9a7d-11e5-9eb0-02d00a8f746f.png)

Dont work:
![captura de pantalla 2015-12-04 a las 11 52 18](https://cloud.githubusercontent.com/assets/15628215/11587986/a6961004-9a7d-11e5-85cf-b83aee80527f.png)
 Yes, as you said you had to explicy set the return type. If anyone interested:  
func getCustomers() -> Observable<[Customer]> {
        return TestApiProvider.request(TestApi.Customers).map { response -> [Customer]  in
            do {
                if  let customersJSON: NSArray? = try response.mapJSON() as? NSArray {
                    if let customers = Mapper<Customer>().mapArray(customersJSON) {
                        return customers
                    }
                    throw CustomError.ParseError
                }
            } catch {
                throw CustomError.ServerError
            }
        }
    }

```
enum CustomError: ErrorType {
    case ParseError
    case ServerError
}
```
  I've been dabbling with this for the past hour... Does anyone have any idea how we would split up `ReactiveMoya` and `RxMoya`? I know we just went through this for Carthage, but I think this deserves the same amount of scrutiny.

In the current state, as per the `swift-package-manager` documentation, the sources in the `Plugins/`, `ReactiveCocoa/` and `RxSwift/` directories will be compiled as separate modules, named as their directories specify. I've attempted to embed `Package.swift` files within each subdirectory, but it doesn't work due to file name collisions.

**EDIT** I'm going to try this after lunch, but I think it might be possible if we split everything up into targets and specify the dependencies in `Package.swift`.

FWIW: https://github.com/apple/swift-package-manager/blob/master/Documentation/DevelopingPackages.md#working-on-apps-and-packages-side-by-side
 I think that specifying targets would be the way to go just like the example from (`Package.swift` documentation)[https://github.com/apple/swift-package-manager/blob/master/Documentation/Package.swift.md] . Don't know if that will cause the targets that depend on the "core" target to need to have `import Moya` in their source code.
 @swizzlr True, but that would then break our CocoaPods and Carthage integrations.

TBH, I think this is the way to go. I know that the `RAC` and `Rx` extensions are supposed to be subspecs, but in reality, they're extensions of the library. They're built on top of it, very similarly to how Apple built the dealer example libraries. 
 I currently use cocoapods to integrate Moya in my projects, but subspecs are basically a proprietary notion and the library needs to be easily usable for everyone without them (and without simultaneously requiring Rx and RAC for all users, obviously).

+1 for breaking out the extensions, in the absence of any other apparent solution.
 @tomburns That's a good point. The Swift package manager is going to be distributed with all versions of Swift and Xcode in the future. There's no 3rd party software to be installed like there is with `CocoaPods` and `Carthage`. Someone who says that `Moya` is a dependency in their `Package.swift` file should not be required to also import `ReactiveCocoa` or `RxSwift` into their project if they don't use it, which they're required to do now with `Carthage`. 
 Nice; that'll be great if it makes it in. My major point in the previous comment was that we should probably make good support for the pending first-party package manager our top priority, even if it involves some additional overhead. If we can pull off the current structure in SPM, so much the better.
 Hi, 

I went through all discussions (https://github.com/Moya/Moya/pull/169, https://github.com/Moya/Moya/pull/215) regarding multi repo setup / carthage / cocoapods and so on. But I still don¬¥t get the point why it¬¥s such a mess to break out Moya¬¥s reactive extensions from the core library. 

TBH the reactive stuff is _nothing more_  (like @justinmakaila and @swizzlr pointed out) than convenient extensions of the core library. Why can¬¥t we treat them like the other [Community extensions](https://github.com/Moya/Moya#community-extensions) and keep things simple? I think that approach would work for Carthage, CocoaPods and SPM. 

I am a Carthage user and I am using Moya together with ReactiveCocoa in _every_ project. I like it. But I don¬¥t like to include dependencies I am actually not using (RxSwift), and I am sure RxSwift users don¬¥t like to wait for ReactiveCocoa to build, when updating their dependencies (what happens often caused by e.g. a new Xcode release, Moya release, ReactiveCocoa release, RxSwift release, ....). If you checkout the [Changelog](https://github.com/Moya/Moya/blob/master/Changelog.md) every second release of Moya just updates it¬¥s dependency to external libraries. Maybe this is caused by the nature of external dependencies but why should pure Moya users care about an updated ReactiveCocoa or RxSwift? Why should a ReactiveCocoa user care about RxSwift updates? They have to deal with issues caused by a library they are not using. 

IMHO since everything is moving so fast with new releases, its worth the multi repo tradeoff to make developers everyday life easier / increasing (minimal) maintenance effort for contributors. Maybe I¬¥m not experienced enough to catch all implications of moving the extensions to external repos but I can only report that I nearly always run into issues with Moya when updating my dependencies. 

Sorry for reigniting this discussion üôÉ‚úåüèº
 @aloco I'm all for that. When Xcode 7.3 dropped, I had serious issues building Moya due to dependencies not yet being updated. It's a huge hassle, especially when the dependencies that are causing issues aren't used in the project.
  Pushed to trunk
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=d76a93afad0f00911471649107e5faab10b2432d) is `84.84%`

> Merging **#329** into **master** will not affect coverage as of [`d76a93a`](https://codecov.io/github/Moya/Moya/commit/d76a93afad0f00911471649107e5faab10b2432d)

``` diff
@@            master    #329   diff @@
======================================
  Files           13      13       
  Stmts          640     640       
  Branches         0       0       
  Methods          0               
======================================
  Hit            543     543       
  Partial          0       0       
  Missed          97      97       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/117af026df08d006aaac317c92294ebb9d5dffd1...d76a93afad0f00911471649107e5faab10b2432d) as of [`d76a93a`](https://codecov.io/github/Moya/Moya/commit/d76a93afad0f00911471649107e5faab10b2432d)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=d76a93afad0f00911471649107e5faab10b2432d)
1. `+2.50%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=d76a93afad0f00911471649107e5faab10b2432d#53) 
2. `+1.72%` via [Source/Result.swift#38...48](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=d76a93afad0f00911471649107e5faab10b2432d#38) 
3. `+1.25%` via [...ource/Response.swift#75...82](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=d76a93afad0f00911471649107e5faab10b2432d#75) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=d76a93afad0f00911471649107e5faab10b2432d)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 the problem that I've encountered with the prebuilt binaries from Carthage is that when a new version of swift/Xcode comes out it has to be recompiled right now. I saw myself using the "-no-use-binaries" option a lot to circumvent that since even though the source didnt have errors it just doesn't work and has to be rebuilt. 

Right now I would advise against distributing prebuilt binaries until that problem with swift is solved.
  See issue #326 
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=0e743ca46f6d68a346377788b4f9a8bb94baa8d5) is `84.63%`

> Merging **#328** into **master** will decrease coverage by **-0.21%** as of [`0e743ca`](https://codecov.io/github/Moya/Moya/commit/0e743ca46f6d68a346377788b4f9a8bb94baa8d5)

``` diff
@@            master    #328   diff @@
======================================
  Files           13      13       
  Stmts          640     651    +11
  Branches         0       0       
  Methods          0               
======================================
+ Hit            543     551     +8
  Partial          0       0       
- Missed          97     100     +3
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/117af026df08d006aaac317c92294ebb9d5dffd1...0e743ca46f6d68a346377788b4f9a8bb94baa8d5) as of [`0e743ca`](https://codecov.io/github/Moya/Moya/commit/0e743ca46f6d68a346377788b4f9a8bb94baa8d5)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=0e743ca46f6d68a346377788b4f9a8bb94baa8d5)
1. `+2.46%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=0e743ca46f6d68a346377788b4f9a8bb94baa8d5#53) 
2. `+1.69%` via [Source/Result.swift#38...48](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=0e743ca46f6d68a346377788b4f9a8bb94baa8d5#38) 
3. `+1.23%` via [...ource/Response.swift#75...82](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=0e743ca46f6d68a346377788b4f9a8bb94baa8d5#75) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=0e743ca46f6d68a346377788b4f9a8bb94baa8d5)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Close this PR,  create a new branch in my local repo and then create a PR?
 @wangshengjia I've used my local repo in a new project and everything works fine.
 @wangshengjia Credential is the missing part and I am working on it.
 @ashfurrow Alter the changelog and make a PR?
 It seems that separating two kinds of plugins (ordinary plugins and plugins used to change requests) is a much more appropriate way to solve this bug since almost no related point is exposed by Alamofire.
  I conformed PluginType to intercept the request, the `NetworkLoggerPlugin` do logged the changes I've made. However, I can see nothing changed in outgoing requests through Charles app.

Here is my code:

``` swift
// Plugin
struct InterceptPlugin: PluginType {
  func willSendRequest(request: RequestType, target: TargetType) {
    (request.request as? NSMutableURLRequest)?.allHTTPHeaderFields = ["Hello": "World"]
    (request.request as? NSMutableURLRequest)?.HTTPBody = "RxMoya".dataUsingEncoding(NSUTF8StringEncoding)
  }

  func didReceiveResponse(result: Result<Response, Error>, target: TargetType) {

  }
}

// Provider

lazy var provider: RxMoyaProvider<HTTPBin> = {
    return RxMoyaProvider<HTTPBin>(plugins: [InterceptPlugin(), NetworkLoggerPlugin()])
}()

```
 I've printed the request and the mutable request do exist. 

``` swift
print(request.request)           // Optional(<NSMutableURLRequest: 0x7fa0fbf12e30> { URL: http://httpbin.org/post })
print(request.request != nil)    // true
```

This is what the logger logged:

```
["Moya_Logger: [02/12/2015 05:53:18] Request: <NSMutableURLRequest: 0x7fd5134ae1c0> { URL: http://httpbin.org/post }", "Moya_Logger: [02/12/2015 05:53:19] Request Headers: [\"Content-Type\": \"application/x-www-form-urlencoded; charset=utf-8\", \"Hello\": \"World\"]", "Moya_Logger: [02/12/2015 05:53:19] HTTP Request Method: POST"]
```
 Yes, the workaround in issue [#325](https://github.com/Moya/Moya/issues/325#issuecomment-161039326)  can be used to solve my interception problem.

~~And I think the solution of the plugin interception is to pause the request in the initializer of `MoyaProvider` by setting property `startRequestsImmediately` of the Alamofire manager to `false`. And then resume the request after enumerating plugins in `sendRequest(_:request:completion:)` of `MoyaProvider`.~~

The `NSURLRequest` objects have been wrapped into Alamofire request before `willSendRequest(_:target:)` has been invoked. And the process of wrapping (`manager.request(request)`) should happen after plugins finish process the raw requests.
 Never notice the `requestClosure` ever before. Let me have a try on it.
 @ashfurrow Resolved.
  I want to add to my headers a credentials, so i created an endpoint:

```
var endpointClosure = { (target: TestApi) -> Endpoint<TestApi> in
    let endpoint: Endpoint<TestApi> = Endpoint<TestApi>(URL: url(target), sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
     let credentialData = "userString:passwordString".dataUsingEncoding(NSUTF8StringEncoding)!
     let base64Credentials = credentialData.base64EncodedStringWithOptions([])
     return endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Basic \(base64Credentials)"])
}
```

And then i created my provider:

```
let TestApiProvider = MoyaProvider<TestApi>(endpointClosure: endpointClosure)
enum TestApi {
     case Login
}
```

How can i'm supposed to pass parameters to my closure to provide userString and passwordString? 
I created a [GIST](https://gist.github.com/ivanruizscm/6f0d90bd8b39beec707e) with the code, basically in my viewController im calling a function with an user and pass  
    func testLogin(user: String, password: String) {  
And i need to provide those string to my header.
 Nope, i want to pass those parameters to my endpointClosure cause i need to modify my headers
See my endPointClousure which uses      "userString" and "passwordString"
    let credentialData = "userString:passwordString".dataUsingEncoding(NSUTF8StringEncoding)!
 Awesome! 
Edit suggest: case .Login 
 @ashfurrow Just curious if this is still the best solution doing HTTP Basic Auth with Moya. Didn't found a way to set `NSURLAuthenticationMethodHTTPBasic`

Is it correct that I can't use the credentialsPlugin doing this? 

Thanks
 @ashfurrow  Alright, thank you for your fast response!
  URGH! Don't know why this intermittently fails seems like #259 is still an issue. Whenever it fails it happens to be the `uses a custom Alamofire.Manager for session challenges` test that fails.
 You think its a quick thing or a travis thing?
 I had done it already. cross your finger lol
 nope. :cry: 
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=1113bf800d14d5f44f91b96268cf7912fbd7ed6c) is `84.84%`

> Merging **#324** into **master** will not affect coverage as of [`1113bf8`](https://codecov.io/github/Moya/Moya/commit/1113bf800d14d5f44f91b96268cf7912fbd7ed6c)

``` diff
@@            master    #324   diff @@
======================================
  Files           13      13       
  Stmts          640     640       
  Branches         0       0       
  Methods          0               
======================================
  Hit            543     543       
  Partial          0       0       
  Missed          97      97       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/e069bc22e28b2d69cfcfbbae3cb15304d112fbd6...1113bf800d14d5f44f91b96268cf7912fbd7ed6c) as of [`1113bf8`](https://codecov.io/github/Moya/Moya/commit/1113bf800d14d5f44f91b96268cf7912fbd7ed6c)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=1113bf800d14d5f44f91b96268cf7912fbd7ed6c)
1. `+2.50%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=1113bf800d14d5f44f91b96268cf7912fbd7ed6c#53) 
2. `+1.72%` via [Source/Result.swift#38...48](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=1113bf800d14d5f44f91b96268cf7912fbd7ed6c#38) 
3. `+1.25%` via [...ource/Response.swift#75...82](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=1113bf800d14d5f44f91b96268cf7912fbd7ed6c#75) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=1113bf800d14d5f44f91b96268cf7912fbd7ed6c)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  I have installed Moya trought Cocoapods in a new fresh project.
And im getting an error when i try to subclass my enum. (Use of undeclared TargetType).

ivangodfather
<img width="1046" alt="captura de pantalla 2015-11-30 a las 16 28 53" src="https://cloud.githubusercontent.com/assets/15628215/11475845/cf7283f0-977f-11e5-9f0e-115e5896912b.png">
-> pod install
Updating local specs repositories
Analyzing dependencies
Downloading dependencies
Using Alamofire (3.1.3)
Installing Moya 4.5.0 (was 4.5.0)
Installing RxSwift (2.0.0-beta.3)
Generating Pods project
Integrating client project
Sending stats
Pod installation complete! There are 2 dependencies from the Podfile and 3 total
pods installed.
 For 4.5 it is still called `MoyaTarget`. Sorry about the confusion in documentation but we are getting ready for 5.0 which should be out real soon. 
 Ok! Fixed. Waiting for it. Theres a branch for 5.0 so i dont have to rename it later?
 Master is the branch for 5.0. Setting `:git =>` in your podfile to this repos url should get you 5.0. 
 Still getting 4.5.0 with this repo url.

```
ivan.ruiz$ pod update
Update all pods
Updating local specs repositories
Analyzing dependencies
Pre-downloading: `Moya` from `https://github.com/Moya/Moya`
Removing RxSwift
Downloading dependencies
Using Alamofire (3.1.3)
Installing Moya 4.5.0 (was 4.5.0)
Generating Pods project
Integrating client project
Sending stats
Pod installation complete! There is 1 dependency from the Podfile and 2 total
pods installed.
AFE0806015:TestingMoya ivan.ruiz$ cat Podfile
# Uncomment this line to define a global platform for your project
# platform :ios, '8.0'
# Uncomment this line if you're using Swift
use_frameworks!

target 'TestingMoya' do
    pod 'Moya', :git => 'https://github.com/Moya/Moya'
end

target 'TestingMoyaTests' do

end

target 'TestingMoyaUITests' do

end
```
 Ah ya my mistake. The podspec probably was still pointing to 4.5. Anyways the update should be available shortly. @ashfurrow is currently releasing it.
 Yes, now points to 5.0.0 
Thank you all
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=86bd4051b755bd85fc39a79d5606cd30be9baa61) is `84.84%`

> Merging **#321** into **master** will not affect coverage as of [`86bd405`](https://codecov.io/github/Moya/Moya/commit/86bd4051b755bd85fc39a79d5606cd30be9baa61)

``` diff
@@            master    #321   diff @@
======================================
  Files           13      13       
  Stmts          640     640       
  Branches         0       0       
  Methods                          
======================================
  Hit            543     543       
  Partial          0       0       
  Missed          97      97       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/76e312e06816c1f0931168cb9e8ecb8edd7840d3...86bd4051b755bd85fc39a79d5606cd30be9baa61) as of [`86bd405`](https://codecov.io/github/Moya/Moya/commit/86bd4051b755bd85fc39a79d5606cd30be9baa61)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=86bd4051b755bd85fc39a79d5606cd30be9baa61)
1. `+2.50%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=86bd4051b755bd85fc39a79d5606cd30be9baa61#53) 
2. `+1.72%` via [Source/Result.swift#38...48](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=86bd4051b755bd85fc39a79d5606cd30be9baa61#38) 
3. `+1.25%` via [...ource/Response.swift#75...82](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=86bd4051b755bd85fc39a79d5606cd30be9baa61#75) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=86bd4051b755bd85fc39a79d5606cd30be9baa61)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=4c3b41e77eb7d7e3bb62758bdda67806a8d84135) is `84.84%`

> Merging **#320** into **master** will not affect coverage as of [`4c3b41e`](https://codecov.io/github/Moya/Moya/commit/4c3b41e77eb7d7e3bb62758bdda67806a8d84135)

``` diff
@@            master    #320   diff @@
======================================
  Files           13      13       
  Stmts          640     640       
  Branches         0       0       
  Methods                          
======================================
  Hit            543     543       
  Partial          0       0       
  Missed          97      97       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/a6f72754540039295ea6f314752db6a4cf6fad42...4c3b41e77eb7d7e3bb62758bdda67806a8d84135) as of [`4c3b41e`](https://codecov.io/github/Moya/Moya/commit/4c3b41e77eb7d7e3bb62758bdda67806a8d84135)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=4c3b41e77eb7d7e3bb62758bdda67806a8d84135)
1. `+2.50%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=4c3b41e77eb7d7e3bb62758bdda67806a8d84135#53) 
2. `+1.72%` via [Source/Result.swift#38...48](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=4c3b41e77eb7d7e3bb62758bdda67806a8d84135#38) 
3. `+1.25%` via [...ource/Response.swift#75...82](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=4c3b41e77eb7d7e3bb62758bdda67806a8d84135#75) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=4c3b41e77eb7d7e3bb62758bdda67806a8d84135)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  Attempts to resolve intermittent failures noted on https://github.com/travis-ci/travis-ci/issues/4725
 got my :eyes:  glued to the build, not sure if i implemented it right but we'll see! :green_heart: 
 ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=c3c0d9c4852c505f288cc0c8dd732b59a85ac1f8) is `72.93%`

> Merging **#317** into **master** will not affect coverage as of [`c3c0d9c`](https://codecov.io/github/Moya/Moya/commit/c3c0d9c4852c505f288cc0c8dd732b59a85ac1f8)

``` diff
@@            master    #317   diff @@
======================================
  Files           14      14       
  Stmts          665     665       
  Branches         0       0       
  Methods                          
======================================
  Hit            485     485       
  Partial          0       0       
  Missed         180     180       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/d61650b6acd7665124067c64a410ef1540214174...c3c0d9c4852c505f288cc0c8dd732b59a85ac1f8) as of [`c3c0d9c`](https://codecov.io/github/Moya/Moya/commit/c3c0d9c4852c505f288cc0c8dd732b59a85ac1f8)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=c3c0d9c4852c505f288cc0c8dd732b59a85ac1f8)
1. `+7.37%` via [...rkLoggerPlugin.swift#33...81](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=c3c0d9c4852c505f288cc0c8dd732b59a85ac1f8#33) 
2. `+2.40%` via [Source/Moya.swift#15...30](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=c3c0d9c4852c505f288cc0c8dd732b59a85ac1f8#15) 
3. `+2.40%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=c3c0d9c4852c505f288cc0c8dd732b59a85ac1f8#53) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=c3c0d9c4852c505f288cc0c8dd732b59a85ac1f8)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 :green_heart: 

Can't say that this is conclusive since the original issue is intermittent, but we can merge and find out!
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=f2972eacfb8a72dc908345dc2fabb5a83b54a142) is `72.93%`

> Merging **#316** into **master** will not affect coverage as of [`f2972ea`](https://codecov.io/github/Moya/Moya/commit/f2972eacfb8a72dc908345dc2fabb5a83b54a142)

``` diff
@@            master    #316   diff @@
======================================
  Files           14      14       
  Stmts          665     665       
  Branches         0       0       
  Methods                          
======================================
  Hit            485     485       
  Partial          0       0       
  Missed         180     180       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/ffc52d5a279dbb8d6efbb9316c3e6d8ad7bd899a...f2972eacfb8a72dc908345dc2fabb5a83b54a142) as of [`f2972ea`](https://codecov.io/github/Moya/Moya/commit/f2972eacfb8a72dc908345dc2fabb5a83b54a142)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=f2972eacfb8a72dc908345dc2fabb5a83b54a142)
1. `+7.37%` via [...rkLoggerPlugin.swift#33...81](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=f2972eacfb8a72dc908345dc2fabb5a83b54a142#33) 
2. `+2.40%` via [Source/Moya.swift#15...30](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=f2972eacfb8a72dc908345dc2fabb5a83b54a142#15) 
3. `+2.40%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=f2972eacfb8a72dc908345dc2fabb5a83b54a142#53) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=f2972eacfb8a72dc908345dc2fabb5a83b54a142)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=06a9a488ddcaa298fb524a05f4e195261e21e690) is `72.93%`

> Merging **#315** into **master** will not affect coverage as of [`06a9a48`](https://codecov.io/github/Moya/Moya/commit/06a9a488ddcaa298fb524a05f4e195261e21e690)

``` diff
@@            master    #315   diff @@
======================================
  Files           14      14       
  Stmts          665     665       
  Branches         0       0       
  Methods                          
======================================
  Hit            485     485       
  Partial          0       0       
  Missed         180     180       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/ffc52d5a279dbb8d6efbb9316c3e6d8ad7bd899a...06a9a488ddcaa298fb524a05f4e195261e21e690) as of [`06a9a48`](https://codecov.io/github/Moya/Moya/commit/06a9a488ddcaa298fb524a05f4e195261e21e690)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=06a9a488ddcaa298fb524a05f4e195261e21e690)
1. `+7.37%` via [...rkLoggerPlugin.swift#33...81](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=06a9a488ddcaa298fb524a05f4e195261e21e690#33) 
2. `+2.40%` via [Source/Moya.swift#15...30](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=06a9a488ddcaa298fb524a05f4e195261e21e690#15) 
3. `+2.40%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=06a9a488ddcaa298fb524a05f4e195261e21e690#53) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=06a9a488ddcaa298fb524a05f4e195261e21e690)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 The problem with option 1 is that cocoapods support would be broken. If we want to keep subspecs the way they are then we can't change the source files to using `import Moya` for reactive extensions. If we use option one then I believe that we also will need 3 distinct pods rather than 1 with subspecs. 
  I need to make a POST request with query string and json body. How can I pass each parameters to Moya?
 Thanks, I'll try it!
 Like this?

``` swift
let compositeParameterEncodingClosure: (URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?) = { request, parameters in
    guard let parameters = parameters else {
        return (request.URLRequest, nil)
    }

    let (queryRequest, _) = ParameterEncoding.URL.encode(request, parameters: parameters["query"] as! [String: AnyObject])
    let (bodyRequest, _) = ParameterEncoding.JSON.encode(request, parameters: parameters["body"] as! [String: AnyObject])
    let compositeRequest = queryRequest.mutableCopy() as! NSMutableURLRequest
    compositeRequest.HTTPBody = bodyRequest.HTTPBody
    return (compositeRequest, nil)
}
```
 Thanks!
 The current version of this solution is:

``` swift
let compositeParameterEncodingRequestClosure(endpoint: Endpoint<YourTarget>, closure: NSURLRequest -> Void) -> Void {
    guard let parameters = endpoint.parameters else {
        return closure(endpoint.urlRequest)
    }

    let (queryRequest, _) = ParameterEncoding.URL.encode(endpoint.urlRequest, parameters: (parameters["query"] as! [String: AnyObject]))
    let (bodyRequest, _) = ParameterEncoding.JSON.encode(endpoint.urlRequest, parameters: (parameters["body"] as! [String: AnyObject]))
    let compositeRequest = queryRequest.mutableCopy() as! NSMutableURLRequest
    compositeRequest.HTTPBody = bodyRequest.HTTPBody
    return closure(compositeRequest)
}
```

and use it as the `requestClosure` of your provider.
 I don't know why but I can't build my url with parameter["query"]
ex: url is `example.com`, `parameter["query"] = ["q": "wane"]`
after `ParameterEncoding.URL.encode(endpoint.urlRequest, parameters: (parameters["query"] as! [String: AnyObject]))`
the url will still be `example.com` but not `example.com?q=wane`

I end up change the code to

``` swift
let compositeParameterEncodingClosure: (URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?) = { request, parameters in
    guard let parameters = parameters else {
        return (request.URLRequest, nil)
    }


    let (bodyRequest, _) = ParameterEncoding.JSON.encode(request, parameters: parameters["body"] as? [String: AnyObject])
    let compositeRequest = bodyRequest.mutableCopy() as! NSMutableURLRequest
    compositeRequest.HTTPBody = bodyRequest.HTTPBody
    if let query = parameters["query"] as? [String: String],
        let url = request.URLRequest.URL?.absoluteString,
        var urlComponent = NSURLComponents(string: url) {
        urlComponent.queryItems = query.flatMap {
            NSURLQueryItem.init(name: $0.0, value: $0.1)
        }
        compositeRequest.URL = urlComponent.URL
    }
    return (compositeRequest, nil)
}
```
 This is my solution for Moya 8:

```swift
import Moya
import Alamofire

public struct CompositeEncoding: ParameterEncoding {

    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        guard let parameters = parameters else {
            return try urlRequest.asURLRequest()
        }

        let queryParamters = (parameters["query"] as! Parameters)
        let bodyParameters = (parameters["body"] as! Parameters)

        let queryRequest = try URLEncoding(destination: .queryString).encode(urlRequest, with: queryParamters)
        let bodyRequest = try JSONEncoding().encode(urlRequest, with: bodyParameters)

        var compositeRequest = bodyRequest
        compositeRequest.url = queryRequest.url
        return compositeRequest
    }
}
``` In case anyone wants to perform: **[only Query]** or **[Query + Body] (application/json)** request:

```swift
struct CompositeEncoding: ParameterEncoding {
    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        guard let parameters = parameters else {
            return try urlRequest.asURLRequest()
        }

        let queryParameters = (parameters["query"] as! Parameters)
        let queryRequest = try URLEncoding(destination: .queryString).encode(urlRequest, with: queryParameters)

        if let body = parameters["body"] {
            let bodyParameters = (body as! Parameters)
            var bodyRequest = try JSONEncoding().encode(urlRequest, with: bodyParameters)

            bodyRequest.url = queryRequest.url
            return bodyRequest
        } else {
            return queryRequest
        }
    }
}

public var parameterEncoding: ParameterEncoding {
    return CompositeEncoding() // For all requests composite encoding.
}

public var parameters: [String: Any]? {
    var params:[String: Any] = [:]
    params["query"] = ["token": API_TOKEN, "appId":API_APP_ID, "appKey":API_APP_KEY]

    switch self {
        case .validatePhone(let phone):
            params["body"] = ["phone":phone] // Setting body attribute finally makes request application/json
            break
        default: break
    }
    return params
}
```
 Just a heads up:

Once my PR #1147 gets merged then a solution to this issue will be built into Moya via the new [`requestCompositeParameters(bodyParameters:bodyEncoding:urlParameters:)`](https://github.com/Dschee/Moya/blob/flexible-target/Sources/Moya/TargetType.swift#L51) task case.

You will be able to write something like the following (instead of `parameters` and `parameterEncoding`):

```swift
var task: Task {
    switch self {
    case .profile(let username, let language):
        return .requestCompositeParameters(bodyParameters: ["username: username], bodyEncoding: JSONEncoding.default, urlParameters: ["lang": language])
    default:
        return .requestPlain
    }
}
```  Ya. I am unsure of how to solve this. If you change the module name and the framework name it works. The problem with that is that it build 3 frameworks but overwrites the previous one since it is also called Moya.framework. Im gonna try to rename them in the post build phase. Maybe that will work.
 I believe I found a solution to this problem. I still need to test out if works with Carthage but it works fine in Xcode so I don't see why it wouldn't work. 
  Updated ReactiveCocoa examples in `README` and `docs/ReactiveCocoa` with changes to the `Error` case of `Event` introduced in ReactiveCocoa 4.0 Alpha 3.

Closes #311 
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=bce0dbef477ae195460c96bd192aa4cc37bf89d7) is `72.93%`

> Merging **#310** into **master** will decrease coverage by **-7.37%** as of [`bce0dbe`](https://codecov.io/github/Moya/Moya/commit/bce0dbef477ae195460c96bd192aa4cc37bf89d7)

``` diff
@@            master    #310   diff @@
======================================
  Files           13      14     +1
  Stmts          584     665    +81
  Branches         0       0       
  Methods                          
======================================
+ Hit            469     485    +16
  Partial          0       0       
- Missed         115     180    +65
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/f8ab2ea6fbd034a62d89ebda94c263ff0364668b...bce0dbef477ae195460c96bd192aa4cc37bf89d7) as of [`bce0dbe`](https://codecov.io/github/Moya/Moya/commit/bce0dbef477ae195460c96bd192aa4cc37bf89d7)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=bce0dbef477ae195460c96bd192aa4cc37bf89d7)
1. `+7.37%` via [...rkLoggerPlugin.swift#33...81](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=bce0dbef477ae195460c96bd192aa4cc37bf89d7#33) 
2. `+2.40%` via [Source/Moya.swift#15...30](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=bce0dbef477ae195460c96bd192aa4cc37bf89d7#15) 
3. `+2.40%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=bce0dbef477ae195460c96bd192aa4cc37bf89d7#53) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=bce0dbef477ae195460c96bd192aa4cc37bf89d7)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  Hey Moya Contributors (moyers?)

I believe only admins like @ashfurrow have access to the repo settings, so I aplogize in advance if it's already enabled as i'm unable to tell, BUT I wanted to field opinions on protected branches/status checks.

Here is the gist:
- By making master a "protected branch", we can enforce that no one can force push to it, preventing a potential flurry of git surgery/issues (which is what prompted me to do it on my own repo)
- More importantly, we can enforce that _any_ pull request to Moya must be passing certain status checks (CI + Unit Tests passing, either one, or all) before the pull request can be merged. 

One of the big questions I would want to pose to the community is `Would we ever want master to be in a failing state?`. My personal opinion is no, because if master is failing, and others begin branching and contributing back, now we all have broken tests :open_mouth:  

I have been using this on a private org repository with 6 other developers, and it has been working great! Pasting some screenshots from my private repo for reference:

Thanks! :tada: 

<img width="718" alt="screen shot 2015-11-16 at 5 44 58 pm" src="https://cloud.githubusercontent.com/assets/307819/11197332/d0b32288-8c8a-11e5-98d5-04c5ed32ee54.png">

<img width="703" alt="screen shot 2015-11-16 at 5 51 36 pm" src="https://cloud.githubusercontent.com/assets/307819/11197338/d4f8e616-8c8a-11e5-8f82-765f050eb30b.png">
 Glad to hear master is already ‚ö†Ô∏èprotected‚ö†Ô∏è!!!

 Sorry to hear about the intermittent CI failures, those are always fun :grimacing: 

You have a great point that getting a PR merged may be more important than passing tests. I'm coming from an app-based repository mindset with bi-weekly releases, so pretty different :fish: here. 
I think that with the right kind of friendly community (which Moya has!) either approach can work, and barring the intermittent failure issue, it could get people more involved and focused on testing, with other contributors pitching in to help people out with tests!

If it weren't for those intermittent failures, I would propose an experiment to try it out, but we should figure those failures out first! I'll do a little bit of researching on that issue 

Thanks again @swizzlr @ashfurrow :tada: 
 Awesome, possible fix for the failures is merged!

We should probably wait a couple days, see if they resolve, then pick back up here. If we do want to try this idea out, we could use this issue as a tracker/retro on how we think the process went, and if we want to revert the change or not! Good way to keep track of on an on-going experiment :hammer: 

Maybe like a 1 month trial run of it, open to suggestions!
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=cc6b0429b010f969612a99aaef1c52b94bc039cd) is `84.84%`

> Merging **#307** into **master** will increase coverage by **+11.91%** as of [`cc6b042`](https://codecov.io/github/Moya/Moya/commit/cc6b0429b010f969612a99aaef1c52b94bc039cd)

``` diff
@@            master    #307   diff @@
======================================
  Files           14      13     -1
  Stmts          665     640    -25
  Branches         0       0       
  Methods                          
======================================
+ Hit            485     543    +58
  Partial          0       0       
+ Missed         180      97    -83
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/fd8445835e953f46f0b89c8208a80d463c166c56...cc6b0429b010f969612a99aaef1c52b94bc039cd) as of [`cc6b042`](https://codecov.io/github/Moya/Moya/commit/cc6b0429b010f969612a99aaef1c52b94bc039cd)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=cc6b0429b010f969612a99aaef1c52b94bc039cd)
1. `+2.50%` via [Source/Result.swift#53...68](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=cc6b0429b010f969612a99aaef1c52b94bc039cd#53) 
2. `+1.72%` via [Source/Result.swift#38...48](https://codecov.io/github/Moya/Moya/Source/Result.swift?ref=cc6b0429b010f969612a99aaef1c52b94bc039cd#38) 
3. `+1.25%` via [...ource/Response.swift#75...82](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=cc6b0429b010f969612a99aaef1c52b94bc039cd#75) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=cc6b0429b010f969612a99aaef1c52b94bc039cd)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 I think this should be good to go now.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=c06be6e736b64979427f28deeadd45b4e33970ba) is `80.13%`

> Merging **#306** into **master** will not affect coverage as of [`c06be6e`](https://codecov.io/github/Moya/Moya/commit/c06be6e736b64979427f28deeadd45b4e33970ba)

``` diff
@@            master    #306   diff @@
======================================
  Files           13      13       
  Stmts          579     579       
  Branches         0       0       
  Methods                          
======================================
  Hit            464     464       
  Partial          0       0       
  Missed         115     115       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/72f2f5419713ee8444de49cecb8d265b55467ba7...c06be6e736b64979427f28deeadd45b4e33970ba) as of [`c06be6e`](https://codecov.io/github/Moya/Moya/commit/c06be6e736b64979427f28deeadd45b4e33970ba)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=c06be6e736b64979427f28deeadd45b4e33970ba)
1. `+8.47%` via [...rkLoggerPlugin.swift#28...76](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=c06be6e736b64979427f28deeadd45b4e33970ba#28) 
2. `+2.77%` via [Source/Moya.swift#18...33](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=c06be6e736b64979427f28deeadd45b4e33970ba#18) 
3. `+1.56%` via [...rkLoggerPlugin.swift#12...20](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=c06be6e736b64979427f28deeadd45b4e33970ba#12) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=c06be6e736b64979427f28deeadd45b4e33970ba)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=d5a8a72bf630bc181a945994f84f34411fbb20bb) is `80.30%`

> Merging **#305** into **master** will increase coverage by **+0.17%** as of [`d5a8a72`](https://codecov.io/github/Moya/Moya/commit/d5a8a72bf630bc181a945994f84f34411fbb20bb)

``` diff
@@            master   #305   diff @@
=====================================
  Files           13     13       
  Stmts          579    584     +5
  Branches         0      0       
  Methods                         
=====================================
+ Hit            464    469     +5
  Partial          0      0       
  Missed         115    115       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/72f2f5419713ee8444de49cecb8d265b55467ba7...d5a8a72bf630bc181a945994f84f34411fbb20bb) as of [`d5a8a72`](https://codecov.io/github/Moya/Moya/commit/d5a8a72bf630bc181a945994f84f34411fbb20bb)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=d5a8a72bf630bc181a945994f84f34411fbb20bb)
1. `+8.39%` via [...rkLoggerPlugin.swift#28...76](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=d5a8a72bf630bc181a945994f84f34411fbb20bb#28) 
2. `+2.74%` via [Source/Moya.swift#15...30](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=d5a8a72bf630bc181a945994f84f34411fbb20bb#15) 
3. `+1.54%` via [...rkLoggerPlugin.swift#12...20](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=d5a8a72bf630bc181a945994f84f34411fbb20bb#12) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=d5a8a72bf630bc181a945994f84f34411fbb20bb)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 I'm a fan of this. It simplifies things a little bit. _technically_, the type is currently Moya.MoyaResponse, which is redundant.

‚ÄîJustin Makaila

On Mon, Nov 16, 2015 at 10:00 AM, Greg Pardo notifications@github.com
wrote:

> https://github.com/raywenderlich/swift-style-guide
> 
> ## According to this we should just use namespaces. I'm okay with that. If there is a collision you just have a little more to type.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/pull/305#issuecomment-157097295
 @colinta loves to merge!
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=1726e03e7de71018bff6a255d2631a23a0d08bbe) is `80.13%`

> Merging **#304** into **master** will not affect coverage as of [`1726e03`](https://codecov.io/github/Moya/Moya/commit/1726e03e7de71018bff6a255d2631a23a0d08bbe)

``` diff
@@            master    #304   diff @@
======================================
  Files           13      13       
  Stmts          579     579       
  Branches         0       0       
  Methods                          
======================================
  Hit            464     464       
  Partial          0       0       
  Missed         115     115       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/72f2f5419713ee8444de49cecb8d265b55467ba7...1726e03e7de71018bff6a255d2631a23a0d08bbe) as of [`1726e03`](https://codecov.io/github/Moya/Moya/commit/1726e03e7de71018bff6a255d2631a23a0d08bbe)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=1726e03e7de71018bff6a255d2631a23a0d08bbe)
1. `+8.47%` via [...rkLoggerPlugin.swift#28...76](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=1726e03e7de71018bff6a255d2631a23a0d08bbe#28) 
2. `+2.77%` via [Source/Moya.swift#15...30](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=1726e03e7de71018bff6a255d2631a23a0d08bbe#15) 
3. `+1.56%` via [...rkLoggerPlugin.swift#12...20](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=1726e03e7de71018bff6a255d2631a23a0d08bbe#12) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=1726e03e7de71018bff6a255d2631a23a0d08bbe)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  If reactive cocoa 4 is final by then it sounds like a good idea. 
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=f4ab7e7f0b580e8b98c13786c007995df8378696) is `81.16%`

> Merging **#302** into **master** will increase coverage by **+1.03%** as of [`f4ab7e7`](https://codecov.io/github/Moya/Moya/commit/f4ab7e7f0b580e8b98c13786c007995df8378696)

``` diff
@@            master    #302   diff @@
======================================
  Files           13      12     -1
  Stmts          579     568    -11
  Branches         0       0       
  Methods                          
======================================
- Hit            464     461     -3
  Partial          0       0       
+ Missed         115     107     -8
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/72f2f5419713ee8444de49cecb8d265b55467ba7...f4ab7e7f0b580e8b98c13786c007995df8378696) as of [`f4ab7e7`](https://codecov.io/github/Moya/Moya/commit/f4ab7e7f0b580e8b98c13786c007995df8378696)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=f4ab7e7f0b580e8b98c13786c007995df8378696)
1. `+8.62%` via [...rkLoggerPlugin.swift#28...76](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=f4ab7e7f0b580e8b98c13786c007995df8378696#28) 
2. `+1.93%` via [...ource/Response.swift#75...85](https://codecov.io/github/Moya/Moya/Source/Response.swift?ref=f4ab7e7f0b580e8b98c13786c007995df8378696#75) 
3. `+1.58%` via [...rkLoggerPlugin.swift#12...20](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=f4ab7e7f0b580e8b98c13786c007995df8378696#12) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=f4ab7e7f0b580e8b98c13786c007995df8378696)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=16446878b2914f4d4070381c8df902cfcf0a4265) is `80.13%`

> Merging **#301** into **master** will not affect coverage as of [`1644687`](https://codecov.io/github/Moya/Moya/commit/16446878b2914f4d4070381c8df902cfcf0a4265)

``` diff
@@            master    #301   diff @@
======================================
  Files           13      13       
  Stmts          579     579       
  Branches         0       0       
  Methods                          
======================================
  Hit            464     464       
  Partial          0       0       
  Missed         115     115       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/63abababf6c833c390b207f19528981ec1d495f0...16446878b2914f4d4070381c8df902cfcf0a4265) as of [`1644687`](https://codecov.io/github/Moya/Moya/commit/16446878b2914f4d4070381c8df902cfcf0a4265)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=16446878b2914f4d4070381c8df902cfcf0a4265)
1. `+8.47%` via [...rkLoggerPlugin.swift#28...76](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=16446878b2914f4d4070381c8df902cfcf0a4265#28) 
2. `+2.77%` via [Source/Moya.swift#18...33](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=16446878b2914f4d4070381c8df902cfcf0a4265#18) 
3. `+1.56%` via [...rkLoggerPlugin.swift#12...20](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=16446878b2914f4d4070381c8df902cfcf0a4265#12) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=16446878b2914f4d4070381c8df902cfcf0a4265)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  I think some protocols could be still be renamed to match the new ones that remove the Moya from their name

`MoyaTarget` -> `Target`
`MoyaResquest` -> `Request`

Maybe change the naming of some protocols to include `Type` or `able` at the end like a lot of swift protocols do. Would clearly show the line of separation between what is and isn't a protocol. Right now something like `MoyaTarget` might be confusing since it is not actually a target but a protocol that targets need to implement. `TargetType` might make more sense for users.
 Also if `Endpoint` is never supposed to be subclassed we could mark it as `final`. Anyone have a use case where `Endpoint` would need to be subclassed?
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=637a753319b7365429f2c0e979075d1c1fad930b) is `72.22%`

> Merging **#299** into **master** will not affect coverage as of [`637a753`](https://codecov.io/github/Moya/Moya/commit/637a753319b7365429f2c0e979075d1c1fad930b)

``` diff
@@            master    #299   diff @@
======================================
  Files           12      12       
  Stmts          540     540       
  Branches         0       0       
  Methods                          
======================================
  Hit            390     390       
  Partial          0       0       
  Missed         150     150       
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/04bc823e205e7e5c67b7bcc210fdfe88cfe0abab...637a753319b7365429f2c0e979075d1c1fad930b) as of [`637a753`](https://codecov.io/github/Moya/Moya/commit/637a753319b7365429f2c0e979075d1c1fad930b)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=637a753319b7365429f2c0e979075d1c1fad930b)
1. `+9.07%` via [...rkLoggerPlugin.swift#28...76](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=637a753319b7365429f2c0e979075d1c1fad930b#28) 
2. `+2.96%` via [Source/Moya.swift#18...33](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=637a753319b7365429f2c0e979075d1c1fad930b#18) 
3. `+1.66%` via [...e/MoyaResponse.swift#33...41](https://codecov.io/github/Moya/Moya/Source/ReactiveCore/MoyaResponse.swift?ref=637a753319b7365429f2c0e979075d1c1fad930b#33) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=637a753319b7365429f2c0e979075d1c1fad930b)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 I don't think this will solve the problem. Doesn't the framework bundle version have to match the app version now?
 It wasn't fixed last week when I uploaded a beta. Maybe with the update to iTunes connect that just came out it is fixed,
 Ah ok. Thanks for the fix. That was probably my fault. Forgot to add MOYA_VERSION to the other targets when I created them. 
 I have no need for it. I didn't add it. I just updated the project to have more targets. Just didn't add it to the newer ones I guess. 
  I'm all for removing them. We could mark them as depreciated in the next major version and keep them in as long as RAC4 is still not final.
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=82678ce08cf03325f59128965518ef7636dd8c63) is `80.13%`

> Merging **#297** into **master** will increase coverage by **+7.91%** as of [`82678ce`](https://codecov.io/github/Moya/Moya/commit/82678ce08cf03325f59128965518ef7636dd8c63)

``` diff
@@            master    #297   diff @@
======================================
  Files           12      13     +1
  Stmts          540     579    +39
  Branches         0       0       
  Methods                          
======================================
+ Hit            390     464    +74
  Partial          0       0       
+ Missed         150     115    -35
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/a8f0c089b33fe33a120ae759629973da43fee706...82678ce08cf03325f59128965518ef7636dd8c63) as of [`82678ce`](https://codecov.io/github/Moya/Moya/commit/82678ce08cf03325f59128965518ef7636dd8c63)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=82678ce08cf03325f59128965518ef7636dd8c63)
1. `+8.47%` via [...rkLoggerPlugin.swift#28...76](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=82678ce08cf03325f59128965518ef7636dd8c63#28) 
2. `+2.77%` via [Source/Moya.swift#18...33](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=82678ce08cf03325f59128965518ef7636dd8c63#18) 
3. `+1.56%` via [...rkLoggerPlugin.swift#12...20](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=82678ce08cf03325f59128965518ef7636dd8c63#12) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=82678ce08cf03325f59128965518ef7636dd8c63)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
 Should be good to merge now. If anyone wants to look it over.
 Equality is just what we define to be equal. In this case since we are just using it for tests its simpler to just check the error type since in the tests that use it the response is going to be the same since it is hard coded. If we were going to make it public then ya I agree. @tomburns wanted it to be exhaustive and comparing the responses too without a default case is not fun. The equality is just for a simpler syntax in tests. If it is agreed that a function is better than we can change it back
 Good points all round. I didn't think it would have caused such a big issue since that file is not even in Moya. Yes it is public but it is only part of the test target. I'll see what I can do about it later today. 
 Since the MoyaError Equatable method was only used by tests to compare the types of errors, I changed it to be a matcher for Nimble. Makes more sense since it's only for tests. 

@JRHeaton want to review this and then merge?
 That should do it :smile: 
  ## [Current coverage](https://codecov.io/github/Moya/Moya?ref=df44c413847d8babc1a8b0a6cd067b0f0c17fc63) is `72.22%`

> Merging **#296** into **master** will increase coverage by **+1.11%** as of [`df44c41`](https://codecov.io/github/Moya/Moya/commit/df44c413847d8babc1a8b0a6cd067b0f0c17fc63)

``` diff
@@            master    #296   diff @@
======================================
  Files           12      12       
  Stmts          509     540    +31
  Branches         0       0       
  Methods                          
======================================
+ Hit            362     390    +28
  Partial          0       0       
- Missed         147     150     +3
```

> Review entire [Coverage Diff](https://codecov.io/github/Moya/Moya/compare/b2aa9d662bab2b979e856b15b107a16f4bd31f02...df44c413847d8babc1a8b0a6cd067b0f0c17fc63) as of [`df44c41`](https://codecov.io/github/Moya/Moya/commit/df44c413847d8babc1a8b0a6cd067b0f0c17fc63)

---

### [Uncovered Suggestions](https://codecov.io/github/Moya/Moya/features/suggestions?ref=df44c413847d8babc1a8b0a6cd067b0f0c17fc63)
1. `+9.07%` via [...rkLoggerPlugin.swift#28...76](https://codecov.io/github/Moya/Moya/Source/Plugins/NetworkLoggerPlugin.swift?ref=df44c413847d8babc1a8b0a6cd067b0f0c17fc63#28) 
2. `+2.96%` via [Source/Moya.swift#18...33](https://codecov.io/github/Moya/Moya/Source/Moya.swift?ref=df44c413847d8babc1a8b0a6cd067b0f0c17fc63#18) 
3. `+1.66%` via [...e/MoyaResponse.swift#33...41](https://codecov.io/github/Moya/Moya/Source/ReactiveCore/MoyaResponse.swift?ref=df44c413847d8babc1a8b0a6cd067b0f0c17fc63#33) 
4. _[See 7 more...](https://codecov.io/github/Moya/Moya/features/suggestions?ref=df44c413847d8babc1a8b0a6cd067b0f0c17fc63)_

> Powered by [Codecov](https://codecov.io). Updated on successful CI builds.
  Looks good to me :+1: :rocket: 
  Like this a lot :+1:
 Into it
 This is a great idea :+1: 
 ![giphy](https://cloud.githubusercontent.com/assets/1313663/11134697/e28bfeb6-89f2-11e5-8471-d781b4936e96.gif)

Sounds good to me. :+1: 
 I've been playing with this idea a little bit and would like to suggest something a little different. How about the following:

`public typealias Completion = (result: () throws -> MoyaResponse) -> Void`

The advantage is that there is a clear distinction between the success and error paths. Which would look something like this:

``` swift
GitHubProvider.request(.UserRepositories(username)) { result in
    do {
        let response = try result()
        print(response)
    } catch {
        print(error)
    }
}
```
 I like the idea of using a single result type. :+1: 
 I'm fine with a result type. I was going to go with a result type but I was trying to find way that we could remove the `Underlying` error from MoyaError. This would mean that we could have a clear distinction between our errors and cocoa errors. It would give the user a better indication of where things are going wrong.

So you could do something like this:

``` swift
GitHubProvider.request(.UserRepositories(username)) { result in
    do {
        let response = try result()
        print(response)
    } catch let error as MoyaError {
        print("moya errors", error)
    } catch {
        print("other errors", error)
    }
}
```
  Hi,I use CocoaPods Installation `Moya`

xcode issue a warning:

`ViewController.swift` is part of module `Moya`;ignoring import
 I think this is a bug in Xcode. When I delete the project to re-establish this project, everything becomes normal.Thank you for your answer, then what is the problem I will initiate issue.
  The only case I can think of this being a breaking change would be if the developer subclassed the provider and created a new request function that returned a subclass of `MoyaRespnse` instead. I believe that this would not work anymore but it would have before. I could try it out to see if that is really the case. Aside from that there are no API changes just additions. 
  Currently, with the way that the `MoyaTarget` protocol is written, there's no straightforward way to send a string as the body of the request (i.e. GraphQL query).

Any suggestions from the community?

cc: @Moya/contributors
 We want to be able to recreate this CURL functionality:

``` bash
$ curl -XPOST -H 'Content-Type:application/graphql'  -d '{ count }' http://localhost:3000/graphql
```

As far as custom parameter encoding, I'm seeing something like this:

``` Swift
// A GraphQL utility that I'm currently developing
import GraphQL

static let ApplicationBaseAPIURL = NSURL(string: "https://myDomain.com/")!

// The query for a user matching an ID
func userQuery(id: String) -> GraphQLNode {
  return GraphQLNode(name: "user", arguments: ["id": id], properties: [
    "id",
    "firstName",
    "lastName",
    "username",
    "email"
  ])
}

enum UserEndpoint: MoyaTarget {
  case GetUserByID(id: String)

  var baseURL: NSURL {
    return ApplicationBaseAPIURL
  }

  var path: String {
    return "graphql"
  }

  var method: Moya.Method {
    switch self {
      case GetUserByID(_):
        return .GET
    }
  }

  var parameters: [String: AnyObject]? {
    switch self {
      case GetUserByID(let id):
        return ["query": userQuery(id)]
    }
  }

  var sampleData: NSData {
    // Return sample data in the same shape specified by the query.
  }
}


let GraphQLProvider = ReactiveCocoaMoyaProvider(endpointClosure: { target in
    let graphQLParameterEncoding = Moya.ParameterEncoding.Custom { requestConvertible, parameters -> (NSMutableURLRequest, NSError?) in
        // A little pseudo cod never hurt... 
        let urlRequest = requestConvertible.URLRequest.mutableCopy()
        if let query = parameters["query"] as? GraphQLQueryType {
            urlRequest.body = query.description
        }

        return urlRequest
    }

    let graphQLEndpoint = Endpoint(
        URL: target.baseURL,
        sampleResponseClosure: {
            return .NetworkResponse(200, NSData())
        },
        method: target.method,
        parameters: target.parameters,
        parameterEncoding: graphQLParameterEncoding
    )

    return graphQLEndpoint
})
```

But I don't really like how we abstract away the requirement of there being a `GraphQLQueryType` available at the `query` key in the parameters dictionary.

We _could_ change the `parameters` property of `MoyaTarget` to `AnyObject?`, and have `Endpoint` do some assertions to ensure that `parameters` is either an `Array`, `[NSObject: AnyObject]`, or `String`, which would allow us to supply the `GraphQLQueryType.description` to the `parameters`, but this is more of the same black-box functionality that I'd like to avoid.
 Could you elaborate a little bit on that idea?

I'm starting to think that it might be best to leave that on the end user's side, and have them use similar logic to what was outlined above. I can't think of a way to do it without breaking changes, and without making assumptions about what was intended. 
 I have a GraphQL framework that I've been working on, in case anyone wants to contribute ;)

‚ÄîJustin Makaila

On Sat, Nov 14, 2015 at 12:44 PM, swizzlr notifications@github.com
wrote:

> ## A protocol, "ParameterEncodable" might be a good plan. We could add conformance for dicts to keep previous behavior, and then allow further smarts by providing a "GraphQLNode" struct (or let the users define it as an optional third party extension to Moya, until such time as it's a huge demand).
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/issues/290#issuecomment-156740424
 :+1: to the idea of a `ParameterEncodable` protocol.
 How to  add post data in MoyaProvider subclass?  Is there a solution?
 I have a similar issue. We have an S3 proxy endpoint where we would like to perform the equivalent of curl's `--data-binary` (i.e., setting the URLRequest body to a binary file) and can't send multipart form data. Is there a suggested idiomatic approach for this now, or some workaround (e.g., getting a mutable URLReqest)?
 Ah, sorry, I'm new to all this and didn't understand what was happening the custom parameter encoding solution. I understand now and got it working. Thanks, @ashfurrow!
 Hey @ashfurrow! Do you use GraphQL in combination with Moya? Is there any update on how to make parameter encoding more generic? I'm very new to GraphQL and try to integrate [Apollo iOS](https://github.com/apollostack/apollo-ios) with how I use Moya and Alamofire to make network requests. 
  I took a blind stab at the change I was talking about in #288, mostly as an exercise for myself. I think this preserves the data presented previously in the NSErrors' userInfo, while providing a more swift-friendly interface for retrieving it.

As I said in the issue, I have no idea what I'm doing, but I'd love to hear your thoughts!
 Hmm, tests are passing for me locally after that last commit. Let me know if there's something I can do to make Travis happy :)
 Im all for moving to a typed error instead of NSError. We could possibly use the typed error everywhere instead of just the reactive extensions. It would make things more consistent. The same could be done for `MoyaResponse` as I discussed [here](https://github.com/Moya/Moya/issues/198#issuecomment-154258823)
 Pushed a simple comparison function for the error type; I wasn't comfortable shoving that operation into `Equatable` (or a custom operator) without further discussion. Also updated the changelog.
 While we're looking at this change, it might be worth examining which associated values we'd like to have for each error. As an example: I've already added the status code as an associated `Int` on the `.StatusCode` error, but it might be nice to have the expected range which resulted in the error as well? e.g. `.StatusCode(404,200...299,response)`
 To keep the associated values clean (especially given their lack of names) we could also consider specialized struts, like so:

```
public enum MoyaError: ErrorType {
    case StatusCode(StatusCodeErrorMetadata)
    [...]
}

struct StatusCodeErrorMetadata {
    let encounteredStatusCode: Int
    let expectedStatusRange: Range<Int>
    let response: MoyaResponse
}
```

That struct's name is a bit of a mouthful, but I like that it keeps us down to one associated value and the convention is fairly straightforward.
 You mentioned that you want to keep associated values clean "especially given their lack of names". You can give names to associated values inside an enum in swift if that's what you wanted to do. So like `case CoolCase(value: Sting)`
 I think associated values are the way to go. They represent a domain, and each case can encapsulate any values associated with it.

‚ÄîJustin Makaila

On Sun, Nov 8, 2015 at 7:50 PM, Pierre-Marc Airoldi
notifications@github.com wrote:

> ## You mentioned that you want to keep associated values clean "especially given their lack of names". You can give names to associated values inside an enum in swift if that's what you wanted to do. So like `case CoolCase(value: Sting)`
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/pull/289#issuecomment-154894267
 Ah, glad to learn that names work! No idea why I was so sure they didn't. 

+1 for associated values, then :joy: 
 I broke it again! :tada: 

Tests are passing locally for me; not sure what's up: 

```
tburns@Monarch ~/code/Moya [error-type *]
¬± % rake test                                                                                                                              !10072
set -o pipefail && xcodebuild -workspace 'Demo.xcworkspace' -scheme 'Demo' -configuration 'Debug' -sdk iphonesimulator -destination platform='iOS Simulator',OS='9.0',name='iPhone 6' build test | xcpretty -c --test
2015-11-08 23:02:13.836 xcodebuild[73178:2107923] [MT] IDETestOperationsObserverDebug: (FC2F7820-8995-42A0-8796-B9ADFD7D4C44) Beginning test session FC2F7820-8995-42A0-8796-B9ADFD7D4C44 with Xcode 7B91b on target <DVTiPhoneSimulator: 0x7f9b2d6ef3f0> {
        SimDevice: SimDevice : iPhone 6 (C5B3EBC8-B35E-44DE-8D89-72DCB622959D) : state={ Shutdown } deviceType={ SimDeviceType : com.apple.CoreSimulator.SimDeviceType.iPhone-6 } runtime={ SimRuntime : 9.0 (13A344) - com.apple.CoreSimulator.SimRuntime.iOS-9-0 }
} (9.0 (13A344))
..................................................................

     Executed 66 tests, with 0 failures (0 unexpected) in 5.932 (5.959) seconds
```
 You didn't add the `MoyaError+MoyaSpec.swift` to the DemoTests target inside the demo project. Should work after you do that.
 @JRHeaton The only nice thing about the current shape of that comparison function is that it's exhaustive, and will generate warnings if we add to the enum. Your version is certainly the more handsome of the two; what does the group think?

As an aside, the latest CI failure appears to be Travis flapping again.
 I like pattern matching more but that's just me. Also the switch can be exhaustive without default if that is what you are worried about. You just need to add all the combinations as cases. I don't think having a default case that returns false would be bad. Usually we would want to check that 2 errors are the same so if there is a new error and that function has not been updated then it will return false so tests would fail etc. 
 I think this can be merged as a first step, unless we want to go all-in on the new error type all at once. If there are any pending changes I've missed, let me know and i'll try to address them.
 Scanning the thread, the only things that I see as unresolved are what associated values we want to make available on each error, and naming them inside the tuples. Do we want to take care of that before merging, or just before releasing this into the wild?
 Merge to master: :white_check_mark: 

If someone could give that a quick spot check I think we're good to go.
 After those small changes I think it should be good. It might cause you to have to update other parts of the codebase like the tests and the RxSwift extension though. If you need help with that, I'm here to help. :+1: 
 Thanks for the feedback! Good catches all around; I agree with all the proposed changes and I'll try to get this updated today.
 I believe this is ready for further review; as it stands I was able to make the suggested changes without touching the Rx extensions or tests. I'm a little unhappy with that revised attempt at passing along the status code error (see my comment on the latest commit above) , so if anyone has any tips I'm all ears.
 Looks good. There might be a little clean up needed to maybe remove `MoyaErrorDomain` and `MoyaErrorCode` if possible. If no one has other objections I will merge this.
  I'm just getting started with Moya (and ReactiveCocoa, for that matter), but when using `request()`, `mapJSON()` etc to create a `SignalProducer` I find that I'm having to do a lot of mapping from the many underlying `NSError`s to a typed error enum in my code.

Is this something Moya could take care of by having an intermediate `ErrorType`, or is it best handled in my code? Personally I'd much rather see `request()` return something like `SignalProducer<MoyaResponse,MoyaError>` than `SignalProducer<MoyaResponse,NSError>`, but it's entirely possible I'm just holding it wrong :smile: 

Let me know either way; this seems like it'd make a decent first PR for me to tackle if you like the idea. 
 I think this would cause the RAC4 support to diverge a bit from the legacy `RACSignal` interface, but I'm not sure that's a bad thing either.
 Im not sure how `RACSignal` would work with an error other than `NSError`. I have never tried it. But other than that everything looks good.
 I believe anything that conforms to `ErrorType` can be bridged to an `NSError`, but honestly I don't know enough about the older `RACSignal` ReactiveCocoa interface to guarantee that'd work in this specific case.
 I think a custom error type is the way to go, because it gets rid of some guessing on the end-user side. I'm all for it
 #289 is nearly merged, so I'm moving conversation back here to continue discussing which associated value's we'd like to see on the newly minted `MoyaError` type.

Here's what we have currently:

```
public enum MoyaError: ErrorType {
    case ImageMapping(MoyaResponse)
    case JSONMapping(MoyaResponse)
    case StringMapping(MoyaResponse)
    case StatusCode(Int,MoyaResponse)
    case Data(MoyaResponse)
    case Underlying(ErrorType)
}
```

At the very least i think it might be helpful to add names to these tuples for clarity's sake; does anyone else have suggestions?
 Names aren't needed. All the errors only have 1 thing which is easy to understand. If you absolutely wants names then `reponse` I guess. 
  How to integrate `Moya` into my project manually. Thanks
 thanks. I download `Moya-4.4.0` to my project. dragging the `Moya.xcodeproj` to project  and remove `RxSwift` „ÄÅ`ReactiveCocoa` also remove the `import Alamofire` from the Moya files. Click on the + button under the "Embedded Binaries" section. add the `Moya.framework`.  Then have an error:

```
clang: error: no such file or directory: '/Users/xiaolei/Library/Developer/Xcode/DerivedData/WeatherQ-cvhqwncoeewmnxemtgteetjgepxd/Build/Products/Debug-iphonesimulator/Moya.framework/Moya'
```

![](http://7u2j0x.com1.z0.glb.clouddn.com/QQ20151109-0.png)
 The reason the Xcode project won't work is because it relies on frameworks that aren't present in the folder. You need to run `carthage bootstrap` to get them. Other than that, just dragging the project should work. No need to delete anything. 
 Think you, I will try other methods.
  Many API's require some form of parameterisation of the URI.
For example: 

`/users/{user}/repos`

or a more complex and useful example (that would be harder to solve cleanly with simple interpolation)

`/conversations/{conversationIdentifier}/messages{?max,after,before}`

that could expand to something like

`/conversations/547104ac-74b6-441a-bf9c-eda489498005/messages?max=30&after=1994-11-05T08:15:30-05:00`

or

`/conversations/547104ac-74b6-441a-bf9c-eda489498005/messages?max=30&before=1994-11-05T08:15:30-05:00`

It would be really great if we could provide this as a part of or as an extension to Moya to make integration super easy.

For an RFC compliant implementation of URI's I'd recommend @kylef's [URITemplate](https://github.com/kylef/URITemplate.swift).

My main issue is that I'm not too sure of the best way to integrate this into Moya with minimal impact to the API.
 I agree with @BasThomas, my intentions for using URITemplate in iOS applications are a little different than the goals of Moya. The compile-time checking in Moya is making upfront assumptions on how the API currently works and assumes that to always be the case in the future. If you're already hard-coding the URIs then I don't think it adds too much using URI Template in this case and just adds unnecessary complexity. Unless you are looking to use a common format to specify URLs which you can share against your backend or other clients.

The goals behind URI Template (and other libraries I created using URI Template) was to communicate with APIs using the REST architectural style similar to the GitHub API. This would allow machines to dynamically understanding how the API works instead of it having up-front hard-coded knowledge.

Allowing a machine to learn how to communicate with a foreign API providing it has shared semantic understanding of the given domain.

Instead an approach without hard-coding upfront knowledge of the API layout might look as follows:

```swift
let client = Client()

// Find the master commit for kylef/URITemplate.swift repository on GitHub
client.enter("https://api.github.com")
  .flatMap { client.load($0.transition("repository", ["owner": "kylef", "repo": "URITemplate.swift"]) }
  .flatMap { client.load($0.transition("branches", ["branch": "master"]) }
  .map { $0.attributes["commit"] }
```

Where I've entered the API at it's root and  then followed some of the transitions the API has offered. The client has an understanding of a `repository` and know a specific owner and repository I'm looking for.

```json
{ "repository_url": "https://api.github.com/repos/{owner}/{repo}" }
```

**NOTE:** *The client could just as easily look at all repositories for a user by not expanding the `repo` component of the URI.*

Then following a transition called `branches` with a branch parameter.

```json
{ "branches_url": "https://api.github.com/repos/kylef/URITemplate.swift/branches{/branch}" }
```

*Obviously this example makes a lot of assumptions about the features in the API so it should instead check for the features and the types of variables that can be supplied to the transitions. For brevity and simplicity the example is as-is.*  :+1: 
  Forgot to update both `Podspec` and `Cartfile` in https://github.com/Moya/Moya/pull/281. This PR takes care of that.
  - Replace `AnonymousObservable` with the `create` method
- Replace `onComplete` with `onCompleted`

https://github.com/ReactiveX/RxSwift/releases/tag/2.0.0-beta.2
 @ashfurrow Oops no, I forgot to update the podspec. 
  I made some formatting changes so that the two type of providers more closely match. If you are ok with this change it should be ready to merge.
 yep will do. Im not a fan of those either.
  Ya it is a relic from the inflight request days and not needed. The RxSwift version has this issue too.
  I like framework targets but I have some concerns with this move. I find that it might be hard to keep everything up to date with what is proposed here and might result in duplicate work. 

What happens when someone wants to contribute to the project? They change a file and then to make sure everything works they have to do `carthage bootstrap` to get those dependencies, make sure everything builds fine without error in the framework project, the run `pod install`, then run the tests in the demo project.

To me seems like a lot more work to make sure things are working fine. I think we should pick either having a project with framework targets or the current setup as the source of truth for the library. This would be only the place people would need go to contribute to the library (build framework, run tests, etc.). 

What does everyone think?
 I think a contributing.md is a good idea. 
  fixed a typo
  As the title says.

One note:
The podspec entry will have to remain as `"ReactiveCocoa", "= 4.0.0-alpha-3"` vs `"ReactiveCocoa", "~> 4.0.0-alpha-3"` until/unless https://github.com/CocoaPods/Specs/pull/13588 is merged. Not a big deal in this case.
 Could you separate the update to Xcode 7.1/Swift 2.1 from the OS X support?
 Sorted.

CI is failing but for reasons unknown to me. Something to do with your guys' wacky multi-podpsec setup. ;)
 Yeah I guess @JRHeaton has made these changes since, and theyre on master. So I guess we can close this?
  Only thing breaking OS X compatibility was UIImage use. Easy fix.
 Thats a good way to fix that. There are a couple of issues though.
1. The podspec does not pass linting you can try it out by doing `pod lib lint`
2. There should probably be a demo target for os x
3. Tests should also be added for os x
 It had to do with Alamofire and deployment targets. Just pushed a fix.
 Yayyy, thanks
 Out of curiosity, what's the flow from tag necessitating change, to new CocoaPods version? Would be cool to see OS X support on trunk, but not sure if there's a lot to do (for example, if addressing the CI issue is pre-req) before making a push?
 Okeedoke, good to know
  This is a rebuilt Demo and Pods project.

Somehow, the previous changes to the Pods project got reverted.
Also, there were some files missing in the RxSwift pod sources, which made the project uncompilable.

The Gemfile has also been updated since it was locked to a CocoaPods beta.
  Hi,

since the release of 4.0.2, `Carthage` fails at building `RxMoya`

Sadly I am not very familiar with cocoapods, but I guess the issue is related with https://github.com/Moya/Moya/commit/f6a791398b47b4a982c91305d1bdd25533a52407, because 4.0.1 worked fine under the same conditions.

```
Xcode 7.0.1
Carthage 0.9.3
```

Cartfile:

```
github "Moya/Moya" ~> 4.0
```

```
*** Cloning Moya
*** Cloning Alamofire
*** Checking out Alamofire at "3.0.1"
*** Checking out Moya at "4.0.2"
*** xcodebuild output can be found in /var/folders/fp/2hwf2d3j6mjf8kz8h2v27zc80000gn/T/carthage-xcodebuild.APAymT.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "ReactiveMoya" in Demo.xcworkspace
*** Building scheme "RxMoya" in Demo.xcworkspace
** BUILD FAILED **


The following build commands failed:
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(1 failure)
<unknown>:0: error: no such file or directory: '/Users/Andi/Desktop/MoyaTest/Carthage/Checkouts/Moya/Demo/Pods/RxSwift/RxSwift/AnyObserver.swift'
<unknown>:0: error: no such file or directory: '/Users/Andi/Desktop/MoyaTest/Carthage/Checkouts/Moya/Demo/Pods/RxSwift/RxSwift/Schedulers/ConcurrentMainScheduler.swift'
<unknown>:0: error: no such file or directory: '/Users/Andi/Desktop/MoyaTest/Carthage/Checkouts/Moya/Demo/Pods/RxSwift/RxSwift/Schedulers/ImmediateScheduler.swift'
<unknown>:0: error: no such file or directory: '/Users/Andi/Desktop/MoyaTest/Carthage/Checkouts/Moya/Demo/Pods/RxSwift/RxSwift/ObservableConvertibleType.swift'
<unknown>:0: error: no such file or directory: '/Users/Andi/Desktop/MoyaTest/Carthage/Checkouts/Moya/Demo/Pods/RxSwift/RxSwift/Observables/Implementations/ShareReplay1.swift'
<unknown>:0: error: no such file or directory: '/Users/Andi/Desktop/MoyaTest/Carthage/Checkouts/Moya/Demo/Pods/RxSwift/RxSwift/Observables/Implementations/SkipUntil.swift'
<unknown>:0: error: no such file or directory: '/Users/Andi/Desktop/MoyaTest/Carthage/Checkouts/Moya/Demo/Pods/RxSwift/RxSwift/Observables/Implementations/SkipWhile.swift'
<unknown>:0: error: no such file or directory: '/Users/Andi/Desktop/MoyaTest/Carthage/Checkouts/Moya/Demo/Pods/RxSwift/RxSwift/Observables/Implementations/Using.swift'
A shell task failed with exit code 65:
** BUILD FAILED **


The following build commands failed:
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(1 failure)

```
 Hey, can you post the contents of the `xcodebuild` output file?
 This is fixed with 731db29d6a68d350ef97ad059e881f361dc35e3f, thx @bojan 
A version bump would be nice :)
 Exactly, leaving my Cartfile with `"Moya/Moya" "master"` looks risky to me :)
 thx! Although Carthage can¬¥t pick this tag with `github "Moya/Moya" ~> 4.0` I think this is sufficient for the moment, since I can use `github "Moya/Moya" "4.0.2-carthage"` 

I hope there is soon a 4.0.3 release so I can use `~> 4.0` again :)
 There were some files missed, but as already mentioned https://github.com/Moya/Moya/commit/731db29d6a68d350ef97ad059e881f361dc35e3f fixed that. So I guess there is no need for any deploy script update
 thx, everything seems to be working again üëçüèª
  For what it's worth, I'm seeing the same thing happen on our jenkins instance.  
 I had this issue when multiple builds were executing at the same time. Decreasing the number of executors to 1 resolved the issue. Not an ideal solution but this bought us some time to look for other solutions. 
 Little bit of snooping around led me to this issue on Travis-CI:
https://github.com/travis-ci/travis-ci/issues/4725

This appears to be a known bug. There is a potential workaround where you can a `sleep n` to the end of our travis.yml

Thoughts on doing the above hack?
  Incompatible library version: RxMoya requires version 2.0.0 or later, but RxSwift provides version 1.0.0

I have the latest RxSwift 2.0beta1, what should I do?
 Carthage

github "Moya/Moya"
 @ashfurrow I think that some of the fixes in f6a791398b47b4a982c91305d1bdd25533a52407 were somehow reverted in the later commits. I've tried recreating the Demo project with 0.39.0 (not b4) on 4.0.2, it builds and works just fine.
 I'm already on it.
 #261 should do it.
  Allow CancellableToken to debug print Alamofire curls
#256
   #257 
  The previous Demo project was built using an older version of CocoaPods that caused incompatibilities when using a Carthage build of Moya.

What happened was that Alamofire in the Demo project was built with a `DYLIB_COMPATIBILITY_VERSION` set by CocoaPods (3), instead of the original value of Alamofire (1).
Later when Moya was built and included into a Carthage project that also used Alamofire, the linker would complain that Moya was trying to load an Alamofire version that is not compatible.

This fix was suggested by this specific response in the CocoaPods repository https://github.com/CocoaPods/CocoaPods/issues/4308#issuecomment-145479575.
  Great work all round, just trying to figure out how this change works when creating a `ReactiveCocoaMoyaProvider`.

Presumably,
`typealias OnlineSignalClosure = () -> RACSignal` won't work.

Porting the older code leads to:

```
typealias OnlineSignalClosure = () -> RACSignal

// Closure that returns a signal which completes once the app is online.
let onlineSignal: OnlineSignalClosure

init(endpointClosure: MyTarget -> Endpoint<MyTarget>, requestClosure: (Endpoint<MyTarget>, NSURLRequest -> Void) -> Void, plugins: [NetworkActivityPlugin<MyTarget>]) {
    // code
}
```

But I can't figure out how to port the onlineSignal hooks.
 I guess I should ask if there's an updated version of the Artsy app :)
 Thanks @ashfurrow - appreciate the response. ReactiveCocoa is changing so quickly that when I tried the Artsy app to help me, it was clear that they've diverged somewhat! I'm still using Moya 2.2.0 as I can't get up to speed with the changes yet, but thanks for the software, it's pretty good stuff.
    Giving this little one a shot too. 
 Yes I mentioned that [here](https://github.com/Moya/Moya/issues/246#issuecomment-146257866). I can make another pull request if needed unless someone wants to push a quick fix. 
  Also make wording a bit more clear by discussing the requestClosure first and then then how endpointClosure should not be used for the same purpose after.
  Erm realized I should have used ~> 2.0 on that instead... Grr
 I remember seeing talk about this in the Carthage issues tracker. If I remember correctly there is nothing like subspecs in Carthage so essentially ReactiveMoya and RxMoya need to be separated into their own repositories/frameworks I believe. 
 The Cartfile is there now but I don't think it should include ReactiveMoya. Not all projects will need that dependency. Can't we just update the README to include instructions for setting up your personal Cartfile for all configurations: Moya, RxMoya, ReactiveMoya?
 So it looks like anyone using Carthage has to install Alamofire, Moya, ReactiveCocoa, RxSwift, ReactiveMoya, and RxMoya it seems. Is that correct?
 Okay so what's the downside if any of adding the other required install dependencies to the Cartfile? 
  So I've dug into this project and maybe I missed it but is there a way to set the body of the request without sending parameters. I took a look at Artsy's app and they basically have a lot of boilerplate like this. 

```
  case CreateUser(let email, let password,let phone,let postCode, let name):
            return [
                "email": email, "password": password,
                "phone": phone, "name": name,
                "location": [ "postal_code": postCode ]
            ]
```

So what I'm assuming here. And perhaps I'm wrong is that the parameters are converted to 'x-www-form-urlencoded' if the request is a .POST? Does this happen automatically or am I missing something?

Perhaps there is a way to extend this do allow sending an object and passing some sort of request encoding closure to Moya. 

I don't think the current setup is bad for small objects but imagine a complex JSON object body with nested array objects. 
 That makes sense. The only issue I had with this was that I could not include custom enum types in the parameters

```
public enum MyApi {
    case GetSomething
    case SendSomething(CustomObject)
}
```

However I suppose this may not be a good idea and maybe I should map my objects to [String: AnyObject] before sending them through the parameters instead?
 Apparently you can't if the object is marked as 'public'. I'm sure there's some sort of reason the compiler doesn't allow it. I'll just attempt to convert the object before hand and it should work fine for now. 

One thing to mention though is that on [Endpoint Documentation](https://github.com/Moya/Moya/blob/master/docs/Endpoints.md) it mentions that:

> Note that the endpointResolver is not intended to be used for any sort of application-level mapping. This closure is really about modifying properties specific to the NSURLRequest, or providing information to the request that cannot be known until that request is created, like cookies settings.

Is that supposed to say endpointClosure? Also it's kind of confusing wording at first glance. Maybe something like...

> This requestClosure is useful for modifying properties specific to the NSURLRequest or providing information to the request that cannot be known until that request is created, like cookies settings. Note that the endpointClosure mentioned above is not intended for this purpose or any request-specific application-level mapping. 
  looks good :+1: 
   Thank you for Moya :smile: 
  A lot of pods are being updated to support tvOS and the latest RxSwift development branch has been updated as well. Unfortunately I investigated and found that you can't use specific branches in the podspec dependencies due to versioning issues so we might have to wait for the dependencies to work these changes into a tag. This library is a really great idea and I'd love to use it in a tvOS app I'm coding instead of manually wrapping Alamofire with RxSwift observables. 
 When I did that it said there was conflicts with Moya's dependencies. Also the Moya podspec only defines target of iOS. 
 Well I did try that too and such resulted in the dependency conflict with my own pods. Here was the pods I was using.

```
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'tvOS'
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'develop'
pod 'RxCocoa', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'develop'
```
 A branch would be great. Keeping it out of the main branch until all dependencies are updated solves the issue for me at least. Then I can just use Moya and get rid of all the other libraries! Thanks for looking into this everyone!
 In my Podfile

```
pod 'Moya/RxSwift', :git => 'https://github.com/Moya/Moya.git', :branch => 'tvOS'
```

I get this error on pod install

```
[!] The platform of the target `My Project` (tvOS 9.0) is not compatible with `Alamofire (3.0.0-beta.3)`, which does not support `tvos`.
```
 Okay I was anxious to try it and I guess I didn't notice the Alamofire part. It's working now. Not sure if you guys want to close this out or leave open until these libraries catch up and this can be merged into master...
 Ok this will be a little more difficult than anticipated. Its seems like some pods have been pushed to trunk with a new version but without the tvos information. One example is Result. [Repo version](https://github.com/antitypical/Result/blob/master/Result.podspec) vs [trunk version](https://github.com/CocoaPods/Specs/blob/master/Specs/Result/0.6.0-beta.5/Result.podspec.json). The same goes for ReactiveCocoa as well.
 Yes. The ReactiveCocoa one needs updating too. There are two things wrong with it.
1. Doesn't specify tvOS when it should
2. OS X target version is 10.10 instead of the project's 10.9
 looks good :+1: 
  @ashfurrow  What are the next plans for 3.0+ release. I use `Moya` intensively in my pet and job Swift projects, so I'm interested about the plans and future updates.
  I really like this approach! Since Moya get¬¥s more and more awesomeness, there should be a consistent way in adding new features without having dozens of specific closures (like the already mentioned credentials, logger, network activity). 
It would also reduce the amount of breaking changes if new features were implemented as `Plugin`s whenever possible.
 Great!
  This feature was discussed in the issue [220](https://github.com/Moya/Moya/issues/220). Current PR adds `Logger` protocol with three methods to log response, request and data, their default implementations via `MoyaLogger` and new `MoyaProvider` ivar called `logger`.  Also, I think we should add some info or instructions about logging to the Moya Documentation, although I don't know where to put it :disappointed: .
 @aschuch "I would like to suggest to at least accumulate a the log output" - very reasonable, thanks - will reimplement it to `print` everything  after we get either a response or error. Or may be we should use `NSLog`? `NSLog()` ensures that all strings passing through it are written in a thread safe manner to `stderr`. Or it will look not good in Swift code?
 @ashfurrow  Thanks a lot for feedback! Yeah - there are many style errors, so I asked for review:). Will fix it and add comments to `protocol` methods.
 @ashfurrow `"Could you update the MoyaProvider subclasses for ReactiveCocoa and RxSwift?"`. Sorry I'm not sure I understood your comment...
You mean only to add `logger` parameter to initializer in Reactive/Rx Moya extensions? Or add some FRP-friendly implementation of the Logger? :smile: 
 @aschuch `"Anyone have any resources? Blog posts?"` - yes, we need some authoritative opinion here about the thread safety. Also I'm not sure if it is good from the code style viewpoint...
 As far as I can tell `print` doesn't write to the device log which `NSLog` does. It might be useful to debug things when you device is not connected. Since its extensible leaving it as just print is fine
 @ashfurrow Oh. Sorry Again, I'm sooo slow :smile:  (deleted previous comments),
As I found [here](https://github.com/Moya/Moya/pull/240). You have already merged my `Logger` code with new `Plugin` feature and also did all the code cleaning. Thanks for the terrific work!
Are there smth. left for me in in the logger functionality? Or I can look for other features to implement? :smiley: 
  Hello, is it possible to use this library from Objective-C? 
  Regard the demo in this repo about GithubProvider

```
public enum GitHub {
    case Zen
    case UserProfile(String)
    case UserRepositories(String)
}

extension GitHub : MoyaTarget {
...
}
```

Normally, we would pass the MoyaTarget instance to the MoyaProvider (the enum Github in this case, but it could be struct, class, whichever conforms to MoyaTarget), like this

```
let GitHubProvider = MoyaProvider(Github.Zen)
```

but the way you use generic,

```
let GitHubProvider = MoyaProvider<Github>()
```

I find this interesting because we can leverage generic and still can call methods on the `MoyaTarget`, without passing the instance into `MoyaProvider`
 The `MoyaTarget` never gets passed the the provider directly. You call `provider.request(Github.Zen)`. Could you elaborate on what the issue is?
 @petester42 @ashfurrow this is not an issue. Maybe I misunderstand the code
 I just misunderstood the code. Now I'm realize that `MoyaProvider` uses generic on `MoyaTarget`, and indeed, `MoyaTarget` instance is passed into `MoyaProvider` 's `request` method
  There is an issue where if a custom Alamofire manager is set, it's not actually used for making the requests in Moya - the default Alamofire one is. This pull request features a test to exhibit this behaviour, and a fix to use the manager that's set on the MoyaProvider. Let me know if any further changes are required.
  Passing by, as I was looking for this feature. I did miss it, as my app requests many of the same API endpoints at the same time. I was wondering why all these calls were fired.

Just for my understanding, what would ideally be the way to handle these duplicate calls and prevent them to be all fired? Should I create my own inflights and duplicate detection?
 Ok, I gave it a shot, but my knowledge did not let me create a certain solution using plugins. I'm really looking into a way to fix this for all Moya users. Anyone here to give me a good shot in the right direction?
 I was thinking about a simple boolean added to the initializer of MoyaProvider `trackInflights:Bool = false` to make it available for all provider types. This makes if easy to enable for those who need it.

Creating a dictionary <Endpoint, [Moya.Completion]> containing all completion blocks for that request and call them when that existing request is finished.

How about that?
 Ok, I gave it a shot: 

https://github.com/AvdLee/Moya/commit/a029491b3219716c91b32feb0172e0f74be67154

For a quick test I duplicated the zen request. Checked it in Charles, one request, three completions.

Curious about your feedback!
 I would love to, but I'm unexperienced with Nimble and Quick. I'm having trouble to even execute the existing tests, but I'm happy to learn and see this working.

Is there anything to do before the tests works with a clean checkout?
 Got it working, needed to force update the project to version 4.0.1 of Nimble, as a clean checkout used version 3.0.0. Had the convert string to staticstring error.

This is the unit test I've got now, which is close, but not successful yet:

``` swift
        it("returns 3 times but executes one request") {
            var networkActivityCallTimes = 0
            var requestCompletionTimes = 0
            let plugin = NetworkActivityPlugin { (change) -> () in
                if change == .Ended {
                    networkActivityCallTimes += 1
                }
            }

            let provider = MoyaProvider<GitHub>(plugins: [plugin], trackInflights: true)
            let target: GitHub = .Zen

            provider.request(target) { _ in
                requestCompletionTimes += 1
            }
            provider.request(target) { _ in
                requestCompletionTimes += 1
            }
            provider.request(target) { _ in
                requestCompletionTimes += 1
            }

            expect(requestCompletionTimes).toEventually(beIdenticalTo(3))
            expect(networkActivityCallTimes).toEventually(beIdenticalTo(1))
        }
```

It's probably a small thing, any suggestions here?
 Ok, got it! https://github.com/Moya/Moya/pull/477
  Looks good to me. :+1: 

I particularly like these changes -

```
 `MoyaProvider.MoyaEndpointResolution` to `MoyaProvider.RequestClosure`
 `MoyaProvider.endpointResolver` to `MoyaProvider.requestClosure`
```

So much clearer! 
 :+1: Good for me :)
 :metal: Nice work. The API is much clearer with these changes.
  It looks like the Endpoint main initializer still requires them as a non-optional
  Why does ReactiveCocoa get to have all the fun. Here are the same data processing extensions but for RxSwift. Tested and all.

Enjoy!
  This should address #118. It is based on @justinmakaila's work for ReactiveCocoa 3 but with processing methods moved to an extension. I also added tests for the new `SignalProducer` code (kind of a duplication of the `RACSignal` tests).

Everything should be :green_apple:  and ready to go!

If anyone has input on how to make [this](https://github.com/Moya/Moya/compare/Moya:master...petester42:reactive-cocoa-4?expand=1#diff-6e6eda96ca4cf5e24ec7f03907dbbbcbR15) nicer and keep the compiler happy it would be great. The force cast should never fail but I don't really like it.
 I think that should do it.
 There we go! xcodeproj conflicts are the worst.
  Im so sorry i ask this question here! but i didn't get any answer in Stackoverflow here is my problem

```
 let authorizationEndpointsClosure = { (target: LokaliiAuthorizationAPI) -> Endpoint<LokaliiAuthorizationAPI> in
let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
let endpoint = Endpoint<LokaliiAuthorizationAPI>(URL: url, sampleResponse: .Success(200, {target.sampleData}), method: target.method, parameters: target.parameters)
switch target {
case .TokenRequest,
     .SignUp,
     .SignInFB,
     .SignUpFB,
     .CreateProfile,
     .TokenRefresh:
    return endpoint
default:
    MNAuthClient.sharedClient.validateLoginFirst { result in
        switch result {
        case .Success(let token):
            dispatch_async(dispatch_get_main_queue(), {
                return endpoint.endpointByAddingHTTPHeaderFields(["Authorization": "Bearer \(token.accessToken)"])
            })
        case .Failure(let error):
            dispatch_async(dispatch_get_main_queue(), {
                return endpoint
            })
        }
    }
}
} 
```

in .default: i need to return the authorization header but i need to check if i need to refresh the token, how can i fix this? again sorry i asked here
 Thanks! Yeah i use ReactiveCocoa would be great if u could provide more details on that :) 
 Ah Amazing! thanks. :heart: 
  Hi, I'm getting this error with the latest version (using Carthage) and i have the latest Alamofire (2.0.0)

```
dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
Referenced from: /Users/X/Library/Developer/CoreSimulator/Devices/B3EC90B1-97EC-4E7B-B459-282565E65D17/data/Containers/Bundle/Application/7B3476BB-ECBF-4CB3-8D13-02D44AD934FE/X.app/Frameworks/Moya.framework/Moya
Reason: Incompatible library version: Moya requires version 2.0.0 or later, but Alamofire provides version 1.0.0
```
 I think this is actually a issue with Cocoapods [check it](http://stackoverflow.com/a/31636313/2129504)

```
github "ReactiveCocoa/ReactiveCocoa" ~> 4.0
github "TransitApp/SVProgressHUD" ~> 1.1
github "Moya/Moya" ~> 2.2.2
github "robb/Cartography" ~> 0.6
github "kishikawakatsumi/KeychainAccess" "swift-2.0"
github "Hearst-DD/ObjectMapper"
github "Alamofire/Alamofire" ~> 2.0
github "tristanhimmelman/AlamofireObjectMapper" ~> 0.8
github "onevcat/Kingfisher" ~> 1.5
```
 Not sure if its CocoaPods issue, but it didn't work when i removed `Alamofire`  and  `ReactiveCocoa` from Cartfile either
 @ashfurrow @MarvinNazari you shouldn't have to specify `Moya`'s dependencies in your Cartfile, unless you also have a specific dependency on it. 

The initial error looks like you missed adding the `copy-frameworks` script. Check out [step 4](https://github.com/Carthage/Carthage/blob/master/README.md#if-youre-building-for-ios) in the "Getting Started" section of the `README`.
 @justinmakaila I have the `copy-frameworks` script and all the library works except Moya, i removed the `Alamofire` from Cartfile too, but no luck.
 @MarvinNazari Can you post your updated Cartfile real quick?
 ```
github "ReactiveCocoa/ReactiveCocoa" ~> 4.0
github "TransitApp/SVProgressHUD" ~> 1.1
github "robb/Cartography" ~> 0.6
github "Moya/Moya" ~> 2.2.2
github "kishikawakatsumi/KeychainAccess" "swift-2.0"
github "Hearst-DD/ObjectMapper"
github "tristanhimmelman/AlamofireObjectMapper" ~> 0.8
github "onevcat/Kingfisher" ~> 1.5
github "MarvinNazari/ICSPullToRefresh.Swift" "master"
github "raulriera/TextFieldEffects" ~> 0.4.2
```
 @MarvinNazari Are you building for Xcode 7 and Swift 2?
 Yes.
 Ah, I'm afraid I can't be of much help right now, I need to install the Xcode 7 GM. Let me get that download started, and I'll report back here if I find anything.

@Moya/contributors: Can anyone step in?
 Xcode 7 is coming very soon so just wait for that (https://developer.apple.com/xcode/download/)
 ;) I've been checking the Software update section on my phone every half hour all day.

‚ÄîJustin Makaila

On Wed, Sep 16, 2015 at 1:23 PM, Marvin Nazari notifications@github.com
wrote:

> ## Xcode 7 is coming very soon so just wait for that (https://developer.apple.com/xcode/download/)
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/issues/222#issuecomment-140811163
 Ok, all installed. Beginning triage!
 Any news on this. I've started seeing the error as well. No luck yet.
 Using the latest of Carthage and RAC 4.0, I built just fine¬†

‚ÄîJustin Makaila

On Fri, Sep 18, 2015 at 5:28 AM, Petr Korolev notifications@github.com
wrote:

> The same issue with my projects. I believe it's not related with Moya..
> 
> ## https://github.com/Alamofire/Alamofire/issues/55
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/issues/222#issuecomment-141397118
 it builds fine! when u run the app it crashes!
I just copied the files directly in the project for time being and it runs as it should
 The problem is that ReactiveCocoa doesn't set it's version or compatibility version so it is just one. They use carthage to manage the version so it doesn't matter what the version is in the Xcode project. On the other hand, cocoapods does set it the compatibility version to 4 when building ReactiveCocoa which results in a conflict. You could manually set the compatibility version for all the pods in the `Carthage.xcodeproj` to 1. That should fix the issues. Not really a fix but should work.  
 @petester42 thanks, changing _compatibility version_ to 1 helped
 Pretty sure the work from #267 closes this issue.
  When following the README to set up Reactive Moya, e.g.:

```
pod 'Moya/ReactiveCocoa'
```

After a `pod update` the build results are:

```
/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Box/Box/Box.swift:6:37: error: 'Printable' has been renamed to 'CustomStringConvertible'
public final class Box<T>: BoxType, Printable {
                                    ^~~~~~~~~
                                    CustomStringConvertible
/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Box/Box/Box.swift:31:10: error: 'toString' has been renamed to 'String'
                return toString(value)
                       ^~~~~~~~
                       String
Swift.toString:1:33: note: 'toString' has been explicitly marked unavailable here
@available(*, unavailable) func toString<T>(x: T) -> String
                                ^

/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Box/Box/MutableBox.swift:8:51: error: 'Printable' has been renamed to 'CustomStringConvertible'
public final class MutableBox<T>: MutableBoxType, Printable {
                                                  ^~~~~~~~~
                                                  CustomStringConvertible
/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Box/Box/MutableBox.swift:25:10: error: 'toString' has been renamed to 'String'
                return toString(value)
                       ^~~~~~~~
                       String
Swift.toString:1:33: note: 'toString' has been explicitly marked unavailable here
@available(*, unavailable) func toString<T>(x: T) -> String
                                ^
```

This is probably related to the following dependencies that get pulled in:

```
Using Box (1.2.2)
Using ReactiveCocoa (3.0.0)
Using Result (0.4.4)
```
 Xcode 7 GM.
 All fixed. Sorry for the slow response! (Too many windows!)
  I don't know if this is relevant, but Moya adds another level of abstraction on top of Alamofire which is on top of NSURLSession, so with all this debug logging of all the network stuff can be hard. I think may be we can implement something similar to incredibly useful https://github.com/AFNetworking/AFNetworkActivityLogger in such a way it fits Moya's architecture? IMO it will be very useful. E.g. add enableLogging flag to Endpoint with print() calls or something better?
 If we add something like `print("\(applicationName): \(date) Request Headers:\(request.request!.allHTTPHeaderFields)")` inside `func request(token: T, completion: MoyaCompletion)` it will be too intrusive. Or did you mean smth. different in "hook into the existing provider initialization"?  `NSNotification` sounds like a good idea. 
 @ashfurrow  Great idea. We can go with this solution. What about logging a response? It can be useful to see plain server response in string format.
 @ashfurrow  Just to be sure I understood you correctly. We will have a `protocol Loggable` with some methods/callbacks (`networkRequestDidStart/Finish`). Also we would have some kind of type class (`protocol extension`) with default implementations of the logging methods. And we will use it as some kind of delegate and call its methods inside of  `request(token: T, completion: MoyaCompletion) -> Cancellable`. We will declare it like `let loggerDelegate: T` and  `T where T: Loggable`.  Correct me, please, if I was wrong somewhere or missed smth.
 @ashfurrow  I understood my mistake, so I deleted my previous response:)
The only question: why do you want to make it an Optional `var`, not just `let` ? I don't really want mutable properties inside `Provider`. We can allow user to init it when he creates a provider instance here:  `return ReactiveMoyaProvider<UserApi>(endpointsClosure: endpointsClosure, endpointResolver: endpointResolver(), logger: MyLogger(), stubResponses: false)` or use a default parameter `PlainLogger` with our predefined implementation.
As for other you suggestions I completely agree. 
 @ashfurrow "Many (most?) users won't want HTTP logging" - reasonable :blush: 
Ok, so we will have a nullable property `let logger?` and no logging by default, a `PlainLogger` (better `MoyaLogger` or smth. like this), which we have to include in the documentation and `Logger` protocol, so users can provide their own logging implementations if they want. In the basic implementation we just will print() all the things (headers, data in UTF8 strings)
 Great.  I hope to implement this soon, when I will have more free time.
  I think this method can be useful to avoid boilerplate, because in my case I have to use different parameter encodings for some selected requests and I didn't find another method to quickly change encoding for a particular API request, except from directly calling init with all parameters again.
  Hello again, sorry for disturbing you second time today. I launched Demo in Xcode 6.4 while I was playing with #216 and got Swift compilation error (code from master branch).

Could you please take a look at this gist ? https://gist.github.com/nmtitov/154cd1738a517065593c Looks like toolchain is not set up? But `xcode-select -p` shows correct path.
 Oh, I see. Thank you!
 Hi, i am trying to run Xcode for mac app. No code nothing but still it gives errors . I am using Xcode 6.4.  why ?
Steps i am doing are : open Xcode , select OS X - application- cocoa application, and language swift. errors are with objective c as well. Why so ?
 The first thing would be that this library requires Xcode 7.1 and the second would be that there are issues with the Mac target if you are not using cocoapods. There is a fix here #283 but we still have some problems. 
  I can't get demo running. I'm using Xcode 7.0. Here is error log from console:

```
dyld: Library not loaded: @rpath/libswiftCoreLocation.dylib
  Referenced from: /Users/hello/Library/Developer/Xcode/DerivedData/Demo-djsbbkgjbpaearfipsplncpfociz/Build/Products/Debug-iphonesimulator/Moya.framework/Moya
  Reason: image not found
```

```
$ cat Podfile
platform :ios, '8.0'

source 'https://github.com/CocoaPods/Specs.git'

use_frameworks!

# Swift indirect dependencies we need to force to Swift 2
pod 'Box', :head
pod 'Result', :head

pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'RxSwift', '~> 2.0.0-alpha'
pod 'Alamofire'

pod 'Moya/ReactiveCocoa', :path => "../"
pod 'Moya/RxSwift', :path => "../"
pod 'Moya', :path => "../"

target 'DemoTests' do

  pod 'Quick', :git => 'https://github.com/Quick/Quick'
  pod 'Nimble', :git => 'https://github.com/Quick/Nimble'
  pod 'OHHTTPStubs'

end
```

I'd be glad if someone could help. Thanks!
 Yes of course. I am running latest stable cocoapods (however I've noticed you are using 0.39 beta?):

```
$ pod --version
0.38.2
```

This is my Podfile.lock

```
PODS:
  - Alamofire (2.0.0)
  - Box (HEAD based on 1.2.2)
  - Moya (2.1.0):
    - Moya/Core (= 2.1.0)
  - Moya/Core (2.1.0):
    - Alamofire
  - Moya/ReactiveCocoa (2.1.0):
    - Moya/ReactiveCore
    - ReactiveCocoa
  - Moya/ReactiveCore (2.1.0):
    - Moya/Core
  - Moya/RxSwift (2.1.0):
    - Moya/ReactiveCore
    - RxSwift
  - Nimble (2.0.0-rc.3)
  - OHHTTPStubs (4.2.0):
    - OHHTTPStubs/Default (= 4.2.0)
  - OHHTTPStubs/Core (4.2.0)
  - OHHTTPStubs/Default (4.2.0):
    - OHHTTPStubs/Core
    - OHHTTPStubs/JSON
    - OHHTTPStubs/NSURLSession
    - OHHTTPStubs/OHPathHelpers
  - OHHTTPStubs/JSON (4.2.0):
    - OHHTTPStubs/Core
  - OHHTTPStubs/NSURLSession (4.2.0):
    - OHHTTPStubs/Core
  - OHHTTPStubs/OHPathHelpers (4.2.0)
  - Quick (0.6.0)
  - ReactiveCocoa (3.0-swift2):
    - Box
    - ReactiveCocoa/UI (= 3.0-swift2)
    - Result
  - ReactiveCocoa/Core (3.0-swift2):
    - Box
    - ReactiveCocoa/no-arc
    - Result
  - ReactiveCocoa/no-arc (3.0-swift2):
    - Box
    - Result
  - ReactiveCocoa/UI (3.0-swift2):
    - Box
    - ReactiveCocoa/Core
    - Result
  - Result (HEAD based on 0.6-beta.1)
  - RxSwift (2.0.0-alpha.2)

DEPENDENCIES:
  - Alamofire
  - Box (HEAD)
  - Moya (from `../`)
  - Moya/ReactiveCocoa (from `../`)
  - Moya/RxSwift (from `../`)
  - Nimble (from `https://github.com/Quick/Nimble`)
  - OHHTTPStubs
  - Quick (from `https://github.com/Quick/Quick`)
  - ReactiveCocoa (from `https://github.com/ashfurrow/ReactiveCocoa.git`, branch `swift2`)
  - Result (HEAD)
  - RxSwift (~> 2.0.0-alpha)

EXTERNAL SOURCES:
  Moya:
    :path: ../
  Nimble:
    :git: https://github.com/Quick/Nimble
  Quick:
    :git: https://github.com/Quick/Quick
  ReactiveCocoa:
    :branch: swift2
    :git: https://github.com/ashfurrow/ReactiveCocoa.git

CHECKOUT OPTIONS:
  Nimble:
    :commit: 91f3921fbfdae1b02def17b27267a13f4606ec03
    :git: https://github.com/Quick/Nimble
  Quick:
    :commit: ac5eadd202dd67741628f80fb96e8c57388d954d
    :git: https://github.com/Quick/Quick
  ReactiveCocoa:
    :commit: b653f8db9f1788ec1f1ae6523a2f2e01a289b3c1
    :git: https://github.com/ashfurrow/ReactiveCocoa.git

SPEC CHECKSUMS:
  Alamofire: 2f13548b29d25a58ecd91c9225fb51493e2b782b
  Box: a92e8aa4c099e6bc0733829665caf9e668ef53b8
  Moya: cf40dc2fef002d59b6745cac715d6016bc0428aa
  Nimble: 2f64d173ad23dc39f10110840a1ed15f29ef75e8
  OHHTTPStubs: f639130b83fb5f4f022d38f841141b0a6fa77249
  Quick: aaa961333f0bec39bfefa4b759128e4eb39f0d0e
  ReactiveCocoa: d99571cf654b8e6703f338ca13f486b999c51969
  Result: 6c990ec4a72470672f9fc5b6fef009da0f6f40d1
  RxSwift: 0450126df5f8de3ec7ee789b420d7ba98baea364

COCOAPODS: 0.38.2
```

By the way I guess everything is fine with Xcode 6.x? Will demo work if I reinstall previous version?
 I tried cocoapods version 0.39.0.beta.4 and got same error:

```
dyld: Library not loaded: @rpath/libswiftCoreLocation.dylib
  Referenced from: /Users/hello/Library/Developer/Xcode/DerivedData/Demo-djsbbkgjbpaearfipsplncpfociz/Build/Products/Debug-iphonesimulator/Moya.framework/Moya
  Reason: image not found
```

This error happens in runtime, after I see simulator with launch screen. Compilation completes successfully without errors. I'll try with Xcode 6 and report status soon.
 Thank you, it works now :)
  How does this work for Cartfiles? What do carthage users do to use ReactiveMoya, RxMoya, and Moya, on a per requirement basis? Is that a concept anymore, or are we back to the single Moya.framework?

‚ÄîJustin Makaila

On Sat, Sep 12, 2015 at 9:24 PM, Ash Furrow notifications@github.com
wrote:

> This pull requests adds Carthage support to Moya, including its two extensions, RxMoya and ReactiveMoya. It works off of @justinmakaila's work in #169 to include Carthage support, but works using a different solution that @orta and I implemented this afternoon. Let me explain.
> In #154, we discussed a solution that involved splitting up Moya into several repositories to generate separate `.framework` files for each Moya, ReactiveMoya, and RxMoya. The solution in this PR instead uses thin podspecs _solely_ for the ReactiveCocoa and RxSwift extensions. This lets the `Pods` Xcode project build separately-named targets, which compile into the frameworks that Carthage needs.
> The benefits of this approach are that we keep all of our code in _one_ repository instead of having to synchronize version numbers, tags, pull requests, and so on between three or four repositories. This would be a significant challenge.
> The downsides are that we need to keep versions synced between the three podspecs (I've written a `rake` task to automate this). Additionally, if the public APIs to RxSwift or ReactiveCocoa change, Carthage users will need to continue to use the versions required by the CocoaPods builds. I actually kind of like the idea of one Moya existing in parallel on two dependency managers.
> 
> ## Work Done
> - We switched from a `Makefile` to a `Rakefile`.
> - Automated releases.
> - Re-added `Pods/` directory for Carthage support.
> - Duplicated the RxMoya and ReactiveMoya subspecs into their own standalone podspecs, and trimmed them down.
> - Removes unnecessary `Box` dependency from the Demo's `Podfile`.
> - Updated documentation.
>   ## Next Steps
>   The [ReactiveMoya](https://github.com/Moya/ReactiveMoya) and [RxMoya](https://github.com/Moya/RxMoya) repositories are no longer needed and should be deleted after this pull request is merged. Any existing Carthage users will need to update their Cartfiles.
>   ## Notes
>   `MoyaResponse.swift` is included in both Carthage-specific podspecs, but it only appears once in the `Pods` project's file pane. The file is a member of both targets, but only appears once. The ambiguity between the files referenced in both frameworks led me to split up the unit tests into distinct files (to avoid having both `MoyaResponse`s in scope). I also tidied them up a bit.
>   Fixes #204.
>   Fixes #154.
>   Fixes #184.
>   You can view, comment on, or merge this pull request online at:
>   https://github.com/Moya/Moya/pull/215
>   -- Commit Summary --
>   - carthage_via_internal_podspecs
>   - [Carthage] Added Reactive podspec.
>   - [Carthage] Cleaned up unit tests.
>   - [Infrastructure] Moved to Rake tasks.
>   - Merge branch 'master' of https://github.com/Moya/Moya into internal_podspecs
>   - [Carthage] Slims down podspects.
>   - [CocoaPods] Cleans up Demo Podfile.
>   - remove cartfiles
>   - bring back the pods
>   - [CocoaPods] Updated to latest beta.
>   - [README] Updated installation section.
>   - [CocoaPods] Adds version requirement on Alamofire.
>   - [Deploys] Automated release task.
>   - [README] Updated installation instructions.
>     -- File Changes --
>     M .gitignore (7)
>     M .travis.yml (2)
>     M CHANGELOG.md (3)
>     D Cartfile (2)
>     D Cartfile.resolved (4)
>     M Demo/Demo.xcodeproj/project.pbxproj (8)
>     M Demo/DemoTests/EndpointSpec.swift (4)
>     M Demo/DemoTests/MoyaProviderIntegrationTests.swift (9)
>     M Demo/DemoTests/MoyaProviderSpec.swift (574)
>     M Demo/DemoTests/RACSignal+MoyaSpec.swift (20)
>     A Demo/DemoTests/ReactiveCocoaMoyaProviderTests.swift (150)
>     A Demo/DemoTests/RxSwiftMoyaProviderTests.swift (78)
>     M Demo/Podfile (8)
>     M Demo/Podfile.lock (36)
>     A Demo/Pods/Alamofire/LICENSE (19)
>     A Demo/Pods/Alamofire/README.md (1072)
>     A Demo/Pods/Alamofire/Source/Alamofire.swift (368)
>     A Demo/Pods/Alamofire/Source/Download.swift (244)
>     A Demo/Pods/Alamofire/Source/Error.swift (66)
>     A Demo/Pods/Alamofire/Source/Manager.swift (649)
>     A Demo/Pods/Alamofire/Source/MultipartFormData.swift (669)
>     A Demo/Pods/Alamofire/Source/ParameterEncoding.swift (217)
>     A Demo/Pods/Alamofire/Source/Request.swift (536)
>     A Demo/Pods/Alamofire/Source/ResponseSerialization.swift (331)
>     A Demo/Pods/Alamofire/Source/Result.swift (114)
>     A Demo/Pods/Alamofire/Source/ServerTrustPolicy.swift (305)
>     A Demo/Pods/Alamofire/Source/Stream.swift (180)
>     A Demo/Pods/Alamofire/Source/Upload.swift (372)
>     A Demo/Pods/Alamofire/Source/Validation.swift (187)
>     A Demo/Pods/Headers/Private/Nimble/DSL.h (1)
>     A Demo/Pods/Headers/Private/Nimble/NMBExceptionCapture.h (1)
>     A Demo/Pods/Headers/Private/Nimble/Nimble.h (1)
>     A Demo/Pods/Headers/Private/OHHTTPStubs/Compatibility.h (1)
>     A Demo/Pods/Headers/Private/OHHTTPStubs/OHHTTPStubs.h (1)
>     A Demo/Pods/Headers/Private/OHHTTPStubs/OHHTTPStubsResponse+JSON.h (1)
>     A Demo/Pods/Headers/Private/OHHTTPStubs/OHHTTPStubsResponse.h (1)
>     A Demo/Pods/Headers/Private/OHHTTPStubs/OHPathHelpers.h (1)
>     A Demo/Pods/Headers/Private/Quick/NSString+QCKSelectorName.h (1)
>     A Demo/Pods/Headers/Private/Quick/QCKDSL.h (1)
>     A Demo/Pods/Headers/Private/Quick/Quick.h (1)
>     A Demo/Pods/Headers/Private/Quick/QuickConfiguration.h (1)
>     A Demo/Pods/Headers/Private/Quick/QuickSpec.h (1)
>     A Demo/Pods/Headers/Private/Quick/World+DSL.h (1)
>     A Demo/Pods/Headers/Private/Quick/World.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/MKAnnotationView+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/RACObjCRuntime.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/EXTKeyPathCoding.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/EXTRuntimeExtensions.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/EXTScope.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSArray+RACSequenceAdditions.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSData+RACSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSDictionary+RACSequenceAdditions.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSEnumerator+RACSequenceAdditions.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSFileHandle+RACSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSIndexSet+RACSequenceAdditions.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSInvocation+RACTypeParsing.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSNotificationCenter+RACSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSObject+RACDeallocating.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSObject+RACDescription.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSObject+RACKVOWrapper.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSObject+RACLifting.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSObject+RACPropertySubscribing.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSObject+RACSelectorSignal.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSOrderedSet+RACSequenceAdditions.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSSet+RACSequenceAdditions.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSString+RACKeyPathUtilities.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSString+RACSequenceAdditions.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSString+RACSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSURLConnection+RACSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/NSUserDefaults+RACSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACArraySequence.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACBehaviorSubject.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACBlockTrampoline.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACChannel.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACCommand.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACCompoundDisposable.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACDelegateProxy.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACDisposable.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACDynamicPropertySuperclass.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACDynamicSequence.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACDynamicSignal.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACEagerSequence.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACEmptySequence.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACEmptySignal.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACErrorSignal.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACEvent.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACGroupedSignal.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACImmediateScheduler.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACIndexSetSequence.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACKVOChannel.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACKVOProxy.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACKVOTrampoline.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACMulticastConnection+Private.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACMulticastConnection.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACPassthroughSubscriber.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACQueueScheduler+Subclass.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACQueueScheduler.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACReplaySubject.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACReturnSignal.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACScheduler+Private.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACScheduler+Subclass.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACScheduler.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACScopedDisposable.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACSequence.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACSerialDisposable.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACSignal+Operations.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACSignal.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACSignalSequence.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACStream+Private.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACStream.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACStringSequence.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACSubject.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACSubscriber+Private.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACSubscriber.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACSubscriptingAssignmentTrampoline.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACSubscriptionScheduler.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACTargetQueueScheduler.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACTestScheduler.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACTuple.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACTupleSequence.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACUnarySequence.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACUnit.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/RACValueTransformer.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/ReactiveCocoa-Bridging-Header.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/ReactiveCocoa/metamacros.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIActionSheet+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIAlertView+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIBarButtonItem+RACCommandSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIButton+RACCommandSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UICollectionReusableView+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIControl+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIControl+RACSignalSupportPrivate.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIDatePicker+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIGestureRecognizer+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIImagePickerController+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIRefreshControl+RACCommandSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UISegmentedControl+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UISlider+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UIStepper+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UISwitch+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UITableViewCell+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UITableViewHeaderFooterView+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UITextField+RACSignalSupport.h (1)
>     A Demo/Pods/Headers/Private/ReactiveCocoa/UITextView+RACSignalSupport.h (1)
>     A Demo/Pods/Local Podspecs/Moya.podspec.json (68)
>     A Demo/Pods/Local Podspecs/Nimble.podspec.json (31)
>     A Demo/Pods/Local Podspecs/Quick.podspec.json (35)
>     A Demo/Pods/Local Podspecs/ReactiveCocoa.podspec.json (76)
>     A Demo/Pods/Local Podspecs/ReactiveMoya.podspec.json (20)
>     A Demo/Pods/Local Podspecs/RxMoya.podspec.json (20)
>     A Demo/Pods/Manifest.lock (89)
>     A Demo/Pods/Nimble/LICENSE.md (201)
>     A Demo/Pods/Nimble/Nimble/Adapters/AdapterProtocols.swift (17)
>     A Demo/Pods/Nimble/Nimble/Adapters/AssertionDispatcher.swift (20)
>     A Demo/Pods/Nimble/Nimble/Adapters/AssertionRecorder.swift (99)
>     A Demo/Pods/Nimble/Nimble/Adapters/NimbleXCTestHandler.swift (40)
>     A Demo/Pods/Nimble/Nimble/DSL+Wait.swift (50)
>     A Demo/Pods/Nimble/Nimble/DSL.swift (32)
>     A Demo/Pods/Nimble/Nimble/Expectation.swift (64)
>     A Demo/Pods/Nimble/Nimble/Expression.swift (90)
>     A Demo/Pods/Nimble/Nimble/FailureMessage.swift (56)
>     A Demo/Pods/Nimble/Nimble/Matchers/AllPass.swift (90)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeAKindOf.swift (34)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeAnInstanceOf.swift (34)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeCloseTo.swift (121)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeEmpty.swift (90)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeGreaterThan.swift (37)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeGreaterThanOrEqualTo.swift (39)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeIdenticalTo.swift (28)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeLessThan.swift (36)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeLessThanOrEqual.swift (37)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeLogical.swift (93)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeNil.swift (18)
>     A Demo/Pods/Nimble/Nimble/Matchers/BeginWith.swift (53)
>     A Demo/Pods/Nimble/Nimble/Matchers/Contain.swift (91)
>     A Demo/Pods/Nimble/Nimble/Matchers/EndWith.swift (63)
>     A Demo/Pods/Nimble/Nimble/Matchers/Equal.swift (148)
>     A Demo/Pods/Nimble/Nimble/Matchers/HaveCount.swift (48)
>     A Demo/Pods/Nimble/Nimble/Matchers/Match.swift (27)
>     A Demo/Pods/Nimble/Nimble/Matchers/MatcherProtocols.swift (98)
>     A Demo/Pods/Nimble/Nimble/Matchers/RaisesException.swift (178)
>     A Demo/Pods/Nimble/Nimble/Matchers/ThrowError.swift (181)
>     A Demo/Pods/Nimble/Nimble/Nimble.h (6)
>     A Demo/Pods/Nimble/Nimble/ObjCExpectation.swift (125)
>     A Demo/Pods/Nimble/Nimble/Utils/Functional.swift (11)
>     A Demo/Pods/Nimble/Nimble/Utils/Poll.swift (86)
>     A Demo/Pods/Nimble/Nimble/Utils/SourceLocation.swift (21)
>     A Demo/Pods/Nimble/Nimble/Utils/Stringers.swift (62)
>     A Demo/Pods/Nimble/Nimble/Wrappers/AsyncMatcherWrapper.swift (98)
>     A Demo/Pods/Nimble/Nimble/Wrappers/MatcherFunc.swift (95)
>     A Demo/Pods/Nimble/Nimble/Wrappers/ObjCMatcher.swift (78)
>     A Demo/Pods/Nimble/Nimble/objc/DSL.h (133)
>     A Demo/Pods/Nimble/Nimble/objc/DSL.m (142)
>     A Demo/Pods/Nimble/Nimble/objc/NMBExceptionCapture.h (8)
>     A Demo/Pods/Nimble/Nimble/objc/NMBExceptionCapture.m (35)
>     A Demo/Pods/Nimble/README.md (1175)
>     A Demo/Pods/OHHTTPStubs/LICENSE (9)
>     A Demo/Pods/OHHTTPStubs/OHHTTPStubs/Sources/Compatibility.h (47)
>     A Demo/Pods/OHHTTPStubs/OHHTTPStubs/Sources/JSON/OHHTTPStubsResponse+JSON.h (57)
>     A Demo/Pods/OHHTTPStubs/OHHTTPStubs/Sources/JSON/OHHTTPStubsResponse+JSON.m (48)
>     A Demo/Pods/OHHTTPStubs/OHHTTPStubs/Sources/NSURLSession/OHHTTPStubs+NSURLSessionConfiguration.m (88)
>     A Demo/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHHTTPStubs.h (195)
>     A Demo/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHHTTPStubs.m (530)
>     A Demo/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHHTTPStubsResponse.h (264)
>     A Demo/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHHTTPStubsResponse.m (193)
>     A Demo/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHPathHelpers/OHPathHelpers.h (86)
>     A Demo/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHPathHelpers/OHPathHelpers.m (52)
>     A Demo/Pods/OHHTTPStubs/README.md (113)
>     A Demo/Pods/Pods.xcodeproj/project.pbxproj (3980)
>     A Demo/Pods/Pods.xcodeproj/xcshareddata/xcschemes/Moya.xcscheme (60)
>     A Demo/Pods/Pods.xcodeproj/xcshareddata/xcschemes/ReactiveMoya.xcscheme (60)
>     A Demo/Pods/Pods.xcodeproj/xcshareddata/xcschemes/RxMoya.xcscheme (60)
>     A Demo/Pods/Quick/LICENSE (201)
>     A Demo/Pods/Quick/Quick/Callsite.swift (28)
>     A Demo/Pods/Quick/Quick/Configuration/Configuration.swift (147)
>     A Demo/Pods/Quick/Quick/Configuration/QuickConfiguration.h (30)
>     A Demo/Pods/Quick/Quick/Configuration/QuickConfiguration.m (83)
>     A Demo/Pods/Quick/Quick/DSL/DSL.swift (227)
>     A Demo/Pods/Quick/Quick/DSL/QCKDSL.h (234)
>     A Demo/Pods/Quick/Quick/DSL/QCKDSL.m (79)
>     A Demo/Pods/Quick/Quick/DSL/World+DSL.h (20)
>     A Demo/Pods/Quick/Quick/DSL/World+DSL.swift (102)
>     A Demo/Pods/Quick/Quick/Example.swift (107)
>     A Demo/Pods/Quick/Quick/ExampleGroup.swift (101)
>     A Demo/Pods/Quick/Quick/ExampleMetadata.swift (22)
>     A Demo/Pods/Quick/Quick/Filter.swift (31)
>     A Demo/Pods/Quick/Quick/Hooks/Closures.swift (35)
>     A Demo/Pods/Quick/Quick/Hooks/ExampleHooks.swift (36)
>     A Demo/Pods/Quick/Quick/Hooks/SuiteHooks.swift (34)
>     A Demo/Pods/Quick/Quick/NSString+QCKSelectorName.h (17)
>     A Demo/Pods/Quick/Quick/NSString+QCKSelectorName.m (33)
>     A Demo/Pods/Quick/Quick/Quick.h (13)
>     A Demo/Pods/Quick/Quick/QuickSpec.h (48)
>     A Demo/Pods/Quick/Quick/QuickSpec.m (158)
>     A Demo/Pods/Quick/Quick/World.h (17)
>     A Demo/Pods/Quick/Quick/World.swift (197)
>     A Demo/Pods/Quick/README.md (66)
>     A Demo/Pods/ReactiveCocoa/LICENSE.md (19)
>     A Demo/Pods/ReactiveCocoa/README.md (333)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/MKAnnotationView+RACSignalSupport.h (29)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/MKAnnotationView+RACSignalSupport.m (31)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSArray+RACSequenceAdditions.h (20)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSArray+RACSequenceAdditions.m (18)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSData+RACSupport.h (22)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSData+RACSupport.m (35)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSDictionary+RACSequenceAdditions.h (31)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSDictionary+RACSequenceAdditions.m (34)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSEnumerator+RACSequenceAdditions.h (20)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSEnumerator+RACSequenceAdditions.m (22)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSFileHandle+RACSupport.h (19)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSFileHandle+RACSupport.m (40)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSIndexSet+RACSequenceAdditions.h (21)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSIndexSet+RACSequenceAdditions.m (18)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSInvocation+RACTypeParsing.h (56)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSInvocation+RACTypeParsing.m (232)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSNotificationCenter+RACSupport.h (18)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSNotificationCenter+RACSupport.m (31)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACDeallocating.h (34)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACDeallocating.m (129)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACDescription.h (16)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACDescription.m (50)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACKVOWrapper.h (46)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACKVOWrapper.m (213)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACLifting.h (61)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACLifting.m (142)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACPropertySubscribing.h (117)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACPropertySubscribing.m (159)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACSelectorSignal.h (79)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSObject+RACSelectorSignal.m (330)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSOrderedSet+RACSequenceAdditions.h (20)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSOrderedSet+RACSequenceAdditions.m (19)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSSet+RACSequenceAdditions.h (20)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSSet+RACSequenceAdditions.m (19)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSString+RACKeyPathUtilities.h (34)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSString+RACKeyPathUtilities.m (36)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSString+RACSequenceAdditions.h (21)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSString+RACSequenceAdditions.m (18)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSString+RACSupport.h (22)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSString+RACSupport.m (35)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSURLConnection+RACSupport.h (25)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSURLConnection+RACSupport.m (54)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSUserDefaults+RACSupport.h (27)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/NSUserDefaults+RACSupport.m (56)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACArraySequence.h (18)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACArraySequence.m (125)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACBehaviorSubject.h (18)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACBehaviorSubject.m (56)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACBlockTrampoline.h (30)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACBlockTrampoline.m (156)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACChannel.h (70)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACChannel.m (90)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACCommand.h (123)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACCommand.m (267)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACCompoundDisposable.h (48)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACCompoundDisposable.m (239)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACCompoundDisposableProvider.d (4)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACDelegateProxy.h (28)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACDelegateProxy.m (76)
>     A Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACDisposable.h (35)
>     I Demo/Pods/ReactiveCocoa/ReactiveCocoa/Objective-C/RACDisposable.m (0)
>     -- Patch Links --
>     https://github.com/Moya/Moya/pull/215.patch
>     https://github.com/Moya/Moya/pull/215.diff
>     ---
>     Reply to this email directly or view it on GitHub:
>     https://github.com/Moya/Moya/pull/215
 Before I started the Carthage refactor, that's initially what I did. I had three frameworks output, with all of their dependencies. The downside was that in every file where you wanted to use any component of `ReactiveMoya`, you had to import `Moya` as well. 

Is this still the case? Or do `ReactiveMoya` and `RxMoya` have the `Moya` core embedded?
 It shouldn't be the default, it was an annoyance, for which we initially compensated by creating the separate repositories. This allowed for Cartfile level specification of the flavor of Moya, and an output of a single Moya.franework.

‚ÄîJustin Makaila

On Sun, Sep 13, 2015 at 8:47 AM, Orta notifications@github.com wrote:

> ## Right now that's not the case, but I don't see any reason to not make that behaviour default @ashfurrow ?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/pull/215#issuecomment-139870146
 Yes, exactly. That way, if you change your flavor, you don't have to search for all the imports and update, you just update your usage of the API.

‚ÄîJustin Makaila

On Sun, Sep 13, 2015 at 8:59 AM, Orta notifications@github.com wrote:

> ## So you want the behaviour where you would always do `@import Moya;` and it would work fine regardless of which framework you've imported? This is totally doable using [module_name](https://guides.cocoapods.org/syntax/podspec.html#module_name) in the other Podspecs. I _think_ it would generate three differently named frameworks for drag & drop but they would all all work with `@import Moya;`. Can't guarantee that Xcode allows the generation of the three frameworks with the same module name, but can be tested. 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/pull/215#issuecomment-139872551
 fwiw, pulling this down and running `carthage build --no-skip-current` results in a failure (with Xcode 7):

```
‚ùØ carthage build --no-skip-current
*** xcodebuild output can be found in /var/folders/ym/cjv2ctc130v3slskyn7zw_2r0000gn/T/carthage-xcodebuild.Kbexbi.log
*** Building scheme "RxMoya" in Demo.xcworkspace
** BUILD FAILED **


The following build commands failed:
        CompileSwift normal x86_64 /Users/gordon/Code/Moya/Moya/Moya/RxSwift/Moya+RxSwift.swift
        CompileSwift normal x86_64 /Users/gordon/Code/Moya/Moya/Moya/ReactiveCore/MoyaResponse.swift
        CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(3 failures)
/Users/gordon/Code/Moya/Moya/Moya/RxSwift/Moya+RxSwift.swift:2:8: error: no such module 'Moya'
/Users/gordon/Code/Moya/Moya/Moya/RxSwift/Moya+RxSwift.swift:2:8: error: no such module 'Moya'
A shell task failed with exit code 65:
** BUILD FAILED **


The following build commands failed:
        CompileSwift normal x86_64 /Users/gordon/Code/Moya/Moya/Moya/RxSwift/Moya+RxSwift.swift
        CompileSwift normal x86_64 /Users/gordon/Code/Moya/Moya/Moya/ReactiveCore/MoyaResponse.swift
        CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(3 failures)
```
 Sure, I'll take it

‚ÄîJustin Makaila

On Sun, Sep 13, 2015 at 2:45 PM, Ash Furrow notifications@github.com
wrote:

> ## I've fixed #216 on this branch ‚Äì just rearranging the podfile a bit. I've run carthage locally and it seems to be :+1: 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/pull/215#issuecomment-139907249
  This set of commits fixes a bunch of compilation issues that the Swift 2 branch has had. 

Even better - the tests work again! (Excluding ReactiveCocoa, more on this below)
1. Fixed up the Moya+RxSwift and Moya+ReactiveCocoa compilation issues with the change from NSError -> ErrorType (as I mentioned in my last PR at https://github.com/Moya/Moya/pull/207) 
2. With the release of Xcode 7 GM, Alamofire decided to move fast and break things by deleting their Swift 2 branch. I've updated the Podfile to point at master.
3. Fixed a compilation issue in the demo project.
4. Running `make test` spat out a heap of issues, all errors due to changes in Swift 2 over the Xcode 7 beta. I've updated the Quick and Nimble pods and fixed the issues. 

I should point out that in https://github.com/Moya/Moya/commit/3b46ef81f55d9f906a0fea8c7fa67889ce1eee19 ReactiveCocoa was commented out due to incompatibility. As such, I've commented out the tests that use ReactiveCocoa until the incompatibilities are fixed. 

This PR might look rather large but it's mostly down to the fact that Moya has the Pod directory committed. (As per https://github.com/Moya/Moya/pull/147)

Also I should say - thanks for adding me as a collaborator, Ash! I'll leave you or someone else to merge this in (probably better to have someone look over it that isn't me at least.)
 OK, looks like I spoke too soon on the tests. They run locally? :-P

I'm seeings lots of things like `use of undeclared type 'ErrorType'` - I'm guessing CI isn't using Swift 2?
  Tried to pull the latest swift-2.0 into Xcode 7 GM and getting lots of compiler errors, such as "#" having been removed from Swift.
 Tried a few different things, starting with the swift-2.0 branch README.md... obviously out of date.

After updating to:

```
pod 'Box', :head
pod 'Result', :head
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'
```

It is healthier ‚Äì¬†seems to be down to two compile errors (versus the dozens prior to the change):

```
CompileSwift normal x86_64 /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Moya/Moya/ReactiveCocoa/Moya+ReactiveCocoa.swift
    cd /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Moya/Moya/Endpoint.swift -primary-file /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Moya/Moya/ReactiveCocoa/Moya+ReactiveCocoa.swift /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Moya/Moya/Moya.swift /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Moya/Moya/ReactiveCore/MoyaResponse.swift /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Moya/Moya/ReactiveCocoa/RACSignal+Moya.swift -target x86_64-apple-ios8.2 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.0.sdk -I "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Products/QA 1-iphonesimulator" -F "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Products/QA 1-iphonesimulator" -g -import-underlying-module -module-cache-path /Users/zbeckman/Library/Developer/Xcode/DerivedData/ModuleCache -D COCOAPODS -serialize-debugging-options -Xcc "-I/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/Moya-generated-files.hmap" -Xcc "-I/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/Moya-own-target-headers.hmap" -Xcc "-I/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/Moya-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/Moya-project-headers.hmap" -Xcc "-I/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Products/QA 1-iphonesimulator/include" -Xcc -I/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Headers/Private -Xcc -I/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Headers/Private/Moya -Xcc -I/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Headers/Public -Xcc "-I/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/DerivedSources/x86_64" -Xcc "-I/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/DerivedSources" -Xcc -DQA_1=1 -Xcc -DCOCOAPODS=1 -Xcc -ivfsoverlay -Xcc "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods -emit-module-doc-path "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/Objects-normal/x86_64/Moya+ReactiveCocoa~partial.swiftdoc" -O -module-name Moya -emit-module-path "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/Objects-normal/x86_64/Moya+ReactiveCocoa~partial.swiftmodule" -serialize-diagnostics-path "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/Objects-normal/x86_64/Moya+ReactiveCocoa.dia" -emit-dependencies-path "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/Objects-normal/x86_64/Moya+ReactiveCocoa.d" -emit-reference-dependencies-path "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/Objects-normal/x86_64/Moya+ReactiveCocoa.swiftdeps" -o "/Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/Pods.build/QA 1-iphonesimulator/Moya.build/Objects-normal/x86_64/Moya+ReactiveCocoa.o"

/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Moya/Moya/ReactiveCocoa/Moya+ReactiveCocoa.swift:37:66: error: value of type 'ErrorType' has no member 'domain'
                            subscriber.sendError(NSError(domain: error.domain, code: statusCode, userInfo: error.userInfo))
                                                                 ^~~~~ ~~~~~~
/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Moya/Moya/ReactiveCocoa/Moya+ReactiveCocoa.swift:39:50: error: cannot convert value of type 'ErrorType' to expected argument type 'NSError!'
                            subscriber.sendError(error)
                                                 ^~~~~
```

Ideas...?

By the way, what's the difference between your Alamofire branch and the Swift 2 master (Alamofire) branch? Can I safely point at the Alamofire URL or should I stick with your's for now...?

(Kind of looking for guidance on how to proceed now that Xcode 7 GM is out...)
 Alamofire were very quick - they've already merged their Swift branch into master and deleted the Swift 2 branch. You just need to point at the master branch for Alamofire now. 

I've submitted a PR for Moya which updates this. 
 Hmm. Still no good, I'm seeing the same error. Updated to use the latest AlamoFire. Here's the complete Podspec I'm using:

```
target 'Glimpulse', :exclusive => false do
        pod 'SwiftSpinner', :git => 'https://github.com/zbeckman/SwiftSpinner.git'
        pod 'XCGLogger', :git => 'https://github.com/DaveWoodCom/XCGLogger.git', :branch => 'swift_2.0'
        pod 'GRValidation', '~> 0.2'
        pod 'SwiftDate', :git => 'https://github.com/malcommac/SwiftDate.git', :branch => 'swift-2.0'
        pod 'DateTimeKit', :git => 'https://github.com/zbeckman/DateTimeKit.git'
        pod 'MagicalRecord'
        pod 'Box', :head
        pod 'Result', :head
        pod 'Alamofire', '~> 2.0'
        pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
        pod 'Moya/ReactiveCocoa', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'
end
```
 (Realizing that, technically this looks like a Moya/ReactiveCocoa issue ‚Äì¬†I can create an issue over there if you would prefer).
 I'm now pulling the following pods:

```
    pod 'Box', :head
    pod 'Result', :head
    pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
    pod 'Alamofire', '~> 2.0'
    pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'
```

After adding Alamofire and Moya, I'm getting the following runtime error. This only _seems_ to be happening after adding in Alamofire and Moya, but I'm still debugging.

If you see anything wrong with my config please let me know.

```
2015-09-11 01:48:07.648 XCTRunner[35507:240964] The bundle ‚ÄúGlimpulseUITests‚Äù couldn‚Äôt be loaded because it is damaged or missing necessary resources. Try reinstalling the bundle.
2015-09-11 01:48:07.648 XCTRunner[35507:240964] (dlopen_preflight(/Users/zbeckman/Library/Developer/CoreSimulator/Devices/FCFAAFBF-1AB4-4223-9BCC-CA91CBDE96DC/data/Containers/Bundle/Application/11F5D849-3061-4E91-A44C-F35AA544520A/GlimpulseUITests-Runner.app/PlugIns/GlimpulseUITests.xctest/GlimpulseUITests): Library not loaded: @rpath/libswiftCoreLocation.dylib
  Referenced from: /Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/CodeCoverage/Glimpulse/Products/QA 1-iphonesimulator/ReactiveCocoa.framework/ReactiveCocoa
  Reason: image not found)
```
 Yes ‚Äì¬†all the routine fixes.

I'm very fuzzy on which pods I need to pull in... ReactiveCocoa, Alamofire, Moya, ReactiveMoya... And I'm pretty sure the README is quite out of date in this regard.

I'm able to get Moya to install ‚Äì¬†but, any attempt to bring in ReactiveCocoa fails.
 Hm, OK ‚Äì¬†a little more info ‚Äì¬†the error I reported above:

```
2015-09-11 01:48:07.648 XCTRunner[35507:240964] The bundle ‚ÄúGlimpulseUITests‚Äù couldn‚Äôt be loaded because it is damaged or missing necessary resources. Try reinstalling the bundle.
2015-09-11 01:48:07.648 XCTRunner[35507:240964] (dlopen_preflight(/Users/zbeckman/Library/Developer/CoreSimulator/Devices/FCFAAFBF-1AB4-4223-9BCC-CA91CBDE96DC/data/Containers/Bundle/Application/11F5D849-3061-4E91-A44C-F35AA544520A/GlimpulseUITests-Runner.app/PlugIns/GlimpulseUITests.xctest/GlimpulseUITests): Library not loaded: @rpath/libswiftCoreLocation.dylib
  Referenced from: /Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/CodeCoverage/Glimpulse/Products/QA 1-iphonesimulator/ReactiveCocoa.framework/ReactiveCocoa
  Reason: image not found)
```

Only seems to be a problem in the "iOS UI Testing Bundle" target type. (Unfortunately, this is where we do all our testing, so the outcome is that when we run tests, it immediately fails and nothing works ‚Äì¬†we just get the above error).
 Also, if I only use:

```
pod 'Alamofire'
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'
```

Then, I get compile errors as follows:

```
CompileSwift normal x86_64 /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Box/Box/Box.swift
    cd /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods

/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Box/Box/Box.swift:6:37: error: 'Printable' has been renamed to 'CustomStringConvertible'
public final class Box<T>: BoxType, Printable {
                                    ^~~~~~~~~
                                    CustomStringConvertible
/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Box/Box/Box.swift:31:10: error: 'toString' has been renamed to 'String'
                return toString(value)
                       ^~~~~~~~
                       String
Swift.toString:1:33: note: 'toString' has been explicitly marked unavailable here
@available(*, unavailable) func toString<T>(x: T) -> String
                                ^

CompileSwift normal x86_64 /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Box/Box/MutableBox.swift
    cd /Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods
/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Box/Box/MutableBox.swift:8:51: error: 'Printable' has been renamed to 'CustomStringConvertible'
public final class MutableBox<T>: MutableBoxType, Printable {
                                                  ^~~~~~~~~
                                                  CustomStringConvertible
/Users/zbeckman/Projects/Glimpulse/iOS/project/Glimpulse/Pods/Box/Box/MutableBox.swift:25:10: error: 'toString' has been renamed to 'String'
                return toString(value)
                       ^~~~~~~~
                       String
Swift.toString:1:33: note: 'toString' has been explicitly marked unavailable here
@available(*, unavailable) func toString<T>(x: T) -> String
                                ^
```

(Hence, the addition of the pods for Box and Result from HEAD). However, once I add in those (fixing the compiler errors) ‚Äì¬†we end up back at the original problem where none of our tests work (the `image not found` error).
 It would seem that if I build ReactiveCocoa using Carthage, and install it as directed (that is, drag the framework into my embedded binaries) ‚Äì¬†the problem changes. Now:

```
2015-09-11 21:15:50.796 XCTRunner[20612:2543548] (dlopen_preflight(/Users/zbeckman/Library/Developer/CoreSimulator/Devices/FCFAAFBF-1AB4-4223-9BCC-CA91CBDE96DC/data/Containers/Bundle/Application/7FD22288-32A0-419F-B0AF-54DE9143FDBB/GlimpulseUITests-Runner.app/PlugIns/GlimpulseUITests.xctest/GlimpulseUITests): Library not loaded: @rpath/libswiftCoreLocation.dylib
  Referenced from: /Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/CodeCoverage/Glimpulse/Products/QA 1-iphonesimulator/Moya.framework/Moya
  Reason: image not found)
```

(Notice that now it's Moya that has library problems...)

I think this has something to do with the fact that I'm building &/or testing for iOS. And I found this, which I'm not sure what to make of: https://github.com/Carthage/Carthage#if-youre-building-for-ios.
 Ok, so after a good bit of fiddling, I learned a few things.

I'm using Xcode 7 GM. I'm in the habit of clearing the project directory and derived data whenever anything odd happens (so, um... like hourly ;-).

First off, everything works just fine if I install ReactiveCocoa using Carthage (Swift 2 branch of course), and drag the framework into our project, in conjunction with the following pods (all required for a good build). In addition, I have `SwiftCheck` installed via Carthage:

```
# UX components
pod 'SwiftSpinner', :git => 'https://github.com/zbeckman/SwiftSpinner.git'

# Frameworks
pod 'MagicalRecord'
pod 'Alamofire'
pod 'Moya', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'

# Utility components
pod 'XCGLogger', :git => 'https://github.com/DaveWoodCom/XCGLogger.git', :branch => 'swift_2.0'
pod 'GRValidation', '~> 0.2'
pod 'DateTimeKit', :git => 'https://github.com/zbeckman/DateTimeKit.git'
```

I also learned that `BrightFutures` has an incompatible dependency (it requires `Result` 0.6.1 and ReactiveCocoa is now using 1.0.0 ‚Äì¬†which leads to a lot of problems... However, with RAC your probably don't need BrightFutures so hopefully this isn't an issue for anyone).

_NOW._ After getting all that figured out (and committed! It took forever so I don't want to lose this config), I gave our project a try with _nothing except these pods_ (and, of course, I removed the Carthage install of RAC):

```
pod 'SwiftSpinner', :git => 'https://github.com/zbeckman/SwiftSpinner.git'
pod 'Result', :head
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => 'https://github.com/Moya/Moya.git'
pod 'XCGLogger', :git => 'https://github.com/DaveWoodCom/XCGLogger.git', :branch => 'swift_2.0'
pod 'GRValidation', '~> 0.2'

target 'GlimpulseTests', :exclusive => false do
    # Testing framework
    pod 'Nimble', :git => 'https://github.com/Quick/Nimble.git', :branch => 'swift-2.0'
    pod 'Quick', :git => 'https://github.com/Quick/Quick', :branch => 'swift-2.0'
end
```

Did the usual (clean project, delete derived data) ‚Äì¬†**and it fails** with the following output:

```
2015-09-12 20:20:32.726 XCTRunner[84436:3618319] (dlopen_preflight(/Users/zbeckman/Library/Developer/CoreSimulator/Devices/FCFAAFBF-1AB4-4223-9BCC-CA91CBDE96DC/data/Containers/Bundle/Application/EF1E312C-E955-45EE-B805-B86307D314A2/GlimpulseUITests-Runner.app/PlugIns/GlimpulseUITests.xctest/GlimpulseUITests): Library not loaded: @rpath/libswiftCoreLocation.dylib
  Referenced from: /Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/CodeCoverage/Glimpulse/Products/QA 1-iphonesimulator/Moya.framework/Moya
  Reason: image not found)
```

Just for the heck of it (to make sure nothing is different) I tried:

```
pod 'Moya', :git => 'https://github.com/Moya/Moya.git'
```

But I think that initial name is just symbolic ‚Äì¬†anyhow, it didn't matter.

So bottom line ‚Äì Still no good using the CocoaPod, but it's fine using Carthage from the original ReactiveCocoa repository.

I'm stumped...
 I tried removing the Carthage install of ReactiveCocoa, and then updating with the pods you suggested:

```
pod 'Result', :head
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => "https://github.com/Moya/Moya.git"
```

I get the same problem, again, only on the UI testing target (regular test targets and the app itself seem to work fine):

```
2015-09-13 11:22:13.386 XCTRunner[29003:4857736] (dlopen_preflight(/Users/zbeckman/Library/Developer/CoreSimulator/Devices/FCFAAFBF-1AB4-4223-9BCC-CA91CBDE96DC/data/Containers/Bundle/Application/056B5BED-0B9F-41AB-A248-117BD6824748/GlimpulseUITests-Runner.app/PlugIns/GlimpulseUITests.xctest/GlimpulseUITests): Library not loaded: @rpath/libswiftCoreLocation.dylib
  Referenced from: /Users/zbeckman/Library/Developer/Xcode/DerivedData/Glimpulse-avhroqmcgyzbiecltqxshdpczkht/Build/Intermediates/CodeCoverage/Glimpulse/Products/QA 1-iphonesimulator/Moya.framework/Moya
  Reason: image not found)
```

I also took a look at your test project. There is an important different in regard to how we have our Podfiles set up, and possibly the resulting code:

My Podfile installs all of the common pods without including them in a target (that is, like this):

```
pod 'Moya'
pod 'OtherCommonStuff'

target 'UITests'
    pod 'Quick'
end
```

So, with that in mind, I started "upgrading" your Podfile, incrementally adding elements until I got a similar failure.

The first step was to adopt the above format. Then I added a few lines that were missing from yours, but present in my config (such as the iOS target). Finally, I added in my testing libraries.

This is what I ended up with:

```
platform :ios, '8.0'

source 'https://github.com/CocoaPods/Specs.git'

use_frameworks!

pod 'Result', :head
pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
pod 'Moya/ReactiveCocoa', :git => "https://github.com/Moya/Moya.git"

target 'TestTests' do
    pod 'Nimble', :git => 'https://github.com/Quick/Nimble.git', :branch => 'swift-2.0'
    pod 'Quick', :git => 'https://github.com/Quick/Quick', :branch => 'swift-2.0'
end

target 'TestUITests' do
    pod 'Nimble', :git => 'https://github.com/Quick/Nimble.git', :branch => 'swift-2.0'
    pod 'Quick', :git => 'https://github.com/Quick/Quick', :branch => 'swift-2.0'
end
```

And I get this result when the UI tests run:

```
2015-09-13 11:31:46.948 XCTRunner[32697:4885511] (dlopen_preflight(/Users/zbeckman/Library/Developer/CoreSimulator/Devices/A5E91AA9-62B2-43C9-9378-9FA9A3F5491D/data/Containers/Bundle/Application/B2691E9B-944A-49C7-8EF3-FE1CCB98D62B/TestUITests-Runner.app/PlugIns/TestUITests.xctest/TestUITests): Library not loaded: @rpath/libswiftCoreLocation.dylib
  Referenced from: /Users/zbeckman/Library/Developer/Xcode/DerivedData/Test-hbfuhujgtjfczffhoidfubqaazyo/Build/Products/Debug-iphonesimulator/Moya.framework/Moya
  Reason: image not found)
```
 Same here! Ok, I updated our main project's Podfile as follows (specifically, I put the main target 'Glimpulse' back in, so now every pod is explicitly included in a target):

```
platform :ios, '8.0'
source 'https://github.com/CocoaPods/Specs.git'
use_frameworks!

target 'Glimpulse', :exclusive => false do
    # UX components
    pod 'SwiftSpinner', :git => 'https://github.com/zbeckman/SwiftSpinner.git'

    # Frameworks
    pod 'MagicalRecord'
    pod 'Result', :head
    pod 'ReactiveCocoa', :git => 'https://github.com/ashfurrow/ReactiveCocoa.git', :branch => 'swift2'
    pod 'Moya/ReactiveCocoa', :git => "https://github.com/Moya/Moya.git"

    # Utility components
    pod 'XCGLogger', :git => 'https://github.com/DaveWoodCom/XCGLogger.git', :branch => 'swift_2.0'
    pod 'GRValidation', '~> 0.2'
    pod 'DateTimeKit', :git => 'https://github.com/zbeckman/DateTimeKit.git'
end

target 'GlimpulseTests', :exclusive => false do
    # Testing framework
    pod 'Nimble', :git => 'https://github.com/Quick/Nimble.git', :branch => 'swift-2.0'
    pod 'Quick', :git => 'https://github.com/Quick/Quick', :branch => 'swift-2.0'
end

target 'GlimpulseIntegrationTests', :exclusive => false do
    # Testing framework
    pod 'Nimble', :git => 'https://github.com/Quick/Nimble.git', :branch => 'swift-2.0'
    pod 'Quick', :git => 'https://github.com/Quick/Quick', :branch => 'swift-2.0'
end

target 'GlimpulseUITests', :exclusive => false do
    # Testing framework
    pod 'Nimble', :git => 'https://github.com/Quick/Nimble.git', :branch => 'swift-2.0'
    pod 'Quick', :git => 'https://github.com/Quick/Quick', :branch => 'swift-2.0'
end
```

And it works!

Questions, though:

Notice that _I am not including_ any of the following pods:

```
    #pod 'Box', :head
    #pod 'Result', :head
    #pod 'Alamofire'
```

So, are `Result` and `Alamofire` looped in through dependencies? Do we need to include these in our Podfile?

Thankfully this simplifies our Carthage setup too... just one project now (`SwiftCheck`) that doesn't do pods.
 Nice! Thanks for the tip.
  Yeah!! this is awesome!
 Looks good! solves my problem üëç
  hi, how can i add additional http headers? e.g Content-Type: application/json
 awesome! thanks @ashfurrow sorry didn't see those documentations
 ```
let endpointClosure = { (target: MyTarget) -> Endpoint<MyTarget> in
    let url = target.baseURL.URLByAppendingPathComponent(target.path).absoluteString
    let endpoint: Endpoint<MyTarget> = Endpoint<MyTarget>(URL: url, sampleResponseClosure: {.NetworkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
    return endpoint.endpointByAddingHTTPHeaderFields(["APP_NAME": "MY_AWESOME_APP"])
}

let provider = MoyaProvider<MyTarget>(endpointClosure: endpointClosure)
```
then i got this error
  "errors" : [
    "Unable to find endpoint"
  ]


my usage is not correct or something, i read the documents....,thank you 
  I did a `carthage update` this morning and saw that Alamofire pushed a new commit to their `swift-2.0` branch which breaks Moya. The commit (https://github.com/Alamofire/Alamofire/commit/64a004472c16313d04671518ef03ef4b72293dbc) swaps out NSError for ErrorType. 

I've updated MoyaCompletion to now take `ErrorType` rather than `NSError` to be inline with Swift 2 changes.

I should note that I haven't updated the RxSwift nor ReactiveCocoa extensions simply because I wasn't sure how you would want to handle the following bit that's present in both Moya+RxSwift and Moya+ReactiveCocoa.

```
if let statusCode = statusCode {
    observer.on(.Error(NSError(domain: error.domain, code: statusCode, userInfo: error.userInfo)))
} else {
    observer.on(.Error(error))
}
```

As you can see, this just replaces the statusCode if it's been given back by Alamofire. We can't suck out the domain and userInfo from the ErrorType unless it's cast to NSError. Xcode 7 beta 6 spits out a warning that this always succeeds so I was certainly averse to putting that particular code smell in. I suppose we could potentially make a new ErrorType within Moya which has the statusCode as an argument but I didn't know whether that'd be a bit of an overkill? Alternatively we could just simplify it and return the existing error. I haven't been using either of these extensions at this point so I figured I'd leave that to someone who might have a bit more expertise with them on how it should be handled.
  @Moya/contributors 

All,
Is there any interest in setting up a gitter.im room for the organization? I find that I have some questions regarding the future of Moya and the direction we want to go, but am reluctant to file an issue, because it's not necessarily related to the code (Just like this one!).

**Edit**: I'm happy to take care of the integration.
 I agree, especially because of "searchability".

I have bad luck with chat-room-as-support-channel.  In chat rooms, people seem to assume that the people there have tons of free time available, to _answer their question right now_, even though a quick search would yield the answer they need, or opening an issue would help people out in the future.
 On the other hand, if there are maintainers who DO want to hang out in that chat room, it wouldn't hurt to have it!  But an empty gitter room, with a link from the README, might give people the wrong idea.
 I'll throw my vote in for using GH issues. One of the problems with a separate discussion tool in my opinion is fragmenting the conversation and not preserving it for the future. Future Moya users (and current ones) can easily search and read the conversation history in GH.
  Hi,

I added HTTP Basic auth support (and other protocols that Alamofire supports, like NTLM) by adding an optional closure to the `MoyaProvider` initializer. This has been discussed previously and I've basically implemented what Ash suggested [here](https://github.com/Moya/Moya/issues/151#issuecomment-112961113).

I've only tested this with NTLM (yeah, I know...), so this should probably be tested a bit more with other authentication protocols before being merged. There also seems to be an issue with the current Alamofire version and NTLM, for more info [see here](https://github.com/Alamofire/Alamofire/issues/721).
 Thanks for your kind words :-)

I've merged the master and you should be able to merge the pull request now.

About tests: I'm pretty busy right now, but maybe I'll give it a shot next week. I'm familiar with OHTTPStubs, but I haven't used Nimble before. I'll message you when I get started or if I need help, ok?
 Hey, thanks for doing the merge! I should really turn on github notifications ;-)
  Maurice Kelly add new function and fix typo in fde0eca3d63d79b615093db8c072673091c53375.
I believe we should left old-named method for backward compatability for a while, but it would be nice to deprecate wrong named method. Then we can delete it in next major update.
  typo + remove empty spaces
  +1. Fully agree with you. It's quite confusing to see success, when actually there is no relevant data in json.
 About response codes, my thoughts:
- **Response `2xx`** - **successful** operation.
- **Response `3xx`** says that for the successful execution the request is necessary to take additional action. - **it's not an error**. _(luckily `Alamofire` handle automatically most of this responses, so we don't need to worry about that)_
- **Response `4xx`** says that the client, making the request, did something wrong. - this is **error behaviour**
- **Response `5xx`** indicates that the client did everything right - a problem on the server side. - it's discussible but I think it should be also **error behaviour**
 Concerning the endpoint documentation:

I'm working on an iOS application that fetches data from the GitHub API and I've already OAuth authentication.  Originally I was planning on using Alamofire to make the authenticated requests to GitHub, but I've been wanting to use Moya for a while in a larger project.  Anyway, I was going over the documentation on endpoints and I saw the OAuth example but it is not very clear to me how to implement it in an actual application.  Perhaps the Artsy application would be a good place to look?
 You are welcome.  Yes, I completely agree that Moya doesn't need a separate OAuth component to it :smile: .  I have OAuth up and running with good old `NSURLSession` and I plan on eventually moving over to Moya once I get the rest of the requests a but more fleshed out.  Thanks!  
 I definitely will.
 It just happened two days ago that one of my colleagues took over a project I implemented a new API class for using Moya and he was completely confused by the fact that an API error (regardless of 4xx or 5xx) was returned within the `.Success` case. Although I understand and like the fact that Moya only forwards network errors to the `.Failure` case what about renaming the generic `.Success` and `.Failure` cases to something more clear? For example simply adding `Network` as a prefix resulting to `.NetworkSuccess` and `.NetworkFailure` should already improve the clarity a lot. What do you think?
 Hmm, I understand now why those are named the way they are.

But the good news is that the Result dependency has exactly the same license as Moya does (MIT). :) Therefore what about we **create our own fork with only the renamed cases** and use that? Should be a straight forward find & replace. And in case we want to update the dependency rebasing shouldn't be hard either. Also if I remember correctly I read about plans for the Swift Package Manager to support dependencies with alterations, so maybe we can even drop maintaining the fork sometime?

Not very happy about the suggestion myself, but that would definitely solve the main problem.
 Sure, no hurry on my side.

I think we have two more options:
First we could of course try to convince the Swift community that we need **support for `typealias` for enum cases in Swift 3**. Second option is we create a **wrapper around Result** that simply passes through all features we need for Moya from the Result project.

The first option (if it would be successful which we can't be sure of) would delay the support for a better naming until at least September so I think we should only discuss the second alternative for now. What do you think about a wrapper?
 Result seems to be a pattern now, actually Alamofire has its own modified version of Result, see https://github.com/Alamofire/Alamofire/blob/master/Source/Result.swift

So, maybe improving [Moya.Error](https://github.com/Moya/Moya/blob/master/Source/Error.swift) is a better way, to clear what failure is, currently, Moya will wrap all Alamofire's error (which is `NSError`) to `Error.Underlying(error)`, and `NSError` not easy to do pattern-match.

Consider that if we add more error types, such as `Timeout`, `Cancelled`

``` swift
provider.request(.UserProfile) { result in
  switch result {
  case let .Success(response):
    doSuccess(response)
  case let .Failure(error):
    switch(error) {
    case .Timeout:
      // tip timeout
    case .Cancelled:
      // tip cancelled
    default:
      // tip unknown
    }
  }
}
```

does it more make sense?
 @jasl Although I like the suggestion about improving the failure case with pre-defined cases, that still doesn't solve the issue that API errors (4xx/5xx) are still accessed via something simply called `.Success`. The confusion therefore wouldn't be reduced with `Timeout` and `Cancelled` failure cases imo.
 @Dschee  The definition of Result is `Result<Response, Error>`, means errors of API's shouldn't be handled, because you've got the response. 

But your question is right, we need to handle API errors, for now Moya has provided some functions to help filter the status code, [codes here](https://github.com/Moya/Moya/blob/master/Source/Response.swift#L31-L49), but those can't be used for pattern-matching. so we could do a small extension

``` swift
public enum ResponseClass {
    case Informational
    case Success
    case Redirection
    case ClientError
    case ServerError
    case Undefined

    public init(statusCode: Int) {
        switch statusCode {
        case 100 ..< 200:
            self = .Informational
        case 200 ..< 300:
            self = .Success
        case 300 ..< 400:
            self = .Redirection
        case 400 ..< 500:
            self = .ClientError
        case 500 ..< 600:
            self = .ServerError
        default:
            self = .Undefined
        }
    }
}

public extension Response {
    public var responseClass: ResponseClass {
        return ResponseClass(statusCode: self.statusCode)
    }
}
```

then, we could

``` swift
provider.request(.UserProfile) { result in
  switch result {
  case let .Success(response):
    switch response.responseClass {
    case .Success:
      doSuccess(response)
    case .ClientError:
      // tip user provided data is invalid
    default:
      // tip unexpected error
    }
  case let .Failure(error):
    switch(error) {
    case .Timeout:
      // tip timeout
    case .Cancelled:
      // tip cancelled
    default:
      // tip unknown
    }
  }
}
```
 @jasl Thanks for adding cases for the success part as well. I continue to think those are great suggestions.

But again, that still doesn't solve the problem that the outer `let .Success(response)` case is named in a way people may be confused. To repeat the example with my colleague two days ago: I implemented a Moya provider class and he used it. But at the moment he wrote the first outer `.Success` and `.Failure` cases he already was convinced that he had handled API errors within the `.Failure` case and couldn't understand why the `.Success` case was called but didn't provide any data he was expecting from a successful API response.

To put it in code, here's what I would expect your code to look like:

``` Swift
provider.request(.UserProfile) { result in
  switch result {
  case let .Response(response):
    switch(response.responseClass) {
    case .Success:
      doSuccess(response)
    case .ClientError:
      // tip user provided data invalid
    default:
      // tip error
    }
  case let .Incomplete(error):
    switch(error) {
    case .Timeout:
      // tip timeout
    case .Cancelled:
      // tip cancelled
    default:
      // tip unknown
    }
  }
}
```
 @Dschee your issue I also meet too, but I think there is two parts, one is the codes that I just provided is the right way (at least for me), the other part is this really make some people confusing.

In my opinion, there are too many kinds of errors could be occured, but we don't need to handle those one per one, let's regrouping them (remember, this depends on your business and your restful-api design)

``` swift
enum APIResult {
    case Ok // the request with success but no content (e.g. status code 204)
    case Success(NSData) // success with content
    case Failure(APIError) // the request success but with 4xx, 5xx status
    case NetworkError(Moya.Error) // the request is failed
}
```

then I wrapped Moya's provider (just for demo)

``` swift
func request(provider: Provider = Provider.defaultInstance(), completion: (result: APIResult) -> ()) -> Moya.Cancellable {
        return provider.request(self) { result in
            var apiResult: APIResult

            switch result {
            case let .Success(response):
                let json = response.mapSwiftyJSON()

                if json["ok"].int != nil {
                    apiResult = .Ok
                } else if let errorMessage = json["error"].string {
                    apiResult = .Failure(APIError(statusCode: response.statusCode, message: errorMessage))
                } else if let entity = parseResponse(json) {
                    apiResult = .Success(entity)
                } else {
                    apiResult = .Ok
                }
            case let .Failure(error):
                apiResult = .NetworkError(error)
            }

            completion(result: apiResult)
        }
    }
```

so my colleagues could use like

```
request(.UserProfile) { result in
  switch result {
  case .Ok:
  case let .Success(data):
  case let .Failure(error):
  case let .NetworkError(error):
  }
}
```

you could see my project for learning https://github.com/jasl/RubyChinaAPP/blob/master/RubyChinaApp/Controllers/Topics/TopicsViewController.swift#L127 (It's for Ruby Community of China, and the repo may not be passed to compiling because I using my forked Moya, but you could see how I wrapping Moya's Provider)

In my opinion, I don't like a library to do too much, if you think it's too complex to use, you can wrap it, that should be easy, but if the library to do too much, if there has any which not suit for your need, hacking it would be hard. I think Moya is a balance choice,
  Sometimes a signup endpoint succeeds and passes back no data, sometimes it fails and passes back data/info on what fields caused the failure. Not really sure how to model this in Moya.

Perhaps sampleResponse on endpoint, and sampleData on target should have failure specific cousins?
 Having rethunk it, my real question is: if there's only one sampleData property, what am I do to if a target has sample data for success _and_ sample data for failure? Other than that, I think I get the pattern for representing success/failure with endpointClosures.
 Your MoyaTarget implementation can have multiple `sampleData` properties, it is only a required `MoyaTarget` property so that it is easy to make use of `MoyaProvider.DefaultEndpointMapping`.

To use multiple sample data properties, you need to create your own endpoint-closure, which maps targets to `Endpoint<T>`:

``` swift
public static var endpointTestingClosure = { (target: YourAPI) -> Endpoint<YourAPI> in
    let method = target.method
    let parameters = target.parameters
    let sampleResponse = EndpointSampleResponse.Success(200, { target.testingData })
    // let sampleResponse = EndpointSampleResponse.Success(200, { target.sampleData })

    var endpoint = Endpoint<YourAPI>(URL: url(target), sampleResponse: sampleResponse, method: method, parameters: parameters, parameterEncoding: target.encoding)
    return endpoint.endpointByAddingHTTPHeaderFields(target.headers)
}

public static func TestingProvider() -> MoyaProvider<YourAPI> {
    return MoyaProvider(endpointClosure: testingClosure)
}
```
 Your two answers combined covered the bases. I get it now. Thanks a bunch!
  It would be great if Moya supported [ObjectMapper](https://github.com/Hearst-DD/ObjectMapper) usage. It already can be accomplished with pure [Alamofire](https://github.com/Alamofire/Alamofire) with the help of [AlamofireObjectMapper](https://github.com/tristanhimmelman/AlamofireObjectMapper).
 Why just ObjectMapper?  Shouldn't the user decide what library to use?  This is a "middleware" decision, so I think that a separate `MoyaObjectMapper` library would be appropriate - and it could live in the **github.com/Moya** organization!  But there are plenty of other JSON <-> Object libraries:
- Argo
- ObjectMapper
- SwiftyJSON

The trouble I've run into is that it's impossible to have compile-time checking on these, because the endpoints map to _many_ different return types.  We've solved this by having `Service` classes that define per-endpoint closures.  Tedious, but at the application-code level we know we'll get back the objects we asked for.
- Api.recentPosts -> `[Post]` (`PostService.recentPosts() { (posts, error) in }`)
- Api.post(id: 12) -> `Post` (`PostService.post(id: 12) { (post, error) in }`)
- Api.currentUser -> `User?` (`UserService.currentUser() { (user, error) in }`)

How are you using ObjectMapper + Moya right now?  Does it lend itself to becoming a generic library?
 I mean, this COULD be solved with the same principles we applied to the `ReactiveMoya` and `RxMoya` extensions, I just think that these things need to be contributed by the community, otherwise we're going to have a hell of a time maintaining it all, or more likely, flat out denying the feature requests.

I can put together a more detailed guide (if anybody's into it), but here are the basics:
1. Add Moya as a submodule.
2. Write your code which uses Moya.
3. Package it up in your package manager of choice and distribute.

I don't think this is ideal, but it is a possibility for those who really want to use Moya to compose their ideal networking stack into a framework.
 I am happy that I could spark this discussion :) I agree that this is a topic for a separate pod (possibly living inside github.com/Moya organization as @colinta said). Like the @ashfurrow idea about clever completion blocks and I am really curious what will emerge out of it.
 I've actually been building, and using, an extension to MoyaProvider that integrates ObjectMapper support. It's been working really great so far, but I haven't gotten to the point of PR-ing it just yet. I feel like pattern of subclassing `MoyaProvider` isn't the best decision, and ultimately limits flexibility (what if i want to use ObjectMapper in on instance, but the RAC extensions in another?)

I like @ashfurrow's idea above, and think we could focus on making Moya more flexible and conducive to extensions without subclassing

The basics of the ObjectMapper extension are:
- The MoyaMappable protcol requires you to specify the key at which the object can be found in the JSon response. (Follows a RESTful assumption)

``` Swift
public protocol MoyaMappable : MoyaTarget {
    //The keypath in the response which contains the nested object or objects you want to map
    var rootKeyPath: String { get }
}
```

ObjectMapperMoyaProvider takes generic type MoyaMappable
`public class ObjectMapperMoyaProvider<T: MoyaMappable>: MoyaProvider<T>`

When sending a request, you specify alla generics what type of object is returnd. The object must conform to Mappable

``` Swift
    func requestObjects<U: Mappable>(token: T, completion: ((objects: [U]?, data: NSData?, statusCode: Int?, response: NSURLResponse?, error: NSError?) -> ())) -> Cancellable {
```

Here is a Gist to the extension I wrote
https://gist.github.com/SRandazzo/a07500391da99a580937
 I don't think that mapping to objects should be in the library but we could provide an easier way to transform responses for people who don't use reactive extensions. I've been playing around with some changes [here](https://github.com/petester42/Moya/tree/moya-extensions-test) and what we could do is move all responses to `MoyaResponse`.

This change would allow anyone to make an extension to `MoyaResponse` and create functions that map from `MoyaResponse` to anything.

For Argo it would be something like this:

``` swift
extension MoyaResponse {

    func mapEntity<U: Decodable where U == U.DecodedType>() throws -> U {

        let response = try self.mapJSON()
        let decoded: Decoded<U> = decode(response)

        switch decoded {
        case .Success(let success):
            return success
        case let .Failure(.MissingKey(key)):
            throw NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.JSONMapping.rawValue, userInfo: ["data": response, "missing": key])
        case let .Failure(.TypeMismatch(expected, actual)):
            throw NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.JSONMapping.rawValue, userInfo: ["data": response, "expected": expected, "actual": actual])
        case let .Failure(.Custom(error)):
            throw NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.JSONMapping.rawValue, userInfo: ["data": response, "custom": error])
        }
    }

    func mapEntity<U: Decodable where U == U.DecodedType>() throws -> [U] {

        let response = try self.mapJSON()
        let decoded: Decoded<[U]> = decode(response)

        switch decoded {
        case .Success(let success):
            return success
        case let .Failure(.MissingKey(key)):
            throw NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.JSONMapping.rawValue, userInfo: ["data": response, "missing": key])
        case let .Failure(.TypeMismatch(expected, actual)):
            throw NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.JSONMapping.rawValue, userInfo: ["data": response, "expected": expected, "actual": actual])
        case let .Failure(.Custom(error)):
            throw NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.JSONMapping.rawValue, userInfo: ["data": response, "custom": error])
        }
    }
}
```

What does everyone think about solving object mapping this way?
 Could you clarify what you mean by `configure different maps per endpoint`. Doesn't ObjectMapper handle this?

I believe you can achieve everything you need without plugins, subclasses or changing the library. For example you could do something like this:

``` swift
public extension MoyaResponse {

    func mapObjectMapper<U: Mappable>() throws -> [U] {

        let response = try self.mapJSON()
        guard let decoded: [U] = Mapper<U>().mapArray(response) else {
            throw NSError(domain: MoyaErrorDomain, code: MoyaErrorCode.JSONMapping.rawValue, userInfo: nil)
        }

        return decoded
    }
}

public extension MoyaProvider {

    func request<U: Mappable>(target: Target, completion: (response: [U]?, error: ErrorType?) -> ()) -> Cancellable {
        return request(target) { (response: MoyaResponse?, error: ErrorType?) in
            do {
                completion(response: try response?.mapObjectMapper(), error: error)
            } catch {
                completion(response: nil, error: error)
            }
        }
    }
}
```

And then just call the provider like so: 

``` swift
GitHubProvider.request(.UserRepositories(username)) { (response: [Repo]?, error) in
    //do cool things here
}
```
 @petester42 I'm a big fan of that approach as well. That's essentially how Alamofire adds support for different `ResponseSerializers`, just extensions on the `Request` object. And I think that's the best way to go because it doesn't really require changes to what Moya is or how it's implemented. Instead the burden is offloaded to the consumer. Another benefit of doing it the Alamofire way is that then the different "transform" or mapping functions can be chained. 

The only thing I would change is instead of having mapping functions like `mapObjectMapper`, just use the built-in response serializer functionality of Alamofire because that's all AlamofireObjectMapper does.
 :+1: for the documentation. We could also add references to moya extensions that do this in the documentation so that people don't have to reimplement things.
 I created a [pod](https://github.com/ivanbruel/Moya-ObjectMapper) for people who specifically want to use `Moya` alongside with `ObjectMapper`. 

I also created the `RxSwift` bindings, if anyone wants to create the `ReactiveCocoa` ones feel free to create a pull request.
 I think we could provide a default project for new mapping projects so that people can just copy the project and write their extensions. This would probably help people especially for the carthage support since the carthage support for Moya does have some custom scripts to get around the namespacing issues.
 It would be more like a starting project for any extensions someone would want to create for Moya not just for ObjectMapper. It could also document how the scripts work to change the namespaces when building for carthage.
 Ya it would be a bigger project for sure.
 Wow, never imagined that this would explode to such an active discussion! üéâ

@ivanbruel Great work, thanks for sharing! üëç

@petester42 Very nice idea! Would gladly collaborate myself ‚Äì thinking about the same thing for [Unbox](https://github.com/JohnSundell/Unbox). We have recently switched to Unbox as it offers immutable model classes, gets rid of empty inits and it basically lives well with basically any model class.
 I'll open a new issue for it when I have time to put my thoughts into a good description. 
  Sounds great!
I think we should also consider caching the result of any previous requests and replay them in case we are offline.
 @ashfurrow You have it correct. I can definitely share some more details on how this works in Tumblr.app (the code isn‚Äôt generic enough to be open sourced in it‚Äôs current form).

Let me know if you have any specific questions, additionally I can just dumb down our implementation and post some sample code or pseudocode.
 Could this potentially help with things like #164? If we provide an offline cache and specify a TTL at the request level, and whether or not a request should use the cache, I think we could ditch the idea of inflight requests.
 @irace Would you mind sharing some info/pseudocode of what you are doing in Tumblr.app? Would love to get some more ideas. What kind of use cases do you cover with your implementation? 
 This is a great idea! I really like the idea of caching responses for use in offline situations (as suggested by @aschuch). I've implemented a similar thing in my own projects in the past. It's pretty straightforward and is super useful. 
 I don't think I can get away with sharing the existing code as the company I'm at isn't quite as open-source friendly as Artsy. ;-) But! That code's quite old, written well before Swift, sits on top of AFNetworking and isn't as generic as it could be. What I can do is explain what we did. 

This was purely for caching responses (not requests). 

The goal at the time was essentially to prevent users from seeing a loading indicator as much as possible. If they've loaded data before and there's a fair chance it hasn't changed, we should present existing data and update it in the background. This also handled the case of the user's internet dropping out. We only used it for `GET` requests (it doesn't really make much sense for POSTs, etc).

It doesn't make sense for some responses to be cached (eg, search responses). Others should be, but may be invalidated by a pull-to-refresh. So, we had an enum that we'd pass into our API client with each request that looked something like - 

```
enum CachePolicy {
    case None, // don't cache the response
    case UpdateOnly, // don't show old data. eg, user just did a pull-to-refresh, but update the cache with what we get if we read it again
    case ReadAndUpdate // return old data and then go update it in the background. 
}
```

I'm sure those names could be improved. For Moya, I can potentially see this as something that we could add to `MoyaTarget` as an instance variable. Obviously if the user's offline, there's no need to fire the update request.

How did we show old data/new data? If we had a cached response, we'd immediately call the response block (ie, `MoyaCompletion`), then go make the request anyway. If the data changed, the response block would be called again. So, that response block could therefore be called twice (I can see how that might be confusing, but since the developer would need to set a cache policy it wasn't too bad - by default it was disabled). 

Whenever we received a response, we'd wrap it in an object which contained a couple of other bits of metadata, namely -
- `data` - the NSData itself
- `ETag` - HTTP header for checking if the response actually changed or not. 
- `version` - This was an API version specific for our app. If we bumped our API version, we wouldn't use old cached responses at all. I'm not sure how we'd tackle this in Moya cleanly at this point. 

This object would then be saved to disk with the request URL as the key. 

Any time we would make a request, firstly we'd check the cache policy. 
- For `None`, simple - just fire off the request.
- For `UpdateOnly`, fire the request but save the response. 
- For `ReadAndUpdate`, check the cache and if an entry is found, return the response. Then for the interesting bit: we get ready to fire off the request anyway to update the data. We'd pull off that `ETag` field I mentioned earlier from the cached response and add it as a `If-None-Match` header for the request. Then fire the request. If that `ETag` hadn't changed, or if the response code was 304 (not modified), we wouldn't call the completion block. Otherwise, the updated data would be passed back up. 

I'm far from an expert on HTTP headers/ETags, but I understand that it's respected by `NSURLRequest` if you set the `cachePolicy` property to `NSURLRequestUseProtocolCachePolicy`. That's something AFNetworking seems to take care of itself (just looking at the header file documentation, I haven't looked into whether Alamofire does it).

We should probably also respect the `Expires` header (though that's something we didn't implement in our solution). 

I hope this all makes sense and that I haven't waffled on too much (I have a tendency for doing that). I'd definitely be keen to hear others' thoughts and suggestions on this and how it might be implemented. I'm more than happy to have a stab at it when I find some time if we agree on the method. 
 At Tumblr, we have the concept of an `OutgoingRequest` and an `OutgoingRequestEngine`.

The request itself just models an HTTP request and conforms to `NSCoding`. It has:
- A type (certain types may have their progress reflected in the UI, others won‚Äôt)
- A URL
- A parameter dictionary
- (Optional) file names/paths/content types (for multipart file uploads)
- A created date (we won‚Äôt retry if a request is too old)
- A retry count (we‚Äôll only retry so many times)

We keep all of these in an `OutgoingRequestStore`, which is some sugar on top of a thread-safe, persistent `NSArray` with some additional smarts like deleting files from disk once a request has finished (or we‚Äôve given up on it).

The `OutgoingRequestEngine` is backed by an `OutgoingRequestStore` and requests are added to it from the application‚Äôs controllers/coordinators/whatever. It‚Äôs fairly naive at the moment but could be more sophisticated: it retries the requests in the store whenever `UIApplicationWillEnterForegroundNotification` is received, or whenever reachability changes. It does so in serial ‚Äì requests are only processed one at a time in FIFO order. It has a delegate that can notify other parts oft he application about success/failure/progress.
 Any progress on this or alternatives @ashfurrow?
  I'm doing request signing in the endpoint resolver, but it's conditional based on target. At the moment the target is only accessible in the endpoint closure.
 `request()` currently..

``` obj-c
let endpoint = self.endpoint(token)
let request = endpointResolver(endpoint: endpoint)
let stubBehavior = self.stubBehavior(token)
```

... perhaps it could go... 

``` obj-c
let endpoint = self.endpoint(token)
let request = endpointResolver(token, endpoint: endpoint)
let stubBehavior = self.stubBehavior(token)
```

Btw, thanks for the speedy reply!
 Yes, definitely gleaned the significance of the pattern/chain vs. this just being an error. Don't want to change it unless necessary.

Unfortunately I'm not sure how to work around it in this case. In the the endpointClosure I'm adding the appropriate headers for my auth flow. That's for all targets.

But for some targets I need to HMAC sign the url requests, which is based off of properties of the url request, so it needs to go in the endpointResolver.

I feel like people doing oAuth or other auth flows might also need this, since most of the time you're not signing your signup/signin targets.
 It is janky, but it'll do for now. Anyway, I guess just see if anybody else runs into a similar issue, and if so maybe this is worth revisiting.
Thanks!
  Curious what's involved in this? Seems like it's the last piece in the puzzle in getting Moya working under Swift 2/Xcode 7..

Great work, btw!
  Hi, I have the following Podfile:

```
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'rxswift-2.0'
pod 'RxCocoa', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'rxswift-2.0'
pod 'Moya/RxSwift', :git => 'https://github.com/Moya/Moya.git', :branch => 'swift-2.0'
```

And when I do pod install, I receive the following error:

[!] Unable to satisfy the following requirements:
- `Alamofire (from`https://github.com/Alamofire/Alamofire.git`, branch `swift-2.0`)`required by`Podfile`
- `Alamofire (~> 1.3.0)` required by `Moya/Core (2.0.0)`
 I change my pod file to:

platform :ios, "8.0"

source 'https://github.com/CocoaPods/Specs.git'

use_frameworks!

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
pod 'RxSwift', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'rxswift-2.0'
pod 'RxCocoa', :git => 'https://github.com/ReactiveX/RxSwift.git', :branch => 'rxswift-2.0‚Äô

pod 'Moya/RxSwift', :path => "../"
pod 'Moya/ReactiveCocoa', :path => "../"
pod 'Moya', :path => "../"

and still have the following error:

[!] Unable to satisfy the following requirements:
- `Alamofire (from`https://github.com/Alamofire/Alamofire.git`, branch `swift-2.0`)`required by`Podfile`
- `Alamofire (~> 1.3.0)` required by `Moya/Core (2.0.0)`

[!] Your Podfile has had smart quotes sanitised. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice.
Evgeniys-MacBook-Pro:Eventgram evgeniy$ open -e Podfile
  Currently the podspec is limiting use to iOS 8. But there doesn't seem to be anything in moya which is iOS specific, nor iOS 8 specific. Since Alamofire's requirements are iOS 7 and OS X 10.9 and up, it seems like Moya's should be as well.
 Oops, silly me. iOS 8 it is.
 Ya the ReactiveCocoa podspec also doesn't reflect the project's settings. In the project it is 10.9 but not in the podspec. üò¢
  This is definitely something I would like to see. :)

At the moment I am trying to figure out how to have a parameter always passed to every request, in this case is an `access_token`. It took me some time to understand how to use this library and I had to check the whole source code to master it, I know they are not so much lines, but still... also the RxSwift's version requires some extra documentation b/c it looks like is outdated, I think. :+1: 
  I've some trouble modifying the `parameterEncoing` defined in the [Moya class](https://github.com/Moya/Moya/blob/master/Moya/Moya.swift#L47) since it's not part of the `MoyaTarget` protocol definition. For some endpoints I need to POST data as `.JSON`, not the default `.URL`.

Sadly the Demo App doesn't cover it in [GitHubAPI class](https://github.com/Moya/Moya/blob/master/Demo/Demo/GitHubAPI.swift#L23).

Can somebody give me hint or should it also be part of `MoyaTarget` and nobody hasn't the need to change that until now?

**Update 1**
I've something like the following in my `MoyaTarget` extension:

``` swift
extension MyAPI : MoyaTarget {
    // ‚Ä¶
    // public var path: String {‚Ä¶}
    // public var parameters: [String: AnyObject] {‚Ä¶}
    // ‚Ä¶
    public var parameterEncoding: Moya.ParameterEncoding {
        switch self {
        case .Search(_):
            println("parameterEncoding for .Search: JSON")
            return .JSON
        default:
            println("default parameterEncoding: URL")
            return .URL
        }
    }
    // ‚Ä¶
}
```
 Found the solution by myself. I had a hard time with the docs.

I had to replace the following line

``` swift
let MyAPI: MoyaProvider<MyAPI> = MoyaProvider<MyAPI>()
```

where I used the default initializer, with the following:

``` swift
let MyAPI: MoyaProvider<MyAPI> = MoyaProvider<MyAPI>(endpointClosure: {
    (target: MyAPI) -> Endpoint<MyAPI> in

    return Endpoint(URL: url(target), sampleResponse: .Success(200, {target.sampleData}), method: target.method, parameters: target.parameters, parameterEncoding: target.parameterEncoding)
})
```

where I set the `endpointClosure`. Within the the closure I defined my Endpoint with my own parameterEncoding: (`parameterEncoding: target.parameterEncoding`).

Hopefully this issue helps future like-me's :)
 @ashfurrow I'm already thinking about it, but it needs some more thoughts. In general I would shoot for more complete examples. Newcomers as I am one, lack guidance. For example it wasn't quite clear at first for me if I have to implement my own Provider. Turns out it was sufficient to use the default one with a closure as an initialization parameter.
 Hi, sorry for commenting closed issue. I spent last hour troubleshooting an `Error Domain=NSURLErrorDomain Code=-1017 "cannot parse response"`.

Due to non-optional `parameter` property in `MoyaTarget` protocol, setting endpoint's parameter encoding to `.JSON` causes the associated `NSURLRequest` to have an empty `HTTPBody` property instead of a `nil` one. It seems that some server-side technology can have bad time handling such configurations (I'm using Node.js/Express.js as a sandox server).

Moreover, it's more likely that parameter encoding are request-basis instead of global-basis (usually `.URL` for `.GET` methods and `.JSON` for `.POST | PUT` methods).

Could be a good idea to make `parameterEncoding` part of the `MoyaTarget` ?
 @ashfurrow Thanks for your quick reply :) Actually I already had some solutions in mind but I was wondering if some changes on Moya could reduce possibilities of server-side errors like I had today.
Two idea in mind : making `parameterEncoding` as part of `MoyaTarget` protocol or maybe changing the `MoyaTarget`'s `parameters` property to an optional.
Big inconvenience to these solutions : they don't support backward compatibility to previous versions :(
 Totally makes sense !
 jk's solution works for me! üëç üëç üëç 
  Our app is still required to support iOS 7, so CocoaPods / Carthage are not considered as options. Could you please give any guidance on manual installation of the library? Or would you recommend against using `Moya` in this case? Thank you!
 Add the `.xcodeproj` to your project, and then link the `Moya.framework` output against your project.

Let me know if you have any issues or need more clarification. 
 @justinmakaila, @esttorhe: In iOS 7 we cannot use dynamic frameworks, so probably there's no way to install `Moya`, neither `ReactiveCocoa` (which seemingly dropped iOS 7 support at some point). Please let me know, if I'm wrong.
 Oh, sorry, just woke up. Skimmed it and missed that part ;)

You can just add the source files straight to the project.
 @justinmakaila: It was the first thing that I did. : ) But then you need to add `ReactiveCocoa`, which is not possible for iOS 7. From their `Readme` page:

> ReactiveCocoa supports OS X 10.9+ and iOS 8.0+.

I realized this limitation only after asking the question. Seems that the `Moya` is an iOS 8+ library as well.
 @ashfurrow Thank you for clarification! I realized that there's some manual way to get things work, but it seemed tedious to try. Finally we decided to simply drop iOS 7 support, so this is no more an issue.
  While reviewing some of the Moya documentation, I noticed that there was a class method on `MoyaProvider` called `DefaultEnpointResolution()`. I‚Äôve assumed this to be a typo, and have updated it be named `DefaultEndpointResolution()`.

Sorry if the naming was intentional, or this PR is viewed as being overly pedantic!
 I probably should add a line to the changelog.md given that this changes the API - but I‚Äôll leave it until I get the thumbs up/down.
 Hey guys, sorry for not coming back sooner. I like the idea of the backwards compatible function, but I want to make sure I have the same understanding as yous. I‚Äôm thinking something like this:

``` swift
public class func DefaultEnpointResolution(endpoint: Endpoint<T>) -> NSURLRequest {
    return DefaultEndpointResolution(endpoint)
}

public class func DefaultEndpointResolution(endpoint: Endpoint<T>) -> NSURLRequest {
    return endpoint.urlRequest
}
```
 Okay, I‚Äôve force pushed an update to this PR that has the following changes:
- Adds `DefaultEndpointResolution` as a method
- Updates `DefaultEnpointReolution` to call through to `DefaultEndpointResolution`
- Updates the `MoyaProvider#init` methods to use `DefaultEndpointResolution` as the default
- Adds an entry to the `CHANGELOG.md` file that explains the change - no version number with it, as I‚Äôm assuming you fine folks will add a version at the top when you decide what the next release will be.
- Fixes a comment typo from `metods` to `methods`

Let me know if there‚Äôs anything else that I‚Äôve missed, or can improve upon.
 Thanks for accepting it - was a pleasure at this end :-)
  Hi. I created special script for this steps ( it do anything except 2 ). I use it for my personal needs, but create a gem also. Check https://github.com/skywinder/bumper_pusher repo for details. Or just intall and try it: 

```
gem install bumper_pusher
```

You can also try a dry run to verify steps. 
 No. But if it is all about running make release command, I believe that it's easy to implement. 
 Ok, so we can add some shell script in the root directory to bump and update and push pod.
Feel free to ask, if you need any help with `bumper_pusher`
  This PR adds an optional `Alamofire.Manager` argument to `MoyaProvider`'s init. `Alamofire` 1.3.0 introduced SSL pinning in [PR 581](https://github.com/Alamofire/Alamofire/pull/581). SSL Pinning requires a customized `Alamofire.Manager`. 

```
let policies: [String: ServerTrustPolicy] = [
    "example.com": .PinPublicKeys(
        publicKeys: ServerTrustPolicy.publicKeysInBundle(),
        validateCertificateChain: true,
        validateHost: true
    )
]

let manager = Manager(
    configuration: NSURLSessionConfiguration.defaultSessionConfiguration(),
    serverTrustPolicyManager: ServerTrustPolicyManager(policies: policies)
)
```

Prior to this PR `Moya` used the standard `Alamofire.Manager.sharedinstance`. The default behavior remains but now a customized `Alamofire.Manager` can be used to create a `MoyaProvider`. All `MoyaProvider` request calls will use the customized manager.

```
let manager = Manager()
let provider = MoyaProvider<GitHub>(manager: manager)
```
 Sure thing @ashfurrow! I'll add those here shortly.
 I'll bump the version to 2.1.0 since this is an added feature. Have you been using lightweight tags or annotated tags?
 Ok, latest is up. Sounds like I'd better leave the release to you :smile: Thanks!
  Hi, Moya solve the problem of ‚Äúrequest‚Äù, and how about "response"?
For example, I want to get the ‚Äúcount‚Äù of current online user, the code may look like this:

```
    UserProvider.request(.Online) { (data, status, resonse, error) -> () in
        if let data = data {
            let json: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: nil, error: nil)
            if let count = json["count"] as? String {
                ...
            }
        }
    }
```

And every time I want to get the count data, I have to repeat the code above to handle response.

But actually, all I need is the "count" value. Is there any way to handle response data graciously?

Thanks
 You could extend your provider with a `requestCount` method, which handles that logic for you. You can even go a step further, and have a `requestJSON` method, which handles the JSON serialization for you, and then use it within your `requestCount` method.

```
extension MoyaProvider {
    func requestJSON(endpoint: T, completion: (AnyObject?, NSError?) -> Void) -> Cancellable {
        return self.request(endpoint) { (data, status, response, error) in
            if let data = data {
                let json: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: nil, error: nil)
                return completion(json, error)
            }

            completion(nil, error)
        }
    }

    func requestCount(endpoint: T, completion: (Int, NSError?) -> Void) -> Cancellable {
        return self.requestJSON(endpoint, completion: { json, error in
            if let jsonObject = json as? [NSObject: AnyObject], count = jsonObject["count"] as? Int {
                return completion(count, error)
            }

            completion(-1, error)
        })
    }
}
```
 Good idea. Thanks
 Let me know if that works for you, and I'll close the issue. 
 It works for me. 
 Awesome! :+1: 
 @ashfurrow Thanks, it's really awesome!
   "All checks have failed" makes it sound pretty horrible.
Like I BROKE ALL THE THINGS with just plain english. :joy:

No biggie.

Found a typo and thought "nah, I can't spam them with a PR for a single cosmetic character change". 
So I looked for another one. Found one and thought "now we're talking!". :smile:
  I'm not sure if this is already known or furthermore intended but I tried to use `pod try Moya` and it failed with the following error message:

```
Updating spec repositories

Trying Moya
Performing CocoaPods Installation
Fetching podspec for `Moya` from `../`
[!] Unable to satisfy the following requirements:

- `Moya/RxSwift (from `../`)` required by `Podfile`
- `Moya/RxSwift (from `../`)` required by `Podfile`
- `Moya/RxSwift (= 1.1.1)` required by `Podfile.lock`
```

or did I do something wrong?
 Woha. That's a great troubleshooting experience. A lot like following a sports live ticker :)
 @ashfurrow it does work now. Thanks.

```
pod try Moya
Updating spec repositories

Trying Moya
Performing CocoaPods Installation
Fetching podspec for `Moya` from `../`
Using Alamofire (1.3.0)
Using Box (1.2.2)
Using Moya (2.0.1)
Using Nimble (0.4.2)
Using OHHTTPStubs (4.0.2)
Using Quick (0.3.1)
Using ReactiveCocoa (3.0-beta.6)
Using Result (0.4.4)
Using RxSwift (1.9)
Sending stats
Opening '/private/var/folders/pc/plkw89_s63lb5cj277y8_f580000gn/T/CocoaPods/Try/Moya/Demo/Demo.xcworkspace'
```

And by the way, you don't want to set iTerm to ¬ªunlimited scrollback¬´ it will get slow after a certain threshold. I'm very comfortable with it set to 5.000.
  I'm using RxSwift + Moya in my project, Is the sample code like this  would help?

```
      provider.request(.UserProfile("ashfurrow")).subscribe(next: {
          image = UIImage(data: $0)
        }, error: {
          println($0)
      })
```
 Can you help me setup a Provider with RxSwift? How a simple RxMoyaProvider should look? How the closure should look?

It would be good that the demo includes examples for both RAC and RX. 

Currently I got my way with the Artsy implementation but im having problems declaring the provider. I know there is a branch about Rx Docs, but this probably be some kinda Faqsy. 
 @ashfurrow Thanks! working now :yum: 
  There's no way to remove Demo/Pods from the repo, is there?  Sure is a lotta noise.
 Hahaha, well I'm with you on that.  Seems like a classic case of fixing what ain't broke, if you ask me. (Carthage I mean)
 NIIIICE
  AlamoFire has added SSL Pinning, and a host of other features that I'm sure are just lovely, but that I don't have an immediate need for.

But I think SSL Pinning is the most compelling feature of this release.
 ```
> make ci
..............................................

     Executed 46 tests, with 0 failures (0 unexpected) in 3.557 (3.574) seconds
```
 Whaddup with those specs failing on CircleCI?  I haven't seen that on previous PRs.
 Oh, I see, looks like it's a known issue since #161.
 Looks legit to me, would be sweet to get SSL Pinning in!
 Do we need a minor version bump in Moya to use `:head` that way?
    As option:
As @esttorhe suggested, but this 2 images in a row and add arrow between like this: :city_sunset:  :arrow_right:  :rocket: 
 @ashfurrow  :+1:
  This PR adds full support for Carthage, and a solution to using `RxSwift` and `ReactiveCocoa` without mandating it for those who wish to use pure `Moya`.
- Adds `ReactiveMoya` and `RxMoya` targets
- Adds RAC 3.0 support to `ReactiveCocoaMoyaProvider`
- Expands the example project to include demonstrations using reactive extensions
 No idea, I've never worked with circle before. I'll take a look and get back to you about that

‚ÄîJustin Makaila

On Thu, Jul 16, 2015 at 9:09 PM, Ash Furrow notifications@github.com
wrote:

> Thanks a lot, Justin! It's a huge PR ‚Äì I'll take a look at it this weekend. If any other contributors could lend a hand, that'd be :+1: 
> Justin, could I please ask you to mark these improvements in the changelog? I see you've already updated the README ‚Äì awesome :tada: 
> 
> ## The tests are failing ‚Äì looks like a Circle configuration problem around the Demo workspace. Any ideas?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/ashfurrow/Moya/pull/169#issuecomment-122141741
 1,054 files!?  That's... _ahem_ a bit alarming.

It looks like all these files are mostly build artifacts.  Looking at other projects that support Carthage & CocoaPods, they don't include a `Carthage/` folder that contains all the build headers.  I'm looking in particular at https://github.com/thoughtbot/argo

I'm wondering: can that entire folder be removed?  From what I understand about Carthage, it's a minimalist system, it seems like a red flag that all these header files are included here.
 Yes, we could remove it. I pushed the Carthage/build dir so you can use the demo without running Carthage

‚ÄîJustin Makaila

On Thu, Jul 16, 2015 at 11:15 PM, Colin T.A. Gray
notifications@github.com wrote:

> 1,054 files!?  That's... _ahem_ a bit alarming.
> It looks like all these files are mostly build artifacts.  Looking at other projects that support Carthage & CocoaPods, they don't include a `Carthage/` folder that contains all the build headers.  I'm looking in particular at https://github.com/thoughtbot/argo
> 
> ## I'm wondering: can that entire folder be removed?  From what I understand about Carthage, it's a minimalist system, it seems like a red flag that all these header files are included here.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/ashfurrow/Moya/pull/169#issuecomment-122157655
 Ah I see.  Well obv my vote is to keep the repo lighter.  Might make sense, then, to add something to the README about building, but I think people that use Carthage already can figure it out :-)
 @colinta I'm with you completely, I just didn't want to introduce a PR with less functionality than the previous version. Ultimately, the decision is up to @ashfurrow and the core team, and I'm open to modifying this PR to match the requirements!
 Are you saying the demos won't even run if the user doesn't use Carthage?
 @orta I'm with you on that. Not a huge fan of pushing things just for the sake of an example project.

I'm going to make the adjustments for the circle build, and then make the modifications I need to to get `pod try Moya` to work. I think broke that in my haste of ripping everything out early on.
 Can we link the library to the demo repo some how? `git submodule`s or something?
 I mean, we could move the demo project to a separate project, pushing a `Carthage/Build` dir there, which would allow people to just clone and run.

Obviously, this isn't ideal, because `pod try` is a sweet way to handle that. 
 I‚Äôm going to add that to this PR.

Though, because this is such a small library, I think it‚Äôs perfect to try to optimize for these cases, so bigger libraries can follow suit.¬†

‚ÄîJustin Makaila

On Mon, Jul 20, 2015 at 5:04 AM, Orta notifications@github.com wrote:

> I don't think moving the example to a separate repo is a good idea, other libraries don't do this. 
> 
> ## I'd move the `Pods` and the Carthage-whatever directories into `.gitignore` then add a note in the README that if you want to run the example you have to go to the example folder and run `pod install` or `carthage install`. Or for the no-effort approach `pod try Moya`. Again, this isn't some mega-huge library with thousands of moving parts.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/ashfurrow/Moya/pull/169#issuecomment-122817681
 So this is just about ready to go, I just want to get the CI to build successfully.
 @ashfurrow It'd be possible, but all of that would have to be redone. As it stands:

To run the example:
1. Run `carthage update` in the root
2. Open `Moya.xcworkspace` and set your target to `MoyaExample` ~~OR open `Example/MoyaExample.xcodeproj`~~
3. Run.

To execute tests:
1. Run `carthage update` in the root (if you haven't already)
2. Open `Moya.xcworkspace` or `Moya.xcodeproj` and set your target to `Moya Tests`
3. Run

**EDIT**: Slight correction, you can't open the `MoyaExample.xcodeproj` and run the project because it has a target dependency on the `Moya.xcodeproj` output.
 Yes. CocoaPods was symlinking to the Pods project, but I found it to be overkill. I totally understand your hesitation, and want to do everything I can to make the transition simple, and answer any questions you have along the way.
 I'm glad the focus is remaining on CocoaPods.  I think Carthage is a great tool, but since most users aren't clamoring for supporting it, I think we'd be doing a disservice if CocoaPods was made a second class citizen.
 None here

‚ÄîJustin Makaila

On Thu, Sep 10, 2015 at 1:31 PM, Ash Furrow notifications@github.com
wrote:

> Hey! This is still on my radar, just got sidetracked. 
> 
> ## As for the code structure, having the separate repos like https://github.com/Moya/ReactiveMoya is fine for _code_, but I think it's a good idea to keep all documentation and issue tracking in this main repo. This will keep the barrier to entry low (someone learning to use Moya shouldn't have to know how we structure our code to read our docs). Any objections? 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/pull/169#issuecomment-139319537
 I agree ‚Äì¬†as someone that definitely falls into the "new user" category. I'm just now trying to get Moya, ReactiveCocoa, and Alamofire working together... and the fewer things I have to hunt down and figure out, the better. I also vote for keeping a focus on CocoaPods. I have one Carthage module (because they don't have a pod yet... but should soon). Pods work much better for us, in a distributed project.
 As long as the reactive repositories can be imported into the test suite without naming collisions (They both have their product names set to ‚ÄúMoya‚Äù).¬†

‚ÄîJustin Makaila

On Thu, Sep 10, 2015 at 1:44 PM, Ash Furrow notifications@github.com
wrote:

> Alrighty, I've disabled issues on the other repositories. We also need to update their READMEs to point to this repository. These other repos are basically just places to store files.
> 
> ## If we're centralizing docs here, I think it makes sense to centralize tests here as well. I can't see that being a problem with Carthage ‚Äì @justinmakaila does that sound OK? 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/pull/169#issuecomment-139322383
 üëçüèª

‚ÄîJustin Makaila

On Thu, Sep 10, 2015 at 2:04 PM, Ash Furrow notifications@github.com
wrote:

> ## Shouldn't be a problem ‚Äì we're restructuring the tests to run under CocoaPods, which won't have that problem. 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/pull/169#issuecomment-139329643
  What other projects will be in this org?  We can ask github to make github.com/Moya available.
 Is there any chance the @github support could intervene, a bit like the twitter one does when you request an unused account (for good reason)?
 github.com/Leviathon/Moya

> On Aug 4, 2015, at 3:01 PM, Ash Furrow notifications@github.com wrote:
> 
> It's possible, but the user could have private activity that we just can't see. I don't want to write them off :)
> 
> Moya is named after a living spaceship https://en.wikipedia.org/wiki/List_of_Farscape_characters#Moya. puts on nerd glasses Moya doesn't speak, so she doesn't have a voice actor, but she's biologically bonded to a pilot, voiced by Lani Tupu. It's been suggested https://twitter.com/twannl/status/628670104667070464 that using some variation of that name might work, though those names are taken. I'd be pretty cool with using another homage to Farscape, too, but everything I found was too on the nose.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/ashfurrow/Moya/issues/168#issuecomment-127760581.
 Dang it, I spelled "Leviathan" incorrectly.  github.com/Leviathan is taken.
 Awww I JUST got the same email from github, and I was hoping to bring a present to the discussion today!

Well, ‚ÄúHUZZAH‚Äù nonetheless.  These other names were‚Ä¶ less good. ;-)

> On Aug 5, 2015, at 9:05 AM, Ash Furrow notifications@github.com wrote:
> 
> I've been in contact with GitHub support, and https://github.com/Moya https://github.com/Moya is now an organization I control. I'll be adding contributors as team members there, then transferring and doing related chores hopefully today, maybe tomorrow.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/ashfurrow/Moya/issues/168#issuecomment-128029428.
 :tada: 
  I have looked at getting Moya (specifically for RxSwift) working with swift 2.0.
Using the new Xcode 7.3 beta and by totally ignoring ReactiveCocoa, I think I've managed to get Moya somewhat working.

It seems to be working well in my own project but I haven't got the Demo project and its tests working. I also had problems with ReactiveCocoa due to Carthage setup which I'm not very familiar with.

The main concern for me is the return defer in Moya+RxSwift.swift due to the changes which won't allow defer's to return.  I don't really see the need for a defer anyway so have simply replaced with a return closure.

Nonetheless, hopefully this might help with the migration over to 2.0
 Hi, I rebased this branch into my PR and fixed the defer issue.

## 

Esteban Torres
(+506)8813-0934
Twitter: @esttorhe

On Sat, Jul 11, 2015 at 8:07 AM -0700, "Ash Furrow" notifications@github.com wrote:

Hey, thanks so much! This is a great step forward. @esttorhe has done some work in #162 ‚Äì maybe you two could work together?

Until RxSwift renames defer, if it does, you just need to surround it in backticks like `defer`.

‚Äî
Reply to this email directly or view it on GitHub.
  Hi Ash,

I've seen a possible bug in Moya RAC integration, but I'm not a RAC expert so not sure if it's really a bug.

I think that [here](https://github.com/ashfurrow/Moya/blob/master/Moya/ReactiveCocoa/Moya%2BReactiveCocoa.swift#L52) it should be

```
.replayLast().autoconnect()
```

instead of

```
.publish().autoconnect()
```

but I could be wrong.
 :)
  Hi Ash,

I've been checking out reactive integration code (RX and RAC), and have some questions :)

It looks like the idea is to try to share results of in flight requests. That would make sense for idempotent query requests, but not sure that is correct in case of mutating command requests.

What do you think?
 Yeah, you could do that. I would suggest that default behavior should be `false` :)

It would also be cool if you could do something like 

```
internalRequest(token)
    >- cacheInFlightRequests
```

`cacheInFlightRequests` should probably be internal method so you could write the code like

```
func request(token: T) -> Observable<MoyaResponse>
    if shouldCheckInflightRequests(target) {
        return internalRequest(token)
    }
   else {
        return internalRequest(token)
                   >- cacheInFlightRequests
    }
}
```

It would maybe also make sense to add functionality that would enable you to get typed object for endpoint instead of MoyaResponse (Observable<MyObject>).
 That's probably a reasonable tradeoff. If somebody has command GET and HEAD requests he probably has bigger problems on his hands anyway :)
 We just discovered a case where in-flight GET requests would lead to a bug in one of our apps.

We continuously check for user settings whenever the app is opened. 
In case the user is no longer authorized, an automatic "relogin" attempt is made, which also tries to download the user settings.
In case the user settings call is not finished by the time of the "relogin", the "relogin" waits for the current _unauthorized_ user settings request to return and gets a 401 from the API.
This was easy enough to fix, but shows that GET requests might also lead to some unexpected behaviour.

I think I'd like in-flight caching to be opt-in, which would also make it less "magic" for everyone new to reactive programming concepts.
  Hi Ash,

I've seen this some time ago, but was swamped :)

I think there is a threading concern [here](https://github.com/ashfurrow/Moya/blob/master/Moya/RxSwift/Moya%2BRxSwift.swift#L20)

```
            if let existingObservable = self?.inflightRequests[endpoint] {
                return existingObservable
            }
```

We should probably use 

```
            objc_sync_enter(weakSelf)
            let inFlight = self?.inflightRequests[endpoint]
            objc_sync_exit(weakSelf)
            if let existingObservable = inFlight {
                return existingObservable
            }
```

It looks like ReactiveCocoa integration has the same [issue](https://github.com/ashfurrow/Moya/blob/master/Moya/ReactiveCocoa/Moya%2BReactiveCocoa.swift#L24)

If you want, I can make a PR, but just wanted to be sure this is a bug.

I think we are also [missing](https://github.com/ashfurrow/Moya/blob/master/Moya/RxSwift/Moya%2BRxSwift.swift#L38) sharing of a result construct (`>- variable`), I can add that also.
  # Fix #156

This is still a WIP but wanted to create the `PR` anyways.
I tried tackling the `ReactiveCocoa` task but it proved harder than expected due to its `LlamaKit` dependency and it being stuck on `1.2` and no work to migrate to `2.0` is being made.

I went down the :rabbit: hole and this is a major rework I think.
So far `Moya` compiles on the `Demo` project with the current `Podfile` that's leaving `ReactiveCocoa` and `RxSwift` out of it (only core is being integrated).

This is what's done so far.
## Done:
- Currently using Quick and Nimble `swift-2.0` branches
- AlamoFire `swift-2.0` branch as well
- Moya Core is compiling
- Minimal Swift 2.0 migration (not reworked; only made it compile)
- @garethknowles migrated the code for `RxSwift`
## TODO:
- [ ] Migrate `ReactiveCocoa` to `swift2` branch
  - [ ] Generate a `podspec` for `swift2` branch first
    - ~~Migrate `LlamaKit` to `Swift2` :scream:~~ <-- `LlamaKit` is no longer a dependency
- [x] ~~Migrate `RxSwfit`~~

![](http://cdn1.bloguin.com/wp-content/uploads/sites/26/2015/04/kramer_screaming.gif)
 I think I accidentally left my current take of `ReactiveCocoa.podspec` in there (I'm migrating the `JSON` file to a proper podspec but is less than WIP ATM)
)
 https://github.com/ashfurrow/Moya/pull/167

I have looked at getting Moya (specifically for RxSwift) working with swift 2.0 using the newly released Xcode 7.3 beta and by totally ignoring ReactiveCocoa, I think I've managed to get it somewhat working.

It seems to be working well in my own project but I haven't got the Demo project and its tests working. I also had problems with ReactiveCocoa due to Carthage setup which I'm not very familiar with.

The main concern for me is the return defer in Moya+RxSwift.swift due to the changes which won't allow defer's to return.  I don't really see the need for a defer so have simply replaced with a return closure.

Nonetheless, hopefully this might help with the migration over to 2.0
 @garethknowles I rebased your branch into mine and updated the code in this `PR` to keep it under unified. 

The demo currently compiles and runs (although I didn't check the code if `RxSwift` was being used anywhere).

Sadly the tests won't run because of the `ReactiveCocoa` issue; I'll try to leave them out in the meantime to have a passing build
 That's not my username but I think its because of me; give me a sec
 @alcarvalho I pushed a change to the `Podfile` pointing `Alamofire` to its github path and to the `swift-2.0` branch instead of a relative path.
 What tests specifically?

If you open the `Demo` project on this branch and hit `Command + U` the test won't work because there are a bunch of `ReactiveCocoa` tests there and `ReactiveCocoa` imports and that part is not yet migrated to `Swift 2.0`.

I'm currently working on having a `podspec` that works with their `swift2` branch but I'm getting a `CocoaPods` crash locally that I'm trying to fix first.
 First of all, thanks to all contributors and of course the author :D

Any news with Swift 2.0? I still see in the fork that Alamofire is not pointing to the right version thus not compiling with xCode 7 beta 4. 

In order to set Alamofire correctly, this is an extract of my podfile:
pod 'Alamofire',
    :git => 'https://github.com/Alamofire/Alamofire.git',
    :branch => 'swift-2.0'

I know they may remove that branch, but for now maybe is convenient to point there in sift 2.0 branch?

Thanks for your effort!
 Thanks for your feedback guys, I will do that in the meantime.

I find this framework really interesting and meets my philosophy quite well, so keep up the good work and let's spread it :D

Cheers.
  The ReactiveCocoa subspec only depends on `ReactiveCocoa/Core`. ReactiveCocoa's default subspec is the larger `ReactiveCocoa/UI`
 It appears the [ReactiveCocoa/Core](https://github.com/CocoaPods/Specs/blob/master/Specs/ReactiveCocoa/3.0-beta.6/ReactiveCocoa.podspec.json) subspec is broken when using frameworks. It's missing a header referenced in the bridging header.
  When installing Moya (master) using Carthage, I am running into the following error on app launch:

```
dyld: Library not loaded: @rpath/RxSwift.framework/RxSwift
  Referenced from: [REDACTED]/Frameworks/Moya.framework/Moya
  Reason: image not found
```

Seems like RxSwift is not downloaded, thus not found at app launch. 
I have tried to add RxSwift to the Cartfile but [RxSwift does not yet support Carthage](https://github.com/kzaher/RxSwift/issues/40).

/cc @neonichu 
  fixes #153
  I want to integrate Moya into an Xcode 7/Swift 2.0 project. Any chance of an official branch to support this to go along with the Alamofire swift-2.0 branch?
 I'm in the midst of cleaning up the dependencies on the `swift-2.0` branch, and I wanted to make some changes to how the demo project is set up and whatnot (having it in the `Pods.xcodeproj` is kind of bulky and confusing). How attached are you to keeping CocoaPods in the directory? If I can achieve the same thing using `Carthage` and pushing the frameworks to the repo, would that be cool?

The goal is still to make it as easy as possible for people to run the Demo project, but to remove the bulk of CocoaPods.
  I am trying to find out how to get `Alamofire.Request` after I did `provider.request(.Zen)` (currently it responses with `Cancellable` protocol).

``` swift
func sendRequest(request: NSURLRequest, completion: MoyaCompletion) -> CancellableToken {

        networkActivityClosure?(change: .Began)

        // We need to keep a reference to the closure without a reference to ourself.
        let networkActivityCallback = networkActivityClosure
        let request = Alamofire.Manager.sharedInstance.request(request)
            .response { (request: NSURLRequest, response: NSHTTPURLResponse?, data: AnyObject?, error: NSError?) -> () in
                networkActivityCallback?(change: .Ended)

                // Alamofire always sends the data param as an NSData? type, but we'll
                // add a check just in case something changes in the future.
                let statusCode = response?.statusCode
                if let data = data as? NSData {
                    completion(data: data, statusCode: statusCode, response:response, error: error)
                } else {
                    completion(data: nil, statusCode: statusCode, response:response, error: error)
                }
        }

        return CancellableToken {
            request.cancel()
        }
    }
```

I think it's more needed to return `Request` here then CancellableToken or merge this somehow. What do you think?
 For example I am not using `Moya` for now, because I want to use https://github.com/tristanhimmelman/AlamofireObjectMapper
 @ashfurrow hi Ash, glad to see you here :) Just checked https://github.com/tristanhimmelman/AlamofireObjectMapper/blob/master/AlamofireObjectMapper/AlmofireObjectMapper.swift and they use `extension Request`. How I can get similar with `MoyaProvider`? 
 @ashfurrow Thanks, already found solution. Inspired by Kiosk app :)

``` swift
public class Provider<T where T: MoyaTarget>: MoyaProvider<T> {

    override public init(endpointsClosure: MoyaEndpointsClosure = MoyaProvider.DefaultEndpointMapping(), endpointResolver: MoyaEndpointResolution = MoyaProvider.DefaultEnpointResolution(), stubResponses: Bool = false, stubBehavior: MoyaStubbedBehavior = MoyaProvider.DefaultStubBehavior, networkActivityClosure: Moya.NetworkActivityClosure? = nil) {
        super.init(endpointsClosure: endpointsClosure, endpointResolver: endpointResolver, stubResponses: stubResponses, stubBehavior: stubBehavior, networkActivityClosure: networkActivityClosure)
    }

    public func mappingRequest(token: T) -> Request {
        let endpoint = self.endpoint(token)
        let request = endpointResolver(endpoint: endpoint)

        return sendRequest(request)
    }
}

private extension Provider {
    func sendRequest(request: NSURLRequest) -> Request {
        return Alamofire.Manager.sharedInstance.request(request)
    }
}
```

And then somewhere in the code:

``` swift
APIProvider.mappingRequest(.Login(username: "test", password: "test123")).responseObject { (user: User?, error: NSError?) -> Void in
            println(user?.username)
}
```
  i installed Moya with Carthage and i get a error in xcode when building because i don't have RxSwift, maybe to have a another branch or something for RxSwift? 

this is the error i get

```
dyld: Library not loaded: @rpath/RxSwift.framework/RxSwift
Referenced from: /Users/marvinnazari/Library/Developer/CoreSimulator/Devices/9A8009C8-48F2-47FD-86A8-7E6251DF5B60/data/Containers/Bundle/Application/CB3D1236-77FF-4664-8EEF-D94DD08CE55D/X.app/Frameworks/Moya.framework/Moya
Reason: image not found
```
 Same here. Seems like RxSwift can't support carthage ATM, so there's no easy way to include it manually.
 AFAIK, there's nothing like subspecs in Carthage, so it would need to be a separate repo, probably?
 Yah, I wouldn't know how to do optional dependencies, but I'm also not the most knowledgeable on this subject :)
 Hey guys, I filed this [issue](https://github.com/Carthage/Carthage/issues/588) on the Carthage repo asking for "subspec" support. If you have any ideas to contribute, I'm sure it would help the case.

I may add Carthage support to RXSwift, but I'm on the fence, mainly because RXSwift is the foundation of RAC 3.0, and it doesn't appear as if development is going to continue moving forward. Where does everyone stand on that? Is RXSwift support necessary, or can it be phased out down the line?
 AH! I had a feeling I was looking at the wrong RxSwift repo.

Either way, the enhancement suggested to the Carthage maintainers should help solve this issue, that is, if it's implemented.

‚ÄîJustin Makaila

On Sat, Jun 27, 2015 at 4:06 PM, Ash Furrow notifications@github.com
wrote:

> ## RxSwift was the original name of the RAC 3 proof of concept. It also happens to be the name of a [Swift-based reactive extensions library](https://github.com/kzaher/RxSwift). The library is young but growing. Whether there's enough demand for this from Carthage users, I don't know. 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/ashfurrow/Moya/issues/154#issuecomment-116127584
 In my opinion i think its better to separate these extensions to have a its own repository e.g. (Moya, ReactiveMoya, and RxMoya)
 @MarvinNazari I've started doing something similar. I'm battling with myself over the idea of master holding a project with multiple targets, all of which are built when someone specifies `Moya` in their `Cartfile`, or different branches where you can pull the one you need... i.e.

```
// Build Moya
git "ashfurrow/Moya" "master"

// Build ReactiveMoya
git "ashfurrow/Moya" "ReactiveMoya"

// Build RxMoya
git "ashfurrow/Moya" "RxMoya"
```

But that's adds a whole lot of pain to whomever is maintaining the repository.
 @ashfurrow That's also legit. I'm trying to be extremely considerate of the CocoaPods support.
 @ashfurrow It's okey i understand, i really love Moya and Carthage for their simplicity, for now I'm gonna go oldskool and copy-paste the code until there is a better solution
 @ashfurrow, could you clarify a little bit? Do you mean OS X vs iOS platforms?
 Well, `carthage` uses `xcodebuild` to build the schemes which are shared by your `.xcodeproj`. In order to build an iOS framework and an OS X framework, you need to share both schemes in your `.xcodeproj`.

We would need a `Moya`, `ReactiveMoya`, and `RxMoya` scheme & associated target.
 Yes, a separate `xcodeproj` for telling `carthage` how to build the framework. I'd be happy to get it set up on my fork so you can take a peek and pass judgements rather than building it into the main repo.
 I get how you feel @ashfurrow. What do you think of my proposed solution based on multiple frameworks. https://github.com/Carthage/Carthage/issues/588

This way we can keep everything in one repo?
 All,
I added support for two target outputs from `carthage`, `Moya` and `ReactiveMoya` (`RxSwift` doesn't support `carthage`, and I didn't want to play with it just yet) on my [fork](https://github.com/justinmakaila/Moya/tree/swift-2.0).

If you add `github "justinmakaila/Moya" "swift-2.0"` to your Cartfile, then run `carthage update`, it should build `Moya` and `ReactiveMoya` for you. `Moya` requires `Alamofire`, and `ReactiveMoya` requires `Moya`, `Alamofire`, `Result`, and `ReactiveCocoa` to work.

I also made some changes to the `ReactiveMoyaProvider` for RAC 3.0.

Let me know if you run into any issues!

NOTE: I borked the Demo project. I'll be fixing that, btw.

EDIT: I overlooked the `Cartfile`. Just re-added `ReactiveCocoa`. 
 @ashfurrow Totally. I'll try to get something in by the end of the day.
 Hi guys,

sorry for being [unable to currently support Carthage](https://github.com/kzaher/RxSwift/issues/40) in RxSwift, but I'm waiting for some issues to be resolved on their end.

https://github.com/Carthage/Carthage/issues/395
 I've temporary made a workaround that enables Carthage to compile RXS/RXC.

It's one huge hack, but it looks like it could work until Carthage gets support for multiple repositories.

I've made separate branches for Carthage releases.

`latest-carthage/rxswift`
`latest-carthage/rxcocoa`

The both contain one last commit that contains something like

`ln -s RxSwift/RxSwift.xcodeproj _.xcodeproj`
`ln -s RxCocoa/RxCocoa.xcodeproj _.xcodeproj`

This helps Carthage automagic target finder to locate targets for RxSwift and RxCocoa correctly and build them.

It looks like you can't have Carthage fetching both in parallel :( so you'll need to only uncomment one of them at a time.

Comment one, `carhage update`, then comment other `carthage update`.

```
git "git@github.com:kzaher/RxSwift.git" "latest-carthage/rxswift"
#git "git@github.com:kzaher/RxSwift.git" "latest-carthage/rxcocoa"
```

:(
 @ashfurrow @kzaher Sorry for the delay, but check out my fork right now. I restructured a good portion of the repo, added `RxSwift` support and an `RxMoya` target, as well as updates to the `ReactiveMoya` target to simplify retrieving JSON data from an API service. Also included is a completely new example project, demonstrating how to use each type of `*MoyaProvider`.

I'm in the process of updating the README right now.

Check it out and let me know what you think. If you're into it, I'll merge in master and file a PR. 

**EDIT**: Check out the `carthage/reactive-extensions` branch
 I bet @gfontenot could answer these questions.  Drop some Carthage knowledge on us, Gordon!
 Carthage will happily download any submodule in a repo. So yeah, you _could_ have `Moya/Moya` as a subspec for `Moya/RAC` and `Moya/RxSwift`, where those both build the RAC and RxSwift versions of the frameworks. The best part here would be that all 3 could output `Moya.framework`, which would be much nicer than needing to do `import MoyaRxSwift` all over the place.

I actually think this is a pretty rad solution to this problem. The only downside would be added overhead with updating the reactive versions, and (presumably) keeping the tags in sync. But I'd be willing to bet there's a fancy way to automate that using computers.
 @gfontenot Correct me if I'm wrong, but I don't think it could output `Moya.framework`, mainly because `Moya` is a dependency for `RxMoya` and `ReactiveMoya`. I'm all for the separate repos for the sake of modularity and intent, but I don't think it would solve that problem.
 It'd depend on how you constructed the repos. If you make Moya.framework a dependency of the reactive version then no, you wouldn't be able to name it like I suggested. But if you use submodules (as hinted at by Ash) to pull in just the _source_ of Moya for the reactive version, then you could name it whatever you want, including Moya.framework.

Obviously, this is a more complicated solution. But CocoaPods could take advantage of this same architecture by using subspecs with different sources that have submodules enabled. It'd also provide a way to split up READMEs and documentation for each of the reactive versions, which might be nice.

Fwiw, I'd be happy to help out in figuring out how to put this together. Seems like it'd be a fun experiment.
 But wouldn't that lead to files being overwritten by the `carthage` output?

I'm just trying to understand, as I'd also be happy to help with putting this together.

@ashfurrow, do you want to throw the repos up and add @gfontenot and myself as collaborators?
 I don't know why it would. Carthage just spits out built frameworks, it doesn't care too much about how the project itself is constructed, so long as it builds cleanly.
 @gfontenot So, from what you're saying:

``` ruby
github "ashfurrow/RxMoya"
```

Where the project is configured to spit out `Moya.framework`, rather than my current solution, where all three dependent projects are spit out by the single `Cartfile` entry:

``` ruby
github "ashfurrow/Moya"
```

I like this. A lot. 
 @gfontenot How would you recommend handling the shared files between the reactive repos? Include them in the main Moya repo?
 @gfontenot @ashfurrow @orta 

I put together the repos that were discussed.

[justinmakaila/Moya](https://github.com/justinmakaila/Moya)
[justinmakaila/RxMoya](https://github.com/justinmakaila/RxMoya)
[justinmakaila/ReactiveMoya](https://github.com/justinmakaila/ReactiveMoya)

Can we transfer them to the organization so we can get a collaborative effort? I don't have access rights to do it myself. 
 @ashfurrow just got rejected while trying to push:

```
j ~/W/S/ReactiveMoya> git push upstream master
remote: Permission to Moya/ReactiveMoya.git denied to justinmakaila.
fatal: unable to access 'https://github.com/Moya/ReactiveMoya.git/': The requested URL returned error: 403
```
 Worked, and pushed
 @gfontenot Take a peak at the branch when you get a chance. I keep getting this error while trying to build the example projects for `RxMoya` and `ReactiveMoya`:

```
j ~/W/S/R/Example> carthage update
*** Fetching RxMoya
*** Cloning RxSwift
*** Fetching Alamofire
Parse error: expected submodule commit SHA in ls-tree output: 
```
 @Moya/contributors 

The `ReactiveMoya` and `RxMoya` repositories are updated. I'd love for some help on getting them to work with `CocoaPods`. The `ReactiveMoya` `README` and Example are the only "complete" ones. I still need to update `RxMoya`.

Let me know if you need hlep getting anything set up.
 @ashfurrow `RxMoya` and `ReactiveMoya` all work with Carthage. They're Swift 1.x. Yes, we just need to update CocoaPods.

`RxMoya` also requires an example project, right now I only have `TODO`s. 

**EDIT**: Just realized that I have the submodules pointing to my fork of `Moya`. I'm merging in master now with Carthage and CocoaPods support and some tweaks for CI. I will need some help to get `pod try` working on that.
 @ashfurrow I have 1 and 2 done, going to be pushing it soon

‚ÄîJustin Makaila

On Tue, Aug 18, 2015 at 3:17 PM, Ash Furrow notifications@github.com
wrote:

> Super, cool! So if everything is working with Carthage, there's only a few things left to do:
> 1. Ensure the new repos with RxMoya and ReactiveMoya are up-to-date with this one. 
> 1. Remove files from this repo.
> 1. Update podspec to point to the two new repos.
> 1. Test/lint podspec
> 1. Ensure `pod try` continues to work.
> 1. Release a new version of Moya.
> Let me know if I'm forgetting anything. 
> 
> ## All sounds good? I can get started as early as this weekend, unless someone wants to do it sooner. 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Moya/Moya/issues/154#issuecomment-132322735
 @ashfurrow I'm good with the proposal. I'd like to jump on a hangout to understand the organization's feelings on this subject, and also to spec out next steps for the reactive repositories and further developments. Shoot me an email at justinmakaila[at]gmail[dot]com to set something up this week.

‚ÄîJustin Makaila

On Tue, Aug 18, 2015 at 4:44 PM, null justinmakaila@gmail.com wrote:

> @ashfurrow I have 1 and 2 done, going to be pushing it soon
> ‚ÄîJustin Makaila
> On Tue, Aug 18, 2015 at 3:17 PM, Ash Furrow notifications@github.com
> wrote:
> 
> > Super, cool! So if everything is working with Carthage, there's only a few things left to do:
> > 1. Ensure the new repos with RxMoya and ReactiveMoya are up-to-date with this one. 
> > 1. Remove files from this repo.
> > 1. Update podspec to point to the two new repos.
> > 1. Test/lint podspec
> > 1. Ensure `pod try` continues to work.
> > 1. Release a new version of Moya.
> > Let me know if I'm forgetting anything. 
> > 
> > ## All sounds good? I can get started as early as this weekend, unless someone wants to do it sooner. 
> > 
> > Reply to this email directly or view it on GitHub:
> > https://github.com/Moya/Moya/issues/154#issuecomment-132322735
  Is there a policy on tracking dependency releases?

RC is on beta 8 while adding Moya required my project to go back to beta 6 (using Carthage).
 Yes you can definitely just fork Moya, change the ReactiveCocoa branch in the Cartfile and you are good to go.

To add more context: The problem here is that the ReactiveCocoa beta is referenced using its specific github branch.
I think we should simply add a version requirement to the major version of ReactiveCocoa, so that Carthage has a bit more room to decide which version of ReactiveCocoa to use.

```
github "ReactiveCocoa/ReactiveCocoa" ~> 3.0
```
 @aschuch sounds good, do you want to make a PR for that?
    This is likely entirely my fault for missing it, but ‚Äî¬†I looked in the Kiosk app, and Artsy seems to encode the API keys into the the URL itself, but the API I‚Äôm working against encodes the keys using HTTP Basic Auth. Is that a supported feature of Moya, or is that something that I should drop down into Alamofire for (or even open a PR for)?

Thanks.
 (I should add ‚Äî¬†a lengthy answer isn‚Äôt necessary! just a yes or no would suffice.)
 Unless I misunderstand, HTTP Basic Auth is implemented by Alamofire as just a chained method after `.request`. 

Here‚Äôs my naive suggestion: pass the username/password to `MoyaProvider#sendRequest` as an optional parameter of type `NSURLCredential`, and if it‚Äôs not nil, call `.authenticate` after the `Alamofire.Manager.sharedInstance.request(request)` call.

Granted, that makes the method messy, hence my referring to it as ‚Äúnaive‚Äù.
 Good point, I didn‚Äôt think through how my API would break a lot of applications in production. I like your suggestion of the the optional closure in the `MoyaProvider` initializer.

Would you like me to open a pull request in the next day or so?
 üëç
 So the API I‚Äôm writing against is going to be deprecating their basic auth, and because of that, I don‚Äôt need to add that to Moya. Since nobody else seemed to expressed a need for it, I think it's best if the issue is closed.
 Thanks for your help!
  I tried to set up a project with Moya + ReactiveCocoa and got this error when following the README and typing "pod install":

```
Analyzing dependencies
[!] Unable to satisfy the following requirements:

- `ReactiveCocoa (= 3.0.0-beta.6)` required by `Podfile
```

Then I changed it to '3.0-beta.6' because I saw it in your .podspec and it worked:

```
Analyzing dependencies
Downloading dependencies
Using Alamofire (1.2.3)
Installing Box (1.2.2)
Installing Moya 1.1.1 (was 1.1.1)
Installing ReactiveCocoa (3.0-beta.6)
Installing Result (0.4.4)
Generating Pods project
Integrating client project
```

I guess that this is the correct way to do it, otherwise just ignore this request.

Moya seems very interesting, thanks! :+1: 
  Awesome :tada: 
  Was it actually addressed? We are trying to subclass both `MoyaProvider` and `ReactiveCocoaMoyaProvider` and Xcode says we should override designated initializer.
 I see. Yes, it is easier to define default parameters now, but it still require overriding designated initializer. Actually situation does not change in compare with what you writing in Oct, 1. Here is current experience of subclassing ‚Äî¬†https://www.evernote.com/l/AEaV5Z1HlZRGprguAUiszmTarcbrRgFzQA0
 Swift actually supports inheritance of initializers. For example in a following code Bar will not require initializer, but it will still be available:

```
class Foo {
  let value: Int
  init(value: Int = 5) {
    self.value = value
  }
}

class Bar: Foo {
}
```

The problematic situation will be if we make Foo generic. Somehow in this scenario Swift starts to ask designated initializer override. I do not really understand why yet and what could be an option, but I am trying to find an answer now.
 While I am going to dig a little bit more, I am not sure that I will be able to handle the whole issue. I suggest to not create a new one, but just reopen current issue. It has whole history of thought, with an actual problem described by you. I think this issue is good enough for tracking everything related to simplifying of subclasses. 

Also I would like to highlight why it is important. As for today we have a lot of code duplication in our product of initializers like following:

```
    override init(endpointClosure: EndpointClosure = ReactiveCocoaMoyaProvider.DefaultEndpointMapping, requestClosure: RequestClosure = ReactiveCocoaMoyaProvider.DefaultRequestMapping, stubClosure: StubClosure = ReactiveCocoaMoyaProvider.NeverStub, manager: Manager = ReactiveCocoaMoyaProvider<IdentificationServiceAPI>.DefaultAlamofireManager(), plugins: [PluginType] = [], stubScheduler: DateSchedulerType? = nil) {
        super.init(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, manager: manager, plugins: plugins, stubScheduler: stubScheduler)
    }
```

With the only difference of manager`s token. Our static analysis tools complaining about this a lot, and I believe it is right complain, as it eventually unnecessary code duplication that hard to read and that does not actually adds value.
 Here is a stack overflow question with a problem explained ‚Äî¬†http://stackoverflow.com/questions/36957858/why-swift-requires-override-of-designated-initializer-of-generic-superclass lets see if someone in community actually can explain this strange generics behavior.
 @ashfurrow As result of my research I found some combinations of associated types and default values that actually removes requirement to override designated initializer. It seems that major reason for override requirement in Moya can be some default values. While it is definitely some buggy behavior of Swift, I think it is possible to find workaround even in a current state of Swift.
 @ashfurrow good news, an issue that prevents of removing this huge initializers was recently fixed in master ‚Äî¬†https://bugs.swift.org/browse/SR-416 so this issue prob not bearably will be fixed in Swift 3. 
ps I still suggest to reopen it, as it ongoing and reproducible in current maya with Swift 2.2.
  At the moment, I find it hard to browse code on the Github repo.
I think we should consider adding a folder structure to make browsing Moya on Github a better experience.

I would keep everything the same but introduce a new `Moya` folder that contains all the relevant files.

```
- üìÅDemo
- üìÅdocs
- üìÅweb
- üìÅMoya
-- Endpoint.swift
-- Moya.swift
-- MoyaResponse.swift
-- üìÅReactiveCocoa
--- Moya+ReactiveCocoa.swift
--- RACSignal+Moya.swift
-- üìÅRxSwift
--- Moya+RxSwift.swift
- README.md
- Moya.podspec
- etc...
```

Thoughts?
 Is `MoyaResponse` solely used for ReactiveCocoa stuff? If so, we should document that in its header too.
 I am also :+1: for this!

On a related note, is there not a dedicated XCProj/workspace for Moya development?
If we have one, we can mirror project structure with file structure
  My immediate, gut response is yes, because they seem related and it's easier (conceptually, to a new Moya user) to implement just the one protocol. 

Is there ever a time when these protocols would be implemented by separate objects?

> On Jun 11, 2015, at 8:35 PM, Ash Furrow notifications@github.com wrote:
> 
> Does it make sense now that we're saying that parameters are on the target, and path is on the path, given that either property depends on the enum's associated values?
> 
> /cc @chriseidhof
> 
> ‚Äï
> Reply to this email directly or view it on GitHub.
 I don't really understand the code base, so feel unqualified to comment on
this... But I'd be happy to have a look at this together at a computer
during the next days?

On Thu, Jun 11, 2015 at 9:01 PM, Colin T.A. Gray notifications@github.com
wrote:

> My immediate, gut response is yes, because they seem related and it's
> easier (conceptually, to a new Moya user) to implement just the one
> protocol.
> 
> Is there ever a time when these protocols would be implemented by separate
> objects?
> 
> > On Jun 11, 2015, at 8:35 PM, Ash Furrow notifications@github.com
> > wrote:
> > 
> > Does it make sense now that we're saying that parameters are on the
> > target, and path is on the path, given that either property depends on the
> > enum's associated values?
> > 
> > /cc @chriseidhof
> > 
> > ‚Äï
> > Reply to this email directly or view it on GitHub.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/ashfurrow/Moya/issues/136#issuecomment-111345814.

## 

Chris Eidhof
  Sounds great @ashfurrow, I'm in. I think @colinta is mentioning this but I have two github accounts, doh, and I use @steam for the most part these days (I am also @process255). If possible @steam would be a better github user to add.

Great work with Moya so far. We're loving it at Ello.
 I'm in!  We have loved using Moya at @ello.  We're using, I _think_, all the features that Moya provides, and we'd like to not only keep abreast of changes, but help other people take advantage of it.

(Haha I removed my "@process255" is better know as "@steam" comment when I saw Sean's comment ^)
 I'm not actually using Moya, but I'd be up to help out with support for dependency managers :)
 That would be great! Still getting familiar with Moya but this will help push me along!
 Great idea, count me in. 
 Cool! I'm in! +1 :+1: 
 And for anyone looking for that "push" I gave Ash, [this is the talk](http://blog.testdouble.com/posts/2014-12-02-the-social-coding-contract.html) he's referencing.
 @ashfurrow Btw another thing you can do, going forward, is that, while you can still oversee it all, give commit access to contributors early.

E.g. When they create a second PR that follows all design rules.

It worked great for CocoaPods, but your audience and mileage might vary.
 I wouldn‚Äôt say _all_ open source, but if your goal is to have contributors, then yeah making them feel as owners hugely improves contribution. I‚Äôd also outline the rules for getting push access in e.g. your README, which might give people that extra push they need to contribute something they‚Äôd otherwise not feel motivated enough for.
 @ashfurrow I really like the message you wrote here, is it possible to use this as a template for a similar issue for my own project ? (Obviously tagging different users).
 You might want to conform to the Moya Contributing guidelines - which is still in a bit of flux, https://github.com/Moya/contributors/issues/6 but can provide a lot of the framework you're looking for
   Glad to help. The documentation is first class :+1: 
  _I think it's the wrong wording but maybe I just don't understand it xD_

A minnor wording change.

PS: Kudos for the documentation üëè
    `NSURSession` -> `NSURLSession`
 @ashfurrow thank you! Looking forward to getting into Moya :-D
  I am not sure if the steps declared in the dependencies section of the `circle.yml` are actually needed, so I removed them and used the `Makefile` (which does kind of the same) instead.
  This adds support for using Moya with Carthage, using the technique described in CocoaPods/pod-template#106. It merely makes it possible to build with Carthage, though, to be useful without requiring the user to have CP installed as well, the `Pods/` directory would need to be added to the repo. I didn't want to pollute the PR with that, though.

It is WIP, because it currently needs `master` of both CocoaPods and Carthage. I'll update the PR once those things are released, for now it is just for the adventurous.

The only duplicated effort this requires is declaring the dependencies in the `Cartfile` as well as the `Podfile`.
 @ashfurrow since both CP as well as Carthage have shipped now with the required changes, this should be good to merge. 

Keep this in mind, though:

> the Pods/ directory would need to be added to the repo
 @ashfurrow should be good to merge now, sir!
 @ashfurrow this should be :ok_hand: now
  I added a few doc changes but overall it's a step in the right direction. Good job!

![](http://img.pandawhale.com/52241-Will-Smith-dance-gif-Rmef.gif)
  Hi, as I can see, you are carefully fill tags and labels for issues in your repo.

For such cases I create a [github_changelog_generator](https://github.com/skywinder/github-changelog-generator), that generate change log file based on **tags**, **issues** and merged **pull requests** from :octocat: Issue Tracker.

This PR add change log file to your repo (generated by this script).
You can check, how it is look like here: [Change Log](https://github.com/skywinder/Moya/blob/add-change-log-file/CHANGELOG_AUTO.md)

Some essential features, that has this script:
-  it **exclude** not-related to changelog issues (any issue, that has label `question` `duplicate` `invalid` `wontfix` )
- Distinguish issues **according labels**:
  - Merged pull requests (all `merged` pull-requests)
  - Bug fixes (by label `bug` in issue)
  - Enhancements (by label `enhancement` in issue)
  -   Issues (closed issues `w/o any labels`)
- Generate neat Change Log file according basic [change log guidelines](http://keepachangelog.com).

You can easily update this file in future by simply run script: `github_changelog_generator ashfurrow/Moya` in your repo folder and it make your Change Log file up-to-date again!

Hope you find this commit as useful. :wink:

P.S.
I know that you already has CHANGELOG.md file but give this script a chance and compare it with yours change log. Hope, you will love it! :blush:
 Yep, it's not perfect, it can't read your minds (what should be in change log and what shouldn't), but can work very closely with labels.
(for example #81 should be also tagged as `duplicate` to avoid appearing in change log)
But it's not a big deal. And in the end you will get fully automated change log. ^)
   Hah :dancers: 
 why the close?
 @ashfurrow is a tyrant. I'm gonna hard-fork the project io.js-style and rewrite it in [ArnoldC](https://github.com/lhartikk/ArnoldC).
 :rage1: 
  Resolves #119 
- Functionality will only work for delayed stubbed responses and actual network requests
- For stubbed responses, returns an NSError similar to what you get from a real network cancelation

Don't be shy about any feedback. Nitpick away! :bow:
 The single/double L thing made me laugh.  We had an epic battle on a project a few years ago on which spelling was correct.  Eventually, [American pride](http://grammarist.com/spelling/cancel/) won out, even though (as an American) I preferred the two L's.  Just got so used to coding it that way, that I do it naturally.  

The only thing not done was fixing the ReactiveProvider test.  You can see I tried doing what you suggested, which made sense, but waitUntil() fails the test if it times out.  :crying_cat_face: 

I didn't see anything else in Nimble that would allow for an easy way to wait a certain amount of time, but I could lift some of the code from waitUntil() to give us similar functionality without failing the test?  Any other ideas?
 Oh! Also, I added the spacing around the expectation in the integration tests (since it was the only one without it), but in the `MoyaProviderSpec` the tests (except for one) did not have the spacing.  If you'd like me to just add the spacing on all the tests, let me know.
 Not a problem at all! From Twitter could tell you've been pretty busy. 
  The current API does not provide a way to cancel a network request.  Alamofire's `Request` object exposes `NSURLSessionTasks`'s `cancel` method, but `MoyaProvider` does not keep a reference to the `Request` object to later cancel, nor does it return a token to the client that could be passed later for canceling.

Since supporting this would require a change to the API, I was wondering what your thoughts were on supporting this?  I wouldn't mind helping out if you wanted to have some discussion on how this would look.
 Perfect :ok_hand: 

I can take a look at this in the next couple of days, unless you'd like to handle it.  If you'd like me to start something, let me know which version of Xcode you prefer for the work on master.  I'm assuming 6.1.1? 6.2?
 ~~Couple~~ A few of questions:
1. Do you expect this functionality to work with stubbed responses?  If so, I'm assuming it would only be in the case of a .Delayed behavior, as anything else instantly responds
2. What would you expect to happen in regards to the completion block when a request is canceled?  My first inclination would be to still call the completion block but with an error. I believe that is the behavior of the `NSURLSessionTask`.
3. Any special behavior for the `NetworkActivityClosure`/`NetworkActivityChangeType`?  I would assume the type wouldn't change, just an `.Ended` to be sent to the closure on cancel.
 I ended up using Xcode 6.1.1 because the latest Xcode (with Swift 1.2) won't compile without the changes from the `swift-1.2` branch.
  Were you planning on incorporating ReactiveCocoa extensions based on the 3.0 API?  I'm about to create my own extensions and wouldn't mind sending them along if you were interested.

Thanks for the awesome library!
 I think it would be best to have it in one class. Perhaps it would be best to have three versions of the API:
1. ReactiveCocoa 2 (RACSignals)
2. ReactiveCocoa 3 Bridge ([RACSignal -> SignalProducer](https://github.com/ReactiveCocoa/ReactiveCocoa/blob/swift-development/ReactiveCocoa/Swift/ObjectiveCBridging.swift))
3. ReactiveCocoa 3 (SignalProducer)

2 would provide an API for those already using `RACSignal` throughout their app and want to switch over piecemeal to RAC 3.
 Has anybody done any work on this yet?
 I'm starting a new project with Moya and RAC 3.0, so it's likely I'll end up writing these extensions as part of them. If I'm happy with how they turn out, I'd be happy to contribute them back.
 /cc @rpowelll Any movement on this? I'm considering doing the same now.
 @sammoore Yeah I've been working on a small project on and off over the past few weeks. I'll work on getting my extensions polished up and publish the project on the weekend if all goes as planned.
 This is all taken care of in github.com/Moya/ReactiveMoya. Unfortunately, there's no CocoaPods support yet, only Carthage. 
 What's the current/best configuration for use with Swift 2 (Xcode 7) and RAC? It looks like the Moya swift-2.0 branch, w/ RAC swift-2.0 branch, and a carthage pull of ReactiveMoya?
  This pull request does the following:
- Adds a new Moya project at the root with an iOS Dynamic Framework target
  - The project/target are only used for building with Carthage.  The tests and demo are not included.
- Adds a `Cartfile` and `Cartfile.resolved` pointing to ReactiveCocoa and Alamofire as dependencies.
- Updates the `.gitignore` to ignore the `Carthage\Checkouts` and `Carthage\Builds` directory.  

I spent a considerable amount of time trying to add the dynamic framework target to the Demo project, to avoid requiring a separate project.  Ultimately, I think it is doable, but would require the use of submodules for dependencies.  I tried going the route of using a Cartfile, but because the Cartfile wasn't in the root directory, Carthage was failing to take note of the dependencies when I tried including Moya via Carthage.

I've tested via my own fork and I was able to add and build Moya via Carthage.
 Could switch to CircleCI 
 Absolutely.  Not familiar with Travis or Circle, but I'll see about getting the Travis build functioning :+1: 
 After typing up my comment and doing a bit of research, I see now what you were getting at with Travis.

As for a separate fork, I wouldn't mind doing that for now.  A better solution is bound to come along to support both systems, but until then I wouldn't mind maintaining that.  If a better solution to including a dynamic framework target into the Demo project without using Carthage files for dependency management could be found, might you be more open?  If so, I can continue down that path when I get some time.
 Supporting Carthage is really minimal work, and considering its extreme simplicity in comparison to CocoaPods is something we'll probably see more of in future. Plus, having a dynamic framework target in your project is good practice now that they are available (and now that Cocoapods deployments use them also).

Also, in general, the practice of asking a 3rd party to pull updates into a fork to support a feature is really not the greatest, suddenly the entropy of dependence is doubled. 
 I didn't want to get into a battle over it :v:.  At this point, I agree that if you're using the CocoaPods template for creating a pod with example/demo project, it is a pain to get Carthage support working if you have dependent libraries.  I am planning on submitting a separate PR as requested, just have gotten a bit busy! :smile_cat: 
 @ashfurrow That was definitely not directed at you!  I thought language like "really minimal work" and "extreme simplicity in comparison" was getting into a CocoaPods vs Carthage battle :smile:, but perhaps I am just too sensitive.
 Should be really easy with the approach from CocoaPods/pod-template#106 and ensuring that it continues to work can be done via CI. I'll make a PR once everything is in place inside both Carthage and CP.
  Hi, @ashfurrow! I update your demo project and fix several issues. At least - now Demo project is working! There some errors with the tests, but I will try to fix them later. But you awesome project is works! :wink: 
Fixes #113.
 https://github.com/Quick/Quick/pull/289
 Sorry, I'm not familiar with circle-ci. How should I update readme status?
It seems that you can sign up there with your github account w/o invite.
 @ashfurrow bdw, as you can see - I create PR to branch  `swift-1.2`, not to `master`, so this merge will not break build status for your repo!
 yeah, thats incidental to this PR :+1: 
     I am afraid it is not, out of the box. But it would be great if there was something like Alamofire.upload at least.
 There is [Alamofire support](https://github.com/Alamofire/Alamofire#uploading) for uploading and downloading files, so this would be straight forward I guess.

I anyone already working on this? Might need it in the following weeks so I might as well hack on it if you want.
 Also looking for this fairly soon. @aschuch do you have any progress on this? If not I can take a look.
 @zdavison I did not start on it yet. I probably don't get time to do it anytime soon though... :disappointed: 
 @aschuch that's ok, i'll take a look here, we need it in the next week or so.
 FWIW we ended up just doing it by hand (since we only need it for one request) and having a special case that returns a MoyaResponse until Moya/Alamofire support it natively.

I'd be of the opinion that we should have a seperate `upload` fwiw, trying to compress it into existing methods usually leads to confusion as to what exactly is going on and lack of flexibility.
 @zdavison Can we see what your solution looks like? I tried hacking it in an endpointResolver, but I hit a wall when I figured out the `Endpoint` doesn't seem to know about any of the parameters it's been given in by the `enum`. Now, creating a custom, plain NSURLRequest seems the best option. 

But you returning a `MoyaResponse` sounds intriguing, but I don't get what that would look like.

@ashfurrow 

> On the other hand, if we add a new optional property to MoyaTarget for uploading (say, we call it uploadData), we could ignore the method of the target and assume it's uploading based on the presence of a non-nil uploadData.

I like this one. Beyond the fact that we still need a call-back of some kind, it fits very well within the existing way of creating a `Target`.

> Neither option really sits with me. We could, instead, have a new upload method on the MoyaProvider class. We would still need the optional uploadData property, the API would become slightly more complicated, and it would be some duplicated code in MoyaProvider and its subclasses.

This also sounds good, though slightly confused on how this would interact with a `Target`. Do suddenly all `Target` cases have the ability to upload data if you call them with this method? Should the method check if the request is a .POST or not?
 ``` swift
  // Multipart image uploading not supported by Moya/Alamofire, temporary stand in
  internal static func ns_multipartImageUpload(urlString: String, image: UIImage, imageKind: ImageKind, progressHandler: ((Float) -> Void)?) -> RACSignal{

    let imageData       = UIImageJPEGRepresentation(image, 9.5)

    return RACSignal.createSignal{
      (subscriber) in

      Just.post(
        urlString,
        headers:    ["X-Auth-Token":  DropLogic.sharedInstance.apiToken!],
        data:       ["sizes":         imageKind.rawValue],
        files:      ["file":          HTTPFile.Data("image.jpeg", imageData, nil)],
        asyncProgressHandler: {
          (progress) in
          progressHandler?(progress.percent)
        },
        asyncCompletionHandler: {
          (result) in

          if let error = result.error {
            subscriber.sendError(error)
            return
          }

          let moyaResponse = MoyaResponse(statusCode: result.statusCode!, data: result.content!, response: result.response)
          subscriber.sendNext(moyaResponse)
          subscriber.sendCompleted()
        }
      )

      return RACDisposable()
    }
  }
```

Using [Just](https://github.com/JustHTTP/Just.git) and [ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa). 
 Didn't know about Just :) That's going to be useful. Thanks!
 Has there been any work on this yet? :pray: 
 I'll give it a try this weekend, need to look around the source a bit so it feels enough Moya-like.

Sent from my iPhone

> On 08 Oct 2015, at 18:04, Alexander Schuch notifications@github.com wrote:
> 
> Not yet, do you want to give it a shot and open a PR @clooth?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 BTW Alamofire now [supports uploading multipart/form-data](https://github.com/Alamofire/Alamofire#uploading-multipartformdata)  natively.
 I would really like this to be part of Moya. Might give it as shot, but I think I need a better understanding of the project before that will work... Is anyone else making progress on this?
 Maybe we should not focus on `multipart/form-data`, but on uploads in general. In Alamofire there are [4 types of uploads](https://github.com/Alamofire/Alamofire#uploading):
- File
- Data
- Stream
- MultipartFormData

I would say we add some kind of request type, which can be either `Request` or `Upload` (we could add  `Download` too). Based on the request type it would execute the right Alamofire methods with the needed data from the target. That would also mean adding some kind of `UploadType` enum for all the supported upload types.

This way you maintain the abstraction. If you were adding a request specifically for uploads, you'd be picking the request type when executing a request, but that's something that the target should know.

Please do correct me if I'm wrong, but this seems like a step in the right direction to me.
 Makes sense to add the type of request to the target. 
 Yeah, I'm sorry to say that I don't have time for this after all.
 I think, ideally, we'd like to be able to use the same endpoints for both Requests and Uploads, and therefore directly provide the DataProvider as a parameter to the request function. I ran with @JRHeaton's idea of a protocol extension to MoyaTarget, MultipartFormUploadable. I posted some of the implementation below and would love any feedback!

``` swift
public protocol MultipartFormUploadable: MoyaTarget { }

extension MoyaProvider where Target: MultipartFormUploadable {

    public func request(target: Target, parts: [MultipartBodyPart], completion:Moya.Completion) -> Cancellable {
        precondition(target.method == .POST, "Uploads require Moya.method to be .POST")

        let endpoint = self.endpoint(target)
        let stubBehavior = self.stubClosure(target)
        var cancellableToken = CancellableWrapper()

        let performNetworking = { (request: NSURLRequest) in
            if cancellableToken.isCancelled { return }

            switch stubBehavior {
            case .Never:
                cancellableToken.innerCancellable = self.sendUpload(target, request: request, parts: parts, completion: completion)
            default:
                cancellableToken.innerCancellable = self.stubRequest(target, request: request, completion: completion, endpoint: endpoint, stubBehavior: stubBehavior)
            }
        }

        requestClosure(endpoint, performNetworking)

        return cancellableToken
    }
}
```

The sendUpload function would take an additional parameter representing a collection of each part of the multi-part upload, with those parts represented by the MultipartBodyPart struct. We could then have some helper function on the Manager that takes that collection and returns an Alamofire request.

``` swift
public struct MultipartBodyPart {

    public enum DataProvider {
        case Data(NSData)
        case File(NSURL)
        case Stream(NSInputStream)
    }

    public let name: String
    public let provider: DataProvider

    // Additional stream parameters
    public let length: UInt64
    public let fileName: String
    public let mimeType: String
}

    func sendUpload(target: Target, request: NSURLRequest, parts: [MultipartBodyPart], completion: Moya.Completion) -> CancellableToken {
        guard let request = manager.uploadRequest(request, parts : parts) else {
            var cancellableToken = CancellableWrapper()
            cancellableToken.isCancelled = true
            return cancellableToken.innerCancellable!
        }

        return sendRequest(target, request: request, completion: completion)
    }

public extension Manager {

    private func uploadRequest(request: NSURLRequest, parts: [MultipartBodyPart]) -> Request? {

        let formData = MultipartFormData()

        for part in parts {
            switch part.provider {
            case .Data(let data):
                formData.appendBodyPart(data: data, name: part.name)

            case .File(let file):
                formData.appendBodyPart(fileURL: file, name: part.name)

            case .Stream(let stream):
                formData.appendBodyPart(stream: stream, length: part.length, name: part.name, fileName: part.fileName, mimeType: part.mimeType)
            }
        }

        do {
            let data = try formData.encode()
            return self.upload(request, data: data)
        } catch {
            return nil
        }
    }
}
```
 @colinta pretty much any endpoints that could take optional data. I may not be completely understanding @GuidoHendriks solution, but I'd like to not have to write multiple enum cases for, say a "Create Account" request that may or may not take image data.  Essentially, I want one "Create Account" endpoint to which I can optionally pass one or multiple NSData, NSURL, NSInputStream parameters.  

Essentially, I'd like to avoid extraneous enum cases like this...

``` swift
public enum API: MoyaTarget {

    case CreateAccount(name: String, type: String, description: String)

    case CreateAccountWithImageData(name: String, type: String, description: String, imageData : NSData)
}

extension API  {

    public var requestType: RequestType {
        switch self {
        case .CreateAccount:
            return .Request

        case .CreateAccountWithImageData:
            return .Upload
        }
}
```
 @drw86312 Why would you need an extra endpoint for that? You could instead just use an optional:

``` swift
public enum API: MoyaTarget
{
    case CreateAccount(name: String, imageData: NSData?)

    public var requestType: RequestType {
        switch self {
        case .CreateAccount(_, let imageData) where imageData != nil:
            return .Upload
        default:
            return .Request
        }
    }
}

API.CreateAccount(name: "Guido", imageData: nil).requestType      // .Request
API.CreateAccount(name: "Guido", imageData: NSData()).requestType // .Upload
```
 @zdavison Would you mind sharing your solution on manual implementation?
 Hey, guys. Any progress on this issue? Is there any solution that is working and can be used?
Anyway, upvoting!

And thanks for so cool artefact, Moya literally saved me days of work and tons of headache!
 Getting in way late to the party here but I second @GuidoHendriks' idea of just adding a `RequestType` enum with two cases `.Upload` and `.Request` and then a second enum, `UploadType` with four cases: `.File`, `.Data`, `.Stream`, `.Multipart`.

We could then add two variables to `TargetType`:

```
public var requestType: RequestType { get }
public var uploadType: UploadType? 
```

 where `uploadType` would only be checked if `requestType` returns `.Upload`. What I like a lot about this approach is it's easy to implement, it keeps the abstraction, and makes migrations much easier since all people now have to do is add the two new variables to conform. 

My only concern is as mentioned, how to show progress of a upload request.
 @startupthekid I like that.

> where uploadType would only be checked if requestType returns .Upload. What I like a lot about this approach is it's easy to implement, it keeps the abstraction, and makes migrations much easier since all people now have to do is add the two new variables to conform.

We could even go as far as adding a default implementation with sensible defaults to the added protocol vars, which would "upgrade" any existing implementations. 
 Exactly. Anything that doesn't explicitly say they're an upload is just a request. People can opt into the behavior as needed.
 I'm thinking we should `TargetType` generally the same and steal some patterns from `Alamofire`...

If we add `ParameterEncoding` to `TargetType`, then we could describe a multipart like so:

``` swift
public enum Target {
  ...
  /// Represents a data part upload.
  /// Requires a data part to upload, the name of the part, the file name, and the mime type
  case UploadData(NSData, String, String, String)
}

extension Target: TargetType {
  var parameterEncoding: ParameterEncoding {
    switch self {
    case .UploadPhoto(let data, let partName, let fileName, let mimeType):
      return .Multipart({ formData in
        formData.appendBodyPart(data: data, name: partName, fileName: fileName, mimeType)
      })
    default:
      return .JSON
    }
  }
}
```

I'm going to spend a little time poking around the internals to see what makes the most sense. Personally, this is my preferred API use case. I think it makes a bit more sense than introducing new abstractions that would be ignored in 90% implementations, and also gives the developer a bit more power in handling the encoding on a per-request basis.

**EDIT:** Definitely not great that `Multipart` wouldn't exactly map to an `Alamofire` equivalent. Also, this doesn't solve the progress problem.

**Update:** I went a different direction then mentioned above. I still have to write tests, but I implemented what @ashfurrow was talking about, being a separate `request` method on the `MoyaProvider`. 

Here's the body:

``` swift
    public func multipartRequest(target: Target, multipartFormData: MultipartFormData -> (), completion: Moya.Completion) -> Cancellable {
        let endpoint = self.endpoint(target)
        let stubBehavior = self.stubClosure(target)
        var cancellableToken = CancellableWrapper()

        let performNetworking = { (request: NSURLRequest) in
            if cancellableToken.isCancelled { return }

            self.manager.upload(
                endpoint.urlRequest,
                multipartFormData: multipartFormData,
                encodingCompletion: { result in
                    switch result {
                    case .Success(let encodedRequest, _, _):
                        switch stubBehavior {
                        case .Never:
                            cancellableToken.innerCancellable = self.sendAlamoRequest(target, alamoRequest: encodedRequest, completion: completion)
                        default:
                            cancellableToken.innerCancellable = self.stubRequest(target, request: encodedRequest.request!, completion: completion, endpoint: endpoint, stubBehavior: stubBehavior)
                        }
                    case .Failure(let error):
                        print("An error occurred while encoding multipart request:", error)

                    }
                }
            )
        }

        requestClosure(endpoint, performNetworking)

        return cancellableToken
    }
```

I had to make some slight API changes, and the implementation is fairly naiive, but it works. I'm going to do some cleanup, add some tests, and file the PR, so we at least have a base to refine.
  Now it's strictly binded to Alamofire version `1.1.0` 
https://github.com/ashfurrow/Moya/blob/master/Moya.podspec#L23

But it's `1.2.1` version already released. Is there any reasons to stay with `1.1.0`?
 @ashfurrow hmm, update it to 1.2? :wink: 
 Hooray! :+1: 
   As for me closure will be great
 failed to add closure due to poor swift experience.
added property.
used with this code:

```
class MyReactiveMoyaProvider<T where T: MoyaTarget> : ReactiveMoyaProvider<T> {

    /// Initializes a reactive provider.
    override init(endpointsClosure: MoyaEndpointsClosure, endpointResolver: MoyaEndpointResolution = MoyaProvider.DefaultEnpointResolution(), stubResponses: Bool  = false, stubBehavior: MoyaStubbedBehavior = MoyaProvider.DefaultStubBehavior) {
        super.init(endpointsClosure: endpointsClosure, endpointResolver: endpointResolver, stubResponses: stubResponses, stubBehavior: stubBehavior)
    }

    override var hasNetworkActivity: Bool {
        get {
            return self.hasNetworkActivity
        }
        set(newValue) {
            println("MyReactiveMoyaProvider.hasNetworkActivity \(newValue)")
            UIApplication.sharedApplication().networkActivityIndicatorVisible = newValue
        }
    }
}
```
 Great! That is almost exactly what I wish to express, but failed to make it compilable!
    For now, this only updates the swift files to work with 1.2. The ReactiveCocoa dependencies still need to be updated. This requires a .podspec for ReactiveCocoa 3.0 alpha 3.
 Cool, :+1:
  I'm trying to get Moya going on a swift 1.2 XC 6.3 Beta 4 project and running into some compile errors.  Some were easy fixes (swift demanding that a method parameter be called with its parameter name on lines 166, 170, 174 of Moya.swift, adding the parameter name in satisfied the compiler), but one is stumping me somewhat:

``` swift
/// Used for stubbing responses.
public enum EndpointSampleResponse {
    case Success(Int, NSData)
    case Error(Int?, NSError?, NSData?)
    case Closure(@autoclosure () -> EndpointSampleResponse)

    func evaluate() -> EndpointSampleResponse {
        switch self {
        case Success, Error: return self
        case Closure(let closure):
            return closure().evaluate()
        }
    }
}

```

The use of @autoclosure here raises a `'...Pods/Moya/Endpoint.swift:16:19: 'autoclosure' attribute is only allowed on parameters, not on enum cases'`

error.   I'm not familiar enough with swift yet to know what a the right thing to do in this situation is, though it looks like this discussion here covers it somewhat, at least I think so.  https://devforums.apple.com/message/1101244#1101244
 See changes in #107. 
 Thanks! @ashfurrow great project, can't wait to get more familiar with it.
  ...as discussed in #103. 
  [The version in your ReactiveCocoa podspec](https://github.com/ashfurrow/ReactiveCocoa/blob/podspec/ReactiveCocoa.podspec#L38) does not seem to match [the version defined in your LlamaKit repo](https://github.com/ashfurrow/LlamaKit/blob/rac_podspec/LlamaKit.podspec#L3).

On trying to install the two pods together I am getting this error message:

```
[!] Unable to satisfy the following requirements:

- `LlamaKit (from `https://github.com/AshFurrow/LlamaKit`, branch `rac_podspec`)` required by `Podfile`
- `LlamaKit (= 0.1.1)` required by `ReactiveCocoa (3.0.0-alpha.1)`
```

Any ideas?
 What I mean is that this happens when you follow the installation instructions in your README. :)

```
pod 'Moya', :git => "https://github.com/AshFurrow/Moya"

# Include the following only if you want to use ReactiveCocoa extensions with Moya
pod 'LlamaKit', :git => "https://github.com/AshFurrow/LlamaKit", :branch => "rac_podspec"
pod 'ReactiveCocoa', :git => "https://github.com/AshFurrow/ReactiveCocoa", :branch => "podspec"
pod 'Moya/Reactive', :git => "https://github.com/AshFurrow/Moya"
```
 Ah, alright. Thanks for the help. :)
  At the moment, [`RACSignal+Moya.swift`](https://github.com/ashfurrow/Moya/blob/190a180902919497de05ff4067d39ebcf4cfc96c/RACSignal%2BMoya.swift#L52) defines `200...299` as successful status codes.

I ran into an issue when dealing with cached responses (i.e. 3xx status codes) that would incorrectly be rejected.

Should we change the definition of successful to `200...399`?
I would be happy to open a pull request if needed, but want to start a discussion about this change first.
 - I think that the server sends a response anyway, although it may not contain any actual data. However, it would still be possible to parse the response into a `MoyaResponse` object to e.g. get its `statusCode`.
- Based on [this PR](https://github.com/Alamofire/Alamofire/pull/350), Alamofire seems to be handling redirects transparently, but I have not had the time to further investigate.

Something like `filterSuccessfulStatusAndRedirectCodes` definitely makes sense, especially for backwards compatibility with any existing code using this library.
  We are getting `Link: ... rel="prev"` URLs from our API that are used for pagination.  They return a full URL, and we need to use that URL in the subsequent request.

Since the URL includes `?query=params`, we are having a URL encoding issue.  Makes sense, though, since we are doing something outside the norm.  Is this even a situation that Moya wants to support?

In short, we are trying to come up with a way to bypass the usual URL encoding, and pass the URL and params in all the way down to `NSURLRequest`.
 CC @rynbyjn and @steam - anything to add, fellas?
 @colinta we're currently parsing Link: into NSURLComponents and then reassembling the params in defaultParameters. Its not ideal though. I am curious how other Moya users handle this.
 Nice, we are using WebLinking.swift for the parsing. WebLinking gives us the ability to ask for "next" and "prev" which are super handy. The issue we're running into is that the links are already url encoded by the application server generating the "Link" in the response header. Just saw your representor pattern comment. We'll explore that internally. We're non-RAC so we'll need to come up with something without signals. Seems like a good idea though @ashfurrow. Thanks.
  Hello Ash,

Can you help me with a problem?

When I installed my pods I used bundle exec pod install .. with cocoapods beta 1 on my gemfile. Today I put on the gemfile fastlane and now it's using cocoapods beta 2. I deleted fastlane gems and also cocoapods beta 2  + core but when I try bundle exec pod install it says: We couldn't find cocoapods core .. beta 2. Maybe one of the gems still needs beta 2 but I can't find which one. 
![screen shot 2015-02-22 at 4 00 37 pm](https://cloud.githubusercontent.com/assets/6751025/6318980/fd9cbb80-baab-11e4-85bf-cd7508c8e6f5.png)

Thank You!
 Ok I fixed it. :) I see you guys at Artsy use beta 1. Are there any problems when you submit the app to the app store with beta 1?
 Thank You Orta! :)
  I'm having trouble getting the specs to run... also, if you think this PR is worthwhile, I would like to add some specs around this specific feature.  Let me know what you think!

Example:

``` swift
let endpointsClosure = { (target: GitHub, method: Moya.Method, parameters: [String: AnyObject]) -> Endpoint<GitHub> in
    return Endpoint<GitHub>(URL: url(target), method: method, parameters: parameters,
        sampleResponse: .Lazy({ return .Success(200, target.sampleDataFromSomeExpensiveOperation) })
    )
}
```
 I took an initial stab at this using `@autocomplete` on `sampleResponse:` (and called in the `if stubbedResponses` code), but that had an unfortunate side effect that `sampleResponse: .Success(..)` was not autodetected to be of type `EndpointSampleResponse` (e.g. it had to be `EndpointSampleResponse.Success`).  I figured backwards compatibility was preferred, and this syntax is explicit, which is a win.
 I like the "always lazy" idea.  For that to be backwards compatible we'd need to use an autoclosure, right?

``` swift
public init(URL: String, sampleResponse: EndpointSampleResponse, method: ...
  =>
public init(URL: String, sampleResponse: @autoclosure () -> EndpointSampleResponse, method: ...
```

I attempted this and there were so many repercussions that I went with this more straightforward way instead.  I'll take another stab at it.

I'm down with `s/Lazy/Closure/` if we go that route.
 Btw when I run `make` or `make test` I get this error:

```
‚å¶ The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.
```

```
set -o pipefail && xcodebuild -workspace 'Demo/Demo.xcworkspace' -scheme 'Demo' -configuration Debug test -sdk iphonesimulator -destination 'name=iPhone 5' | xcpretty -c --test
2015-02-16 08:01:23.564 xcodebuild[1654:46790] [MT] iPhoneSimulator: Unable to connect to "com.apple.instruments.deviceservice.lockdown" (Error Domain=com.apple.CoreSimulator.SimError Code=146 "Unable to lookup in current state: Shutdown" UserInfo=0x7fc9d2691c20 {NSLocalizedDescription=Unable to lookup in current state: Shutdown})

‚å¶ The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.


Testing failed:
    Diff: /../Podfile.lock: No such file or directory
    Diff: /Manifest.lock: No such file or directory
    The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.
** TEST FAILED **


The following build commands failed:
    PhaseScriptExecution Check\ Pods\ Manifest.lock Build/Intermediates/Demo.build/Debug-iphonesimulator/Demo.build/Script-703B20D06B76F0F02BE31CB7.sh
(1 failure)
make: *** [test] Error 65
```
 Ahh, right, OK I just reimplemented the autoclosure style locally, and here's the error that turned me off to the idea:

```
var endpoint = Endpoint<MyAPI>(URL: url(target),
  sampleResponse: .Success(200, target.sampleData),
  method: method,
  parameters: parameters)
üö´ '(@autoclosure () -> EndpointSampleResponse).Type' does not have a member named 'Success'
```

Right, so since this method expects a closure, it wouldn't support `.Success`.  This would be a breaking change.

If `(()->EndpointSampleResponse).Type` could be extended to include `.Success` and `.Failure` then we'd have a way of having this feature _with_ backwards compatibility.
 (O_O)

``` swift
public enum EndpointSampleResponse {
    case Success(@autoclosure () -> (Int, NSData))
    case Error(@autoclosure () -> (Int?, NSError?, NSData?))
}
```
 This is still not ideal.  With this autoclosure trick, the `.Success / .Failure` values now look like this - they have to be wrapped in a closure:

`.Success((200, target.sampleData))`
 Is there a `Podfile` I'm missing?

```
> bundle install --path vendor
...
Your bundle is complete!
It was installed into ./vendor
> bundle exec pod install
[!] No `Podfile' found in the project directory.
```
 ```
03:39 PM ~/Code/Swift/Moya ‚Äπ master ‚Ä∫
> ls
CHANGELOG.md             Gemfile                  Makefile                 Moya.swift               docs
Demo                     Gemfile.lock             Moya+ReactiveCocoa.swift RACSignal+Moya.swift     vendor
Endpoint.swift           LICENSE                  Moya.podspec             README.md                web
```
 (root project folder, same as Makefile)
 Success!  I'll work on the specs.

Regardless, I'm unsure what style you like the most at this point:
1. new type, `.Closure()`, which returns an `EndpointSampleResponse`
2. autoclosure in `init`, which requires changing `.Success => EndpointSampleResponse.Success` because the type can't be detected
3. autoclosure in the enum initializer, which is backwards compatible but might not work in 1.2

I still like option 1 (the original patch) because if `@autoclosure` is a moving target, I don't feel much better about using it in `Endpoint.init` than using it in the enums.

Sounds like you're leaning towards option 2 - it just requires the sample response type to have the explicit `EndpointSampleResponse.` prefix.  Not _as_ pretty, but not cumbersome.  And :+1: on the simple use of `@autoclosure` there.
 OK, can do - and yeah, I agree, I think it's the most straightforward.
I'll push up that version soon with specs.

Are you hanging out with Eloy these days?  Tell him Colin says hi! :-D

On Tue, Mar 3, 2015 at 5:38 PM, Ash Furrow notifications@github.com wrote:

> I think the first option, adding a new case to the enum, would be awesome.
> Avoiding @autoclosure seems to be a good idea for now. Let me know if I
> can help!
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/ashfurrow/Moya/pull/100#issuecomment-77074131.
 üëãüòÜ
 @ashfurrow OK, I was working on the specs, and I _accidentally_ (i swear) did this:

`.Closure(.Success(200, ...`

But then I was like, WAIT a second... `case Closure(@autoclosure () -> EndpointSampleResponse)` would make this a very easy opt-in feature!  It supports the syntax I accidentally typed, and as far as I can tell, this syntax will still be supported in 1.2.

I thought it looked great, so I'm pushing it up for review here.  I can still revert to the non-@autoclosure code, e.g. `Closure({ return .Success(200, ...`
  I'm going to take a stab at it in my own fork, but am pretty new to Swift so it probably won't be PR-able.
 Ah, never mind... Misunderstood how this is done.
  a few '!' were missing and the order of the parameters in Endpoint constructors were wrong
 I still have an issue though with :

``` swift
provider.request(.Zen, completion: { (data, error) in
            if let data = data {
                // do something with the data
            }
        })
```

It complains about `Missing argument for parameter 'method' in call`
    It would be sweet if there were a way to randomly or deterministically add a short delay to stub request returns to make it a little more "real".
 Oh, this is purely so we can show off a loading animation, I'm sure I'm not the only one who uses stubs for demo purposes. It already should be async because callbacks (I haven't checked the implementation but a dispatch_async is as good as any guarantee that it'll wait a loop, I think).
 Super helpful for when stage/dev is down.
  These submodules were already removed in abaf6cb0adafc0c0b482724edcf95f89225940d2, but the `.gitmodules` file was never modified to reflect that.

This was causing [Carthage update failures](https://github.com/Carthage/Carthage/issues/135#issuecomment-69566497) of the form:

```
Parse error: expected submodule commit SHA in ls-tree output: 
```

/cc @aschuch
 No problem. :tada: 
 :+1:
 I am still getting this error with 0.6 and 0.6.1 in Carthage.  If I try going back to 0.5 (just to find anything that works) I get a different error:

> **\* Checking out Moya at "0.5"
> fatal: reference is not a tree: 80cc05720013042eccfc8bc20a8304cd3ae656d7

I have tried an empty Cartfile with nothing but Moya and also fully deleting the Carthage/Checkout/Moya folder to start from scratch and I'm still getting this.  Is the errant `.gitmodules` in my own repo or in Moya's?
 @crmorse If you're using Carthage to manage submodules, you might be hitting https://github.com/Carthage/Carthage/issues/320.
  This PR adds the ability to stub data when testing errors. In production many of our errors have structured data. This allows unit tests to account for them. (Thanks for all the hard work on Moya, we are very happy with it so far.) 
 I saw you got the CI failure fixed. Nice work! I've added a spec for the stubbed nsdata error. Should be good to go. Thanks!
  I have been working with this framework on iOS and am having a compile issue when adding custom parameterEncodings. I was wondering if you could help me out. 

My EyeQEndPoints enum does not implement URLRequestConvertible which I believe is ok. 

I declare the custom closure as follows:

let xmlParameterEncoding:(URLRequestConvertible, [String: AnyObject]?) -> (NSURLRequest, NSError?) = {(URLRequest, parameters) in {

//this is just to get things working
return (NSURLRequest.URLRequest, nil)
}

In the endpointsClosure, I set the custom closure:

let endpointsClosure = { (target: EyeQEndPoints, method: Moya.Method, parameters: [String: AnyObject]) -> Endpoint<EyeQEndPoints> in
    return Endpoint<EyeQEndPoints>(URL: url(target), sampleResponse: EndpointSampleResponse.Success(200, target.sampleData), method: method, parameters: parameters, parameterEncoding: .Custom(xmlParameterEncoding))
}

The compiler throws an error on .Custom(xmlParameterEncoding) of

error: type 'URLRequestConvertible' does not conform to protocol 'URLRequestConvertible'
    return Endpoint<EyeQEndPoints>(URL: url(target), sampleResponse: EndpointSampleResponse.Success(200, target.sampleData), method: method, parameters: parameters, parameterEncoding: .Custom(xmlParameterEncoding))

Thanks for your help.
 Thank you for the response. I figured that out shortly after I created the ticket. 
  The link http://ashfurrow.com/Moya is not working. is it possible to put it on github?
 It's in the file "Moya/docs/Readme.md". Now i realize that there is another Readme.md in the root directory, so maybe the obsolete one should be deleted? 
  I use this framework with CocoaPods, but I can't install my app on my device via OTA install (use Fabric).

And I try to submit to iTunes Connect, I got this message.

```
Dear developer,

We have discovered one or more issues with your recent delivery for "". To process your delivery, the following issues must be corrected:

This bundle is invalid - The file extension must be .zip.
```

Any idea?
 Thanks to reply, seems like we need wait that work finished.

I saw your app eidolon(Artsy's new auction app) also use this pod, how do you deploy to Hockey?

Or you haven't deploy yet?
 Ok, I'll check that later, thanks. 
  This PR is intended to return Framework/Carthage/Submodule support to Moya while preserving its ability to be used as a CocoaPod, and for its dependencies to be managed as a CocoaPod.
 Real talk I'm going to bed now and this needs to be squashed but it basically uses CP to manage dependencies while allowing for users to bare clone and integrate as a framework in a subproject, provided you also have AF and RAC.
 It does but I'm not happy with it.
 My findings:
- Defining dependencies using CocoaPods couples the build phases of the framework to a PODS_ROOT that may not exist (cc @modocache)
- This means that as of right now, Frameworks that use CocoaPods _must only be integrated in a CocoaPods environment_

Holy war indeed.

Ash I don't know how much skin in the game you have for this but I really don't want to see a fractured either/or world.

The current solutions:
1. Define your dependencies the "traditional" way through Carthage or submodules, since they support alternative sources of dependent frameworks. Your project will still work as a CocoaPod.
2. Fix CocoaPods so it supports alternative sources of dependent frameworks.
 Delete it mate I will do a new one when I get the chance

i will

i will
  For the Carthage/submodule users‚Äì a Moya.xcodeproj defining the Moya.framework target is something I would very much like. Putting this in as placeholder, I'm working on it.
 Wrote down the idea of CocoaPods being able to generate a throw-away Xcode project from a podspec here https://github.com/CocoaPods/CocoaPods/issues/2885.
 @swizzlr Any news on this issue?
 Oh nice.
This might actually be pretty helpful, thanks. üíû
 Hi @ashfurrow,
I tried to build Moya for Swift 1.2 with your aforementioned link, but went straight to dependency hell.

I've done 2 things now:
1. I updated Moya to swift 1.2. (I am happy to open a separate pull request for that if you want?)
2. I have now created a project at https://github.com/aschuch/MoyaCarthage that creates Moya.framework to directly work with Carthage.  

Do you think Carthage support should be part of Moya itself or do you want someone else to cover that part? I am happy to maintain this project as a reference to other developers using Carthage. 
 Sorry, I'm not sure if this is the appropriate place for this comment, but I'm trying to get Moya going on a swift 1.2 XC 6.3 Beta 4 project and running into some compile errors.  Some were easy fixes (swift demanding that a method parameter be called with its parameter name), but one is stumping me somewhat:

``` swift
/// Used for stubbing responses.
public enum EndpointSampleResponse {
    case Success(Int, NSData)
    case Error(Int?, NSError?, NSData?)
    case Closure(@autoclosure () -> EndpointSampleResponse)

    func evaluate() -> EndpointSampleResponse {
        switch self {
        case Success, Error: return self
        case Closure(let closure):
            return closure().evaluate()
        }
    }
}

```

The use of @autoclosure here raises a `'...Pods/Moya/Endpoint.swift:16:19: 'autoclosure' attribute is only allowed on parameters, not on enum cases'`

error.   I'm not familiar enough with swift yet to know what a the right thing to do in this situation is, though it looks like this discussion here covers it somewhat, at least I think so.  https://devforums.apple.com/message/1101244#1101244

Happy to open a new issue as I'm guessing this isn't related, just saw the discussion of 1.2 compatibility and seized one it.
 Hey @te-chris, I will open a pull request this week that should fix 1.2 compatibility. 

---

@ashfurrow, 1.2 compatibility would require a ReactiveCocoa version bump to alpha 3 on the CocoaPods side of things and I don't think there is a podspec for that yet?

> Someone tried once but apparently it was really hard?

This was actually the reason why I ended up creating a new project for Carthage, because I wasn't able to resolve the CocoaPods dependencies to work with swift 1.2.
I think we should have two separate Demo projects, one for CocoaPods and one for Carthage? I am open towards maintaining the Carthage side of things if you want.
 See changes in #107.
 I think 2 targets would be best, not a huge fan of 2 demo projects or repos tbh. The repo I created was meant to be a POC only.

I think Carthage requires the project file to reside in the root of the repo though, so we would need to rearrange some things.

@orta's idea sounds really great. What do you think, @jspahrsummers?
 @orta wouldn't be a fan of generating that. If you want to support Carthage, you should at least run it once to verify that it builds and then you'll have the Cartfile.lock, anyway.
 I don't think two demos split by choice of dependency manager make sense. A demo is just a demo, so why does it matter to consumers how it includes its dependencies?

On the other hand, it shouldn't be hard to add an Xcode project for Carthage compatibility with the _framework_. If you have questions about that, I'd be happy to help.
  Thanks for this great work, but I can't use that because when i run `bundle install`, it show following message

```
Bundler could not find compatible versions for gem "xcodeproj":
  In Gemfile:
    cocoapods (>= 0) ruby depends on
      xcodeproj (~> 0.20.2) ruby

    xcodeproj (0.20.1)
```
 I don't have time to make a pull request right now, but the Gemfile in this repo no longer works. See https://github.com/CocoaPods/CocoaPods/issues/2869 and https://github.com/CocoaPods/CocoaPods/pull/2835. The changes for swift support in cocoapods have started to get merged into master as 0.36.0 approaches.

Use this:

```
source 'https://rubygems.org'

gem 'xcpretty'

# Pre-release CocoaPods support for Swift AWWW YEAH
gem 'cocoapods', :git => 'https://github.com/CocoaPods/CocoaPods.git', :branch => 'swift'
gem 'cocoapods-core', :git => 'https://github.com/CocoaPods/Core.git'
gem 'xcodeproj',  :git => "https://github.com/CocoaPods/Xcodeproj.git"
gem 'claide',  :git => 'https://github.com/CocoaPods/CLAide.git'  
```
 You guys are genius!! Thanks.
  I found a very small typo. Thanks for all your work on this framework, it has been one of the biggest advantages of using swift in my latest project.
  Not sure if this is supposed to work in the pre-release CocoaPods or if it's just a copy/paste oops, but it wouldn't work for me as is.

:smile_cat: Swift pods!
  I just had the same issue and resolved it with your suggested fix.

Is there a reason this has not made it into master yet? Do you want to hold off until this is resolved in ReactiveCocoa itself?
 :+1: done
  :metal: 
  +1, one step forward to "declarative" API
  I may end up doing this in anger, so I'm dropping a note here in case anyone else is interested. Probably a separate project? It uses mustache templates so how hard can it be?!
 The codegen logic might be abstractable across inputs. Never written this, do I need to use yacc?
 cc @Alexey-Matjuk
 Thanks for the mention @orta! :) I am planning to update the generator soon with new features, including sample data generation and header values parsing.

@orta It would be great if you could quickly test/have a look at the extension and let me know what fundamentals are still missing there before I could launch it officially on Paw Extensions page.
 No PR currently, but you can take a look at what is currently in master.
 Great, thanks! üôå
 Awesome, thanks! üòÉ
 Cross-referencing https://github.com/swagger-api/swagger-codegen/issues/2933 Hey guys, I just created a Moya Generator from Swagger Spec by using SwagGen. At the beginning, I was successful create it by using original Swagger Codegen but it has many limitations and hard to modify.

Luckily @yonaskolb created another Codegen written in Swift, more flexible and simple. I am very happy it now. kudos for him.

You can get the template here: https://github.com/dangthaison91/SwagGen/tree/master/Templates/Swift-Moya

It supports upload file, all parameter types.
But It also has some issues: not support multi-authentication method, the Model generator is not perfect with Realm.  The sample did not build on Xcode 6.1 / OSX 10.9 due optional chaining of non optional.
  I flip-flopped a bit between this and "Only allow endpoints clearly defined through Moya to be accessed through Moya", but this one seems more precise to me.
  When choosing to use Moya as a submodule rather than copy its files into a project, MoyaErrorDomain is unusable outside Moya since it's private by default.
  Fixes https://github.com/AshFurrow/Moya/issues/66
I've also update Readme and .gitignore :smiley: 
  I'm wondering maybe I've missed something, but I do not see any way to pass default parameters to each request.

`Moya.defaultParameters()` exists but it is not exposed in any way to be configured
 modifying `endpointsClosure` works perfectly!
But you really need some documentation for this :+1: 
  ![2014-11-05 14-48-36 moya swift edited](https://cloud.githubusercontent.com/assets/829783/4917206/d9088724-64e1-11e4-9f9c-e02aef081ac2.png)

I've integrated Alamofire as subproject and dragg-n-dropped Moya sources as displayed at the screenshot and got this strange error.

Xcode 6.1
 It can be fixed by changing signature of Custom closure:
        `case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSURLRequest, NSError?))` but I am really not sure that it's the right way.
 Absolutely sure it is because I've checked out the latest master of Alamofire separately.
 If the fix I've described is suitable I'll make the PR (it can be fixed by using the same closure signature as in Alamofire)
  I had a similar thought not long ago.  Being able to define the response _in_ the test would have been convenient when I needed to stub out a _sequence_ of responses... I don't recall the actual example, but a contrived example would be a combined signup screen that also tests to make sure the user isn't trying to create their existing account:
1. Try to login (`login_failure.json`)
2. API says username is available (`availability_success.json`)
3. Submit a signup request (`signup_success`)
4. Now try to login (`login_success.json`)
5. Screen should transition to onboarding.

I think orta's "in line provider" would be one way to solve this.  What would be another way for `sampleData` to be more dynamic?
 I dig it, very readable way to set up a series of requests/responses.

To flesh this out a little more, these requests would be instances of the API enum?

``` swift
let firstReq = Api.Status  // will return "broken"
let secondReq = Api.FixTheThings
let lastReq = Api.Status  // will return "fixed"

// how do these get associated with
// the appropriate JSON file?
let provider = ApiProvider.StubbingProvider().addStubbing(firstReq)
  .addStubbing(...)
```
 Yeah I dig it.  So, continuing to flesh out:

``` swift
let firstReq = Api.Status  // will return "broken"
let secondReq = Api.FixTheThings
let lastReq = Api.Status  // will return "fixed"

let provider = ApiProvider.StubbingProvider()
// push? queue?  add?  something that indicates that this stubbed response will only be used once
  .pushStubbedResponse(success("status__broken.json"), forRequest: firstReq)
  .pushStubbedResponse(success("fixed__success.json"), forRequest: secondReq)
  .pushStubbedResponse(success("status__ok.json"), forRequest: lastReq)
```
  Looks like it was added with ssh key for a submodule. I don't use ssh. Can it be added by http?

```
Warning: Permanently added the RSA host key for IP address '192.30.252.131' to the list of known hosts.
Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
Clone of 'git@github.com:Alamofire/Alamofire.git' into submodule path 'submodules/Alamofire' failed
```
  This is basically what I had in mind for https://github.com/AshFurrow/Moya/issues/46. I'm not sure if this is a great approach or not - I don't _think_ that client code would ever need to know the actual error code vs the status code sent from the server. If so the http status should probably be added to the userInfo and documented?
 Doh, I worked on this on a flight and didn't realize I hadn't pulled in the latest updates in my repository. I'll work those issues out and resubmit.
 What's the advantages of Moya over AlamoFire? Just asking, intending politely.
 @plasmaphonic I'm not sure this is the best issue to go over the potential advantages of Moya over using AlamoFire (which Moya uses) directly, but I would refer you to the README - specifically:
- Treat test stubs as first-class citizens.
- Only allow endpoints clearly defined through Moya can be access through Moya, enforced by the compiler.
- Allow iterating through all potential API requests at runtime for API sanity checks.
- Keep track of inflight requests and don't support duplicates.

This might be useful to you, or it might not. I'm most interested in using test stubs and ReactiveCocoa with with my network requests and Moya looks promising in that regard.
 @powerje Thanks, I didn't find any examples yet to review how other people are taking to it for implementation. Alamofire has several simple ones. Point-4 above is important.
 :+1: on the tests

Interestingly this code:

```
let failureEndpointsClosure = { (target: GitHub, method: Moya.Method, parameters: [String: AnyObject]) -> Endpoint<GitHub> in
    return Endpoint<GitHub>(URL: url(target), sampleResponse: .Error(401, NSError()), method: method, parameters: parameters)
}
```

Sends through an NSError without a domain. This would be fine in Objective-C where I can check domain against nil, but:

```
if error.domain != nil {...}
```

fails to compile in Swift with the error: Cannot invoke '!=' with an argument list of type '(String, NilLiteralConvertible)'

The `domain` property is non-optional so accessing it at all causes a crash.

I'm not sure if we should ever expect actual NSError objects to come through without a domain and am thinking of just giving the NSError in the TestResources a proper domain, but I wanted to make sure domain-less NSErrors aren't something we plan on supporting (I don't think I've ever come across one in practice).
 I asked about this on another forum and John McCall (Apple Swift engineer) said this is an SDK issue - basically the empty initializer should be unavailable from Swift. So I'll go ahead and create a fully fleshed out NSError.
 I think we're all set! I used your test case verbatim (Quick looks awesome). Let me know if there's anything else that should be cleaned up here
  Warnings are bad, yo.
  Because it's shorter :grin: 
    This PR adds the image to the repository and updated the project file to reference that image.
  I recommend adding some specs to assert your expectations when this is used incorrectly.

In the past I would do this with Expecta's `.to.raise()`; I imagine that Quick/Nimble's [RaiseException](https://github.com/Quick/Quick#raiseexception) is similar.
  So you have user generated endpoints?
 Can you make the MoyaProvider generic and have it take an enum as a parameter? Then you can verify the endpoint definition take one of those enums and the request method take one of the enums. The user of the library would still need to associate each enum value with an endpoint... Not sure best way to do that. 
 You could do two sort of things, if I am understanding correctly. Have an enum that defines every endpoint, or pieces of an endpoint, which may be super huge, something like:

``` swift
enum EndpointPiece:String {
    case Base = "http://rdjpg.com/"
    case TwoHundred = "200/"
    case ThreeHundred = "300/"
    ....
}
```

And then have methods to concatenate them to form an actual endpoint. This may give you the closest thing to type safety.

Or you could have a protocol like so:

``` swift

protocol EndPoint {
    typealias E
    func endPoint(point:String) -> E
}
```

And then only take objects conforming to the `EndPoint` protocol, so endpoints would at least have to be constructed out of structs or objects, and not just defined as strings all over the place.
 A more correct protocol:

``` swift
protocol EndPoint {
    func endPoint() -> String
}

```
 ``` swift
struct Endpoint<T> {
    let URL: T
}

struct MoyaProvider<T: RawRepresentable> {
    let EndpointType: T.Type
    let endpoints: [Endpoint<T>]
    func request(URL: T) {
        println(URL.toRaw())
    }
}

enum RdJpg:String {
    case ThreeHundredByTwoHundred = "http://rdjpg.com/300/200/"
}

enum Foo:String {
    case Bar = "http://foo.com/bar"
    case Baz = "http://foo.com/baz"
}

let rdJpgEndpoint = Endpoint(URL: RdJpg.ThreeHundredByTwoHundred)
let fooEndpoint = Endpoint(URL: Foo.Bar)

// Valid providers
let rdJpgProvider = MoyaProvider(EndpointType: RdJpg.self, endpoints: [rdJpgEndpoint])
let fooProvider = MoyaProvider(EndpointType: Foo.self, endpoints: [fooEndpoint])

// Invalid providers
//let rdJpgProvider = MoyaProvider(EndpointType: RdJpg.self, endpoints: [fooEndpoint])
//let fooProvider = MoyaProvider(EndpointType: Foo.self, endpoints: [rdJpgEndpoint])

// Valid requests
rdJpgProvider.request(RdJpg.ThreeHundredByTwoHundred)
fooProvider.request(Foo.Bar)
fooProvider.request(Foo.Baz)

// Invalid requests
//rdJpgProvider.request(Foo.Bar)
//rdJpgProvider.request(Foo.Baz)
//fooProvider.request(RdJpg.ThreeHundredByTwoHundred)
```
 You could get better type safety by making the `enum`s conform to a protocol like this:

``` swift
protocol EndpointURL: RawRepresentable {
  class func fromRaw(raw: String) -> Self?
}

enum RdJpg:String, EndpointURL {
    case ThreeHundredByTwoHundred = "http://rdjpg.com/300/200/"
}
```
 Altogether now:

``` swift
protocol EndpointURL: RawRepresentable {
    class func fromRaw(raw: String) -> Self?
}

struct Endpoint<T> {
    let URL: T
}

struct MoyaProvider<T: EndpointURL> {
    let EndpointType: T.Type
    let endpoints: [Endpoint<T>]
    func request(URL: T) {
        println(URL.toRaw())
    }
}

enum RdJpg:String, EndpointURL {
    case ThreeHundredByTwoHundred = "http://rdjpg.com/300/200/"
}

enum Foo:String, EndpointURL {
    case Bar = "http://foo.com/bar"
    case Baz = "http://foo.com/baz"
}

let rdJpgEndpoint = Endpoint(URL: RdJpg.ThreeHundredByTwoHundred)
let fooEndpoint = Endpoint(URL: Foo.Bar)

// Valid providers
let rdJpgProvider = MoyaProvider(EndpointType: RdJpg.self, endpoints: [rdJpgEndpoint])
let fooProvider = MoyaProvider(EndpointType: Foo.self, endpoints: [fooEndpoint])

// Invalid providers
//let rdJpgProvider = MoyaProvider(EndpointType: RdJpg.self, endpoints: [fooEndpoint])
//let fooProvider = MoyaProvider(EndpointType: Foo.self, endpoints: [rdJpgEndpoint])

// Valid requests
rdJpgProvider.request(.ThreeHundredByTwoHundred)
fooProvider.request(.Bar)
fooProvider.request(.Baz)

// Invalid requests
//rdJpgProvider.request(Foo.Bar)
//rdJpgProvider.request(Foo.Baz)
//fooProvider.request(RdJpg.ThreeHundredByTwoHundred)
```
 Edited the above to reflect that type can be inferred for valid request parameters.
 Here is one possible solution:

``` Swift
// Defined in Moya:

protocol StringConvertible {
    func toString() -> String
}

class Endpoint<T: StringConvertible> {
    let baseURL: String
    let slug: T
    init(baseURL: String, slug: T) {
        self.baseURL = baseURL
        self.slug = slug
    }
    func fullURLString() -> String {
        return self.baseURL + self.slug.toString()
    }
}

// So a user of Moya can write:

enum Slug: String, StringConvertible {
    case DoTaskOne = "/do/task1"
    case DoTaskTwo = "/do/task2"
    // Unfortunately, the following method has to be
    // defined by all Moya users
    func toString() -> String {
        return self.toRaw()
    }
}

var endpoint = Endpoint<Slug>(baseURL: "http://example.com", slug: .DoTaskOne)
println(endpoint.fullURLString())
```
 Hey, looks like it's also possible to get rid of the toString() requirement:

```
// Defined in Moya
protocol StringBackedEnum {
    func toRaw() -> String
}
```

and then:

```
// Code using Moya
enum Slug: String, StringBackedEnum {
    case DoTaskOne = "/do/task1"
    case DoTaskTwo = "/do/task2"
}
```

Personally, I like the StringConvertible way better, because the API contract is clearer there, methinks.
