  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.

If you have received this in error or have any questions, please contact us at cla@fb.com. Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.

If you have received this in error or have any questions, please contact us at cla@fb.com. Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.

If you have received this in error or have any questions, please contact us at cla@fb.com. Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Could you explain more the issue this is solving? isPlainObject should be returning false for deep prototype chains, correct?

Also, could you include performance measurements for this change? This function is called quite a lot and is a potential performance bottleneck for the library Thanks, @jinalkathiara.

I updated your perf test here: https://jsperf.com/check-performance-for-prototype-checking/5 - unfortunately yours included console.log which is very slow and warped the test results.

As you can see, this change makes this function 100x slower, which is not going to be acceptable since it's one of the most often called functions within the library.

Could you talk more about the use case you're trying to enable? Perhaps there's a way to accomplish it without the library-wide performance penalty  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.

If you have received this in error or have any questions, please contact us at cla@fb.com. Thanks!  Yikes. That's not good. I'm not sure what the issue is, but very open to suggestions or PRs to fix this. 

Does anyone know what changed in this point release?  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need the corporate CLA signed.

If you have received this in error or have any questions, please contact us at cla@fb.com. Thanks! Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you, @liubinyi for improving the docs! LGTM =)   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Looks legit to me. Thank you @icopp for fixing!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you @wdhorton for fixing it! =)   Looks legit to me! Thank you @anilreddykatta for fixing it! @leebyron, is it ok if I merge it? =)  I see, it happens if `bundle.js` not yet loaded and one of the links are clicked.
However, I am pretty sure at the time it happened to me, my Internet connection was good. Perhaps something happened on server s.t. `bundle.js` was not returned to me.

Yes, as @jayjaycross mentioned, this problem may apparent on those having bad Internet connection (9-10 seconds to download `bundle.js`). Since the page is apparently server rendered, visitors may clicks any of the links (and encounter error) within those periods.  Thank you for reporting @xaviergonz! Closing it since it is a duplicate of #1183   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  Thank you for improving tests @jokester =) Looks legit to me!  @leebyron, are you agree with this approach? =)  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions.  Sounds legit! Please go ahead and submit pull request. I will review it =)   Looks legit to me! Thank you @philipp-spiess for fixing it! Going to merge it right now. Sorry for delay!   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Thanks!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Thank you @garrettm for adding test! It can be merged when the fix will be ready  =)  The same issue affects TypeScript. I'm not sure how to improve this but would love some help.  Thanks for the report!  Thanks for the report!  This adds strictNullChecks to the ts tests, and improves type definitions such that all tests pass. Specifically this adds two significant changes to typescript defs:

* `size` is now correctly typed to not belong on Collection, exist in a nullable way on `Seq`, and exist in a non-nullable way on all concrete collection types (List, Map, etc)
* `zip` and `zipWith` is overridden in all subtypes such that the return type is more correct.

Fixes #1158  What version of immutable.js? Could you show me what code you're writing to get this issue? I can't reproduce. What I'm running:

```
mkdir test-project
cd test-project
npm init -y
npm install -SE immutable@rc
node
> isImmutable = require('immutable').isImmutable // namespace export
[Function: isImmutable]
> isImmutable = require('immutable').default.isImmutable // default export
[Function: isImmutable]
``` Note that exporting these functions from the top level is new as of v4.0, so they'll only exist in the RC. Perhaps double check which version you're using?  What version of immutable are you using? The docs have been updated for the 4.0RC Merging into #1167   Very nice! Thanks :)  LGTM =) Thank you a lot!  Immutable.js doesn't support subclassing of Maps, Lists, and other collection types. The type constructors are functions (they don't need be called with `new`). The TS declarations are correct, the flow definitions are incorrect in this particular way but using the class definition made other desirable behaviors work with the flow checker.

Records can be sub-classed as a means of adding additional methods to the prototype, however subclasses cannot add new fields to the Record store and cannot perform work in a constructor (since every "mutation" results in the construction of a new Record). I typically recommend against subclassing Records and instead favor general purpose functions which accept the records as arguments - this approach is easier to type check, easier to scale in a codebase, and is more performant at runtime. Part of the confusion is the source text which was written before ES6/ES2015 was finished. It is using a non-compliant class transform which converts back to a prototypal function constructor  This is an intentional breaking change to bring `getIn` and `setIn` into alignment. Bug's resulting from the silent return of `null` for this case were a common complaint from the previous major version.

The reason this fails is because there is a value at `"a"` however that value is not a container and doesn't allow deeper retrieval. This is usually indicative of a mistake, expecting the value at `"a"` to be a collection if it exists.

Note if you change the test code to:

```js
const ABRecord = Immutable.Record({ a: null })
const myRecord = new ABRecord()
console.log(myRecord.getIn(['a', 'b']));
```

That you'll see `null` logged. Ah interesting! I'll definitely make sure there's more tests and clear language around this  Reopening as a reminder to myself to dig in  Thanks for the report. Does this only occur when used with the `uuid` library, or will this also work for a simpler test case? Also could you please let me know what version of the library you're using  Oh thanks! could you please run `npm test` and amend to the PR? That will generate the right distribution files which will make Travis pass LGTM =) Thank you!  Thanks for the report. Just to confirm: RC1 worked as expected with strictNullChecks enabled, and RC2 works only when strictNullChecks is disabled? Thanks for working on a PR!

It depends what that change applies to - for collections like List, Map, etc, size will never be undefined, however Seq (and therefore also Collection as a superclass) may have an undefined size. I think the fix will require removing `size` from `Collection` and then manually adding it to every concrete data type: List, Map, Set, OrderedMap, OrderedSet, Stack as `readonly size: number` Ok thanks for the update on your progress. I'm sure this is fixable.   This adds back the delete() and clear() methods to Record instances that set values back to the default values, in the process improving the equals() and hashCode() implementations.  This expands the type def of filter() to return a type-limited version of the original type.

Fixes #1152  Unfortunately in the previous version the any was *implicit*, so no type checking was occurring at all for Records. In v4 extending Records in a class requires an explicit cast.

I spent some time trying to get Records as soundly typed as possible, but would appreciate help from anyone who can find a way to support this case  Wouldn't this PR also result in problems? I would expect an error like: "Collection<string, C> is not assignable to type List<C>" - Returning a different type would probably mean replicating this change across all types much like `map<M>`

Looking into TypeScript's own lib, it seems like https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts#L1097 might be leveragable. #1146 Also mentions a desire for a sounder filter function - I was wrong to suggest TypeScript couldn't do that, but it seems Flow cannot yet. I just put up #1155 which includes a type-checked test that seems to be working just fine without requiring much specific annotation, the test before the changes to the type definitions failed with the same "Type 'List<A>' is not assignable to type 'List<C>'." error you were seeing before I think the trick was to put the version using guards before the version that does not, since TypeScript attempts to apply each override in the order they were defined.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Great suggestion. In fact I think we can get even more specific than this, similar to how the `map()` method gets specific definitions for each type.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Thanks!  These references are actually now referencing the JavaScript [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) interface! - Because I see errors also mentioning `Iterator` and `Symbol`, I'm guessing that you don't have `--target es6` in use with your typescript project, adding that should resolve these errors.

I'll look into how I might be able to support typescript without this option enabled After digging into this a bit and discussing on Twitter (https://twitter.com/leeb/status/840705430498103297) it seems like there's no way around this without requiring those using Immutable.js & TypeScript together to include either `--target es2015` or `--lib es2015` in their projects. This is the same solution the Angular community recommends. Added to the Readme and website You can also specifically turn on es2015.symbols.wellknown I think for a limited expansion of types  I'd love to support this in a general way, but as far as I know Flow and Typescript don't support lifting a predicate function onto a collection like this. As soon as they add support, then your function as written would pick up that knowledge.

Until then I recommend a type cast or utility function as you're using today.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! :facepalm:  I think this might be too invasive. I find that git hooks can be more burdensome than helpful and what we really want is "pre merge" hooks where travis fills in. I'm going to close this PR - feel free to open it again if you would like to continue discussion on it  Definitely interesting - I like the idea of using predefined tuples for `setIn` type safety.

The master branch contains some pretty dramatic improvements to Record vs what's currently on npm (to be released very soon), so start from those if you're working on concrete improvements, otherwise please feel free to test and submit pull requests when you have this working!  Thanks for this - I've been meaning to add this forever.  Slick!  As suggested in https://github.com/facebook/immutable-js/pull/1035#discussion_r105333309  Ah yes thanks this documentation note is long overdue to be removed. 

There are actually plenty of object types that have toString() methods that make for reasonable strings as well, so I agree that it shouldn't throw.  So good! Thanks for the rapid fire release  Thanks for fixing :)  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thanks for digging into this. 

Our documentation lives in type-definitions/immutable.d.ts and is the source from which all other documentation is generated. I'd prefer not to create duplicate efforts for full documentation  I'm going to close this PR - but feel free to re-open or opening a new PR if you are interested in moving some of this additional documentation to the documentation source of truth. See #1144 for an example of editing those files.  Unfortunately there is a lot of code out there, including built into the JavaScript core and in browsers that assumes if value.length is a number that it's safe to use value[1] style indexing, which only works on Arrays and not custom data structures. 

If List were to expose a length property then a lot of existing code would break. Note that the native Map and Set collections also expose value.size for the same reasons  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! There's a bit too much happening in this PR. do you mind separating out the stuff unrelated to package.json dependencies and yarn.lock? Specifically the ts-jest changes are controversial and reduce test coverage, so I'd like to discuss those in isolation  It's pretty common for us to use the `arguments` object but leave a comment to explain what the arguments represent. Prettier screws those up.

Desired:

```js
static of (/*...values*/) {
```

Produced:

```js
static of /*...values*/() {
```

This was introduced to the codebase in #1123 and hopefully when fixed (https://github.com/prettier/prettier/issues/882 ?) will require a manual pass to cleanup. Sweet!  Applied to all files  Fixes #489  Yes - a new version is on its way soon  I'm glad you brought it up. There are reasons for a lot of this, but I agree that improvements can be made. Also - huge thanks for focusing on the kind of issues that make it easier for others to contribute, that's a great philosophy for contribution.

First of all, I think an obvious win is just to bump up the version of Jest being used to ensure the project is running on the latest. That should help with VSCode and other IDE integration.

Unit tests are written mostly in typescript because it's a two-in-one test, we're also ensuring the type definitions are correct. I recently made a change to the jest runner script to ensure no caching occurs, which ensures that typescript tests get static type checked before runtime tests run.

I think it's important to maintain the tests as typescript when possible, and use plain JS tests only when explicitly testing something outside of the typescript coverage - it ensures we get good coverage.

You may notice some tests actually cast through any in cases where it's testing error behavior, one thing I would like to see improved is something similar to the flow type tests where comments can be inserted where static type check errors are *expected*. That's been hugely helpful in testing the quality of the flow type tests. Since the jestPreProcessor is programmatically running those type tests, I don't think that would be too difficult to achieve.

For running tests against src/ instead of dist/, that gets tricky. It's dependent on another task #1044 to ensure the type definition files align with the source files. It also depends on a fairly major refactoring to actually ensure the src/ is valid ES2015 code - it was written before ES2015 was finalized and contains many quirks that now wouldn't run as written. There's still a good quality about testing the code you expect to distribute rather than the source code itself (ie. for compiled code, tests run against the compiled binary). One improvement that can be made more immediately is a continuous incremental build and test repl, that way the moment you save a file you have the relevant test results in a few seconds. I know the latest version of Jest added a repl, but some additional work may be necessary to get it integrated with the build step. Sorry I think I wasn't very clear on the flow type tests that led to your last action item there. 

What I meant was that the existing flow type tests have a `// $ExpectError` feature that's very useful for test writing and that feature would be a valuable addition to the existing typescript tests.  Does eslint have a typescript compiler plugin? That would be a great way to unify them if possible Very cool that looks like just what we need  This makes a few important changes:

* Existing errors for bad key paths have been improved to explain why and where the issue is.
* Previously strings were converted into an array of characters key path, a constant source of confusion. After this PR providing strings will throw an error.
* Previously anything iterable was allowed, but now only Arrays and Ordered Iterables, otherwise an error is thrown. This avoids a rare pitfall where Sets are used as a path, which have undefined iteration order.
* Adds a new thrown error for getIn()/hasIn() if a key path encounters a value which cannot be read with get(). Previously notSetValue was returned.

Fixes #635
Fixes #940
Fixes #451  Fixes #992
Closes #876 As far as I can tell yes, though if you're able to squeeze out any improvements that I missed, send a PR!  Can you share what version of the library you're using and also if this memory performance hit is still visible when using the latest build in the master branch? I just swapped out the js version for the master build: https://rawgit.com/facebook/immutable-js/master/dist/immutable.min.js and see this:

<img width="692" alt="screenshot 2017-03-07 12 16 37" src="https://cloud.githubusercontent.com/assets/50130/23676029/21a3412e-0330-11e7-9bdb-90f09caf3f63.png">

That looks like the immutable copy is about 38% larger, certainly better than 10x :) Closing this issue just for queue management, but feel free to reopen if there's more to discuss or more discovered  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Manually merged in a2c4c741d9e552d4e2bc88d187970f315e2a0bda

Great work!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! This is awesome, nice work I'd rather not include all the warnings - from past usage I've found warnings get ignored and just pile up over time. I think the eslintrc should either turn things off or make them errors with no need for a "lint:warn" npm script

Some examples of rules that are broken pervasively in this codebase and are safe to turn off:

- vars-on-top
- no-var
- consistent-return
- no-param-reassign  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Sweeeet  These two functions warrant a variant for when the number of sets to be dealt with are unknown, with empty-set special cases.

Closes #415  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Hey @umidbekkarimov thanks for digging into this!

#742 is a master task for modernification, it's important for each actual change to be focused and incremental. Could you separate this into separate pull requests?  Unfortunately there's nothing like that today - but you could certainly try to build it!

When doing something like that along with Immutable.js, you would need to reach into the implementation details of the data structures to have access to node sharing.

If you want to get a string representation of the  *whole* collection, you can just use `JSON.stringify()` to get a JSON representation  Sorry about this. The documentation site is produced from master branch, and this change happened very recently and has not yet been released on npm. After the next release this function will be available  This is actually a feature! `Seq` is a lazy collection and does not produce intermediate representations. Because of this, the order in which data is read results in the order in which the prior functions are called. Since the Sequence was reversed twice before being consumed, it is consumed in it's original order. If it's important that intermediate transforms like `map()` are called in a particular order, you'll need to ensure you convert the lazy Seq back into a real data structure (like an array) before calling it. Intermediate representations in this context refers to an actual data structure which holds the results of the previous operation. For example, if you use `Array` instead of `Seq` and call the same sequence of operations, you'll produce new intermediate representation Array data structures after each operation which will culminate in a final data structure. With `Seq` there are no intermediate representations, and what you say is correct that `Seq` is essentially planning a sequence of operations which is only executed lazily when necessary.

For example, consider this similar example which uses `reverse()` and `map()` but rather than calling `toArray()`, just accesses a single value with `get(2)`:

```js
const s = ['A', 'B', 'C'];
const result = Immutable.Seq(s)
  .reverse()
  .map(ch => (console.log(ch), ch.toLowerCase()))
  .reverse()
  .get(2);
// console.log: 'C'
// result: 'c'
```

Because `Seq` is lazy, the `map()` operation only applies to the one value requested, so `console.log` is only called once. Similar code with eager `Array` would console.log all three values.

This might illuminate what's happening when we "reify" the lazy sequence into a real data structure. `toArray()` is essentially calling `get(0)`, `get(1)`,  ... `get(seq.length - 1)` to produce all the items in the returned `Array` data structure, each access triggering only the transformation operations necessary to produce that specific value, and in aggregate triggering all those necessary to produce and return the `Array`. Because `reverse()` was called twice, `get(0)` refers to the first value in the original sequence, and so `map()` is triggered for that first value first, rather than the first value last.

Consider another example to illustrate why it's not possible for a lazy sequence to run these transforms in an order other than the final one requested without intermediate representations:

```js
const s = ['A', 'B', 'C'];
const result = Immutable.Seq(s)
  .reverse()
  .map(ch => (console.log('first:', ch), ch.toLowerCase()))
  .reverse()
  .map(ch => (console.log('second:', ch), ch + ch))
  .toArray();
```

Based on your original expectations, we might expect this one to log the "first:" three in reverse order, and the "second:" three in forward order. However because we're accessing the data only once in the end we can't be iterating *both* forward and backwards at the same time! A direction has to be chosen, and that direction is the final iteration direction of the sequence.  I would strongly recommend against using value based equality checking (`Immutable.is(a, b)`) within shouldComponentUpdate and instead use reference identity based equality checking (`a === b`). 

That's because you're doing a expensive computation (equality check) to determine if you can skip doing a expensive computation (re-render). If the equality check is slow itself, then you haven't really gained anything. However reference identity is extremely cheap and is perfectly suited for use in `shouldComponentUpdate` when using with React. Depending on how you update your data structure over time, false-positive re-renders will occur but should be rare.

The issue with computing Merkel-style hashes per node when doing equality checking is that you may convert a one-pass equality algorithm into a two-pass equality algorithm, first computing and comparing hashes, and then if equal comparing data structures as well to avoid collisions. An important difference from a Merkel-tree is that Immutable data structures are designed to live in memory and operate efficiently for general purpose use, so they do not use cryptographically secure hashes.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Stuck on #1074  Thanks! Unfortunately I had to revert this in aeb9aa4f3f9fc374a08ec8d9695ed0dfd2a72cba since it's still breaking tests. Also, this PR seems to have only altered the compiled files and not the original sources, so other tests weren't triggered.  Unfortunately I will still suggest that we do not do this.

Every method added has cost: more bytes for a compiled Immutable.js bundle means longer to download. More code means longer startup time in a browser or vm. And cognitive load is important to consider as well. Already one of Immutable.js's common complaints is that the API is relatively large and can take some effort to learn. Adding more methods makes this problem worse.

We only want to add methods when they add a unique capability that aligns to the goal of the library (programming with immutable data) and are non-trivial to implement (methods which take advantage of the inner workings of the data structures). Unfortunately `mean` and `sum` really do not meet these criteria. Honestly I believe it was a mistake on my part to have allowed `min` and `max` to be added as well, and could consider removing them in a future major release.

Immutable.js collections all implement the ES2015 Iterable protocol which was an intentional decision to make it easier to build general purpose versions of the types of methods you're suggesting. Then they could benefit from 1) not being bundled directly with Immutable.js and 2) work equally well with Immutable.js and native collections.

For example, here's an implementation of `sum` that you can use today, put on npm, or do whatever you like with. It will work with any collection that is Iterable, including native and Immutable.js collections:

```js
function sum(iterable) {
  let total = 0
  for (let value of iterable) {
    total += Number(value)
  }
  return total
}
```  This is actually a bug in the documentation generator, not a bug in the type definitions. This is a user defined type guard function:

https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards I just opened an issue for this at #1068 but would still appreciate help in fixing the doc generator!  This is an edge case to how `update` works with identity functions and default values.

See documentation discussion: http://facebook.github.io/immutable-js/docs/#/Map/updateIn

> If the updater function returns the same value it was called with, then no change will occur. This is still true if notSetValue is provided.

@tolmasky thanks for investigating, I added some additional tests for this case and unfortunately I think the changes you made would have broken them. Specifically, that first line you reference is handling the identity function case, and the second line - `NOT_SET` implies the value doesn't exist anymore, so actually `notSetValue` should be used there instead of `this`. I agree this corner isn't a great one. I'm hoping to improve it in a future major version. In the meantime these are great documentation suggestions  My only concern is growing the scope of the library. Maybe types aren't really about immutable data. I would prefer there to be a really good stand-alone library that provided Maybe/Either, but if there is some interoperability concern that building into the library directly would solve, I'd love to hear it.

What sort of interoperability are you thinking about? I'm going to close this issue - I believe Maybe/Either/Option is a really cool construct, but I'd love to see such a thing take off as a general use library outside of this one first. Then if interoperability opportunities arise we can take those on in more detail.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! Thanks!  Thanks for investigating this. Ideally we could find a more performant implementation. ~1/2 as fast is a very high cost for this edge case @simonkberg yes however there are many cases where `isPlainObject()` is handling the uncommon case and it will be very common for non-plain-objects to fall through and hit the slow path.

@augusto-moura milliseconds matter in aggregate! This function is one called very frequently, so I don't think a 25x slowdown will be acceptable. We need to find another approach with a less punishing performance cost. @leebyron , it looks like you fixed it by this commit recently:
https://github.com/facebook/immutable-js/commit/2bff0cf0c13e6ec9f2bbfe2c48aec3740d4f552e

So, now there is no need for this PR  I don't think that rev will fix this particular issue. Objects with custom or other-realm prototypes still are not converted   `Map` typically takes two type arguments, the type of the keys and the type of the values: `Map<KeyType, ValueType>`, however since it's really common to use strings as keys, `Map<ValueType>` is also allowed, the type argument `ValueType` refers to what type you expect every value in the Map to be. Your example likely doesn't type check, but what would type check is:

```js
interface SomeInterface {
  prop: any
}

const map = Immutable.Map<SomeInterface>({
 someKey: { prop: 'hi' },
 someOtherKey: { prop: 'hello' }
})
```

A key detail is that `Map`, much like `Array`, is a *collection* type where every value in the collection is expected to be the same type. If you are looking for each value to be a different type depending on the key, you might be interested in `Immutable.Record`  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!  No problem. It's just a new feature to flow and hasn't made it's way to immutable type definitions yet.

This would be a great task for anyone looking to contribute.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! I think the error with `set` still makes sense. It protects against misuse. The desire to have merge behave similarly to constructor makes sense. It would be great to limit this change to merge. >  Why protect against misuse on set and merge but not on constructor and remove ?

I think `set` and `remove` should have similar behavior and `merge` and `constructor` should have similar behavior.

Specifically, I think it's appropriate for errors to be thrown for misuse of `set` or `remove` because they're indicative of mistaken usage. `record.set('unknownkey', 'value')` would be a no-op and typos would be likely to blame for a difficult to debug issues. However I agree `merge` should work similarly to the constructor and allow for applying a merged set that may contain more keys than the record itself does. Thinking about this more, I think making a breaking change to `remove` by adding throwing behavior could be inappropriate for the next immediate release and so perhaps dropping the error behavior is a reasonable backup plan - and ideally we can use type checking systems like typescript and flow to detect the sort of accidental misuse of set and remove.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! https all the things!  Thanks for the report! Same issue with `skipLast(0)`  Yeah this would be great to have, but it's not easy to implement incrementally - some breaking changes would be necessary.

Specifically right now all types have a `toList()` and `toMap()` etc methods which convert between various collection types. That ties all of the library together and tree shaking typically isn't smart enough to trim prototype methods as well. A breaking major version change would be necessary to remove these methods to enable tree shaking.

However I don't actually think you would shave much from the ~15kb build already. That's roughly split into thirds: Map, List, and everything else. Merging into #317  Fixed in the next upcoming version!  Closing this issue since there's isn't actionable information here. If you can provide a reproducible issue, then please feel free to reopen the issue.  I agree with you about the utility of this. I'll merge this for now, but we certainly should consider a separate module in the future I'd prefer not to rely on 3rd party dependencies - I'll likely consider setting up a multi-package distribution in the future that allows subsets of Immutable to be used in isolation I plan on getting to another release sometime before 2019. 

Just kidding, I'm cooking up a new release in the next few days  For sure. #1056 is one attempt, however it has some punishing performance qualities.

I'm open to more exploration on this topic  Thanks :)  @Carlsson87 thank you for PR! ðŸ¥‡   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! The next issue this is exposing is with generating the documentation. I've worked in a solution and will merge manually.  Coming very soon!  Unfortunately this is a consequence of the current implementation of `Record`. Using the collections higher-order API on them can lead to unexpected results.

Fixing this requires some rather dramatic changes to the implementation of `Record` and will require a major version bump of the library, so unfortunately for now there isn't much that can be done.  Thanks for the fix!  Map is not a type. It's a class as you can see [here](https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow#L489). For more info about `import type...` see [here](https://flowtype.org/blog/2015/02/18/Import-Types.html).  Thanks for answering @philpl. The key detail here is that javascript object keys are always strings, even if the characters in the strings look like numbers, and a numeric key and a string key that has the same numeric characters as the number aren't the same.  Closing since that rev got merged  Thanks for the report. The docs are out of date with the implementation which was updated to match the behavior of [Array#reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)  Good job. I think it's good to merge when there are tests for false positives (`$ExpectError`) Out of curiosity - what do you exactly mean by laxer? 

They are verbose, it's true. I don't have any experience with TS so I cannot compare. `immutable` is a bit special case because of generics and inheritance hierarchy. Great job. The only remaining issue are the `mergeWith` methods. Do you want to fix them here or should I or you create an issue for it? Other than that - thanks for helping all of us with this contribution.  @lacker I think it's good to merge.
@howardjing great job. Thanks for being so precise. Sorry for the nitpicking!  In the meantime, `Seq.Keyed()` will not expect array-likes.  Could you try the following:
1. Add `https://github.com/facebook/immutable-js.git` as your upstream.
2. Rebase your changes on top of master branch in the upstream
3. Build dist
4. Push it here

It fails because your changes are applied on top of an old commit.
<img width="467" alt="zrzut ekranu 2016-12-20 o 21 13 37" src="https://cloud.githubusercontent.com/assets/1693190/21366258/3d520de2-c6f9-11e6-973e-4aa7dba1c286.png">
 Looks good to me.

@lacker please verify and :shipit: .  Great answer by @philpl   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions. Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks! This does look helpful. Thanks!  It would be neat if you could run the docs locally, and then take a before & after screen shot so it's clear what happened. I think https://github.com/facebook/immutable-js/blob/master/gulpfile.js has the stuff to run the docs, maybe just running `gulp dev` works to see that. Hey @flarnie thanks for digging into this!

In order to run locally, make sure you have `gulp` installed then run `gulp dev`.

I noticed in your screenshots that the text shadow is still quite dark, which makes the text fuzzy and harder to read.

I originally put the shadow on the white text to increase contrast against the "immutable blue" header color, which gives an appropriate 3:1 contrast ratio for the typical case.

Perhaps we could do the opposite for boosting contrast? Instead of making the text gray and lightening the blue, we could instead make the splash screen background a slightly darker gray or give a slightly darker shadow on the white link text. Ideally we could make that shadow darker specifically for the gray wash case without much disruption to the blue background case I just added a commit which boosts contrast by deepening the shadows around those links and darkening the background  I think it's a feature. 
`List.findIndex` works like `indexOf` in `Array`
Using negative indices for getting values has been implemented in #116.

You should probably check if `findIndex` returns a negative value before passing it to `List.get` It's understandable since docs don't mention it. It would be great to get a pull request improving the docs to mention this! For this particular bug report though I think we should close as "working as intended". Thanks for bringing this up!  Arrow functions do not capture `this`.

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions  Great answer by @philpl 

Returning the same reference for "no-ops" is a performance optimization and so only occurs in cases where it can be done performantly.

One work around is the following:

```js
x.merge(y.merge(z))
```  I *think* it's impossible to express with `flow` now. I added an [issue](https://github.com/facebook/flow/issues/2959).

---

Sorry, I wasn't clear. It is possible to express but it requires duplication of definitions. `Map` is typed correctly because the definitions are copied from its superclass and the types are tweaked to `Map` from the superclass.  `toJS` will convert deeply - you can check out some examples in the `__tests__` directory for illustration. Note that `immutableList[0]` indexing does not work with Immutable collections. You must use `.get()` and `.set()` instead.

Also, `toJS` converts as deeply as it can before encountering something it does not know how to convert. For example your code is using JS classes which are not immutable collections. My guess is that upon encountering an instance of `Immutable2` which is a general JS class and not an Immutable collection, `toJS` believes that it has converted as far as it can  Not dead! Immutable.js is still used heavily both within Facebook and in the broader dev community. However right now maintenance has slowed. I've been working on some strategies to get more attention to continued maintenance but the focus needs to be on refinements and bug fixes - most issues ask questions and PRs attempt to add new features which deserve their own libraries.

I'll hopefully have more to update soon.  Yeah we don't really advertise this much, and I'm not sure negative indices will stick around for future major versions since it breaks with native indexed collections and can be buggy along with indexOf so I'm not keen on starting to encourage usage now.  Sorry I can't reproduce your issue without runnable code and expected/actual results.

Remember that sort functions return numbers not booleans:

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort  This is expected albeit confusing behavior by JavaScript. 

The issue is:

```
{
  11: {
      name: 'some error'
  }
}
```

This looks like `11` would be a number property on Object, but Objects can *only* have string properties, so JavaScript first converts `11` to `"11"` and then sets a property with a string that happens to have numeric characters.

Collection types like the ones Immutable.js provides (and the native Map and Set collections) allow for all kinds of types as keys or entries, not just strings.

You can use Map with numeric keys, but you just can't create it from a javascript object which itself enforces string keys, instead would have to use a sequence of [k,v] tuples. For example:

```js
Map([ 
  [ 11, Map({ 
    name: 'some error'
  }) ] 
])
```  `shallowEqual` relies on `===` for each value in `props` to determine equality. Two value-equal immutable collections are not necessarily `===` for the same reason two arrays with the same items won't be `===`.

However Immutable collections typically attempt to return themselves whenever an operation results in a no-op, that means that `===` can often be used alongside Immutable collections, but if you're constructing two collections independently and comparing them with `===` will always yield `false`.  I'd love to do this - I think tactically there are a few things we need to do to enable this.

First is to nominate some volunteers - anyone who has a good understanding of the library and it's mission and wants to contribute to maintenance. I'm open to suggestions.

Second is to bias towards creating an ecosystem around immutable-js. I know there are a lot of requested features, and I think the best case scenario is that we encourage a small-library ecosystem around a set of shared patterns and interfaces. That enables a marketplace of ideas and removes myself, Facebook, or any other maintainers from the path of innovation.
 Hey @linusnorton - sorry for not following up on this discussion sooner.

> Could you clarify your idea of the ecosystem?

Ideally installing immutable.js gives you a small set of core functionality, and you can use other npm modules for additional behavior - that way we can allow for anyone to release ideas that work well with immutable.js. I think it would be a failure if the only way new ideas and features can be introduced is if they have to all be added to this library in particular.

> Are you proposing something like extensions to keep the core small and focused? It sounds like a good idea to me. I think this is a very feature stable library and the core of it should stay that way.

Yes, 100% agreed. In my mind, the answer to most feature requests should not be to evaluate the feature itself but instead evaluate if there is a missing extension point that's in line with the library's intended use.

> Deciding the governance model will be important. Assuming people do step forward we'll need some agreement on how decisions are made so that it doesn't all fall on your shoulders, but also doesn't go away from your original vision entirely.

I agree this is important, but also something I'm a bit stumped on accomplishing. I'm open to ideas but right now my thought is to introduce more co-workers who are using Immutable.js at Facebook to help maintain, and then slowly adding trusted contributors from the community at large if necessary.

Overall though, this library intentionally moves slowly and there aren't many decisions to make. The goal is to bias heavily towards stability - so doc clarity, bug fixes, and perf improvements are valuable, but altering the feature set is less valuable. I think this approach shouldn't require a huge amount of effort in governance. Totally agree. In fact you should see some folks helping drive down the issues. The gracious @lacker is already making a dent!

 In the spirit of that, I'm going to close this issue as well. 

I'll try to get a reviewathon scheduled sometime soon to help press down the outstanding PRs. We'll go from there This reviewathon could really use some Typescript & Flow expertise - my first learning after going through a chunk of pull request and issues is what a large % of the issues are actually just updates to the type definitions.  Yes, checkout `zip` http://facebook.github.io/immutable-js/docs/#/List/zip Right to get a hashmap output, just wrap with Map:

Map(keys.zip(vals))  Merged, will be in the next release  Immutable collections allow for any kind of value as a key, not just strings. Your application may expect the proper way is to use strings, but other applications use these collections in other ways. It would be inappropriate to limit the usefulness of the library.

However `toJS()` only works as expected when you are using keys which convert to strings soundly. It sounds like part of the issue is that you are relying on `toJS` and converting Arrays to strings results in comma separated values of their children.

I strongly suggest using Flow or Typescript to catch these sorts of mistakes.  Any Object that has a prototype Immutable.js assumes isn't a candidate for conversion to Map/List. If you want to explicitly convert them, you can wrap them in the type you want:

```js
const obj = fromJS({
  child1: Map(yourCustomClassInstance),
  child2: []
})  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!

**If you are contributing on behalf of someone else (eg your employer)**: the individual CLA is not sufficient - use https://developers.facebook.com/opensource/cla?type=company instead. Contact cla@fb.com if you have any questions.
  Will be fixed in the upcoming release  The size member should not be mutable - I'll be adding a change to the typescript types to make that more clear. Unfortunately JavaScript does not provide many facilities for protecting readonly members in a performant way and performance is paramount in this library  I think this pull request has essentially timed out. If you are still paying attention, I was going to request some sort of test to ensure that this is working properly, but my guess is that this is abandoned. I am going to close it but if someone still actively wants to deal with this then please feel free to reopen it! Hey, I'm glad to hear that this is not abandoned! Sorry for closing this, I'll reopen it. Check out https://github.com/facebook/immutable-js/tree/master/type-definitions/tests - when you run `npm test` it sub-runs `npm type-check` which does a flow check on that directory, so if you add some code that exercises this particular type it'll ensure the type checks are correct. You didn't miss them, they got merged in pretty recently ;-)  Sorry, without code that I can run locally I can't reproduce your problem  Closing this aging issue.

I'd like to avoid relying on `toJS` any more since it's a performance pitfall. Pro tip if you're doing lots of accessing, `getIn` can help access a chain of keys  Closing this aging issue.

I'd like to avoid an ever-growing prototype of methods. Since the implementation for this is quite small, it looks like it would be a reasonable function in your application instead of in the data structure library  Looks like this PR has been failing tests for the past year so I am closing it.  Thank you for your pull request.  As you may know, we require contributors to sign our Contributor License Agreement, and we don't seem to have you on file and listed as active anymore.  In order for us to review and merge your code, please email cla@fb.com with your details so we can update your status.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 `compareWith` seems like a problematic thing to expose because it works indirectly, it's like it just operates with side effects. At least if I understand it properly. Also maybe this just timed out at this point. I am going to close this pull request but let me know if you think there is still something we should do here. It seems like the right way to do this would be to create a collection with a custom comparator - that's how most languages handle this sort of data structure. Then it's per-collection rather than using `compareWith` impurely.  Fixed in master will be released soon!  Sorry for the long delay. Closing this aging issue, so I hope you figured it out.

Prototype methods need to use `function () {}` instead of arrows in order to refer to the class instance as `this`.  Thank you for your pull request.  As you may know, we require contributors to sign our Contributor License Agreement, and we don't seem to have you on file and listed as active anymore.  In order for us to review and merge your code, please email cla@fb.com with your details so we can update your status.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Dead? Pshhh. It's not like we let this pull request sit for 15 months without responding.

Anyway my guess is that this has been abandoned. I was gonna ask for some sort of test if this was still alive, but I'm just gonna drop it. Sorry for letting this be quiet for so long :P and if you want to keep working on this please feel free to reopen! hey, thanks for bringing it back. I didn't mean to insult you. I just didn't see too much activity on any pull request at that time. Anyway, if you want a flow definition here (vs having one in `flow-typed`) I am more than happy to maintain it. What's the "standard thing to do" around having a flow definition here vs in flow-typed? We should have a correct flow-typing as opposed to an incorrect one but I don't particularly have a stance on where it should go. Probably here? So I think it is awesome if you could help maintain this - so here's a question - do you think it makes sense when people submit a change to the flowtypes, to ask for a test that exercises the new type? I just want to make sure that we are protecting against stuff breaking as we improve things. In my opinion it's better when definitions are in the repo. For obvious reasons - it becomes immediately available to everyone who uses it. I'll ask in [this PR](https://github.com/flowtype/flow-typed/pull/401#issuecomment-264533899) for their point of view on it.

We might put it here for now and we will see how it evolves.

When it comes to testing, yes, I do think that tests are necessary. And tests are implemented [here](https://github.com/facebook/immutable-js/pull/878). I just need to make `flow` run on travis so that it's automated. Sorry that I spammed across few PRs to move people's work to my PR in `flow-typed` but I didn't know when and if our work here will ever be merged. Yeah I understand, it's cool that you were spamming your alternative, I feel your pain man. But now that I am paying attention I would like the immutable.js repo to be all nice and things. I could really use your help reviewing Flow stuff though since I'm sort of a Flow noob myself. So what do you think we should do for this pull request - just accept it, or ask for some extra test type stuff, or what? I think that the order should be the following:

1. Decide on the blessed way to [import](https://github.com/facebook/immutable-js/issues/863) things
2. Merge my PR I mentioned above which actually contains tests. It also needs some work but I can do it over the weekend.
3. Further improvements like this one

---

`flow-typed` makes a lot of sense because of versioning (separate versioning for flow versions and module versions). Also [testing if the definitions actually make sense](https://github.com/flowtype/flow-typed/issues/100) is a thing to look forward to. However for now, I'd like the "correct" definition to be anywhere and we can proceed with further improvements in the future. I made the tests run on travis in #878  OK so https://github.com/facebook/immutable-js/pull/878 is in now so we have some Flow type refactorings and also you can now test flow types. Would you mind updating to merge those changes in, and also adding a test that catches these changes? Thanks! I'm a bit confused. The diff shows that my changes are reapplied. Could you rebase the PR against current master? Possibly your fork's master is probably behind  If you look at [this file](https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow) and the contents of the PR, you can see that something is off. Maybe conflict resolution gone wrong? It would be awesome.  omg, sorry. This is what you call a 5 am review. I didn't notice that referred to `dist/` This is awesome. Great work ðŸ‘ 

Now it's up to somebody with commit access to merge it. Thanks @alexfedoseev for submitting this and thanks @wokalski for reviewing!  Fixed in master - will be released soon  The documentation function types are written in [typescript](http://www.typescriptlang.org/) to help explain how various methods work.

Some but not all documentation contains examples. If you wish, adding examples and improving documentation is an excellent way to contribute back to open source software.

All documentation for this library is automatically generated from https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts which should make contributions easier  This is intentional as the method is deprecated and will be removed from the documentation in the next release.

I suggest using `Map([[ 'foo', 'bar' ]])` or `Map({ foo: 'bar' })`  I think it's more important for `reduce` and `reduceRight` to mirror the behavior of the same named functions on `Array` for predictability.

If anyone wanted to submit PRs to add laziness to reduce/reduceRight, that would certainly be interesting but it would either need to be a different name (fold?) or not upset existing predictable behavior.  Glad to hear it
  Fixed in master will release soon  @kentor has the right answer here. Any JS classes that wish to be used as Set members or Map keys need *both* `equals` *and* `hashCode`  Fixed in master now, will release soon  Unfortunately Flow doesn't have this capability just yet, but it's planning on it. I've put in the necessary syntax with fingers crossed that a future version of Flow works correctly, but in the meantime you'll need to use `status instanceof Set`  Sorry without executable code and expected/actual results I can't debug this issue.  Try `contains`. `has` looks for keys/indices while `contains` looks for values.

The first example correctly returns false because the flattened list has only one thing in it (index 0) so it does not have index 1. In the second example there are two things (index 0 and index 1) so it does have index 1.  I do need help reviewing!

However both of the changes in this PR are incorrect and were correct before being changed 
 Ah no wait, I'm reading the diff upside down! Quick someone get me coffee!
  Thanks for this report.

Actually `getIn` isn't possible to correctly type check unfortunately since the key path may lead to a collection of a totally different type and Flow can't translate that, so I'll convert them to return `any`. However you're totally right that `get` could return void.  Unfortunately proxies are *really* slow, so I'm not sure we would want to add this into the core library. Cool idea though! 

Reopen or submit a PR if you have an idea for how to do this in a performant way  As far as I can tell it isn't intended that "Infinity" is supported as a number to pass here. The docs don't claim this works or anything. That seems like it might be nice but at the same time this pull request is pretty old - sorry about that - so I think the practical thing to do here is just to close it. If you're still interested in this please feel free to reopen!  Is there some way to test these? Like adding a little bit of test code that exercises this specific type? We have a big backlog of pull requests of the form "tweak types a bit" and I just hesitate for the plan to be that I eyeball a bunch of them. Closed by #919   Closing this aging issue.

Sorry, I'm not sure I follow. Immutable is designed to provide iterable collections which React can collect as children via the technique described in [iterall](https://github.com/leebyron/iterall). Ensure your version of React is up to date.  Closing this aging issue.

The solution is to not use `new`. The JS VM will allocate new memory when call `new` even though Immutable.js does not use that memory, and that can create a performance hit.

In fact, `Immutable.Map()` when called with no arguments does in fact return the same instance of the empty Map every time, and VMs are very fast at optimizing paths like this.  @ccorcos Yeah we are maintaining this now all seriously-like. I was thinking it would be nice when we update flow types to make sure they are exercised in a test (for the withMutations part) - does that seems sane? Or is that already happening somewhere. OK so https://github.com/facebook/immutable-js/pull/878 is in now so we have some Flow type refactorings and also you can now test flow types. Would you mind updating to merge those changes in, and also adding a test that catches these changes? Thanks! Feel free to submit a PR if you have something working. I'd say closed and rewritten  @ccorcos, from conversation above, it looks like this PR should be closed. Let me know if it is not correct assumption. ðŸ˜…  @ccorcos could you remove the unrelated changes of handling exports? We should tackle that in a different PR. Also, please add some tests (see type-definitions/tests) that describe the correct behavior. @jedwards1211 I'd say let's wait for the conclusion of this PR.

@rgbkrk I started doing it in a PR to `flow-typed` but dropped it in favour of defs built in here. Maybe it needs to be revisited. You get many nice things with `flow-typed` like versioning. My line of thinking is that it allows more people to use flow defs. They don't need to use yet another tool. Closed by #1073  Yeah my mistake on typescript vs flow specific. I'll get equivalent changes out to flow types next :)  Does this PR still make sense now that we merged https://github.com/facebook/immutable-js/pull/878 ? @ccorcos, is the issue addressed in this PR still exists? If no, please, close. ðŸ˜…  @ccorcos could you recommend a way to test this change that would otherwise currently fail? I just added a flow type test that ensures the native es6 collections can be used alongside the Immutable.js ones.  Great idea. If there are any candidates, I think a page on the wiki is the right place for this.  > I assume it has something to do with objects supporting only strings as keys, but accepting integers nonetheless.

Bingo!

```
â¯ node
> Object.keys({1:'foo'})
[ '1' ]
>
```

JavaScript Objects only support string keys, but they allow specifying them without the quotes (as of ES3) which makes numeric character string keys *look* like numbers, but they're not.  I'm guessing this has been abandoned - we do need folks to sign the CLA, for what it's worth.  @Retsam thanks for the excellent answer  It's not clear that this is worth the added code. Maybe we need some sort of "immutable.js improvement proposal" IIP type process, because I feel bad just saying "meh". But, that said, we have to draw the line somewhere. I am going to close this but if you object then let's discuss because maybe there is something more intelligent to do here.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  That's correct. fromJS() expects plain JS arrays and objects as input. It does not operate on anything else.  Highly recommend https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
  Closing this aging issue - sorry I hope you were able to figure out what was going wrong with your app. If you found something related to Immutable.js in there, please open another specific issue  The previous major version had `.length` but a very common problem was that other code would see the `.length` property and attempt to use Immutable collections as if they were arrays, however that does not work because `list[0]` syntax does not work on anything except arrays, with Lists you need `list.get(0)`. So the `.length` property was deprecated and removed, replaced with `.size` to remove confusion and mirror the same decision made for ES6 native `Map` and `Set`.  No description so I just closed it. Sorry! Are you still interested in this pull request? If so can you describe what's going on and why this is good. Sorry for the huge delay! Just kicked Travis to get a passing build and this looks great. Love this new TS feature.  Yea we do accept PRs. I could use a description of what this PR is all about, the ones with no description I stuck at the bottom of my "to-review" pile Super dope, thanks. Loving all these new TS features.  Tests have been failing for a while so I'm going to close this. If you are still interested in working on this please feel free to reopen!  Not really a bug per-se since there's never guarantees about `===` working - that's a perf optimization. However this does seem like it could be a pretty easy enhancement for someone looking to contribute.  Sorry, I don't follow your issue.

ES3 refers to the JavaScript version supported by browsers since 1999 https://en.wikipedia.org/wiki/ECMAScript#Versions  Try this:

```
return fromJS(state).get('myList').filter(l => l.get('id')).map(list => (list.forEach(elem => console.log(elem)), list));
```  Does this PR still make sense now that we merged https://github.com/facebook/immutable-js/pull/878 ? I *think* I fixed it. [The test](https://github.com/facebook/immutable-js/commit/0155f1c7b2e9c575b2090ff0e5e9093ae1039c87#diff-167148588528b5fa451dc535e9c29037R20) passes. The default export is `immutable` module. Since the tests now check that Flow works with:

    import Immutable, {
      List,
      Map,
      Stack,
      Set,
      KeyedIterable,
      Range,
      Repeat,
      IndexedSeq
    } from 'immutable'

it seems like this functionality is now in master. So I am going to close this pull request, but if you think I'm making a mistake please feel free to discuss/object/etc. Thanks for submitting this pr!  Seems like a missing opportunity - let's add it!  Thanks!  Unfortunately splice cannot be used within withMutations. Since it shifts indices it always results in full copy. Check out the docs for more facebook.github.io/immutable-js/docs/#/List/withMutations  Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Hey, sorry for letting this go stale. Would you mind explaining how you tested that this does not introduce any problems? Hi @danjm! I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you, please, rebase? ðŸ˜…
Also, if you can explain how you tested the PR, it would be super helpful! 
 I'm going to close this PR - it's better to include this in the source rather than editing the site builder since some cases will have more than one example, or continued discussion after the example, and this condition is not sufficient for those examples.  This is not a spelling mistake!

https://en.wikipedia.org/wiki/Memoization
  I feel bad that we didn't help better, but honestly I cannot figure out what the heck is going wrong here. I'm going to close this under the theory that it is abandoned but if you're still interested in working on this please feel free to reopen. Sorry!  What problem is this fixing, exactly? Sorry for asking dumb questions. Is there a `this` thing that works better for this? I feel like I saw a different PR that fixed this differently. Updated before committing: some of the overrides were still returning `C<T>` instead of `C<M>`  W.T.F.

Could you please open an issue on Safari? https://webkit.org/reporting-bugs/

This sounds like a serious issue on their end.   Done in master! Will be released soon  Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This seems like a good thing to do. Thank you!  This doesn't seem like something we would want to commit to - what's the problem that this fixes besides sort of an aesthetic completeness? I could be wrong so feel free to object but for now I am closing this.  Since Immutable methods for updating always return new collections, they're naturally chainable!

I just updated the wiki page.

Note that the wiki page for this repo is editable by anyone! Once you have answers, feel free to improve the wiki.  Let's do it  :/ The documentation sidebar used to be fixed and people complained loudly that it was extremely difficult to navigate and so it was changed to remain on the page.

I'm happy to entertain this change again, but a main concern is an ability to scroll that navigation when it's longer than the page.
  Closing this since it's aging  This is intentional - Set doesn't have any of the `*In()` methods since they only apply to associative collections which Set is not.  #1002 explains this

Immutable collections allow any sort of key, not just strings. Array keys are just fine!   New type definitions are almost done, and will be released soon!  `map()` and most other sequence transform functions do not mutate and always return new collections. Check out the docs for more info http://facebook.github.io/immutable-js/docs/#/List/withMutations  You definitely can use indices! I added a test to illustrate  fromJS() is exactly for converting JSON payloads to Immutable Maps and Lists! You're doing it right. 

The least efficient operation is toJS(). Immutable collections already can be provided to JSON.stringify() so there are only rare cases to use toJS() and yet unfortunately it's quite common. Overuse of toJS() can negate a lot of the beneficial properties the data structures in this library offer. 
  What's up with the `DocVisitor` changes?

This is really touching a zillion different things, huh. How did you test to make sure none of these are in error? @lacker, is this PR ready to be merged? Hey @Merott sorry for the huge delay but I'd love to readdress this.

Two primary concerns:

1) `this` is usually used to describe returning the same instance. Not the case for Map.
2) The problem described is relative to Record, but being applied everywhere. Could you re-scope the change to only apply to Record?
  Sorry for not responding in a timely manner.

I'm closing this aging issue, however if you can reproduce the issue against the master branch, please feel free to re-open the issue.  > To update state in Redux with Immutable, do I call state.merge(something) or state.update(...)

Both of these will return a new version of your state with a change applied. They just do different kinds of changes. Merge looks fine as you're using it now. There's a good parallel here to Arrays. push(), shift(), and map() are all about changing things, but they do different things. One isn't superior to the other. 

> When structuring my changed values, what is the best way to do that? I most certainly know that I have done something and most likely everything wrong, so I hope that you will correct me on this.

I think you're over thinking this. There's basically no wrong way to structure your data. It's your data. Structure it however you like that works for your app.

> How do I call update / updateIn on flat objects?

Could you clarify what a flat object is?
 One thing I noticed is that your function says it will accept Map as state and action, but you're using property accessors like `state.data` or `action.type`. Immutable Maps are not like JS Objects, they're like ES6 Maps. They don't have properties but instead have a get() method. 
 I'm not sure this code does what you think it does. Does it work?

I think you may be misunderstanding some fundamental concepts here. I definitely recommend backing up and getting a better grasp on what it is you're trying to accomplish without additional tools like redux and immutable or babel/es6 and only including these when they help you accomplish something in a better way.

To start, I suggest reading more about redux and reducers. Typically the goal or a reducer function is to accept an older version of something and one other value and then return a newer version of that same thing by using the value. When called multiple times with each new value becoming the "older version" with each subsequent call to the function, you can model change over time via the sequence of events. Immutability is a fundamental aspect to how a reducer function should work (not specific to JavaScript, the concept exists in most languages) but you don't need a special library to use immutability. Simply don't edit the "older version" and instead always create a new copy with your change applied. Redux is really just about popularizing this existing concept of reducers to UI programming. The "thing" being updated over time we call "state" and the value used to update it is the "action". You can see that in your latest version of your code, you're not using the previous state at all to produce the new returned state, that's definitely a big red-flag that your reducer isn't doing what you want it to do. 

Next, the ES6 features enabled with Babel being used here represent the "default values" for arguments, or what value to use if one is not passed to your function. In a reducer the second argument "action" is always provided, so the default value there isn't doing anything valuable. It's probably just distracting from how the reducer works. The first argument "state" is only not provided for the very first time the reducer is called in the case that you're not providing an initial state. If your redux setup has an initial state then you don't need that either. If it doesn't, then here's where that initial state can be defined. An empty Map is very likely not what you are expecting to be your initial state. So it's either distracting from what's really going on, or your probably have a bug there, depending on if you're providing your initial state to redux or not.

then there's immutable.js. I would strongly suggest familiarizing yourself with the concepts of immutability without using this library first just by using plain old JavaScript objects at first. Actually in your case it looks like your state is quite simple so you're probably not gaining much by using immutable.js anyhow. Since plain JS objects are much simpler, hopefully this can help you better visualize what's going on. You can return new versions of your state using Object.assign like this:

var newState = Object.assign({}, prevState, { keyToChange: newValueToUse })

I'm sure you can find ample examples of this sort of thing in the redux documentation and explainers. 

Once you get a better grasp of using redux to build apps and things are working, come back to immutable.js as you need to model more complex state or state that has larger amounts of data in it. Immutable.js uses different kinds of data structures that help conserve memory and improve performance for those kinds of situations.

I'm going to close this issue since both the question in the title was answered in an earlier comment (both merge and update are useful for updating redux states, as are the many other methods immutable.js provides) and the discussion has mostly been focused on this one piece of code, which may be better handled by either working with some tutorials or asking on stack overflow. 
  I agree, the docs would be better with some examples, like an "intro" or "tutorial" type thing. That said, I am going to close this issue because we are trying to keep the issues focused on bug reports. My goal here FWIW is to first clean up the outstanding issues & pull requests and then look at some stuff like improved docs, so I am hoping to fix some of this up. And pull requests to improve the docs are welcome too ;-)  Thanks
  I cannot reproduce this in a fresh `npm init` test directory.

In the _args and _requested section of your installed package, it looks like `^3.7.6` was requested. I expect that you might have multiple versions of your dependency listed in your project - or perhaps npm is installing in a buggy way.  Thanks for the great explaination! `fromJS` is the right path  Just as a note, you should always include your IDE's temporary files in your global gitignore for your git user.

See: https://help.github.com/articles/ignoring-files/
  Unfortunately this is a consequence of Records being iterable. You'll notice that if you do the same thing with `Map` in place of `Record` that you'll see the same behavior.

The solution here is to use `map()` instead of `flatMap()` if you're not returning values that do not need to be flattened, or to ensure that you're always returning a collection to be flattened.  That definitely makes sense thanks for investigating. Of course deletion at indices will change the shape of the List itself. Negative indices cause issue there. Let's start with Map since we know that works. I'll help get a clean merge  The original is correct. It's goal is to return a strings which have been "quoted", otherwise 

Input: `'string "foo" bar'`
Output: `'"string \"foo\" bar"'`

This is used for stringifying output so it is clear which values are strings and which values are something else.  Thanks!  Woops, I merged https://github.com/facebook/immutable-js/pull/873 but didn't see this. Does this still work in conjunction with https://github.com/facebook/immutable-js/pull/873 or what do you recommend now? Thanks!  Closing this aging issue

Unfortunately this sort of thing still isn't possible in a performant way.  Thanks for pointing this out! So, if we just add a failing test then the CI will lie down in the snow and die. So I think we would need to simultaneously have a fix for the bug, and a test. I am going to close this PR but if you would like to fix the problem as well then please feel free to reopen!  Thank you!  Sorry, but this isn't enough information for me to answer a question  Sorry, but I don't think such a function is appropriate for the general library. Though this may be something you can create an npm package from if it is of common usage!  So https://github.com/facebook/immutable-js/pull/878 refactored the flow types and also added tests for them. Would you mind updating this PR to merge those changes in, and also add a test that catches this? Thanks! OK, I am going to close this one in favor of 1027.  Seems to be fixed in master by moving the definitions of `map` to their subtypes  I'm on a pretty epic bug. I wanted to fix imports according to [this](https://github.com/facebook/immutable-js/issues/863#issuecomment-264611660) comment. The problem is that when I wrap everything in `declare module` everything is exported correctly, except for `List`. The funny thing is that if I rename `List` to `Lista` or really anything, it works. I just wanted to say that overall having flow type tests in this repo will make it a lot better, because it'll be a lot easier for us to accept a lot of the type-bug-fixes that have been submitted, so you are a hero for putting this PR together @wokalski  thanks for the review - I broke CI and didn't know about it. The little things you mentioned should be fixed now. Does `$ExpectError` actually fail if there is no error there or does it just allow an error on the subsequent line? Good point! It does fail. YOLO  Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!  So https://github.com/facebook/immutable-js/pull/878 refactored the flow types and also added tests for them. Would you mind updating this PR to merge those changes in, and also add a test that catches this? Thanks! Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you, please, rebase? ðŸ˜…  Thanks for sending this! Overall I think this is an improvement although I had a bunch of nitpicky details which is kind of what docsy PRs end up with. Looks good, thanks for helping improve the docs here!  LOL - that's amazing, it's like a secret way to discourage people from reporting github issues. Thanks for fixing this!  Closing this aging issue - there's no plans to add this to the library, however if you ever feel up for a serious contribution, I'd love to see your research into how to accomplish this.  Fixed in master will be released soon  It's partly a bug, and partly intentional!

After some investigation:

It's intentional that `map` is called in reverse order to preserve the order of the ultimate Stack - that is Stacks are constructed "bottom up" and because `map()` uses a prior Stack to create the new one - the initial Stack is iterated in reverse order to create the new one.

However the bug is that idx is not correct for the reversed values. Just some debugging knowledge dump before I leave this for the night. This might be a larger issue than just Stack and map, but perhaps any Seq that has been reversed *after* mapped (or filtered, or anything else) the prior operations may then get reversed indices.

I think fixing this may require a deeper refactor of how sequence reversal works at the moment.

```
> Stack('abc')
Stack [ "a", "b", "c" ]
> s = Stack('abc')
Stack [ "a", "b", "c" ]
> m = s.toSeq().map((v, i, c) => v + i + c.get(i))
Seq [ "a0a", "b1b", "c2c" ]
> Stack(m)
Stack [ "a2c", "b1b", "c0a" ]
> km = m.toKeyedSeq()
Seq { 0: "a0a", 1: "b1b", 2: "c2c" }
> Stack(km)
Stack [ 0,a2c, 1,b1b, 2,c0a ]
>
```  So https://github.com/facebook/immutable-js/pull/878 refactored the flow types and also added tests for them. Would you mind updating this PR to merge those changes in, and also add a test that catches this? Thanks! Closing this - the changed lines are all intentionally optional function arguments and are not nullable types.  I'm not sure a Seq can be meaningfully compared in a numeric greater/less-than way. That definitely sounds like a useful userland code, or perhaps a supporting library!  Either one big PR or separate PRs is ok. Maybe separate PRs are nicer because it's easier to just merge more things in then. Oh and thanks for improving this documentation!  That's correct - the previous behavior was a bug. Clearly the value at index `0` is `1` and not `4` in your example, so the entry `[0, 4]` does not actually exist in the sequence, however the entry `[3, 4]` does. That bug was fixed in 3.8.1  IMHO the standard way to use with ES6 imports should be:

```js
import {Map, fromJS} from 'immutable';
// or 
import * as Immutable from 'immutable';
``` however it would be nice for convenience to also export an ES6 default such that

```js
import Immutable from 'immutable';
```

Also continues to work correctly. That might mean a slightly more awkward flow definition file, but that would enable those who use it this way currently to keep doing so without breakage. I agree with @leebyron - it should be OK to do either of:

    import Immutable from 'immutable';
    import {Map, fromJS} from 'immutable';

It seems like this is how most things export stuff, React and React Native work this way for example. This is option (C) from @zertosh above. Both are now implemented in master and will be released soon  `src/` is pre-compiled source and because this source was originally written in early 2014, it's not perfect ES6 code - unfortunately at present you have to rely on dist/  Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you rebase, please? ðŸ˜…  @xavierelopez - could you please explain what the warnings were and how to reproduce them? Also, our documentation is generated from this .d.ts file - could you please add to your test plan that the documentation website was still correctly generated? I'm going to close this PR since it's starting to age and many new tests have been added to the type defs in the recent weeks.

If you still see issues on the master branch, feel free to rebase and reopen.  Hey, thanks for sending in this pull request! I don't think this is the right thing to do, because then any breaking change to Immutable would also be a breaking change to the website. So I am going to close this pull request, but thanks again for putting in the effort to improve things.  The docs have been updated recently with more examples, hopefully that clears up how to use `.map()`

> The missing information is the mapper function passed to Iterable.Indexed.map() can return arrays of the form [key, value], while Iterable.Keyed.map() cannot.

This isn't correct - there is no significant difference on how `map()` works between Indexed and Keyed collections - both operate on values.  Fixed now!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 It looks like this PR has been abandoned since that last comment never got any response. I am going to close it under that theory but if you are still interested in working on this please feel free to reopen! OK let's see what we should do here. I guess one question is how we should handle deprecations. I don't think the approach of doing a `console.warn` when you use it is quite the right one - that might cause trouble in some environments because you might have `console.warn` do something very interrupty and not even realize what's happening. I think we would be better off just commenting that methods are deprecated, and then removing them in the next major version bump. I will ping @leebyron about what the right timing is here.  Fixed in master will be release soon  Javascript `>` and `<` operators attempt to coerce values into primitives before comparing - so doing that with a collection like `Map` is surely going to get weird unexpected results.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 So https://github.com/facebook/immutable-js/pull/878 refactored the flow types and also added tests for them. Would you mind updating this PR to merge those changes in, and also add a test that catches this? Thanks! Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you, please,  rebase? ðŸ˜…   Thanks for sending in this pull request! It looks like someone independently made this change, so this PR is unneeded and I am going to close it. But thanks for pointing this out!  It's there!
  I can't reproduce this in my Firefox browser - can you share more details about OS/Browser versions?
 Closing this aging issue - feel free to reopen if still having troubles  Thanks
  What's different about `filter` and `flatten` that need to be defined differently from say, `map`, which is defined directly on `Iterable`?
 Not sure it's the right thing to have filter drop the type parameter though.

Based on flow's treatment of Array#filter: https://github.com/facebook/flow/blob/master/lib/core.js#L185 - we should probably match it.
 Right - but at least we could be consistent with flow's existing behavior rather than divergent.

I'd argue that both behaviors are non-ideal, but it usually makes me nervous to drop type information if it's not strictly necessary, that can result in false-negatives.

Example:

``` js
const arr = [1, 'foo', 2, 'bar', 3, 'batz'];
const numberArr = arr.filter(x => typeof x === 'number');
numberArr[0].toLowerCase(); // Wait, where's my error?!
```
 It's reasonably common practice in flow where filter is used to filter out _types_ rather than _values_ to take type coercion into your own hands to make it clear what you're doing:

``` js
const arr = [1, 'foo', 2, 'bar', 3, 'batz'];
const numberArr: Array<number> = arr.filter(x => typeof x === 'number'); // Error
const numberArr: Array<number> = (arr.filter(x => typeof x === 'number'): any); // No Error
```
 Thanks again for your help improving these
  This looks good to me but Travis is failing for some apparently-flawed reason. Let me try rerunning Travis and if that's good then let's accept this. @lacker, is this PR good to be merged? Most excellent.  Ah, yikes! thanks for the report, I'll look into a fix.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This is looking awesome, thanks for your help! I agree with this approach: set up a test infra and then let's do one test migration per PR to keep things easy to follow. 

I'm not sure what's up with the failing tests. I can help investigate tomorrow 
 Closing in favor of #1018   cc @bestander This should probably also fix https://circleci.com/gh/facebook/react-native/5344
  Excellent work, thanks!
  Unfortunately I don't think this is possible, as what you're asking for is syntactic rather than library code.

A default value must _always_ exist, because you can always do `myRecord.myField` and it must return _something_, even if that something is undefined. For example, this is totally fine:

``` js
var MyRecordType = Record({
  myField1: undefined,
  myField2: undefined
})
```
 We have a slightly nicer syntax coming in a future version that lets you provide coercion functions rather than just default values:

https://github.com/facebook/immutable-js/commit/44b20e4168613a7d28920495115a741b20fef2b4
  Thanks
  Good idea
  This warning has been removed in the most recent version
 If you update to the latest version of `immutable` on npm, then you should no longer see this warning.
 Hopefully react-native can update soon, perhaps you can open an issue there with this report. If you're calling `.length` on an Immutable collection that react-native is giving you, then ensuring that you're replaced that with `.size()` will also hide the warning.
  Fixed!
  Thank you!
  Fixed!
  Great answer @thomastuts 

In the future, ask questions on http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
  Thanks for answering!

In the future, answer on http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
  I'm a bit confused as to what you're asking for. Wouldn't a clone method just be an identity function? How would this relate to equality checking? Can you reference the removed clone method you are referring to?

```
Map.prototype.clone = function() {
  return this;
}
```
 I'm too concerned that this method would offer more confusion and anti-pattern than well meaning usage. If you would like to create a sense of change for a collection which has not changed, I recommend wrapping in a simple object or Record.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 You're correct.
  Thanks for answering!

In the future, answer on http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
  A `Repeat` is an object. So this is false for the same reason that this will log `false`.

``` js
console.log({ k: "v" } === { k: "v" })
```

However you can write `zeroArray(10).equals(zeroArray(10))` or `Immutable.is(zeroArray(10), zeroArray(10))` to get `true` by using _value equality_.

In the future, ask on http://stackoverflow.com/questions/tagged/immutable.js?sort=votes!
  Fixed!
  Nice simple implementation, thanks!
  In React, `this.state` is _always_ an Object. It's not safe to assign to `this.state` directly.

Instead try something like `this.state = { store: TabStore.getStore() }`

In the future, ask on http://stackoverflow.com/questions/tagged/immutable.js?sort=votes!
  Thanks for answering!
  This sounds like a great opportunity for a companion library for someone to build! However it probably doesn't belong in this core library.
  @xixixao  is correct here - by _removing_ what you didn't explicitly provide, what you've done is really just created a new value altogether.

Since the impl is quite small, Michal summed it up well, I'd recommend inlining it for your use.
  Fixed!
  Could you provide more information? What did you expect? By looking at your example, all output appears correct.
 groupBy uses equality checking to determine groups. Unfortunately JS arrays and objects are mutable collections that use reference equality.

A good way to remember this is:

```js
[] !== [] // true
{} !== {} // true
```

That means returning arrays or objects from groupBy will create a new group for every return value.

This is tricky to coerce since JS primitives are often used as opaque identifiers in many apps.  Unfortunately many rely on this behavior today, so we cannot remove it.

In a future version we can consider requiring a shared symbol instead.
  Can you share the explicit piece which is performing the `toJSON` and comparison? It appears that one side of the comparison is peering into the implementation-details of a `Map` instance, while the other is a JS Object.
 Closing this aging issue - I hope you were able to solve this. If not, please feel free to open a new issue with a minimal failing test case.  It is a custom built solution. The code for which is all found in https://github.com/facebook/immutable-js/tree/master/pages
 Yep, the docs aren't perfect and what they could really use are example uses
 The docs are autogenerated from the typescript definitions file in /type-definitions, the doc block above each message turns into the description. It's just commented markdown, so it should be easy to embed example use cases right there
 A cookbook would also be cool! Perhaps that's worth its own section on the website (all assembled in this repo in /pages)
  Thanks for the report.
  Great, thank you for this!
  These are very different data-structures. I'm unlikely to build them anytime soon, but if someone is interested in contributing, the first step is to consult existing research in persistently immutable cache mechanisms to determine next steps.

Closing this issue though, as it's not something that's on the near-term roadmap.
 This should behave correctly, but may not be an efficient implementation.  LRUMaps which seek to be performant and persistent usually use some kind of structure that's easier to clean up like a btree or minheap
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This is so dope. Thanks for your hard work!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This pull request looks helpful, but would you mind resolving the conflict? Sorry for leaving this for so long unanswered! I'd like to get this in though. Awesome!  Hmm, this test appears to be failing on Travis: https://travis-ci.org/facebook/immutable-js/builds/184427778 Oh, I see. I thought this test was just like an improvement to the test coverage. My bad  This library references the method prototypes of `Array`, `Map`, and `Set` from ES6 whenever possible, and only diverges when it must or when divergence is relevant to the library.

For example `Map.get` and `Map.set` work identically to ES6 Map.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 awesome. thanks so much for your help
  This landed in master branch yesterday. A new release is coming soon which will include this change.  It is 8 entries. This is a performance optimization where the each of these implementations have different performance characteristics for getting and setting, and ~8 entries is where BitmapIndexedNode begins to outperform ArrayMapNode.
  Fixed!
  Good find.
  This is intended behavior. `flatMap` expects to get back an iterable per item (like an Array or Immutable.List). It is intentionally more strict than `list.map(fn).flatten(true)`
  Actually this looks great. Thanks for this and also for including the tests!
  Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you, please, rebase? ðŸ˜…  I'd prefer to see an approach that didn't require the nested concatenation loop of the key-path. That's liable to make mergeDeep much slower for everyone regardless of if they rely on this value.  #seemslegit

thanks!
  Could you provide some common uses of Multimap and some of the methods you would expect on it?
 Closing this aging issue  Yeah, currently you're doing it the best way. `merge*With` takes a custom merger which will let you do smarter things when it encounters something that is `List.isList()`
 That's correct. The merger function is only called when both previous and next both exist. The default implementation is (prev, next) => next
  You should check out https://github.com/ReactiveX/RxJS
  This is definitely something that would be nice to have one day. #88 tracks.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This file is automatically generated by our website's build script, it pulls directly from our README.md, so unfortunately if I were to merge this, it would be quickly overwritten (in fact, this file should probably be in the .gitignore)
 Seems like what was actually going on was that the readme.json file _wasnt_ being autogenerated anymore :(. I got that all fixed up in aca20705ee96bb00b038b24a531d9f92014ffdf2 which happened to solve this issue. Thanks also for bringing this to my attention, I added these auto-gen files to the .gitignore while I was at it.
  Hopefully this has been fixed by the recent improvements to typescript and the definitions file. Feel free to report again if this is still an issue.
  Thanks Thomas!

This is a great start.
  Thanks for your investigation. Agreed being stuck on old node sucked.
  Thanks for answering!

In the future, ask questions on https://stackoverflow.com/questions/tagged/immutable.js?sort=votes for searchability.
  Thanks for answering!

In the future, ask this kind of question on stack overflow where answers can be easily searched. https://stackoverflow.com/questions/tagged/immutable.js?sort=votes
  Unfortunately this is a limitation of Record. Any instance variables like this need to be defined on the Record itself, for example:

```
class ABRecord extends Record({a:1,b:2, networkstatus:null}) {}
```

Calling a function to compute those values is not safe since new Records are "constructed" again every time `set()` is called to preserve immutability.  I'm not seeing the same results:

```
> a = {test: 1}
{ test: 1 }
> b = {test: 1}
{ test: 1 }
> set = Immutable.Set([a])
Set { [object Object] }
> set.has(b)
false
>
```

Immutable uses something very similar to the `SameValueZero` comparison, however if both sides of the comparison are Immutable collections like `Map` or `List` then they use _Value Equality_ rather than _Object Equality_ which is a concept that ES6 does not contain.
  Closing this issue

I second the recommendation for [transit-js](https://github.com/cognitect/transit-js) for serialization of custom data structures.  Closing this aging issue, if still relevant feel free to reopen  I think this is best as a "recipe" as a written reduce function.

However if you find a non-trivial but very performant way to implement this, consider contributing it as a PR!
  Fixed
  Unfortunately this operation is not supported.

You could accomplish this with `mapEntries` though.
  Closing this aging issue - I hope you were able to figure out the issue with your app.

When testing your example code, I seem to get what you expected:

```
> var recommendations = Immutable.fromJS([{ searchLocations: ['brooklyn', 'manhattan', 'new jersey']}, {}, {}])
undefined
> var rec = recommendations.get(0).toJS()
undefined
> rec.searchLocations.join(', ')
'brooklyn, manhattan, new jersey'
>
```  Native behavior is to throw an error, which is at least more descriptive.

``` js
> [].reduce((left, right)=>left.concat(right));
TypeError: Reduce of empty array with no initial value
    at Array.reduce (native)
    at repl:1:4
    at REPLServer.defaultEval (repl.js:260:27)
    at bound (domain.js:287:14)
    at REPLServer.runBound [as eval] (domain.js:300:12)
    at REPLServer.<anonymous> (repl.js:429:12)
    at emitOne (events.js:95:20)
    at REPLServer.emit (events.js:182:7)
    at REPLServer.Interface._onLine (readline.js:211:10)
    at REPLServer.Interface._line (readline.js:550:8)
```
  Thank you!
  merge only converts structures to immutable if you pass a plain object. For now, try:

``` js
record.merge(Map({
  a: foo,
  b: foo
}))
```
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Great, thanks!
  Released
  Do you have any profiling that helps understand the performance implication of a change like this?

It seems like we also have the choice of saying just not to convert to plain ol JS objects if your map keys contain strings that overlap with JS object special keys.

This ultimately boils down to a tradeoff, so we need some information to make a choice
 It seems like this pull request has been abandoned so I am going to close it. Please feel free to reopen if you'd like to continue working on this!  Best to ask this type of question on Stack Overflow where there is more traffic. https://stackoverflow.com/questions/tagged/immutable.js?sort=votes

The answer likely includes `mergeDeepWith` which allows for a custom merge function.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Great, thank you
  Great catch, thanks
  This is unfortunately not something we're going to do, as the performance of `get` and `getIn` are critical, and doing type sniffing on the input would be a serious performance loss.

I recommend writing a function like:

``` js
function p(path) {
  return path.split('.');
}

so you can write: `getIn(p('a.b.c'))`
```
  Thanks!
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This seems pretty reasonable to me. Would you mind adding some tests and also adding the Flow types in addition to the typescript ones? Actually - chatting with @leebyron it sounds like the ideal outcome would be to move Cursor out of this library entirely. So perhaps a better plan would be to stop trying to add functionality there and first move it out. So, I am going to close this pull request, but if you are interested in maintaining Cursor separately from the core immutable library then I am interested to chat!  Merging into #1039   fixed
  The second will not do anything, because you're iterating over the temporarily mutable list rather than the immutable seed list:

``` js
const newList = List().withMutations(mutList => {
  list.reduce((newList, val) => {
      /*do stuff*/
      return newList.push(val);
    }, mutList))
```
  Most excellent
  Immutable.js's tools are behind the times and it is limiting progress on some of the top line goals.

This is a master task that details all the steps required to modernize the repository.
- [x] move the source for gh-pages into master branch (#741)
- [x] automatically deploy gh-pages when master pages src changes (a71d9b60f0944535c2b05c1dafb926833132473d)
- [x] use latest jest for tests
- [x] use eslint for linting (#1101)
- [x] improve strictness of lint rules (#1101)
- [x] run tests against latest versions of node (a91b5e7)
- [x] update to the latest version of typescript (#745)
- [x] use buble for ES6 -> ES3 compilation (#1102)
- [ ] remove usage of gulp in favor of npm scripts? (1b4166952995a7ceb898c254dfdc3b219210b597)
- [x] remove usage of grunt in favor of npm scripts (1b4166952995a7ceb898c254dfdc3b219210b597) (#1102)
- [x] include flow type definition file
- [ ] no longer check in distributed files (breaking change)
- [ ] move contrib to separate repository (breaking change)
- [x] setup yarn (#1100)
- [x] setup prettier (#1101)
- <s>move documentation generator source of truth to flow type + babel.</s> - Note, updated to latest TypeScript instead.
 Using `new` with collections is actually an anti pattern. They're designed to be used like the JS scalar types (Number, String) as just a callable function. 

That does mean the class syntax either needs to only ever be consumed by an off-spec transformer or it needs to be converted to use MapPrototype.method = function(){} or rely on Object.create's extra properties param or something like that I think it's safe to call this task done. There's always more modernization to be done, but this hits the major objectives.

Thanks so much for your help, @umidbekkarimov!  I would be happy to consider a PR for including `findKey` to Indexed collections.

I disagree that the other indexed methods like `indexOf` make sense on Keyed collections though. It's common that a Keyed collection is not keyed by an integer and then these methods make less sense. Even if a Keyed collection is keyed by an integer, it's not necessarily the case that the integer keys will be iterated over in incrementing order as they are in indexed collections, which at the very least would require different implementations, and at worst could cause unintuitive results.
 I think you're right. Thanks for the discussion and sorry for the delay. Check out the commit for details.
  Closing this since there is an answer with clear code, but please reopen with more details of the issue at hand if your code is different and you've encountered a bug.
  toArray will not alter the items in the list, in this case more Immutable List, since this is a 2D List. Use toJS() to deeply convert Lists to Arrays. Otherwise what you are seeing is fully expected
  Unfortunately `Promise.all` is fairly limiting in this way.

You might notice that using ES6's `Map` with `Promise.all` has the same issue.

Since you want to Promise.all the values of the Map, I would suggest:

`await Promise.all(promises.values())`
  Hello, 

I'm currently using `Immutable` for a project thats under development. I'm pretty new when it comes to immutable. I'm attempting to update multiple values within a `Map` and I know some of the issues that are causing the errors I'm just not sure how to resolve them.

``` js
//Initial attempt
export function handleUpdateSneaker (state, sneaker, sneakerDif) {
  var userSneakers = state.getIn(['dashboard', 'userSneakers']);
  var index = userSneakers.indexOf(sneaker);
  return state.updateIn(['dashboard', 'userSneakers'], sItem => {
    sItem.sneakerName = sneakerDif.sneakerName;
    sItem.shoeSize = sneakerDif.shoeSize;
    sItem.price = sneakerDif.price;
    sItem.trade = sneakerDif.trade;
    sItem.isbm = sneakerDif.isbm;
    sItem.info = sneakerDif.info;
    sItem.brand = sneakerDif.brand;
    sItem.quality = sneakerDif.quality;
    sItem.reRelease = sneakerDif.reRelease;
    sItem.colors = sneakerDif.colors;
  });
}

//Trying to solve the 2 problems stated below
export function handleUpdateSneaker (state, sneaker, sneakerDif) {
  var userSneakers = state.getIn(['dashboard', 'userSneakers']);
  var index = userSneakers.indexOf(sneaker);
  return state.updateIn(['dashboard', 'userSneakers', index], sItem => {
    sItem.set('sneakerName', sneakerDif.get('sneakerName', sneakerName));
    sItem.set('shoeSize', sneakerDif.get('shoeSize', shoeSize));
    sItem.set('price', sneakerDif.get('price', price));
    sItem.set('trade', sneakerDif.get('trade', trade));
    sItem.set('isbm', sneakerDif.get('isbm', isbm));
    sItem.set('info', sneakerDif.get('info', info));
    sItem.set('brand', sneakerDif.get('brand', brand));
    sItem.set('quality', sneakerDif.get('quality', quality));
    sItem.set('reRelease', sneakerDif.get('reRelease', reRelease));
    sItem.set('colors', sneakerDif.get('colors', colors));
  });
}
```

In the code snippet above Im using `getIn()` to reach within the `dashboard Map() -> userSneakers List()` and to find the correct `Map` within the `userSneakers List()` I am using `indexOf()` to return the index of the correct item to update its fields. 
Now the **Problems** that I can identify are:
1. You cant use `.`(dot) notation when trying to use access the values within an _Immutable_ `Map`.
2. When I use `updateIn` I'm reaching within  `dashboard Map() -> userSneakers List()` but not specifying the correct object that I got from `indexOf` to modify.

Im not sure how to fix those 2 problems and would appreciate if someone could explain to me how to fix it because I can imagine that I will encounter similar problems throughout the duration of the project.

Any and All help is appreciated ðŸ™‚
 @tgriesser thank you for the feedback, I didn't think about using `reduce`. I'll test it out now and let you know how it goes!
 @tgriesser My unit-tests checked out! Thank you so much, going to use this as a blueprint for how I go about making multiple changes through out the App!
 @tgriesser , After looking at your code for a bit and trying to understand it, Im not completely sure whats going on. Would you mind explaining whats going on there?
  I think @bvaughn summed it up well. Though this isn't really a performance concern, it's more of a correctness concern. Making a `List` of React components is a great example:

`Immutable.fromJS([ <div />, <span /> ])` could coerce those React components into Maps. `Immutable.List([ <div />, <span /> ])` won't touch the elements.

Obviously there are plenty of examples where this could bite you, React components was just one brought up here. Anything that's intended to remain a JS object shouldn't be forcibly converted. Also `fromJS` only ever builds `List` and `Map`, but of course there are plenty of other data structures you might want to use, which is best represented by using them directly.

This isn't unique to Immutable.js but also is how data structure constructors work in JavaScript:

`Set([ ['A'], ['B'] ])` does not result in a Set of Sets, it results in a Set of Arrays.

Basically the rule of thumb with both Immutable.js and with built-in data structures in JavaScript is that if you use `{}` you're definitely building a JS Object, and if you use `[]` you're building an Array. You need to explicitly use constructor functions to get any other kind of data structure.
  Agreed, thanks!
  This is pretty cool, but I'm concerned about the type signature. Unfortunately this would only allow making Maps where the keys and values are of the same type.

Maybe it would be better to just explicitly type this as `Map<any, any>`?
 I'll look into the test. It seems to pass in newer versions of node which is suspect
  Awesome thanks! I just rebased and landed this
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks for your investigation into this!

We've done some pretty thorough investigation into this idea a couple times now, the most in depth by @tgriesser and found some pretty serious performance burden by this, regardless of whether you actually use the inheritance feature. Since performance is a primary feature, we ultimately decided not to support this. 

Also, philosophically we encourage a functional style or at least composition over inheritance anyhow.

Here's how your same example might work using a functional style:

``` js
function setFormValue(map, z) {
  return map.set("value", z);
}

function setSpecialValidatedFormValue(map, z) {
  return setFormValue(z).set("valid", z != "");
}
```

Here's how your same example might work using object composition:

``` js
class Form {
   constructor(initialValue = "") {
      this._map = Map({ value: initialValue });
   }
   _create(newMap) {
      if (newMap === this._map) { return this; }
      var newForm = new this.constructor();
      newForm._map = newMap;
      return newForm;
   }
   setValue(z) {
      return this._create(this._map.set("value", z));
   }
}

class SpecialValidatedForm extends Form {
   setValue(z) {
      return this._create(super.setValue(z)._map.set("valid", z != ""));
   }
}
```
  Check out the roadmap for Immutable.js here https://www.facebook.com/notes/lee-byron/immutablejs-2016-roadmap/10153447836068757

This is a strawman document, which means I'm interested in your feedback on these priorities and to understand if I may have missed something.

Feel free to use this issue as a place to leave comments!
  Thanks for the report!
  Unfortunately this would add a performance burden. Since `withMutations` is designed to be a critical path optimization, I'd prefer not to incur a performance cost  Actually this is kind of awesome, I'm not sure I would consider this problematic but an (accidental) usage of Immutable.js's value protocol by node Buffer.

I suppose this is a problem for Immutable.js as much as the following is a problem for Node:

``` js
var buf1 = new Buffer('hi');
var buf2 = new Buffer('hi');
buf1.x = 123;
buf1.equals(buf2); // true
```

I'm curious what your expectations here. Should we not treat buffers as values? Does this cause a real issue for you, or is this only a theoretical concern?
 Closing this aging issue  possible that the docs need to be redeployed or something
 Fixed
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Closing since related changes have landed, but thanks for your advocation!
  Closing this since I commented on the DefinitelyTyped task, and that should be good to go.

Moving forward, I believe supporting type definitions distributed through NPM is the right long term solution both for this library and for the node/js community.
  You should check out https://github.com/Reactive-Extensions/RxJS - It provides methods for iterating over asynchronous streams.
 That's exactly correct, and the primary difference is synchronicity. If your DB is a single async operation that results in a collection then you can use a JS Promise to model the database call and then use Immutable Seq to model the results. If accessing each next item is itself an async process then a Seq cannot model this, and you need to use something like a Stream or Observable (rxjs)
  Thanks!
  This has to do with how different platforms and browsers implement `console.log` which unfortunately is not a standardized part of JavaScript.
  The next version of Immutable.js will strive to have an even smaller API surface area, as it's primary benefit is providing highly performant persistently immutable data structures, not a broad data API. Ramda presents an excellent API for functional programming within JS, but that is not the goal of this library.

Immutable.js's data structures are intended to be used as flexibly as possible with many libraries. Unfortunately JavaScript's Array exotic can make this pretty difficult, but ideally libraries like Ramda and Lodash could help determine a standard access pattern so that Ramda and Immutable can work very well together rather than be seen as a "vs".
  Thanks for this info! I didn't know this was possible. I will look into making typescript and flow types for npm packages a first class feature in the next major version
  Closing this issue - you can do this today with `.update()`

```
> function sum(collection) {
...   return collection.reduce((sum, x) => sum + x, 0)
... }
undefined
> Immutable.List([1, 2 ,3]).
... map(x => x + 1).
... filter(x => x % 2 === 0).
... update(sum)
6
>
```  Unfortunately JS object keys are always strings and this is not possible  Updated in master branch, release soon  This is an artifact from the type definitions being written before typescript supported ES6. The comment documents the intent while the actual type definition is the best effort typescript would support.

I'm happy to entertain pull requests which improve this!
 Fixed in master, will be released soon!  Thanks for the report!
  Fixed
  Adding the help wanted tag for any aspiring contributors, however my concern that would need to be fulfilled is that this API would need to avoid confusion around using binary search on an unsorted collection. I anticipate a lot of questions around why their binary search isn't working well I think this is a naming concern first, so maybe searchSorted() or something to imply that it can only be used on a sorted list. That plus documentation would help catch most (but probably not all) issues of searching unsorted lists

Though I'm also concerned about scope creep of the library. In general I think there is currently too much on the prototype of the collections already and would prefer utility functions published as an ecosystem of npm modules instead. More people have been requesting a smaller bundle size than have been requesting additional features on the prototype.

On top of the scope creep issue I think it could be confusing why there would be two methods "find()" and "search()" which are conceptually identical but differ in implementation.

I'm thinking that what might be best is if someone built and published a library like immutable-binary-search which simply implemented this feature and worked with immutable.js. I would be thrilled to feature such a companion library from the documentation  I don't think an implementation of binary search that leveraged implementation details of List would be measurably faster than one that used the public API. Just using `.get(index)` would be best.  Fixed!
  This convenience method is going to be removed in a future version of Immutable as it can be confusing and currently restricts the ability to do incremental builds of Immutable. e.g. instead of doing: `myThing.toMap()` you would write `Map(myThing)`. For this reason I think we would not want to consider expanding the API to perform more tasks.

This also means if you would like a mapping function to construct the Map, you could write: `Map(myThing.map(a => [b, c]))` which is hopefully less confusing (people often confuse the `map` function and the `Map` type)
 Yep, I agree with you. What we're looking at is a tradeoff between chainability and modularity. Currently the library optimizes for chainability, but that means modularity isn't possible. As there's simultaneous demand for adding new kinds of data structures while also reducing the size of the library, we're stuck until the modularity problem is solved, and unfortunately that means giving up some chainability.

Luckily, after surveying a large body of code that uses Immutable, conversion between different types is far from the most common of operations, so this should have relatively small impact on code quality and readability.
 > Does `Map(myThing.map(a => [b, c]))` work currently?

It does!

``` js
var list = Immutable.List([ 1, 2, 3 ]);
var map = Immutable.Map(list.map(v => [ v, v ]));
map.toString();
"Map { 1: 1, 2: 2, 3: 3 }"
```
 I'm sorry you feel that way @dubrowgn, my hope is to balance lots of different concerns for a best possible outcome. I understand that means tradeoffs in some places in order to accomplish other things. I certainly am not trying to actively move in a direction opposite from where issues are trying to highlight, on the contrary I'm trying to move in a direction that can satisfy as many as possible.

Here I'm just trying to highlight that it's good news that your proposed code:

``` js
data.toMap((item) => item.id, (item) => item.value);
```

Can be written today as:

``` js
Map(data.map(item => [ item.id, item.value ]));
```

And that is both compatible with where the library's API is going in the future, and I hope is also not too detrimental to code legibility.
 > I think there is something wrong with the map() function then. This is what I tried before:
> 
> var m = Immutable.Map({ "10":100, "20":200 }).map((v, k) => [parseInt(k), v]);
> m.toString();
> // "Map { "10": 10,100, "20": 20,200 }"

My assumption with the example code above was that you were converting from a `List` to a `Map`. If you already have a `Map`, then at least we're beyond the question of conversion.

The `.map()` function on a `Map` type maps over the values, maintaining keys. If you want to map over each _entry_ as a separate element, then you should check out `.mapEntries()` which let's you write:

``` js
var m = Immutable.Map({ "10":100, "20":200 }).mapEntries(([k, v]) => [parseInt(k), v]);
m.toString();
// "Map { 10: 100, 20: 200 }"
```
  Unfortunately this is beyond the current abilities of OrderedSet to do in a performant way.
  You should be able to use this to generate some version of the docs locally: https://github.com/sebastian-lenz/typedoc
  Sorry for missing this! Thanks so much for the fix.

I'll clear up the dts noise first and then get this in
 Hmm, I actually want to understand this a bit better.

There are cases where we use `is()` to determine value equality - when not knowing true equality would result in an incorrect state, and there are other cases where we use `===` to determine cheap equality, where we're optimizing what would otherwise be a correct but more expensive operation.

This is similar to `myMap.set()` where when setting a new value, it's always correct to return a new Map with the provided value set, and we use `===` as a very cheap optimization to return the same map.

The reason we don't use `is()` for the optimization opportunity is that it does a full walk of any data structures provided.

I think this case you're updating is an optimization opportunity rather than a result correctness.

However, I think it's safe to use the `is()` for the optimization specifically for `mergeDeep` because `mergeDeep` will always walk over iterables and only the scalar (or at least non-iterable) leafs will be compared and merged. 

I think we should find a way to apply this change only in the condition that you're using `mergeDeep`
  Unfortunately not currently supported, but will keep in mind for future versions.
  One recurring point of confusion with this library is that people confuse what operations are fast vs slow. I'm noticing that this is related to how verbose an API is - people seem to expect short terse API to be fast. That gives me pause for `without` - since it's a one-liner to implement yourself so there's low value in adding it to the library, and people may become confused between when to use `without` and when to use `delete`.  Fixed in master and will be released soon!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 The documentation was actually already correct as written, but I agree it was not very clear about _why_ this is the case. I'll make a change which better describes why the key "x" is going to be ignored.
  Fixed in master, will be released soon  Fixed in master, will be released soon  I think this method of taking the difference is too inefficient - a user of this library could just do it themselves if you are removing things one by one in `withMutations`. So if this method were included in the library people would expect it to behave more optimally. This PR is also pretty old, so I am just going to close it. If you are interested in working on this more then please feel free to reopen!  Closing this aging issue

Unfortunately not without digging into the implementation details  A collection of functions may wish to use a function as it's notSetValue - As interesting as this is, I fear it would add more confusion than value in the long run.

In my opinion, a better version is:

```js
var items = Map<string, Item>(...);
var item = items.get(key);
if (!item) {
  item = new Item()
  items.set(key, item)
}
```  I believe it is designed on purpose since === will check if arr1 and arr2 are the same object (using reference equality) but map returns a new immutable object so arr1 !== arr2. If you used immutable.is then they would be equal since is uses value equality 
 Unfortunately the "return the same reference" optimization does exist for `map` yet, so while the result will have the same value equality, it won't have reference equality. 

Similar to how:

``` js
var array = [1, 2, 3];
array !== array.map(x => x);
```

I've opened an issue for this at https://github.com/facebook/immutable-js/issues/679 since this would be a nice optimization to have.
  You can just call `List()` for an empty list or `Map()` for an empty Map. These return memoized versions of the immutable empty collection, so `List() === List()`.

And as a bonus, it's less characters than `List.empty()`!
  Fixed!
  ``` js
Immutable.is( new Immutable.List([{}]), new Immutable.List([{}])) === false
```

Is correct for the same reason

``` js
Immutable.is( {}, {} ) === false
```

For the same reason

``` js
({} === {}) === false
```

Two object references are always considered not equal since they are designed to be mutable and allowed value equality checking between them can be dangerous and lead to bugs.

Immutable.js only treats the immutable collections as value equal, which is why comparing two immutable empty lists together is considered equal.

A variation of your original example but using `Map` instead of a JS object will result in value equality:

``` js
Immutable.is( 
  Immutable.List([ Immutable.Map() ]),
  Immutable.List([ Immutable.Map() ])
) === true
```
  Closing since the question has been answered
  Closing this aging issue - but noted. There are a few other issues recommending improvements to this usage case.
  Or have a section to that explains the syntax that is used in the documentation as I think it is type script type of notation. I think examples of each utility would be great to have.
 Please contribute documentation to this repository once you learn best examples! This project improves when the community can contribute work like this.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thank you, Rich! Sorry for letting this sit. Rollup looks pretty awesome, I'll look into getting this to pass tests and merge
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Given this issue https://github.com/facebook/immutable-js/issues/505 I don't think we want to emphasize this since it should not share exactly the same API as Map
 This is actually just an implementation detail, and one that's likely to change in the future. It's a "Map" in the sense that it exposes `get` and `set` methods, but the HOF methods like `filter` and `forEach` make no sense on a Record.
  Merging into #635  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks!
  They're equivalent. `getIn` is implemented in terms of `get` - it's just a nicer API.
  Specifically only for Records, yes it is an experimental feature  The records themselves do not know where they exist within a parent (or multiple parents!)
  Awesome, thank you for this!
  Closing this aging issue  Sorry for letting this issue go stale.

There are plenty of great libraries out there that help implement OT - I don't think this data structures library is the appropriate place to add another  https://www.youtube.com/watch?v=I7IdS-PbEgI
  Thanks for this investigation, please feel free to open a PR applying your fix and adding a test that documents the original issue!
 I believe this was the result of an older bug with slice that has since been fixed. A new release is coming very soon which will resolve this for everyone  Closing this aging issue which should have been fixed with the v3 release. Please re-open if you see it again.  Sorry for dropping this super aging issue - I hope you were able to build something awesome and your approach sounds great  Nice! Thanks for this
  This is great, thank you for doing this.
  See this issue: https://github.com/facebook/immutable-js/issues/505

`Record.map` should not be used.
 Merging into #505  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 :+1: to this, seems like a lot of issues are being filed from this
 Thanks
  Curious if this is this still necessary after #647?
 Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you rebase or close the issue if it's obsolete? ðŸ˜…  Closing since nonambient definitions are becoming the standard and those will be included in the next release  There's a fairly large API, and at some point we need to draw a line between how many methods have `*In` variations. Generally we favor the methods that apply to many different types for most convenience.

Otherwise, any time a deep method, say `data.xxxIn(arg)` is needed, a worthy substitute is `data.updateIn(_ => _.xxx(arg))`  Unfortunately not since it's not possible to do within JavaScript. WeakMap requires knowledge of the garbage-collection state which isn't available outside of the VM itself.
 Not that I've been able to figure out. I'm happy to take suggestions on how to do this, but every approach I've considered would either be very inefficient (copy the whole structure on every mutation) or leak memory (use a DAG with WeakMap leafs, but no way to know when to clean up without access to GC)

â€”
Sent from Mailbox

On Sat, Oct 3, 2015 at 7:41 AM, Paul Jolly notifications@github.com
wrote:

> ## Not even using the new experimental [`WeakSet`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet) and [`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) under the covers?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/639#issuecomment-145253965
 Actually, I'm not sure a copy of a WeakMap is even possible as that would require interation which they do not support as that would leak GC state. So leaking memory would be the only path forward

â€”
Sent from Mailbox

On Sat, Oct 3, 2015 at 7:41 AM, Paul Jolly notifications@github.com
wrote:

> ## Not even using the new experimental [`WeakSet`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet) and [`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) under the covers?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/639#issuecomment-145253965
  I think it makes sense to mirror the behavior of Array#slice and floor the passed indexes
 Just tried reproducing this but was unable to, it seems like the library exhibits the proper behavior.
 It looks like the version on the immutable website is a bit outdated, but in fact this bug has been fixed in more recent versions of Immutable.js
  Thanks, but when patching this in, I'm getting failures when running `grunt` with this patch applied. 
 Just leave grunt-jest and typescript alone :+1: 
 Thanks, this just landed in rebased form!
 didn't see it, never mind.
  Closing out. `reduce` is the way to go!
  Thanks for the report! You're right that the alias is getting the wrong method in this case.
  Unfortunately not  Immutable collections are not really classes, even though some of the syntax tries to articulate them that way. Instead each Immutable collection type is both a factory function and an instance type. The difference from this and classes, is that there is no constructor function.

Extending a Record as a class is a fine shortcut for adding prototype methods, but the constructor itself will not be called consistently and is probably unsafe to use.
  Closing this aging issue  #928   Unfortunately this is not possible at the moment  Thanks! Sorry for letting this sit - did you verify that this fixes the issue for you? 
 I'd like to test this. Could you include a test or use case that fails before this patch and works after?
 Tests look good, just need to rebase and merge. Will get to that shortly.
  Closing this aging issue  Great, thank you
  Hey, so there are basically two ways to implement a "diff" type function. You can just do it with an iterable over the whole structure, or you can get into the structure itself. The first way is simpler, and it's what this PR does, but people can do it themselves already based on the existing API. The second way actually gives some performance improvement. So I don't think we should go this direction, I think we should either not include "diff" in the API at all, or have an optimally-efficient mechanism. Thanks for submitting this PR though, I really appreciate the effort here.  @leebyron @derekdreery 
 My original intention was to have the key based. It's an oversight in the implementation if it is not, I think that this kind of differencing only makes sense over keys and we should exclude values. If we really wanted to support difference over values I think that that behavior should be specified by the consumer using a separate flag or something.
  what makes you think that this is in fact not the case?

I added the following test case and it seems to be passing the tests locally:

``` javascript
  it('casts to set correctly', () => {
    var orderedSet = OrderedSet([1,2]);
    var set = Set([1,2]);
    expect(orderedSet.toSet()).toEqual(set);
    expect(orderedSet.toSet().equals(set)).toBe(true);
    expect(set.toOrderedSet().equals(orderedSet)).toBe(true);
    expect(orderedSet.toSeq().toSet().equals(set)).toBe(true);
  });
```
 thanks @kentor, looks like https://github.com/tgriesser/immutable-js/commit/23bc0f3905701701cf233fe4e9f0018cee311443 should have fixed this issue
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 thanks!
  `withMutations` is designed for performance-tuning code, so it's critical that it's fast. It would be inappropriate to have it attempt to perform deep operations which could be very costly. Yes I would call this mistaken usage. For example in the original example here is the issue:

 ```js
let m2 = m.withMutations((res) => {
    let y = res.get("y");
    y.set("b", 9);
  });
```

While the `m` collection is in a mutable mode, the collection at the `y` key being referenced is of course still immutable. If `m.withMutations` were to recursively walk the data structure to convert all referenced collections to mutable, it would be extremely costly (O(N) instead of O(1)), defeating the purpose of having `withMutations` as a performance tuning tool.

A correct code would be:

 ```js
let m2 = m.withMutations((res) => {
    let y = res.get("y");
    res.set("y", y.set("b", 9));
  });
```

Or more tersely:

 ```js
let m2 = m.withMutations((res) => {
  res.setIn(["y", "b"], 9);
});
```

If there are multiple updates happening to the collection at `y` which suggest needing `withMutations` performance tuning, then that can be done as well:

 ```js
let m2 = m.withMutations((res) => {
  res.update("y", y => y.withMutations(yMutable => {
    y.set("b", 9);
  })
});
```

Remember that `withMutations` still always creates a copy from the original, so using `withMutations` to apply a single change is overkill and will be slower than just doing the simpler update directly. In general I suggest using `withMutations` only when metrics draw you to a costly piece of code, since normal immutable updates are already quite fast (O(logN)). 

I understand that the original example was intentionally contrived, but any code that updates a single or few values like this is best done directly:

 ```js
let m2 = m.setIn(["y", "b"], 9);
```
  Closing this aging issue - sorry for not getting to your question  Adding things to the prototype is a slippery slope to a hard to follow API and growing library weight. Especially for simple functions, it's preferred to have an external function provide the functionality.
  Thanks for the reminder - I'll get these bug fixes out in a new version today
 v3.7.5 is now on NPM
  This is now fixed in v3.7.5
  Note that you can convert between the two explicitly by passing to the constructor:

```
var es6Set = new Set([1,2,3]);
var immSet = Immutable.Set(es6Set);
var es6Set2 = new Set(immSet);
```
  Immutable collections do not change, so there are no methods for subscribing to changes. When you call a method like "setIn", that method will return a _new_ collection with that change having been applied, and the original collection will not have changed at all. 

If you want to send updates to React components when you have new data to provide, you need to ensure you're doing that directly with the result of the updated data store. 

For example, in your Link click handler, you're not using the return value of "store.set('aa', 100)" which would be the updated version of "store".

It's very much encouraged to use a "flux" like pattern or helping library when using Immutable with React. Redux is a great one. This pattern helps manage data flow so when you perform an update, you're doing so at the top level so there only needs to be one mechanism for re-rendering your app. 
  Merge is another way of saying "union" and a union definitionally never deletes anything. Does `deleteIn` suffice? Perhaps you could provide some code example of what you wish you could write which doesn't work at present?
 Closing this aging issue  This would break the behavior of the second argument to `get`. It would also break Typescript and Flow integration which expect a function to have a single return type. This would cause `get` to return either a value, or an array of values. This could lead to ambiguity. Should `get("id", undefined)` return one value? A list of one? A list of two with a second value of undefined?

Unfortunately I think this would break too many things to be considered.
 Destructuring would be awesome, ideally without having to use get.

I'm looking for the right way to support:

``` js
let { id, name } = myMap;
let [ first, second ] = myList;
```
 Thanks Tim :)
 Also, I believe I'm mistaken and `let [ first, second ] = myList;` works today, as this uses iteration rather than property access.
  This is now fixed in v3.7.5
  Closing this aging issue.

Trying to shy away from `toMap` and family, I'd prefer not to complicate them further.  Thanks Kevin! I'll get this out today
  Could you add what you expected in this case? I can explain what is happening at present: "merge" is an operation you perform upon a collection, but the value found at [2,"c"] is undefined. Perhaps we could improve the behavior or at least the error message in this case, but I'm curious what you expected the outcome to be if not an error. 
 Ah, I understand. At present, the operation you're attempting is covered by `setIn` - e.g. you want to take a value and position it at a certain path. `mergeIn` expects to operate on something which can be merged - some kind of collection - which undefined cannot. The value you provided `"hello"` is also not a collection and not mergeable.
 So these two variants should behave as you expect:

mergeIn against something collection-like:

``` js
test.mergeIn([2], { c: 'hello' })
```

setIn when wanting to position a value regardless of mergeability

``` js
test.setIn([2, 'c'], 'hello')
```
  > Looks like you are importing the "wrong" package. You are including this package from jbiasi and not immutable from Facebook (confusing, I know).

That's unfortunate :(
  This works as of v3.7.5 now on NPM
  The second item in your List is a JavaScript object, not an Immutable collection. You might instead want to type:

``` js
var test = Immutable.List([1, Immutable.Map({'a':1})]);
```

At which point your tests will do what you expect.

You may also want to use `fromJS()` to deeply convert from the inner JS structure you've defined. It will always produce List from Array and Map from Object.
 Could you open a separate issue documenting this? It may be a bug
  Closed in 59028b5e8552339acbdaab0c3f6547bd131f8f54
  Fixed in master, will be released soon!  This is behaving correctly. `List.of()` is a convenience method for creating a List from a list of arguments:

``` js
List.of(1, 2, 3)
```

If you want to create a List from an array, just call the List constructor directly:

``` js
List([1, 2, 3])
```
 Any suggestions on how you would like the documentation to be more clear? The primary landing page there has a number of examples of using `List.of()` throughout, and there is also the complete documentation at https://facebook.github.io/immutable-js/docs/#/List/of
 Thanks for bringing this to my attention anyhow. I'll mark this as needing better documentation in the future.
  Nope, this should not be possible.
 `Immutable.is` is at worst O(N), where N is the number of values in the tree, as it would need to compare every value in a tree. However, in practice often it is able to take short-cuts.

One short-cut is object identity, as you point out. If two sub-trees have object equality, `Immutable.is` does not recurse down them.

Another short-cut is short-circuiting on first mismatch. As soon as `Immutable.is` encounters an inequality, the algorithm halts and returns.

So the only time you the runtime is truly O(N) is when you have two value equal collections which contain  no object-identity subcomponents.
  Thank you for writing this! I added it to fromJS as well in ecae145be82a137f1b7f2d2fad67ad90e9c65ee1

> (I wonder if this confusion is why the ES6 Map doesn't have this kind of constructor.)

It definitely is one of the primary reasons that it does not. I think it's also one of the reasons it's not often used :)
  The issue here is not in Immutable, but JS objects. JS object properties are _always_ strings.

``` js
var x = { 1: 2 }; // { "1" : 2 }
var keys = Object.keys(x); // [ "1" ]
```

When you access a property using square-bracket notation, that value first gets coerced into a string before looking it up in the JS Object.
 Map, on the other hand, does not coerce to string first. Maps (ES6 Maps and Immutable.js Maps) allow you to store any kind of value as keys, strings, numbers, other Objects.
 I would love to entertain PRs for that kind of change to the docs!
 That's mostly right. I should point out that "all keys will be converted to string, am I right?" is not quite right - specifically there is no conversion happening as JSON object keys are _always_ already strings.

For example:

``` js
// Examples of valid JSON
{ "foo" : "bar" }
{ "true" : true }
{ "123" : 456 }

// Examples of invalid JSON
{ foo : "bar" }
{ true : true }
{ 123 : 456 }
```
 Added 59028b5e8552339acbdaab0c3f6547bd131f8f54 to help clarify further
 No problem at all. Thanks for the good questions, that led to better README!
 It's totally fine to use integers as keys - in fact that is a very common practice. However if you wish for an integer key and a string which happens to include that integer to both access the same value, then yes, you need some normalization between them - this is the same behavior as ES6 Map and Set.
  Records are defined with an explicit set of allowed keys.

So when you write:

```
var Car = Immutable.Record({});
```

You're defining `Car` as a kind of Record that always has 0 keys.
  I would suggest:

``` js
var index = 0;
myOrderedMap.forEach(function (item) {
  // do what you need to do with item and index
  index += 1;
});
```

As this will reduce the need to build a new structure, as `toArray` would.

Also, you may re-evaluate your use case and prefer to use a `List` if your primary need is to iterate over in a specific order with incrementing indices akin to an Array. `OrderedMap` is designed to mirror the behavior of the native `Map` and in many ways is similar to the native `Object`. Both of these native collections are not indexed, however happen to iterate over their entries in the order in which they were inserted (insertion order). Immutable.js's unordered `Map` does not make this iteration ordering guarantee, but has considerably better performance at nearly all operations and lower memory usage, as maintaining insertion ordering is not free.
 >  I guess I'm still struggling with the different between OrderedMaps and Lists and when to use what.

Another way to think of this is:

Would I usually use an Array? 
Use an `Immutable.List`.

Would I usually use an Object or ES6 Map? 
Use an `Immutable.Map`

But I need to preserve that insertion-ordering iteration order quirk JavaScript Objects have! 
Use an `Immutable.OrderedMap`
 Depending on how long these lists actually are, you may be better off sticking with a `List` and using the `find` method if you need to lookup by `id`.

Another thing you may consider is keeping both a `List` and `Map` together in parallel. Use the `List` when you need to work with orderings, use `Map` as a lookup from `id` to value. This is roughly how `OrderedMap` works.
  Maybe @chenglou should write that up in a wiki page here, good stuff!

But generally I agree with the suggestion here to add more detail on runtime expense, at least with a time order and ideally a little more flavor on the typical vs worst case vs amortized. 

I would be happy to entertain PR on these!
 This task is definitely still high value for any contributors.

The source of truth for documentation are the comments in type-definitions/Immutable.d.ts  You should check out [Record](http://facebook.github.io/immutable-js/docs/#/Record) which can work well as a Class substitute.
  Yes, this works today!

``` js
import { List, Map } from 'immutable';
var map = Map();
map = map.set(List(['something', 1]), "pair");
console.log(map.get(List(['something', 1]))); // "pair"
```

The Map keys are looked up based on _value_. This means you cannot create a new array to set and get from a Map. This will not work the way you expect:

``` js
import { List, Map } from 'immutable';
var map = Map();
map = map.set(['something', 1], "pair");
console.log(map.get(['something', 1])); // undefined
```

For the same reason:

``` js
var a = ['something', 1];
var b = ['something', 1];
console.(a === b); // false
```

This is also exactly how ES6 maps work:

``` js
var map = new Map(); // ES6 map
map.set(['something', 1], "pair");
console.log(map.get(['something', 1])); // undefined
```

However this will work (in both Immutable Map and ES6 built-in Map), because it refers to the same value:

``` js
import { List, Map } from 'immutable';
var key = ['something', 1];
var map = Map();
map = map.set(key, "pair");
console.log(map.get(key)); // "pair"
```
  ![](https://media.giphy.com/media/1guRIRO0SdOsRBDfL2M/giphy.gif)

![](https://media.giphy.com/media/Z9LMuhfk8iRuU/giphy.gif)

![](https://media.giphy.com/media/krOVpoDFxXgc0/giphy.gif)

![](https://media.giphy.com/media/a3IWyhkEC0p32/giphy.gif)

![](https://media.giphy.com/media/OtbZhLpNLxDoc/giphy.gif)
  Thanks for the report. It seems symbols arent playing nicely with our hash fn
  This is now fixed in v3.5.7
  I apologize for this. Unbeknownst to me, the open-source bot had a well-intentioned change recently that resulted in this noisiness. I will make sure this feedback is carried on to the responsible team.
 Thanks for letting me know. I got them as well and the team responsible for the bot is trying to make it more helpful and less noisy. 
  Merging into #505 

The `map` family should not belong on Records at all - `map` is for homogenous collections with Record is not.  I think this is intuitive because the regular find-index code in javascript does exactly this. Also, it would be a pretty big breaking change, so it would have to be quite valuable before it was worthwhile. I think that means the conclusion here is "wontfix", so I am going to close this pull request. Thank you for submitting it though - I really appreciate the spirit and the effort here.  Absolutely!
  Closing this aging issue - sorry for not getting to your question

`includes()` does indeed use `Immutable.is` which implements value equality for immutable collections  Closing this aging issue - sorry for letting it sit. Excellent work, @hleumas! Please feel free to add the package to the wiki on this repo!  Thanks!
 For future reference, once you squash your commits, you can just run `git push -f` to update the same PR without having to make a new one.
  Both write docs about the various predicates, also add an immutable value detection predicate at the top level of the API.
  Thanks for the report!
  `rest()` returns a Seq, not a List, so you'll need to accept something more generic. I'd recommend:

``` js
printNiceList(listOfStrings: IndexedIterable<string>)
```
 Closing this aging issue - latest in master has excellent types which will be released soon  At present, no this is not possible. Doing so would be a pretty significant performance penalty on `fromJS()`. 

It's also not recommended to rely on object identity when inspecting Immutable value equality. You might want to use `Immutable.is()` to compare the two values.
 It looks like this question is answered so I am going to close the issue!  ImmutableJS in fact does not support class-based inheritance. The current source class syntax is really misleading and I apologize for that, it's not actually creating an ES6 class. I'm working on a set of changes that will allow us to move away from the non-standard class syntax.
  Merged in 825e29ef98012d210f817905994529be09c45de2, thanks!
  Merged, thank you!
  It definitely is related, thank you for the report!
  Thanks for the report! I'll make sure to keep track of this case in #536 
  Thanks for the report, @tphyahoo - you're correct that the documentation isn't correct here. I'd actually like to change the behavior in 4.0 to match the documentation as a simplicity force.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  Thanks for your exploration and explanation, but I'm still a little bit confused.

Why could you not just slightly change your example to:

``` js
var square = input => input * input;
var timesTwo = input => input * 2;

var c2 = c1.update(square);

var c2 = c1.update(square(timesTwo(c1));
var c2 = c1.update(compose(square, timesTwo));
```

This gives you shorter and more versatile definitions for "square" and "timesTwo" -> it operates on the value of the cursor rather than the cursor itself, then you can use the pre-existing "update" function to group operations.

Is there a more real-world use case that you're trying to use that leads to this being necessary?
 Hmm, I'm sorry but I'm still a bit confused - I don't see where "groupedUpdates" fits into your examples. 

Because of the nature of cursor updates, an "onclick" does need to know about cursors, since calling `cursor.update` and ignoring the result (all React event handlers) implies the top-level mutation and side-effects that we use cursors for. 

To me, the 2nd example you illustrate there looks like a cleaner implementation. The component on-click is explicit about calling the cursor's side-effecting `update` method while the library functions are more generic since they operate on values rather than operating on cursors.
 To give more isolated feedback, if I were doing a code review and came across code that looked like:

``` js
function clickAction (cursor) {
  return cursor.update(someSortOfInput => someSortOfOutput)
}
function logAction (cursor) {
  return cursor.update(someSortOfInput => someSortOfOutput)
}
```

With the intention of being reusable or compostable, then I would recommend isolating the `cursor.update` calls outside of these functions. It's the inner `someSortOfInput => someSortOfOutput` functions within `cursor.update` which are reusable and composable.
 Regardless, I think we may be able to solve this using `update` without you needing to change how your methods work today.

When calling `cursor.update(value => ...)`, `value` will be the unwrapped collection. At this point you can call whatever you want on it, including `update` without triggering a change event on the cursor's root.

``` js
let onClick = partial(this.props.data.update, clickAction);
let onLog = partial(this.props.data.update, logAction);
let onClickAndLog = partial(this.props.data.update, compose(clickAction, logAction));

function clickAction (cursor) {
  return cursor.update(someSortOfInput => someSortOfOutput)
}
function logAction (cursor) {
  return cursor.update(someSortOfInput => someSortOfOutput)
}
```

This will still work as expected, each event handler will only result in one change event, since the values passed to `clickAction` and `logAction` are actually not cursors but regular immutable collections in all three cases
 Thanks for sending in this pull request. This has been stalled for a while so I think it is time to just close this pull request. It might be that this feature is useful, but it seems like we would need a more concise case for it to make it core-library-worthy.  I highly recommend you open this issue in the React repo. `toSeq()` produces an iterable, and that iterable is iterated over by the React internals _at some point_. It's up to React to determine how to do that iteration in a way that guarantees any assumptions it makes about context.

I'm closing this here since it's unsolvable from Immutable.js's point of view, but please reference this issue when you open it on React.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks! Could you finish your sentence? When is this useful?

Also, if you could please squash your commits then I can merge this!
  Thank you for the report!
 If the number provided to take is larger than the size, you'll get the whole collection (not a larger one).

This should either raise an error or default to an empty list (eg, undefined/null coerced to 0)
 Closing this issue now as the last release on npm solved the infinite recursion bug.

As far as the no-argument/undefined-argument behavior goes: since `take(N)` is shorthand for `slice(0, N)`, I think it's probably reasonable to expect number coercion to 0 and return an empty list as slice does. Throwing an error would be behavior differing from JavaScript, so I have concern that behavior would be surprising to many.

If you're looking for a method to return the last element, try `last()` - I think that's a clearer named method for the particular use case
  Hey, so right now we wish Cursor were actually separate from Immutable itself. We are considering kicking it out into its own repo or something like that. So if you're interested in maintaining it separately let me know! - otherwise I am going to close this pull request since Cursor-in-the-immutable-main-repo is something we would like to deprecate.  Hey @donabrams let's update this and get it working!

It looks like the transducer protocol suggests that it use symbols when available, should this do the same?

You can look at how Immutable implements the Iterator protocol for an example.
 Ok, we can omit Symbols for now and add them later. This is cool.

Could you please include some simple test cases? That will help ensure these never break in the future, but would also document the minimal use cases.
 This pull request seems like it has gotten stalled in "needs tests" state, and I theorize it is stuck there indefinitely, so I am going to close it. If someone is interested in working on this then I think it could definitely still be a useful area to work on though.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Ok, lets get that in there :)
  The keypath for Lists are just the index, so for the specific example, `[0, "phones", 2, "mobile"]` is the keypath to John's mobile number.

If you want to update a structure like this, a fixed keypath isn't going to work for you since there's no way to index on what you're looking to index on (name, and type of phone). Instead, you'll need to search through the List to find the index to update:

``` js
var indexOfJon = obj.findIndex(person => person.get('name') === 'john')
var indexOfMobile = obj.get(indexOfJohn).get('phones').findIndex(phone => phone.has('mobile'))
var updated = obj.setIn([indexOfJohn, "phones", indexOfMobile, "mobile"], "444");
```

Now: note that `findIndex` is an O(N) operation. It needs to potentially look at every item in the list to find the one that matches your criteria. If this is not a very common operation, or if this list is not ever particularly long, this is just fine. However if looking up people from this list by name is a common operation or the list of people is pretty long, you may find O(N) to have poor performance. If instead of a List you used a Map, access and updates would be O(1) instead of O(N) - much more resilient to larger lists.

Similarly with the list of phones, as your example illustrates a list of maps with a single key, you need to look through the list to figure out which to update, but then also remember to update at the correct key. This is probably pretty burdensome to deal with, and I would recommend a single map with many keys.

``` js
Map({
  john: Map({name: 'john', phones: Map({
     home: '111',
     office: '222',
     mobile: '333'
  }) }),
  ...
});
```

Note however the tradeoff here, that you can't have multiple people with the same name, or multiple phones of the same type when using this sort of structure.
 I think the first line of what I recommended:

``` js
var indexOfJon = obj.findIndex(person => person.get('name') === 'john')
```

Is precisely how you would implement your suggested `myMap.keyPathOf( john:Object )`.

The performance problem as I described it is not just going to be an issue with Immutable.js but with any collection, including the built in native Array. Searching through a list to find one matching instance will always be O(N) where having a lookup into a Map will be O(1). This is simply a tradeoff you need to make for yourself when architecting your client code.

If your REST API returns data that is not going to be efficient to operate on within the client, you can always manipulate it into a different shape first, and then use that later. But again, there are tradeoffs involved and every application will have different needs. Immutable.js is not here to be prescriptive about how you structure your data, but just give you tools to make those decisions for yourself.

> through reflection/introspection in ES6? or have it store the path info internally?

I'm not sure what you're referring to by reflection/introspection in this case. I'm also not quite sure what you mean by storing path info. I think a data structure that maintains a fast lookup of path for every unique object is going to require looking very different depending on each use case. What may be fast for one use case would be slow for others, and constraints may be different - if your data includes the same "john" in two places, it could have two key paths - each semantically different. 
  I think getting the type to work correctly is probably the next step in getting this right. I like this direction.

I'd also like to find a way to be able to require `immutable/Map` rather than `immutable/dist/Map` without causing too much turmoil in the build script and library developer experience.
 Thanks for starting to explore this!
 Thanks for the suggestion, @clintwood - I'll look into that.

@ryan953 - I'm not totally sure, but that's something we'll need to solve in order to make this really work for everyone.
 I think this pull request has essentially timed out. I am going to close it but if someone still actively wants to work on this then please feel free to reopen it!  This is a common request, so I'll try to figure out a way to assemble an API to do this. Perhaps `StrictMap` and `StrictList` or something like that.

Doing so comes with the direct tradeoff that immutable collection of pointers to mutable values would not be possible. Definitely not what we want for the only behavior as this sort of thing is pretty common, but I also understand the desire to enforce strictness and throw errors if trying to put a non-immutable value into an Immutable.js collection.
 Thanks, I'll keep considering ways to do this nicely. It's a careful line to walk between supporting generic collections and supporting deep values.
 Closing - see #473   I made the changes pointed out in the inline comments atop your rev, in case you want to inspect what changed.

Thanks again for investigating this!
 See https://github.com/facebook/immutable-js/commit/8031a8b8b6a74701f6c189ad62af41643b60f5e0 for final code
  I'd like to be not prescriptive about this and let individuals decide for themselves how they would like to name these if they use them in concert with the ES6 collections.

Using your example of ES6 destructuring, I would recommend:

``` js
var { Map: ImmMap, Set: ImmSet } = require('immutable');
```
 Using ES6 module syntax, the same can be accomplished with:

``` js
import { Map as ImmMap, Set as ImmSet } from 'immutable';
```
 Closing this, hoping the suggestions above are sufficient. Let me know if not.
  This is to be expected. We use `console.warn` to alert to misuse, and test cases often test that `length` is in fact reporting this error.

In a future version, this warning will be removed and code that relies on the behavior of using `length` will  break.
 Phantom.js emulates a browser which is why the warns show their way through.
  This has been fixed, and I've merged in your tests to ensure it
  Rather than exposing the internal structure of Immutable.js collections directly, we would probably want some method that is semantically the kind of operation you're proposing and bakes the performance improvements described into the implementation of such a method.

But I'm also not totally sure how what you're proposing would work or how you see it connecting to React.

Can you maybe type some slightly-imaginary future code that describes what you're trying to achieve from the React-side point of view, and maybe that would help me understand what Immutable.js would need to implement to fulfill it?
 Sorry for the delay. I think this is really interesting and obviously the performance benefits are really interesting, but access to the implementation details is pretty dangerous as those are likely to change in the future as Immutable.js encodes more optimizations.

One thing that we _should_ be able to leverage despite future changes is that Immutable collections are always structured as Trees. While exposing the structure of these trees are potentially fragile, perhaps there's some sort of memoizing map/fold we could support.

It seems like what you're finding is that when you have a very long list of components in React, a similar structural sharing approach with memoization is a powerful one. However It would be really interesting to see if a `List -> Tree` mapping transform could be useful to not just React but many other environments as well.
 Closing this aging issue.

See #38 for an example of how implementation details may change in the future, especially around operations like `slice` and `concat`  Thank you for the report
  Yeah I agree. Want to send a PR? :D  Go for it!
 I still think this one is a pretty cool idea - though I've been out of the loop on how often transducers are being used.  Closing this aging issue

It's not uncommon to create Records from a larger input data source.

For type safety concerns like this where a typo can cause a huge headache, I strongly recommend static type checking tools like Flow or TypeScript.  It looks like this issue has been fixed by the referenced PRs so I am going to close it.  Could you expand on what code you wish you could type which today does not yet exist? I think I understand the request, but am not entirely sure how you are hoping for it to be exposed.
 Closing this aging issue. I think this is just a fact of life in a JS environment unfortunately, at least until we get something like the [null-coalescing operator](https://en.wikipedia.org/wiki/Null_coalescing_operator) is added to the language.

For what it's worth, I use `.get('thing') || backupVal` pattern all the time myself.  I'm working on v4.0 which will include a major reworking of `Record` to no longer be `Iterable` nor have most of the collection API. For example, `map` in this case doesn't make a lot of sense.

Of course, the current behavior of returning undefined is pretty awful, but the new behavior will be that `map` is not even defined :)
  Sounds like this question is answered, so I am going to close the issue. Thanks!  `keys`, `values`, and `entries` return Iterators. They are stateful and can be consumed one time, every time you call `next()` on an iterator, there is no way to get to the previous item.

`keySeq`, `valueSeq` and `entrySeq` return Seq, which you can think of as an "Iterable". They are stateless and can be consumed multiple times. Seq is documented well elsewhere, but the primary value proposition is to use their laziness when composing multiple operations to improve performance.

For example:

``` js
var myMap = Map({ a: 1, b: 2, c: 3 });
var squareOddValuesList = List(myMap.valueSeq().filter(val => val % 2 === 1).map(val => val * val);
// List [ 2, 9 ]
```
 That's not quite right, an `Iterator` (`keys`, `values`) and `Iterable` (`keySeq`, `valueSeq`) present different APIs and capabilities.

`keys`, `values`, and `entries` return `Iterator` to match the behavior of the ES6 collections. The same methods on ES6 Map, Set and Array return `Iterator`s, and I wanted to ensure the Immutable.js collections could be used in the same way.

Seq present a full collection-like API rather than the more simplistic `next()` that an `Iterator` provides, but each has it's purpose. `Iterator` is an important part of many ES6-aware APIs that Immutable.js is designed to play nice with.
  Closing this aging issue. May come back to this in the future  Thanks for the suggestion! We're going to pass on this for now while we focus on fixing broken and embarassing things but if a number of people end up clamoring for this then we are open to reconsidering.  Can I ask for some examples of when this is useful in practice? It seems reasonable, but currying arguments like this can often present a performance issue, so I want to ensure I'm supporting the use case you have in mind.
 Thanks :)
 Thanks for the suggestion! We're going to pass on this for now while we focus on fixing broken and embarassing things but if a number of people end up clamoring for this then we are open to reconsidering.  Correct. This is a relic of an earlier version of the API which had deeper integration with a specific cursor implementation but should now be considered deprecated.
  This is unfortunately not backwards compatible because the second argument of `map()` is the context `this` which will be passed to the mapping function, mirroring the `map()` API found elsewhere in the built in JS collection - hence the need for `zipWith` to handle this case.
  Could you explain how you expect these static methods to act via example code? 

The same named static method on List or Stack accepts a variable list of arguments and builds a collection like `List.of(1, 2, 3)`, as a convenience to the slightly noisier `List([1, 2, 3])`.
 Just curious why you would prefer typing `Coll.of(...val)` instead of `Coll(val)`?
 We can do significantly more optimizations with `Coll(val)`, including structural sharing, which can't be done with `Coll.of(...val)` so I'm nervous about encouraging that sort of use.
 I'm actually leaning towards removing the `of` method in a future version. It was added for parity with [`Array.of`](https://gist.github.com/rwaldron/1074126#arrayof--variable-arity-) but notably `Array.of` serves a purpose that isn't particularly relevant for `List`.
 It looks like the conclusion here is to leave as is, so I am going to close this issue. Thanks for bringing this up and sparking some discussion!  Yeah, these should probably be replaced by using `concat`. Good suggestion.
  Ah, thank you for your investigation and straight-forward fix with comments. Excellent work!
  Thank you for this as well, I extended your approach to apply to Map as well. The same issue could have affected Map vs OrderedMap
  Can you explain a bit more about your complex object? If it's an object with a prototype, it can implement an `equals(otherObject)` function, which Set (and the rest of Immutable.js) will then use.
  Thank you!
  I would just iterate through all the stuff in a map and create a new list from that. If you're even still trying to fix this a year and a half later ;-) Anyway hope this worked out for you!  This is reasonable, I understand that it's something people want to use Cursors to do.
  Thank you for the report!
  Wow, that's huge data. 

Have you tried Transit.js? It can help with moving rich data from server to client. I would be curious if that is at all helpful. 

http://swannodette.github.io/2014/07/30/hijacking-json/ Explains how to set this up. 

I'm curious to know if that's helpful on the initial data construction
  Since this is a "stylistic suggestion" and super old I am going to close the issue. Thanks for bringing this up!  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Sorry for not spotting this sooner - this is great but the /dist/ files are auto-generated as output from /src/, so if landed as is, this work would be quickly replaced when the next PR is landed.

Could you ensure this change is applied to /src/ instead of /dist/?
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Merged (and squashed) in 35658506c294121ad3990745cccbe0f1980b3504. Thanks!
  React's propTypes have a well defined API that allows for extension. Because `PropTypes.instanceof` does not play well with value types, It would be excellent to have a sister library of Immutable.js specific PropTypes.
 That specific example works, but not all examples work.
- A variation of `arrayOf(SomeType)` for `immutableListOf(SomeTime)` for example.
- Support for cursors.
- Support for the more basic interface types like `KeyedIterable`
 I am going to close this issue under the theory that if it did not happen in Year 1, it will not happen. Feel free to object if there is some alternate theory for how this issue may become one day useful :P  Hmm let me look more closely at this. Equality checking currently takes into consideration if both sides are ordered or not. If neither side has defined ordering, it just looks for the same values in the sets (or entries in the maps) - but if one has ordering and the other does not - they cannot be considered equivalent because the iteration ordering will be different between the two.

@tgriesser how does this reconcile with clojure's equality semantics?
 It looks like the bug here is probably the unstable return type in union() if one is empty: the return type should always be the left hand side. Though I thought we had fixed that.

As far as equality goes, I know there are many definitions for equality (and ultimately many equality functions in some languages). However the equals() and is() functionality here should be "A could replace B for any operation, and produce the same result" - in which case OrderedSet and Set cannot be equal since OrderedSet makes a guarantee about iteration order and Set does not. Two OrderedSets which contain the same values but with different orderings are not equal. If you agree that should be true then it should follow that an OrderedSet compared to a _____Set of the same values but with any possible (eg undefined) ordering cannot be safely called equal either. Interestingly, an OrderedSet should always be able to stand in for a Set for that definition of equality, however equality must follow the Transitive property. If A = B then B = A
 Another possible issue here is the type constructors like Set() or the conversion functions which are short hands for those like .toSet()

Right now I think if you provide an OrderedSet to those that it returns itself since an OrderedSet is a kind of Set. Perhaps that's bad behavior given that it makes the "downcasting" equality comparison difficult. isSet() should probably still return true though, what do you think?
 Closing this aging issue - the bugs involved have long since been fixed.

  Records should not have the map/filter/reduce and other API methods useful for homogeneous collections like List and Map. Their operation does not do what is expected.
#220 #268
 Note when tackling this, ensure `isImmutable()` still returns true for record instances  I believe the issue here is that your first example is mis-using the record API.

```
var one = new Immutable.Record();
```

This line of code will create a new _type_ of record `one`. `one` is a function that when called will produce record values.

In your second example, you're using the record API correctly (though just a minor note, `new` is not necessary when calling these functions, but harmless). In those cases `one` and `two` are record _values_. We can use value equality to compare them.

_Value_ is an important part of what is going on here. Lots of the objects Immutable.js creates are treated as values by the Immutable.js APIs. The most important difference is in how equality is determined. `one === two` will always return false here because `===` means object reference identity. However if you wrote `one.equals(two)` or `Immutable.is(one, two)`, then you should get `true` as they are equivalent _values_.

Immutable.List's `indexOf` API uses value equality rather than object identity to find the matching index in the collection, and since `one` and `two` are value-equivalent, the first one encountered by `indexOf` is returned, which is why you're getting `0`.

In the first example, `one` and `two` are not values, but function objects, and they are not value-equivalent, which is why given a list of those two functions, indexOf will not see the first as equivalent to what you're searching for.

Please let me know if that's unclear, or if there's anything else I could do to make this sort of behavior more evident either via the API itself or via the documentation.
 `indexOf` uses `Immutable.is` to determine if it's found a match. That uses an `equals` method on each item if it finds one, which means if `object` in your example is an Immutable.js value, that it will use value equality not reference equality.

If you want to use reference equality instead, you could certainly write a bit of code to do that using `findIndex` which will let you define your own function to decide what is "found"

``` js
var i = list.findIndex(item => item === object);
```
  To detect NaN you can just do `value !== value`, NaN is the only value which fails that test.

Infinite recursion is bad news, so it would be nice to invariant here, however what I'd love to see is a test that `_capacity` can never become NaN in the first place.
 Thanks again for this investigation which inspired #511, fixing #459 
  Merged in dd4d8a56e1aa27c049683a16839f3814faa631c8
  You can find the source documentation here: https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts - it's all generated from that file. 
 The code that does the generation is in the gh-pages branch. https://github.com/facebook/immutable-js/tree/gh-pages?files=1
  The documentation represents the latest version of the library. `includes` was added in v3.7.1 in response to changes made in the ES6 spec around the same time. Please ensure you're using the latest version of the library.
  The collection constructor functions List and Map accept any kind of children, so in your second example you have a list of references to JavaScript objects. Since every JavaScript object is unique and not equal ({} !== {}) the two lists of JavaScript object will also not be equal. 

fromJS, on the other hand, converts it's input deeply - replacing JavaScript array with List and JavaScript object with Map at every level of the input. So in that first example you have a List of Map, both of which use value semantics and are equivalent. 

If you're ever not sure what the shape of your data looks like, try calling .toString() on it to see this illustrated in a pseudo-JSON form. 

To update your second case to pass, your collection construction should explicitly create a map:

List([Map({name: "Name: Tim Cook"})]);

Let me know if this doesn't answer your question. 
  Thanks!
  This is an interesting suggestion - such usage isn't currently supported. Right now, the input to the `Record` function should be a list of keys and their default values, so this is actually creating a record type where `getMoneyPrice` is a possible key, and the function 

```
   function () {
        console.log(this);
        if (this.moneyPrice) {
            return (`${this.moneyPrice}`).replace('.', ',');
        }
    }
```

is the default value for that key in the record. Because dot-access can be used to `get` keys from a Record, this sort of miraculously works despite not being directly supported.

I'm not entirely sure of what's going with get property, I've never actually tested doing that.

I'm working on a revamp of Record to simplify the API and improve it's flexibility for v4.0, and this sort of usage which currently sort of works will out-right fail in that version. I'll ensure there's a reasonable API for doing this though, tagging with enhancement.

With today's Record API, you could add these functions by altering the prototype of `Product` directly:

``` js
var Product = new Record({
    'id': 0,
    'name': null,
    'moneyPrice': null
});

Product.prototype.getMoneyPrice = function () {
    console.log(this);
    if (this.moneyPrice) {
        return (`${this.moneyPrice}`).replace('.', ',');
    }
},

Object.defineProperty(Property.prototype, 'needsPayment', {
    get() {
        console.log(this.moneyPrice);
        return (this.moneyPrice && this.moneyPrice > 0);
    }
});

var shoe = new Product({id: 1, name:'Super Sneaker', moneyPrice: 59.00})
shoe.getMoneyPrice();
shoe.needsPayment;
```
 What you've done there is perfectly supported as well.
 Hmm, this is pretty weird and maybe a bug. I'd recommend using different names for derived values for now, if only to avoid confusing behavior between get() and property access.
 Closing this aging issue - the best solution here is adding methods to the prototype of the Record, or using class extension.  What you're doing is about as good as you can do with the data structure as it's currently designed, but it's also a pretty expensive operation since you need to search through the list of children. 

If the "id" of the children are unique, then I would suggest modeling the children as a Map, or OrderedMap if the iteration order is important. Then you can use the much simpler and more performant setIn and updateIn methods. 
 `setIn` and methods like it (e.g. http://facebook.github.io/immutable-js/docs/#/Map/setIn) are best for applying updates in deeply nested locations.

The methods will always return a value of the same shape (nested maps and lists in the same form) and if nothing actually changed as a result of the method call, then it just returns itself, so you can use `===` to see if nothing changed.
 Lists share the same `*In` methods, so to do what you asked you would write:

```
var newData = data.setIn([1, 'children', 3, 'children', 1, 'children', 1, 'active'], true);
```

You should also see that if you were to have set a value where nothing has changed, that you will get back the same original value. So for example, if you were to set true again:

```
var sameData = newData.setIn([1, 'children', 3, 'children', 1, 'children', 1, 'active'], true);
sameData === newData // true
```
  Alexey, I don't fully understand the behavior you're looking for. Could you supply some various examples of arbitrary nesting and the expected output of this operation? I'm curious for more examples of data of type:

type NestedValue = Array<NestedValue> | String
 That should be Array< NestedValue >
 Sorry, I meant List<NestedValue>, not Array<NestedValue>. But also, it's not yet obvious to me from your examples, so please humor me with more input to understand the pattern.

Here are the examples you've provided so far:

``` js
[ [ 'a', 'b' ], [ [ 'c', 'd', 'f' ] ] ] => [ [ 'a', 'b' ], [ 'c', 'd', 'f' ] ]
[ [ [ 'a', 'b' ], [ [ 'c', 'd', 'f' ] ] ] ] => [ [ 'a', 'b' ], [ 'c', 'd', 'f' ] ]
```

I'm curious about:

``` js
[ [ 'a', [ 'b' ] ], 'c' ] => ?
[ [ [ 'a' ] ], 'b' ] => ?
[ [ [ 'a' ] ], 'b' ] => ?
[ 'a', [ [ 'b' ] ], 'c' ] => ?
[ 'a', [ 'b', [ 'c', [ 'd' ], 'e' ], 'f' ], 'g' ] => ?
```
 What is your predicate in this case?

We would likely need a different kind of method or utility function for this sort of operation, since the flatten function is "greedy" to maintain an optimal O(N) performance.
 I'm having trouble following the purpose and behavior of the `getMapPaths` function, but I think I better understand now what you're looking for from a flattening point of view.

Hopefully this code will help you out:

``` js
import { List, Iterable, fromJS } from 'immutable';

function flattenIf(pred, list) {
  function flattenIfReducer(_list, item) {
    if (Iterable.isIterable(item) && pred(item)) {
      return item.reduce(flattenIfReducer, _list);
    } else {
      return _list.push(item);
    }
  }
  return list.reduce(flattenIfReducer, List());
}

function isListOfLists(list) {
  return list.every(Iterable.isIterable);
}

var myDeepList = fromJS([ [ 'a', 'b' ], [ [ 'c', 'd', 'f' ] ] ]);
var customFlatten = flattenIf(isListOfList, myDeepList);
```
 I studied your `getMapPaths` function a bit and I think I understand what you're trying to do here, please correct me if I'm mistaken:

I believe you want to provide a Map of Maps, like 

``` js
{ a: { b: true, c: true }, d: true, e: { f: { g: true } } };
```

And then produce a list of all paths to leafs, like

``` js
[ [ "a", "b" ], [ "a", "c" ], [ "d" ], [ "e", "f", "g" ] ]
```

If this is the goal, then you should be able to write a recursive reducer for doing this without a need for flattening afterwards. You should also avoid going back and forth between native JS arrays and objects and Immutable collections by using `fromJS` and `toArray` within utility methods like this - those require full copies and will add up to be quite poor on performance and should not be necessary.

Here's a recursive reducer version of `getMapPaths` which expects Immutable collections as input and returns Immutable collections as output without producing deeply nested lists.

``` js
function getMapPaths(deepMap) {
  return _reducePath(List(), deepMap, List());
}

function _reducePath(paths, map, path) {
  return !Map.isMap(map) || map.isEmpty() ?
    paths.push(path) :
    map.reduce(
      function (paths, subMap, key) { 
        return _reducePath(paths, subMap, path.push(key)) 
      },
      paths
    );
}
```

Then to use it:

``` js
var deepMap = fromJS({ a: { b: true, c: true }, d: true, e: { f: { g: true } } });
var paths = getMapPaths(deepMap);
console.log(paths.toString());
// List [ List [ "a", "b" ], List [ "a", "c" ], List [ "d" ], List [ "e", "f", "g" ] ]
```
 Thanks, I'm closing this task out since we're in a better place :)
  Thanks for this feedback! I wanted to keep the example as simple as possible but understand why this was confusing. I made some modifications to make them buttons, https://github.com/facebook/immutable-js/wiki/Immutable-as-React-state
  You can do this if your object has a "hashCode()" method. It just needs to return an int. objects that implement hashCode also need to implement "equals(other)" and return true if the two are equivalent. Two equivalent MUST return the same hash code, but the same hashCode doesn't need to guarantee equality.Â 

This hasn't been formally documented yet, but I don't think it will change.Â 

â€”
Sent from Mailbox

On Mon, Jun 1, 2015 at 1:18 PM, Matthew Dapena-Tretter
notifications@github.com wrote:

> Are there any plans to allow objects to define their own hashing algorithms a la Python's [`__hash__`][1]? It seems like it would just require making `UID_HASH_KEY` public (though I can also see an argument for not wanting to introduce new equality semantics into JS).
> 
> ## [1]: https://docs.python.org/2/reference/datamodel.html#object.__hash__
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/490
  Do you have a suggestion for what the method name should be that would be familiar and idiomatic to mongo users?
 Closing this aging issue

However if someone would ever like to resurrect this, I think it would be cool to see a PR illustrating what this would take.  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Very nice
  Thank you for the report!
 Thanks for your investigation!
 It looks like the second should probably also throw an error. getIn expects an Iterable collection of keys. Strings are Iterable but often not considered collections because that leads to confusion. 

Would you please open a separate issue for this other issue?
  remove() is not safe on OrderedMap, but is on Map within a withMutations block. Sort is not safe within withMutations block.Â 

â€”
Sent from Mailbox

On Sun, May 24, 2015 at 9:34 PM, umphy notifications@github.com wrote:

> Hi, I'm trying to perform `remove()` and `sort()` inside a `withMutations()`. Now the documentation says that only `set()` and `merge()` can be used with a mutable collection. However, [this post](https://github.com/facebook/immutable-js/issues/228) suggests that `remove` is safe to use with a mutable Map.
> 
> ## Can someone please let me know whether I can use `remove()` and `sort()` for an OrderedMap in `withMutations`? Thank you.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/485
 remove() is perfectly safe on OrderedMap, just not within a withMutations block. Only set and merge are safe there. 
 And sorry, "safe" isn't really the right word here. It's of course perfectly safe to use that method - but just be clear as to the behavior. remove() never performs a mutation on a mutative collection (e.g. Within a withMutations block) it always returns a new collection. 
 `remove` is actually implemented as a `filter` for ordered map. Removing multiple times will be `O(MN)` where N is the size of the collection and M is the number of keys you remove. Writing a single `filter` will be `O(N)` which will be nice if you're moving a number of things.

The wiki has a nice feature on this exact operation, often called `omit` by other libraries: https://github.com/facebook/immutable-js/wiki/Predicates#pick--omit
  This is about the constant time speed difference I would expect. Native Array is full of performance optimizations and relies on mutability which will always beat immutable data in raw-perf numbers. On average Immutable.js operations are a constant time 5-15x slower than native operations, depending on the operation. In part due to their being implemented directly in JS rather than in the VM, but also because the operations themselves are more involved.

The performance wins (both time and memory) come from opportunities to use structural sharing between operations, which unfortunately `concat` currently does not provide.
 You're correct that `concat` is a good candidate for structural sharing, and in fact there is pretty great research on how to do this - #38 is tracking this enhancement that I'm excited to have in the future.

The stock `flatten` implementation does in fact use laziness and that's likely to win back a lot of performance for this scenario.

``` js
// Immutable.JS flatten
xs = Immutable.Range(0, 700).toList();
item = Immutable.Range(0, 50).toList();
bigList = xs.map(function (x) {return item});
t = +new Date();
bigList.flatten();
console.log(new Date() - t);

// Persistent non-lazy native Array flatten
xs = Array.apply(null, Array(700)).map(function (_, i) {return i;});
item = Array.apply(null, Array(50)).map(function (_, i) {return i;});
bigList = xs.map(function (x) { return item; });
t = +new Date();
bigList.reduce(function(x, v) { return x.concat(v) }, []);
console.log(new Date() - t);
```

On my machine, the non-lazy raw Array flatten (your original code) ran in 33ms, but Immutable.js's `flatten` method ran in 20ms due to utilizing laziness under the hood - it avoids building the intermediate data structures.

mori uses many of the same techniques as Immutable.js (in fact, Immutable.js was inspired by ClojureScript's data structures) and has a similar performance profile, but also has undergone a lot more performance tuning and so that constant time slow down relative to mutable native arrays is more like 4-8x for mori (depending on the operation). ClojureScript (and mori) also do not yet feature RRB trees for enabling structural sharing in the concat case as far as I know.
  You should check out [`merge`](http://facebook.github.io/immutable-js/docs/#/Map/merge). It has exactly the API you're after. `mergeDeep` will handle the nested values.
 It's also perfectly fine to use an object (mutable or immutable) as a key, so the `set` API accepting a JS object is a supported use case
  Immutable.js hopes to mirror Math.min/max behavior as far as ordering goes, though min/max for collections may be comparing things other than numbers, which is why the return values are not the same as Math.min/max - those methods always coerce to numeric values to compare where Collection min/max does no numeric coercion. 

It is intentional that NaN is poisonous as it's meant for error propagation. NaN is usually a surprising value and you don't want to mask over errors by default - but instead handle them explicitly when they're possible.
  In this case the list itself is not being mutated. The list contains the same references to JavaScript objects before and after the operation.

In this example the list elements are mutable JavaScript objects and your update operation is mutating the JavaScript object held at the index, however the object is still the same object. In this case we can say this list is not "deeply immutable". In many cases this is preferable, but I assume you are expecting to be operating on deeply immutable data. 

Immutable.List() is a shallow constructor. It accepts an array of anything and creates an Immutable List of those same things, and makes no assumptions about what those things are - mutable or immutable. 

If you want to deeply convert nested JavaScript arrays and objects to become a deeply immutable nested List and Map, you should use Immutable.fromJS(). 

Once deeply immutable, an update operation which alters an immutable item in the list will result in a new item with that update operation applied (editing the "b" key in your example), and the new list will have to refer to this new item in the same position, and so you will get a new list with the update applied as the result of the "update" method. 
 The issue in your example is the line `item.b = [{a: 456789}];`. There are two issues.

The first issue is that `item.b = ...` is a mutative operation on a JavaScript object, rather than part of the Immutable.js API. You should notice when inspecting newItems.get(index) that in fact the "b" item in the map has not changed, but that instead you've mutated the implementation of the data structure with a b property that isn't be used anywhere by Immutable.js. If you want to do a set operation you need to use the `set` method: `item.set('b', ...)`. After changing your code to use Immutable.js `set` method instead of the JavaScript mutative property setter, indeed `items !== newItems`.

``` js
var items = Immutable.fromJS([{a:1, b:[{c:1}]}, {a:2, b:[{c:2}]}]);

var index = 1;
var newItems = items.update(index, function (item) {
   return item.set('b', [{a: 456789}]);
});

console.log(items === newItems); // false
console.log('old: ' + items.get(index));
console.log('new: ' + newItems.get(index));
```

The second issue is that when setting to `"b"` in `item`, you're setting a JavaScript array of a JavaScript object, not an Immutable.js List with a single Immutable Map. While this might be fine in some circumstances, my guess is that is probably not what you intended considering that the previous value was an Immutable.js List and Map. The final console.logs in that prior block of code will emit:

```
old: Map { a: 2, b: List [ Map { c: 2 } ] } 
new: Map { a: 2, b: [object Object] }
```

So again you probably mean to be constructing Immutable.js collections there either by doing so explicitly: `List([ Map({ a: 456789 }) ])` or via conversion: `fromJS([{a: 456789}])`
 Another tip - when doing these kinds of deep edits, the `*In` collection of methods are really useful - in this case you could replace the `update` and `set` combo with `setIn`:

``` js
var items = Immutable.fromJS([{a:1, b:[{c:1}]}, {a:2, b:[{c:2}]}]);

var index = 1;
var newItems = items.setIn([index, 'b'], Immutable.fromJS([{a: 456789}]));

console.log(items === newItems); // false
console.log('old: ' + items.get(index));
console.log('new: ' + newItems.get(index));
```
 `mergeIn` is probably what you're after for that. There's also `mergeInDeep` which will apply deeper merges.
 @reduxdj AFAICT these functions are already documented. Which page on the docs do you think should be better? Also pull requests are welcome - if you tag me on a docs PR then I promise I will review it real soon :P  Thanks for the report!
  `splice()` operates similarly to `map()` and `filter()` - it cannot be used within a withMutations and also cannot be used to update a cursor.

The right way to insert within an array when using cursors is to refer to the referencing element:

``` js
// instead of 
parentCursor.get('mylist').splice(...);
// do:
parentCursor.update('mylist', list => list.splice(...));
```

That same pattern will work for other kinds of map/filter operations as well.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Most excellent
  This is intentional - only a select few methods can be used in `withMutations` for List those are `set`, `push`, `pop`, `unshift`, and `shift`.

I'm adding these to the documentation now.
  I'm a big fan of the Option structure, but I think it's beyond the scope of the purpose of this library.

I think https://www.npmjs.com/package/option is pretty simple and useful.

Having the prototype methods return these structures is bit more complicated, as @Laiff points out that would be a breaking change and it's also not very idiomatic. Most javascript programs (for better or worse) expect to operate with the null and undefined primitives as a sentinel for "none", and since Immutable.js strives to be idiomatic when possible - I don't think a change like this will be appropriate.
  Perhaps better to use `mapKeys` for this?
 Also - is this function trivial enough that it may be more appropriate to be defined when used?

``` js
function renameKeys(keyMap) {
  keyMap = Iterable(keyMap);
  return myMap.mapKeys(k => keyMap.get(k, k));
}
```
  Great point! I'll try to figure out a way to include these kinds of methods on OrderedSet and OrderedMap
 I don't think so... as it's not indexed, it just has a fixed and specified iteration order vs non-ordered `Map`'s unspecified iteration order.
 Closing this aging issue - note that you can always convert OrderedSet and OrderedMap to various kinds of Seq to access different kinds of lazy indexed APIs at O(N) cost.  Yeah, @Gozala and I have been discussing ways to add these sorts of constraints correctly. #407 has a lot of interesting discussion as we investigate.

Part of the difficulty in getting this right is that it's pretty common to actually want to refer to a plain JS object within an immutable collection. For example, when mapping over an Immutable collection to produce React elements, you're producing plain JS objects - and if some flag was set to disallow plain JS objects, then we couldn't use Immutable.js with React anymore. Or at least not nearly as clearly.

Part of what doesn't feel right here is purely syntactical. Typing `Map({key: "value"})` is just more verbose than typing `{key: "value"}` so I definitely understand the desire to type what is syntactically most simple.

I'm definitely open to more discussion on this front - and hear out any interesting ideas people have.
 Closing this aging issue.

For those looking for guarantees about deep immutability, I strongly suggest using Flow or Typescript so that you can provide static type checks making guarantees about what kinds of values are passed around your program. For our products at Facebook this has effectively solved this sort of issue for us. The added benefit is that this checking doesn't need to be done at Runtime which maintains a performant and slim deployed program  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Hey, thanks for submitting this! I'm sorry for not getting back to you earlier. Since this is old, not a huge pull request, and has conflicts I am just going to close the pull request. It's also kind of a judgment call and keeping the `apply` is probably just OK.  Certainly nothing about the code you've posted here is incorrect. From your stack trace it looks like your application is treating the Immutable `List` as an array somewhere - see `arrayEach` and `baseMerge` which are not part of React or Immutable's codebases.
  Do you have a suggestion for what kind of data structure to use? As far as I was aware, most environments that rely on persistent immutable data structures use a Persistent Vector for both Lists and Queues. That's partially why I choose to only implement List - it has the shift/pop API you want for a Queue, and both operations are the ideal O(log<sub>32</sub> N).
 Perhaps worth implementing a variation http://blogs.msdn.com/b/ericlippert/archive/2008/02/12/immutability-in-c-part-eleven-a-working-double-ended-queue.aspx - when reading couldn't help but think of "middle out" jokes.
 Yeah that seems fine. I usually encourage people to just use List directly and use the `shift` and `pop` methods as `enqueue` and `dequeue`.

The issue with a double-linked-list is that such a structure can't be make immutable. Imagine what "enqueue" would need to do - after creating the new node and pointing to the previous tail, the previous tail would need to be mutated to point to the new tail. Since the nodes are immutable, we would need to clone that node with the edit pointing to the new tail. Then the next node which was pointing to it also needs to be edited and you end up cloning the entire list on every operation, making `enqueue` and `dequeue` both O(N), a sad result.

What that MSDN article describes is called a "finger tree" - which is very similar in structure to the "bitmap vector trie" that is used to implement List, but ensures access to the beginning and end is only one link away while access to the middle is log N links away - making `enqueue` and `dequeue` amortize to O(1) - pretty awesome. In practice, if your queues are smaller than say... 1000 items, a "finger tree" and a "bitmap vector trie" are going to have identical performance. But if your queues are in the 10000+ category and are highly volatile, then using such a structure could squeeze even more performance. That's why adding such a new structure isn't going to be high priority, but still very interesting.
  Immutable.js doesn't have a SortedSet data structure yet, but I'd love to have one in the future. 
 Merging into #88
  Hmm bummer - seems like perhaps an issue with using web fonts. Do you encounter this on any other websites with the same Browser/OS?
 Still broken?
  Can you let me know what browser version and OS version you're encountering this?
  #seemslegit
  Sweet
  I would suggest that rather than passing in a result of `map`, that you instead pass in the original list, and allow the component's render function to perform the `map` - that way you can rely on the equality of that original list.

Otherwise, what you're describing is a memoization function, which should be independent of what operation you're doing (map, sort, slice, anything). Such a memoization function is beyond the scope of Immutable.js, but certainly something that you build yourself with very little amount of code.
 The reason Immutable.js doesn't contain memoization like this is that it makes referential vs value equality even more observable than it already is, which is something we're trying to avoid. - It also can lead to memory leaks if the memoization cache doesn't clear over time - and that behavior is usually application specific rather than library specific.
 Also I should note that referential equality is a performance optimization to be used by value equality - which is the recommended way to compare equality of immutable collections.

The rule of thumb usually being:

Use value equality to determine if two immutable values are equal or not - for whatever purpose you need. If you're concerned that comparing value equality will be expensive for some reason, and you're only using equality to shortcut some work (e.g. memoization), then use referencial equality as that shortcut. It will guarantee you that you'll never get a false positive (unequal things claiming to be equal) but you will often get false negatives (equal things claiming to not be equal).
 > Not sure I follow. Are saying you'd like library consumers to just call .equals() without thinking too hard about whether referential equality is being used vs. a deep compare?

Correct. If you want to know equality, use `.equals()` or `is()`. If you're writing a memoization function and you're wanting to think about the tradeoff for false-negatives and re-running whatever you're memoizing, then you can use `===`.
 Basically, reference equality is just a performance optimization for `.equals()` - so I want to avoid any API changes or performance hits just to enable this performance optimization more often.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thanks!
 Thanks @kemitchell!
  Can you please point to where you're seeing the trailing commas? I'm happy to correct this - I definitely want to preserve IE8 support.
 Thanks for the report - at least uglify strips them by default, so the minified source will be IE8 safe. I'll clean up the rest.
  Array's no, but Immutable List yes. It should work exactly as you've typed it.
  Thanks for the report!
 Fixed by #511 
  This is a great suggestion. Other libs call this "zipLongest" but I kinda like "zipAll"
 Nice work @mduvall! This is definitely a good start where undefined is the default value. Let me review your diff a bit closer, but at first glance it looks great
  Good idea!
  For your second example, if you `merge()` instead of `mergeDeep()` then you will get the result that you expected. `mergeDeep()` attempts to merge at every level it can, including within lists.

Merge never removes fields - you can think of merge as analogous to "union". If you want to remove fields, you should explicitly use `delete()`
  You want to convert the class B instance into an Immutable Map?

You could write a function to do this deeply like:

``` js
function fromJSGreedy(obj) {
  if (Array.isArray(obj)) {
    return Immutable.List(Immutable.IndexedSeq(obj).map(fromJSGreedy));
  }
  return Immutable.Map(Immutable.KeyedSeq(obj).map(fromJSGreedy));
}
```
 Beware of converting non-plain objects - any enumerable property will become a key in the map. In some cases on some browsers that can include keys from a prototype. Also some non-plain objects don't have any enumerable properties and will result in an empty Map.
  The problem with this approach is that it becomes very expensive. `isPlainObject` is called many times through Immutable.js and changing it from an O(1) to an O(N) operation to support an obscure use case is probably the wrong tradeoff.

I would strongly suggest using a custom version from `fromJS` which supports exactly the characteristics you're looking for if the version that comes with Immutable doesn't work for you.

If your data that's been created in a different realm is safe to convert (e.g. has no complex or exotic objects - every object can be safely replaced with Map), then you can use a very simple implementation of fromJS:

``` js
function fromJSGreedy(json) {
  return Array.isArray(json) ?
    Immutable.List(Immutable.IndexedSeq(json).map(fromJSGreedy)) :
    Immutable.Map(Immutable.KeyedSeq(json).map(fromJSGreedy));
}
```
 I think this pull request has timed out, so I am going to close it. I think it would be an improvement to have something `O(1)` here that just works a bit better so if you are interested in making that work then please feel free to reopen!  You can use the variants without "In" suffix in this way. 

For the example you gave, if you instead call props.get("items") it will return the value you expect. 
 Good idea, Tim!
  You can check if something is an Iterable immutable collection with Iterable.isIterable()
 It's on my plate to make a nicer API for this, but you can use Immutable.Iterable.isIterable() to see if an object is any of the Immutable.js collections. Otherwise each type has a Map.isMap() or List.isList() etc that you can use if you're checking just one kind of collection. 
 Yes, I agree. I added a task to track at #566 
  Yep! Thanks for the fix.
  You can use the `.map()` directly in React v0.13 or later (v0.13.1 is the last release, v0.14-beta is also out), v0.12 requires children to be an Array but v0.13+ can accept an Iterable. All Immutable.js collections are Iterables.

If you're stuck using v0.12 for some reason, just write `.map().toArray()` to convert to an Array.
  Yes, `splice` is supported and works very similar to Array.prototype.splice - http://facebook.github.io/immutable-js/docs/#/List/splice

For making edits deeper in a structure, `updateIn` is your friend - http://facebook.github.io/immutable-js/docs/#/Map/updateIn

You can of course combine the two. In fact all of the short-hands like `setIn` are just 1-line implementation functions which combine `set` with `updateIn`.

Here's what that might look like for you:

``` js
var updatedDeepData = 
  deepData.updateIn(['path', 'to', 'items'], list => list.splice(position, 0, itemToAdd));
```
  This is actually counter to the purpose of the converter function. If you omit it, a default converter is used which converts Arrays to Lists and Objects to Maps, however the converter function is there to allow for overriding this behavior.

For example, if I wanted Objects to produce OrderedMaps and Arrays to produce Sets, I could write a converter function to do so. However, after this change, my OrderedMaps would get converted back into Maps and my Sets back into Lists.

I'm curious if you think this functionality is presented in a flawed way - or if the documentation around it just didn't make these cases clear enough?
 I'm also curious for what purpose you're using the converter function? Your example shows just using an identity function - but presumably that's not particularly useful in practice?
 Sorry for the delay, I've been out for a while. I'll get back to this really soon! I'm excited to get this right
 This PR still has the primary concern of coercing the initial inputs into concrete structures first, which is at best a serious performance penalty but at worse an unexpected coercion.

If you could find a way to handle this such that intermediate concrete structures are not created, I think you would be onto something.
  Thank you for investigating this and for this solution! I had to make some changes, but the approach is the same and the test is very close to the one you wrote. 
  Can you illustrate the user-land code you wrote that resulted in the exception? I can start with that to turn into a test case.
 I started with:

``` js
var iterator = Immutable.List.of(1,2,3).slice(0, 0).values();
expect(iterator.next).to.deepEqual({ done: true, value: undefined });
```

And this currently passes and does not throw.
 Thanks for surfacing this area - a bug and repro was found
  Note that `map[1]` first coerces `1` to `"1"` and then does a look-up in the JS object, which is why this is a commonly misunderstood behavior of JavaScript.
  The best practices are to use `.get()` when you need a specific value, and make use of the `.filter()`, `.map()` and other higher-order functions to convert to react children.

I'll update that wiki page.
 Wiki page updated to match this info.
  Another way to phrase this is that it maintains the existing mutability of the plain JS object. This is by design. Immutable collections can contain any values including references to mutable objects. 
 A future major version of immutable will have a way to determine if a collection is "deeply immutable" and contains no references to mutable objects
  Very cool. I'll probably hold off on adding something like this into the library itself until the support is broader, as people are concerned about library byte weight, but this monkey patch is a pretty great way to start experimenting with this.

I imagine Record would want the same sort of support from Proxy.

I'm curious - what kind of performance constraints does Proxy have in the FF nightly? Does this code perform with some overhead compared to using .get() directly?
  Closing this aging issue

Cursor isn't under active development  Since there are only a small number of collections now, there's unlikely to be many bytes shaved. In some earlier experiments I found that doing something like this could save about 1.5KB from the 15KB total if you only used Map and never List or vice-versa, but if you used both it could add up to 4KB _more_ because of the overhead of babel/webpack vs the current inlined build.

This is something I want to keep on deck for a future v5.0 where I hope to simplify the API and factor some functionality into separate pieces.

Also, as new collections are added in the future - the value of this will improve.
 I'll leave it open for 5.0. There's a PR exploring this directly
 Unfortunately this is not yet possible - perhaps in a future version  Closing this aging issue

However It would be really exciting to see someone make this happen in a PR in the future  This conflicts with the work happening on the 4.0 branch (see: https://github.com/facebook/immutable-js/commit/5001072516a65b1245b528f88556ae4d1e4871fe).

But perhaps there's another way to solve your problem. Could you actually explain the problem you're solving? I understand what this code is doing, but I'm just not quite sure why you would want to do it.
 Ah, okay, I see what you're saying.

Perhaps a better way to do this is with a custom factory function:

``` js
var _MyRecord = Immutable.Record({
  reference: null,
  status: Status.AWESOME,
  availableSince: null
});

function MyRecord(initialValues) {
  if (!initialValues[availableSince]) {
    initialValues[availableSince] = moment().toISOString();
  }
  return _MyRecord(initialValues);
}

var one = MyRecord();
console.log(one.availableSince);
```
 If you're using the class syntax, this would be a constructor function which calls `super()`
  Not necessarily a typo, it just made an assumption that you had imported a local Seq variable from the immutable module. I agree this is more clear though. Thanks!
  Unfortunately any library which _requires_ mutation will not work well with immutable data.
  Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks for your exploration on this.

This concept has come up a few times before (#237, #310) and has some serious flaws that keep it from being part of the core library.
- General disagreement on key path format. Some want dots, some want JSONPath, and there are other competing standards. I don't think it's the place of this library to make a call on this.
- Unclear how to support keys which include the character `.`. It also encourages client code to build these key paths, and it becomes easy for a client to write the code `keys.join('.')` which could result in some pretty crazy and hard to debug errors if one of those keys happened to have a `.` in it.
- Ambiguous support for indexing into Lists. Should `"a.1.3"` translate to `["a", "1", "3"]`, or `["a", 1, 3]`, or `[a, "1", 3]`, or `["a", 1, "3"]`. All are legitimate and different interpretations.
- Missing support for complex keys. If my Map is keyed on some complex key type, I can't use keyPath. It's a bit arbitrary for the feature to exist but only support a subset of the library's capabilities.
- General concern about extending the polymorphic shape of these functions. Passing a string where a keyPath is expected is actually a pretty easy mistake to make - usually you intended to use a different method (e.g. passing a single key to any of the `*In` methods when you meant to use the non-deep variant). The purpose of TypeScript and Flow is to help detect these kinds of errors. This change will remove that pitfall detection.

Since the implementation of this is usually very specific to a certain application's assumptions and also usually very simple (in your case, just a `split`), I recommend including a helper function in your own library code. It's slightly more verbose, but also gives you complete control.

``` js
// Vanilla Immutable.js
m.getIn(['a','b','c']);

// Your proposal
m.getIn('a.b.c')

// Using a helper function
m.getIn(p('a.b.c'));
```

Where `p()` can be whatever you want, even just `p = pathStr => pathStr.split('.')` as proposed here, but also could be a JSONPath parser, or as I proposed in #310, `p = pathStr => pathStr.split('.').map(k => parseInt(k, 10) || k);`
 >  In my mind why even bother with get vs getIn just have one function that does both. But thats a matter of taste.

It's also different functionality! Since Maps can have complex keys, the array itself could be a key into a Map, so having one function that does both would limit these uses.
 All the same reasons, @pedroteixeira. Separator escaping is one of many issues. JSON path (and anything with escaping rules) generally still has a "whoops, forgot to escape that" pitfall anyhow. 
 Your suggestion on contrib libs is having access to adding things to the prototype?

Certainly anyone could mutate the Immutable.js prototypes today, I wouldn't recommend doing that instead of using functions, but it would certainly work.
  Yes, any Map key that means something specific in the context of an Object property will be dangerous to convert to a JS object.
  Which two tests failed? Can you confirm what version of typescript you are using?
 Sounds very much like an issue with your local version of typescript. Can you ensure the version of typescript you're using matches the version required by the package.json of this library?
 I just updated package.json to restrict anything above 1.4.x until typescript wraps up their work on 1.5.0 and I can verify it doesn't break anything. Hopefully this fixes things for you.
  Could you please write up a jsfiddle or gist or something which illustrates the issue? I can't figure out how to reproduce the problem from just this description.
 Closing this aging issue  Await already means something specific as an ES7 proposal that is very different from what withMutations does. I think this would be more confusing, and not adding enough value to be worth the pain of having to migrate all existing users of this library through a change to a pretty common API.
  If you need targeted updates, then you may consider using `Map` instead of `List`. `OrderedMap` if the iteration order of the items is important.

> Now I want to get a new version of my_list where approved value is changed(to true or false) only for Map's with ids in ids array.

This will be an O(N) operation where N is the size of `my_list`. It could instead be an O(M) operation where M is the number of ids to update instead.

If you wish to use a List, then the code you originally post looks like it will work just fine. If you wish to use a Map, then the code @camspiers posted looks great.
  I think there's bound to be confusing no matter which direction we go. Vector was confusing to some before because it implied a certain kind of data structure and the properties associated with that data structure. Array is confusing because it's not the same API as JavaScript's Array (notably, no [] access). List does refer to Linked-List in some languages, but also refers to the abstract type of collection in other languages - abstract from any implementation. Tuple also fits this description, but is often used to describe lists of a fixed size where each index holds a different kind of value. Again, potentially causing confusion.

We can bike shed on this as much as we want, but in terms of practical things we can do, changing the name of this kind of collection in a future version of Immutable.js would be pretty high friction and not valuable unless the confusion around List is high and there's an obvious alternative to use, which I don't think there is.

I think the least confusing thing to do is to leave it as is.
 I understand your concern. I think it's a good concern - I'm just don't think it's detrimental enough that it warrants a large change to the library.
  You want toJS() which deeply converts
  This was an unintentional breakage but the use of "size" as a key in a record has always been problematic. I'm working on simplifications and improvements to Record which should fix this issue once and for all. 
 Merging into #377.
  This is intentional. There are two things going on here:
1. `fromJS()` deeply converts a JS object & array tree to Map and List. `Map()` (and the other factories) do not convert deeply.
2. `mergeDeep()` treats non Immutable Collections as opaque references and does not attempt to merge them.

`Map()` does not do deep conversion, only shallowly uses the provided object keys to build the map. For example, if you had custom objects in your application (say for example, React components), and wrote:

``` js
var myCustomObj = new MyCustomObj();
var myMap = Immutable.Map({ "key": myCustomObj });
assert(myMap.get("key") instanceof MyCustomObj);
```

You would expect this to pass. If Map() did deep conversion, then your MyCustomObj would get iterated over and flattened into a Map.

So in your example:

``` js
var a2 = Immutable.Map({ a: 1, b: 2, c: { c1: 3, c2: 4 } })
console.log(a2.toString()); // Map { "a": 1, "b": 2, "c": [Object object] }
console.log(a2.get("c") instanceof Map); // false
```

Immutable.js will treat that inner Object as an opaque object reference - it can't know enough about all objects to assume what kind of merge strategy to use, so it does the only thing that would be safe and predictable: it replaces the reference with the new reference:

``` js
a2.mergeDeep(b2)
```

When it encounters the `"c"` key, it sees the existing `[Object object]` and replaces that reference with the  value of `"c"` in `b2`, which is the Object reference `{ c3: 30 }`.
 Also, just a tip while debugging:

`toJS()` is lossy, and can therefore make it difficult to see the true structure of Immutable collections. Some things you won't see when using toJS() to print values in a console:
- Difference between Record, Map, OrderedMap, JS Object reference.
- Difference between List, Set, JS Array reference.
- Non-string Keys of a Map, such as numbers.

`toString()` should help preserve all of this kind of information and can be helpful when peeking into a data structure.
  Detect that the obj is an Object, both "hashCode" and "equals" properties are functions.Â 

This will be included formally in the next major version as Immutable.isValue() but you can write it yourself as a cheap detection.

If your library is calling any methods on Immutable collections (like perhaps, "get") then it's good practice to check to ensure those properties are also functions.

Does that make sense?

â€”
Sent from Mailbox

On Fri, Mar 27, 2015 at 1:03 PM, JÃ©rÃ©mie Astori notifications@github.com
wrote:

> Right now I am checking that [`obj instanceof Collection`] for https://github.com/astorije/chai-immutable.
> 
> ## Probably not the best way to do it, but I didn't investigate much. I'll keep an eye on this thread and will add a Chai matcher to my plugin when a better answer comes in.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/421#issuecomment-87073502
  Hmm, this seems like a mitigation rather than a fix. A map shouldn't have nulled entries like this. Let me dig deeper, but thank you for your initial exploration.
 @leebyron, is there any decision was made regarding this PR?  I'd like to get to the bottom of this. The original fix is patching a symptom and probably isn't the only place this could appear.  Seen. Certainly there shouldn't be a TypeError, I'll look into that. But this is also not legal code. Union and Intersection always return new collections - even within a withMutations block, so this should result in the Set ['a', 'b', 'd'].
 @magnus-madsen you were right all along. #1083 implements that approach for the fix. Better late than never!  Sorry all, looks like I got ahead of the CDN and the JS file for the docs didn't load. I just fixed it, should work for you now.
  This is almost the fix we want - but we also want the creation of the iterator to be effect-free. The first call to `next()` should cause the fast-forward to the starting position.

I believe the fix should probably be replacing `!==` with `>` so the second iteration skips over this condition.

Thanks for expanding the test case and finding and fixing this issue!
 I added my requested change as well as a few more tests to your PR before merging.

Thanks again!
  There are some failing tests because of this change. What's the reason for that?
 Nice work!
  If there is truly an unknown number of sets, would it be better to provide an array/list of Sets instead of using var-args?
 I'm curious when you would use this API over set1.intersection(set2)
 Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you rebase or close the issue if it's obsolete? ðŸ˜…   Thanks for the heads up! Fixed
  Considering that Record.List's constructor returns a List. I'm not convinced this warrants being a new type of collection. Instead what it looks like you want to do is build a smarter kind of `fromJS` which is aware of a schema of Records, Lists (and Maps, Sets).

I would recommend re-framing this as a standalone function which takes two arguments: the "shape" of the data to construct and the input js object data that returns a tree of Immutable collections in the appropriate shape.
 Hey, I think this pull request has essentially timed out. Sorry! I am going to close it but if you are still interested in it enough to rebase and poke around to see if it still makes sense then please feel free to reopen.  Just reworked the test runner to no longer used the tsc wrapper but use typescript services directly. It should be both faster to run tests and hopefully not fail like this.

If you pull and run `npm update` you should get the latest dev dependencies which should hopefully fix the issue. If it doesn't, re-open it, and we will look into what's wrong with Typescript so you can file an issue on them.
 Strange. CI claims all tests pass. I'll look into it. 
  Hi there. I am starting handling backlog. I know it is been a while since you've submitted PR, sorry for such delay. The are some conflicts. Could you rebase or close the issue if it's obsolete? ðŸ˜…  Closing in favor of 44b20e4168613a7d28920495115a741b20fef2b4 for the future major version - though we still need to get type definitions to work correctly.  This actually seems like a real issue to me, so I'm going to re-open. `merge` should be a shallow operation, `mergeDeep` needs to be used explicitly to do deeper merges.
  I think you may be mis-interpretting the initial value for the Record class. It is intentional that you're unable to specify what type each field is because type checking will quickly expand into a very large (and possibly expensive) extension to this codebase in a really unrelated matter.

What the object provided to Record describes is the list of valid keys on that Record and the _default values_ for each key, not their type. For example: to articulate the difference between `entries`, a list of `Suggestion` records, having a default value of empty list `List()` or `null` (e.g. should `entries` be nullable?) you could write either:

``` js
const Completer = Record({
  selected: -1 // Number
  entries: List() // List<Suggestion>
})
```

or

``` js
const Completer = Record({
  selected: -1 // Number
  entries: null // ?List<Suggestion>
})
```

Does this make sense?
 I'm very interested in layering type information atop Record, I just don't think this library is the right place for this to live. I see a few ways forward:
1. Integration with static type checking tools like _Flow_ and _Typescript_. This would allow the additional type information to be removed at runtime, offering zero overhead and allow for full program analysis ahead of time.
2. A separate library which supplies runtime type checking for Record (and presumably the rest of Immutable.js). This will come at a serious runtime cost, but will enable the strongest sense of safety. That cost (both runtime cost and library size) is not one that every user of Immutable.js should pay, which is why I think this needs to be it's own library if desired.
 I now understand from your pull-requests that you're interested not just in type validation but parsing an arbitrary JS body into a tree of Immutable collections. That's also super interesting and something I would love to see, but probably should not be specific to Record, but apply to all Immutable collections.

Something like that would probably have a different sort of API from the Immutable collection constructors. For example, as you discuss here, you can't simply write: `List(MyRecord)` and expect it to operate as a type checker, for the same reason you can't write `Record({number:Number})` and expect that to operate as a type checker. Both cases expect runtime values. We will need something else for schema-based object inflation.
 Thanks for all the detailed input @Gozala.

> To be able to serialise records into JSON and then construct them back from the JSON producing equal values

This is not possible in all cases because converting to JSON is lossy. In some simplified common cases it's possible though. I understand your overall point of wanting to convert _from_ JSON in a deep way. This points to a need for a serialization proposal which I'm interested in, but is maybe out of scope for this task.

> List implementation is not sub-classing friendly

This is true, and @tgriesser has good ideas on how to improve this. However, I'm not sure that I'm convinced a subclass of List is necessary in order to properly parse JSON to Records and Lists. I understand you want this to be able to override the set/merge/etc methods, but I'm not sure this is strictly necessary.

> In fact I did also wanted to propose another addition in a following iteration:

``` js
const Point = Record({x: Record.Number(0),
                      y: Record.Number(0)})
```

Something along these lines is more interesting to me. I think we can probably get closer to the syntax of your original proposal by differentiating when providing a Record _constructor_ instead of a Record _value_ in the default argument position. For example:

``` js
const Point = Record({ x: 0, y: 0 });
const Line = Record({ start: Point, end: Point });
```

In this case, the `Point` refers to the Point constructor. We can then infer that the `fromJS` should parse these fields using this constructor, and the default value will be the default values of the `Point`, e.g. `Point()`.

This would preclude the ability to define a record constructor as the default value for a Record field, but that use case is probably very rare. I cannot think of a case where that's what you would expect.

My one real concern with an API like this is that it may be confusing to see an intermixing of default values and types. I foresee misreading examples like this and mistakenly writing:

``` js
const Point = Record({ x: number, y: number }); 
```

which is a reference error, or:

``` js
const Point = Record({ x: Number, y: Number }); 
```

Which simply wouldn't do what you expect (Number function as a default value). We can chip away at these cases, but it still makes me nervous.

The remaining case is for Lists of a particular type, but by extension also `Map`, `Set`, `OrderedMap`, etc. As well as all the future possible data structures we may add to the library, or extenders of the library may define (especially if we follow @tgriesser's extension proposal). I don't think requiring subclassing is the answer, but I'm not sure what the answer is.

Rough and dirty sketches of an API might look like: 

``` js
points: Record.Type(List, Point)
points: Record.Type(js => List(Seq(js).map(Point))
points: Record.Type(List, item => Point(item))
```

Not sure, exactly. This needs more exploration.
 For the first part of this: nested Records, I have a diff pushed to the 4.0 branch here: 5001072516a65b1245b528f88556ae4d1e4871fe. This is based on your pull request, I actually borrowed the tests directly.

I've made some generalizations to hopefully make this even more useful - not being limited to only Records as the type factories. This made using Number, Boolean, and String possible to use directly which provides some of the runtime type safety we were interested in without being a wart. It also let me add a `Nullable` factory function which is important when assembling a runtime type system like this. By leaving these factories as just functions, I'm also leaving the future open. I imagine at some point, someone will want something like Union, but not today.

The 4.0 branch was set up to start tracking changes like these that are going to be breaking. There's no set target date for launching 4.0, but having the space will allow for some exploration. Consider it an alpha branch.
 Your rationale is sound here. I totally agree that having a clean way to parse JSON into Immutable collections is really valuable. The trick is getting the semantics and API right so it doesn't preclude other valuable use cases and the API leads you to what you might expect. Hopefully the diff I pushed to 4.0 branch is on the right point of that scale, though it doesn't tackle non-Record types yet. I'd like to brainstorm a bit more on the appropriate API and architecture to enable this kind of factory function on input data across the suite of collections.

> Could you please elaborate, example of where it's not going to work ? I understand that conversion to JSON is lossy, but (with proposed changes) RecordType does hold enough information to be able to reconstruct it back by parsing generated JSON. But it could be that I'm missing something.

There are a ton of small edge cases where information is lost, but there are also larger representation issues. Certainly having a detailed tree of type information that mirrors a JSON body helps enormously, but the toJS() form on Maps produces an Object, but a serialization API would probably want to produce and consume a list of tuples as JS Object keys can only represent strings and their ordering semantics are awkward at best and ill-defined at worst.
 > Did I managed to make a compelling case for RecordLists that are the key to having polymorphic functions without workarounds described earlier

The need for a List that contains Records is pretty clear. The mechanism for doing so, less clear. I'd like to avoid subclassing if at all possible. I have some early thoughts, but nothing implementable yet.

> How do I help to move this forward ? I do understand you do not want to rush this and rightfully so. I just don't know if you'd like to have more discussion or some more code or maybe just time to think through this.

I think I need more time to stew on possible ways to implement this that have the properties:
- Very small overhead on existing library
- Highly performant
- Works for all Immutable collections, current, future, and 3rd party.

If you have thoughts on how to accomplish this, I'm happy to keep spit-balling.

> I do need to move the project I'm working on forward & given the issues I described earlier I do believe I have only following options:

I think fork and patch is probably going to work for you. You can unlock a working but maybe not final API, and by the time we agree on something that works best, it will probably be quite easy for you to code-mod your codebase to fit the new API. Building up a separate library sounds like a lot of work given that I really like the idea and want to see it happen here eventually.
 Yeah, I see what you mean here.  I'm glad you dug into this and figured out the boundaries. I think I agree that this is pretty dooming for typed lists. However typed records still seems valuable, perhaps there's a way to leverage "list" being part of a record type. Typed records won't have the same issue of the mapping functions desiring to produce different shaped records, so I'm not sure the same pitfall exists there.

For example maybe very roughly like:

``` js
var MyRecord = Record({
  listOfFoo: values => List(values).map(Foo)
});
```
  The root of this issue is what merge does on Lists, right @appsforartists? You expected merge to be the same as concat? I'm just trying to unpack the concerns listed here, I'm sure there's some API evolution we can do to make these ops easier to discover and viscerally understand.
 merging by index isn't really useful behavior anyway, I think it should work as you propose @appsforartists but this will be a breaking change and need to wait for a version bump.
  Thanks for the report!
  `Seq` have a full collection API, so you could at least type out as:

``` js
someMap.keySeq().toJS()
```

I'd like to keep the Iterator as simple as possible - in the future I'd like them to be true ES6 IteratorPrototype, so I hesitate on adding much to them.
  Closing this aging issue - Immutable.js doesn't support holey Arrays (Note the TC39 ECMAScript board is trying to phase out holey Arrays as well as they're a constant source of confusion)  Good suggestion
  This is by design, `sort` is unavailable within withMutations.

A future API change will hopefully make this far more clear as it's a very common point of confusion.
  This Issue is old, but would still be a really valuable PR.

Note that one of the primary challenges for a PR is naming this method!  After @robertknight's diff, tests run 3x faster on travis-ci, which uses jest's inline mode. It's closer to 4-5x faster on my MPB. Still on the order of tens of seconds, but much better than the > minute.
  They are not cached because the resulting JS array and objects are _mutable_ and may be changed after created by any other code. At that point, if cached, the cached values would not match the immutable collections. 
  Daniel has the right idea. It is _not safe_ to mutate an Immutable collection in the way you have described. Memoization is just one of the reasons for this.

New empty collections are always memoized to save GC churn.
 Also, I should note that the use of "new" is a bit misleading. The Immutable.Map function is _not_ a class constructor, but a factory function. You can prefix with "new" if it helps your code legibility, however the new'd object is never used and may contribute to GC churn.
 For now, the best way to store that metadata is in the map itself. Perhaps prefix with an underscore or something to illustrate it not being part of your application data. A true metadata API will be part of a future major version update to the library which should help this kind of use case. 
  Louis is correct that retaining the created JS object produces a memory leak that would be unacceptable for uses other than this proposed use.

Another thing to consider is that the resulting JS object is mutable and may be changed after created, so retaining it to return again would not be safe. 

Imagine, from your first example:

var aObj = a.toJS();
aObj.x = "edit";
console.log(a.toJS());

Either this will log an incorrect result, or it will have to carefully track edits to aObj which would be very expensive, or it will have to always return a new object. 

Your example code at the bottom, the simple memoization, is exactly what I would recommend. It doesn't look overkill to me, it's O(1) at runtime. By comparison, Lodash's isEqual (and Immutable.is) are O(N) at runtime. 
  Thanks for the report! I'll dig into this 
  Agreed. You should keep a reference to the "resetted" collection. Because Immutable.js collections are treated as values, you can simply reuse this important initial collection to represent the "reset", similarly to how you would "reset" a String or a Number back to some initial value. 
  This is correct behavior because toJS() coerces all keys to strings so the string key "5" and the numeric key 5 collide when creating the JS object. 

This is one example of how toJS() is lossy: JS objects can only have strings as keys where-as Map can have any value as a key. 
 The key paths are both totally fine. If you log toString() instead of toJS(), or just otherwise manually inspect the resulting Map, you will see that both the string "5" and number 5 represent two different keys in the Map. 

Related, the JS object {5: "value"} has a string "5" as a key, not a number. JS objects cannot have numbers as property names, only strings. 
  Thanks, this makes tons of sense. I wholey agree that being explicit about key types when stringed helps explain the difference from objects, and naked strings look far too much like property names, which they are not. 
  @hufeng is correct. Get the key sequence and pull the first item from it. 

In a future major version update, I will likely change this API to return an entry tuple instead of a value, which adheres to Map's iteration behavior. 
  Using reviver here is interesting. Could you illustrate the API you expected in order to achieve what you're trying to achieve?
 Up for grabs to ambitious contributors.

In my opinion `toJS` is one of the most abused parts of the API - so perhaps this is a good opportunity to break from the norm and implement `Immutable.toJS()` instead of adding weight to the class method.  There's no perf test covering this case yet. We will first need good perf coverage of this use case. I imagine creating a new Seq on every iteration is probably quite expensive. 
 Excellent work, thank you for being so detail-focused!
  We will still need to cover the case where valueOf returns a null-ish primitive which throws when calling value.equals. I think that's the key issue here. 
 Also, could you add test cases that this solves for and ensure you run "grunt" as part of the pull request?
 Thank you again for your patience and great work. I'm happy this issue is fixed and very happy you found and fixed the issue with the tests.

(btw, I fixed that inline concern as I merged)
  Records definitely support nesting today, the full set of nested get/set methods exist on Record instances. 

The initial object provided to the Record class factory are the default values, so if you want an empty version of the sub-record as a default value, you must supply it there. You want to supply instances as default values and not record classes.
 What I believe you're referring to here is a way to parse a nested JS object into nested Records. The Record constructors will not do this for you, as it is equally valid to provide a regular JS object as a key. Instead, you should use Immutable.fromJS() with a custom reviver function which is written in a way that relates to your data schema. 
 I'm not sure I follow how it even works if you override the constructor and have it not accepting any values.

But FYI - I'm working on Record sub-type declarations as part of v4.0.0 in the branch of the same name. See https://github.com/facebook/immutable-js/commit/35c2af0fe5bb8c879c7beba09025966518d68995
 So definitions of Records just set up default values. I know some people also define custom factory functions to go along-side them like you've done with EventRecordFactory. That may be useful as well for something like your `EventRecord` which sets a default "start" time to be when you defined the record - so all event records will have the same default start time, that's probably not what you want.

Having those factory functions are nice because you can define whatever behavior you like in them, including calling other factory functions to produce the kind of nested records originally brought up in this thread.

See this super contrived example of nested records with factory functions.

``` js
var _RecordA = Immutable.Record({
  b: null // RecordB or null.
});

function RecordA(obj) {
  return new _RecordA({ b: obj.b ? RecordB(obj.b) : null });
}

var _RecordB = Immutable.Record({
  a: null // RecordA or null.
});

function RecordB(obj) {
  return new _RecordB({ a: obj.a ? RecordA(obj.a) : null });
}

var abab = RecordB({ a: { b: { a: { b: null } } } });
console.log(abab.toString());
```
  @copy, I'm glad you've caught onto this pattern! I haven't documented it anywhere yet, but in the next major version, I will document this as a way to define "value" objects that work in the Immutable.js ecosystem (eg, can be used as keys, and are considered values by Immutable.is())
 Methods can be added to Record classes as @kentor describes. Simply add methods to the prototype. It is probably not a good idea to add them as values in the Record.

Some ES6 transpilers support extending expressions, in which case you can write:

class Complex extends Record({real:1, image:1}) {
  magnitude() { return ...; }
}

For the transpilers that don't support subclassing an expression, but support an identifier, you can write:

var _Complex = Record({...})
class Complex extends _Complex {
...
}

I personally prefer just adding methods to the prototype. 
  Thanks for finding this, it is a bug. When the name is empty, it should default to "Record"
  toJS() already exists on Records. You can safely call it directly.
  Thanks for your patience, this is a great fix.
  Good call, Hugh!
  This should live in a separate sort of thing. Cursor is meant to be a very transparent view over a Map or a List, not to represent a new kind of data structure. What you're describing sounds more like Zippers which we do not have any tools for at the moment. Feel free to start to flesh that out!
 Sorry for missing your comment here. I highly suggest starting a project for this outside this library. In a future version, the `contrib` folder will be replaced by separate github projects.

What you're onto here is similar to zippers and lenses and probably benefit from being able to evolve as such rather than being tied to the fate of a (not the best) implementation of data cursors.
  This looks great! Thanks for building this. For basic use, what you have made is valuable. If you're looking to expand the API, I would suggest looking at the whole chai API for objects and arrays and writing similar assertions for Immutable collections. The has/includes are certainly valuable assertion methods as well. 

Nice work!
  Immutable's common operations like `Immutable.is()` and prototype methods make assumptions about their input having prototypes of a certain form. This is potentially problematic in some edge and corner cases.

If an individual Immutable collection has an altered prototype, the behavior could change.

If a Record introduces a prop key with the same name as a prototype method/prop, the behavior could change.
 @zerkms certainly the code is not un-runnable, there just may be dangerous caveats. For example, Immutable collections have a method called "map". If you define

``` js
var WorldMap = Immutable.Record({
  map: "flat"
});
var flatMap = WorldMap();
console.log(flatMap.map);
```

This works today and will log the string "flat". However, if the change I proposed earlier was added, then this code will behave differently and log "[Function]". That's why it's breaking.

However, now that I've thought about it a bit more, I'm not sure just not adding the property descriptors is a good idea because it will defy the expectations of the developer. Certainly in your example of Shirt, you would expect `myShirt.size` to be "XL" and not "2". It would be especially weird for `myShirt.size` and `myShirt.get("size")` to not be the same value.

I think what's more important is ensuring that internals cannot be squashed which can cause some issues, as pointed out by the task that spawned this one. I'm not 100% sure what the right strategy is there quite yet, but surely it can be solved. I'll think about it more.
 Fixed in master - now throws clear Errors instead of mysteriously breaking.

Unfortunately no, symbols can't be used because they're public API methods and accessors.  Arrghh. Thanks for flagging it.
 v3.6.4 is released now which is not broken. Thanks for stickin' with me.
  Thanks for this work! I appreciate you digging in and figuring out what to do
  Unfortunately this is not possible using this library. You may be better off using Object.freeze() and Object.seal() on a JS object with properties configured as needed.

This library's immutable Map collection is not analogous to JS Object, but to ES6 Map. As such, it doesn't have a concept of properties (nor property enumerability) but instead has a concept of key->value entries, where keys can be of any type (whereas property names must be strings). The toObject() and toJSON() methods exist as a convenience only, they can be lossy and do not work on all Maps.

In the case that you want to use Immutable Map, but want to ensure some entries are not iterated over as a way of emulating enumerability, you can use `filter` to exclude the keys you don't want to be included in the iteration. A good example of this case is highlighted in the wiki: https://github.com/facebook/immutable-js/wiki/Predicates#pick--omit

The code you might use for toObject could then look like:

``` js
myMap.filter(myOmitFunction).toObject();
```

However you will later need to define the non-enumerable properties.
  Seems like a pretty obvious win. Thanks for your patience, this is great.
  Interesting. I think you're correct here that if the key paths differ then the cursors can't be considered equal because they refer to different parts of the source structure.

However if a cursor is compared to a non-cursor, the key path should be inconsequential.

Thanks for the really detailed write-up about this.
 Closing this aging issue, especially since contrib/ is not a primary focus. If the changes discussed here are still relevant to someone then a PR would be a nice reboot for this concern  All Immutable.js collections implement the ES6 `Iterable` interface. JavaScript Array is in fact iterable in ES6-aware browsers (currently rare), but in other browsers Immutable.js will wrap the array in a `Seq` which is Iterable. Similarly for JS Object, as a convenience, will be wrapped in a `Seq` and iterated similarly to how an ES6 Map is iterated. These `Seq` wrappers have extremely low overhead, and are similar to the excellent [lazy.js](http://danieltao.com/lazy.js/) project in implementation, they do not create an immutable collection from the Array or Object (therefore no trie is created for them).

All methods in Immutable.js which expect an `Iterable` argument internally have a simple check which first checks if the argument is Iterable, and if not, wraps it in a Seq so that it is Iterable before running the rest of the method.

Immutable collections are in fact Trie structures, and since they implement the `Iterable` interface directly, aren't wrapped in `Seq` when provided to these kinds of methods.

Does that help explain?
 In that case, the expected output is an Immutable data structure - so yes, `fromJS` will create a Trie data structure from the array as input. An O(N) operation.

However, if you only want the API ( iteration and higher-order-function methods ) of Immutable, and you have no plans on actually updating that array, then creating the Trie might not be necessary. In that case, you would want to use a wrapping Seq directly.

``` js
import { Seq } from "immutable"
var myArray = [1,2,3,4,5];
var list = Seq(myArray); // O(1)
list.get(2); // 3
```

The Trie data structures are really meant to be useful for persistent immutable data where updated versions are going to be created over time. You can update an immutable Trie in O(log<sub>32</sub>N) which is very close to O(1). Seq has no API for updates at all, it's designed to be read-only.
  Yeah - the more I'm thinking about it, the more I'm concerned about the pandora's box that you brought up just now (and before) @tgriesser.

I agree with your conclusion that we should keep floating this as a fork to investigate the compelling use cases.

In previous conversations you compelled me to include a metadata API which I think handles a lot of the cases that subclassing was desired for - and that's still on the docket.
 @vtambourine I'm a little confused about your prop-types example. Are you saying that you have arrays of Immutable Maps? Or do you have Immutable Lists of Immutable Maps? Or Records?

Also note that React propTypes are just functions which do or do not return an Error, you can always write your own propType function that will do the custom validation you want.
 You're correct that if you're using `Record`, you can use `PropTypes.instanceOf(MyRecord)` without any issue.

> As far as I understand React approach, first array should be treated as immutable array of immutable object. How to handle props validation on each components?

There's no such thing as an immutable array in JavaScript, but you could certainly use an Immutable.js List collection here if you wish. You could use `PropTypes.instanceOf(List)` as your propTypes for this property, there's no need to test for the contents of the list since your `CargoItem` propTypes will already be doing this and there's no need to do so twice.
  This file is auto-generated. Must be a bug in the doc generator.
 Fixed in latest docs
  Note to anyone who would like to attempt this PR - most of the documentation for Record has already been written, however the documentation generator chokes on the Record definition.

The bulk of the PR to solve this issue will be in the documentation generator codebase in `pages/`  Nice work, thanks for your patience!
  Closing this aging issue  Thanks for the report!
 That's close to what I plan to do.

I also want to ensure that none of the other prototype methods are affected for the same reason, so I may use the prototype as a blacklist. Rather than throwing an invariant, I'll probably just not assign property descriptors for those keys, instead requiring that you access those keys via the `get()` method.

Either way, this will be a breaking change that will need to go into the next major version bump of immutable.js, and we may also need to include some way to opt out of this behavior in the case that you _want_ to clobber the prototype.

In the short term, I will look into a way to mitigate the immediate issue reported here.
 Closed because this immediate issue should be resolved in https://github.com/facebook/immutable-js/commit/6b6074677ae986c92c793673ceb958bc130a76c2 but the larger issue of clobbering prototype property keys still exists.
 Tracking the larger issue in #377
  I actually made this change in v3, but changed back after significant push-back. In addition to further decoupling of the cursor API from this library, I think an API like #249 would be nice if cursors are to behave the same way they do today.
  Hashes are calculated only when explicitly necessary, since they're expensive to compute. They're calculated when being used as a key in a Map, as an example.

Always hashing when calling `equals` would always improve speed. Certainly the first call to `equals` for un-hashed values would face a penalty, as now we would not only be comparing equality but _also_ computing these hashes. Also, in the cases that two are value-equal but not ref-equal it will compute matching hashes but still require comparing equality to ensure that no hash-collision has occurred.

I think the next step on something like this is to actually perform more research on the performance cost/benefit
  @samwgoldman is completely correct. Reference equality is a shortcut used in some places but can never replace value equality, which is what you want here. 

This is the case for very similar reasons to why:

var a = []
a.filter(() => true) !== a
 I'll keep this open as a note to myself to improve the docs to make this point more clear
  You cannot because immutable objects have no updates to observe!

Perhaps you could share some example code of what you're looking for and how you expect it to behave and I might give a better suggestion.
 Perhaps `Cursor` would suffice?
  This works today, but I'll keep this task open to make it a bit more obvious.

If you click on a header from the table of contents on the left side, you'll get a link to that location. In your example: http://facebook.github.io/immutable-js/docs/#/List/set
 To any contributors looking to help: it would be great if you could click the headers in the docs to get anchor links  thank you!
  Hey @JonathanHayward thanks for the report.

For future reference, if you scroll to the bottom of any of the pages in the docs, there's a red box explaining that they are autogenned with links to the relevant files.
  Thanks for finding this bug! I'll dig in to fix it
  Thanks for reporting this (and I'm so sorry for getting to it so late!)
 I think this is fixed, so I am going to close it, but if not please feel free to reopen this issue!  It sounds like Record is exactly what you're looking for. 
 Records can already be extended via normal prototypal inheritance, however the storage mechanism cannot.

I'm not sure I'm understanding what's being asked for here. Please re-open if this doesn't resolve the task.
  This should be partially solved by #507
  Use filter() before toJS()

See this recipe for a pick filter: https://github.com/facebook/immutable-js/wiki/Predicates
  This has seemed to trip up a lot of people lately, so I will definitely include more documentation on this. 

m.set('y', 5) !== m.set('y', 5)

For the same reasons:

{y: 5} !== {y: 5}

Objects use referential identity equality, not value equality. 

For value equality, you must use Immutable.is(m, m2) or m.equals(m2) which will determine if two collections have value equality. 

As an optimization, if the two cases being compared are referentially equal, then that value comparison will be extremely cheap.

In immutable, every time you call one of the mutative methods like "set", you're creating a new object. Within that new object it may share portions of data with the previous object, but at the top level it's still a new object and will fail referential equality (===) with any other object, including other objects that happen to hold the same shared data.

As an optimization, when calling a mutative method like "set" Immutable.js first looks to see if the value you provide is === with the value already at that key position. If it is, then it short circuits, returning itself, knowing that the operation would be a no-op.

This optimization helps Immutable.is() find that fast path in this common case.

With immutable data, you're far more often looking for value equality than reference equality. You should use is() and m.equals() whenever you want to know if two collections represent the same information. 

There are some cases, usually when writing memoization functions, where you instead want to know a rough and cheap to calculate equality and are willing to give up on some false negatives, eg "are these definitely not not-equal".

Hopefully that helps explain a bit. I'll capture this in better terms and add to the documentation. 
 They're called Hash Array Mapped Trie and there's decent documentation of the overall concept floating around, including on Wikipedia. I also gave a talk on the structure and have some illustrated examples in that talk that you can find on YouTube. 

Your assumptions are close, but maybe a bit upside down. The root of every structure is unique but often leafs of the tries are shared amongst one another. 
 Unfortunately not, @gniquil - or at least not without severe performance and memory penalty.

For example, a global cache would require some sort of cache eviction policy, which will incur a performance cost on every operation. Having a cache at all requires a memory footprint, and a trivial cache would just grow endlessly, never allowing the GC to clean up any created collections. This would have large negative memory implications on most applications which use Immutable.js and heavily rely on the GC cleaning up after them.

Then there's the problem of determining how to key into the cache in the first place. This means once performing any operation, you will need to do a full hash and cache lookup, an O(N) operation on the size of the object being looked up. This would make every operation in Immutable.js O(N) which would be untenable from a performance point of view.

I believe a better forward path is for the JavaScript/ECMAScript technical committee to consider value types and overloading the `==` equality operator. This is a conversation that is happening for consideration in a future version of the language, so that we may map `==` to use `Immutable.is()` when the operands are Immutable collections.
  This is interesting, thanks for putting this together. However, I prefer the explicitness of loading each dependency. It's easier to keep track of what npm dependencies are in use.
  Sorry, the hope was the assert() was illustrating that point, but I suppose the text could be more verbose.
  Hey zachasme,

Can you explain what happens when you use the current export today?

The raw source of Immutable is not designed to be used directly as it currently has some delicate circular dependencies. It's designed to be transpiled to a single file for use. The current top level export lets us produce the most tightly compiled output that should work with the most consumers. 

I have a few projects that use babel myself and I have used this import pattern without trouble, so I'm curious if something has changed that would break this more recently. 
 Can you run `grunt build` and update the PR? This might be okay, but we will need to take a look at what it does to the built distribution file.

> and making sure classes are instantiated with new

There are exceptionally few classes in Immutable.js, instead most are factory functions. Using `new` along side factory functions likely has some additional memory weight without any added value.
 This approach is more interesting. 

However, I'm curious why you want to load the raw source directly rather than the compiled production distributed file? Babel and other transpilers have support for loading in a vanilla CommonJS module like this one in the way you want. 
 Hey, thanks for submitting a pull request. Sorry for not getting closure on this earlier but I think this pull request has sort of timed out, so I am just going to close it. Please feel free to reopen if you think this is still a problem though.  size and count() are almost always equivalent. However some lazy Seq cannot know their size until being fulfilled so size will be undefined for those cases and calling count() will fulfill the lazy Seq to determine its size. 

Thanks for reminding me to update docs with this. I'll leave this task open until it's done
 If you're making use of Seq in your code then I definitely suggest sticking to count(). If not, there's nothing wrong with using size directly. 
 There are a number of places where it's very beneficial to know the size of a Seq without having to iterate through it - for example when slicing slices. You can reap very real performance benefits from this.

I definitely recognise the potential for causing trouble though - I'll consider this not just a detail to be documented, but an API to improve in future versions that maintains the ability to write highly performant code, but also doesn't present these kinds of potential bugs.
 This seems sufficiently answered, so I am going to close this issue!  Will the recipe for "pick" do what you need?

https://github.com/facebook/immutable-js/wiki/Predicates
  Great idea. I'll look into this more
 There's a missing feature from typescript that would help solve this. The idea of the return type being "this" eg the same type as the context object. In the meantime yes you have to manually write it out for any subtype which is pretty awful
 This should be fixed in master, will be released soon  Is there a particular use case you have in mind here? I would suggest using arrow function or bind if you need the immediate surrounding context at the present moment.Â 

â€”
Sent from Mailbox

On Sun, Feb 22, 2015 at 8:39 PM, Sebastien Barre notifications@github.com
wrote:

> Should `withMutations()` offer a `context` parameter, so that `this` can be set in the context of the `mutator`?
> i.e.
> 
> ```
>   withMutations(mutator: (mutable: Map<K, V>) => any): Map<K, V>
> ```
> 
> becomes:
> 
> ```
>   withMutations(mutator: (mutable: Map<K, V>) => any, context?: any): Map<K, V>
> ```
> 
> to match signatures such as `Map:map()`
> 
> ```
> map<M>(
> mapper: (value?: V, key?: K, iter?: Iterable<K, V>) => M,
> context?: any
> ): Iterable<K, M>
> ```
> 
> ## Thanks
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/340
 Good suggestion, I'll look into it

â€”
Sent from Mailbox

On Sun, Feb 22, 2015 at 7:03 PM, Sebastien Barre notifications@github.com
wrote:

> ## I guess in the context of a React component's method, `this` is set to `window` inside `withMutations()`, preventing any other component's method from being called?  But reading more about the arrow function it appears its biggest benefit is that it does not alter `this`. Sorry, not completely used to ES6. Thanks for the pointer. Maybe for consistency with the sequence methods, it would a useful addition...
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/340#issuecomment-75480112
 Deciding against this in favor of encouraging arrow functions to keep API simple.
  This is very similar to #282 which I suggest you read. 

The TLDR is that object keys are _always_ strings. Javascript lets you omit quotes for keys when writing the literal form, but they are still read and stored as strings. 
  Great suggestion. I need to look into web worker serialization a bit more to figure out the best path forward. Today there is not a clear way to serialize and deserialize Immutable collections. 
 Transit is a great tool, I definitely recommend using it. I'm also considering adding a very simple serialization API to the library
 If you're looking for a serialization method you can use today, I would strongly suggest using transit.js. It's a great library for serialization and you can find write ups on using it with immutable.js.

Better methods for serialization are on the roadmap, but it's unlikely that we will serialize the structural sharing itself, as that can have very tricky implications. Instead we will do something fairly simple and related to what transit.js does
 Unfortunately this is still an open challenge, but I'm closing this aging issue  These are two different objects, so this is expected for the same reason that {k:"v"} !== {k:"v"}. 

If you want to check value equality, use Immutable.is()
 It certainly doesn't defeat the purpose. Objects and Maps are very different things and the data structures this library implements can be very efficient and powerful way to use persistent immutable data in JS. Native JS objects and Maps are mutable, the purpose of this library is to introduce immutability. 

As far as equality checking, it's not that this library replicates a clunky behavior, it's simply that JS does not allow for operator overloading. If it did, this library would certainly take advantage of that. In lieu of operator overloading for ===, we just settle with a function is(). 

There are proposals for future versions of JS to make this sort of thing less awkward. JS Strings are persistent immutable data structures with a custom equality implementation, but since they are native to the language we tend to not stop and think about how strings and objects behave differently relative to memory usage and value equality. 
 That's good feedback. I'll clarify the documentation around this. 
  There is not at this time. You need to always define the whole key set when you define a record. 
  It's intentional, but probably misguided. Changing it would be a breaking change, but alongside clearer APIs about (de)serializing I think it would be the right thing to do.
 Have you tried `map.entrySeq()`? It does basically exactly what your "asTuples" does. 

Also, you can use the for of iteration loop since the natural iterator value for a Map is the entry tuple. This works both for Immutable Map and the existing ES6 Map

```
for (const [k, v] of myMap) { 
}
```
 mapEntries doesn't really make sense for a list, since returning anything other than incrementing ints as keys wouldn't make sense. 
  Thank you for this report! I'll look into it
  I want to append an item to a List deep inside another structure. Would ideally like:

```
pushIn(keyPath: Array<any>, value: T): List<T>
```

where the keyPath is one item shorter than an equivalent `setIn` would be (because the final operation is a push, not a set).

Thoughts?
 There's a bit of a slippery slope where ultimately every API method will have an equivalent *In() parallel. pushIn() makes good sense, so I'll keep this open. 

In the meantime, updateIn() is the generic deep update method which all other *In use directly. 

foo.updateIn(["a", "b", "c"], List(), list => list.push(123));

The empty list 2nd arg will be used in place of undefined in the update fn should the path not yet exist. 
  Merging into #1050 - sorry for the massive delay  Thanks. I must have had a dyslexic moment. 
  I explored this not too long ago, thanks to some help from members of this community and found that it's quite difficult as soon as you have operations that map from one type to another type, namely `reduce` and `map`. You could imagine how calling `map` on a `List.ofType(Number)` with a mapper like `num => num + " many"` List would either have to lose it's typing, or find some way to infer the type of the new list.

I think this fits into the category of things that are difficult and awkward to do without language or compiler support.
  Hmm, I'm having trouble reproducing this.

After running...

``` js
const Thing1 = {};
const Thing2 = {};

const x = {
    "key1": Thing1,
    "key2": Thing1,
    "key3": Thing2
}

const result = Immutable.Map(x).groupBy(x => x);
```

I inspect result...

``` js
console.log(result.size);
2
```

That's expected, since we're returning `Thing1` and `Thing2` as the keys to group on.

``` js
console.log(result.get(Thing1).size); 
2
console.log(result.get(Thing2).size); 
1
```

This also makes sense, Thing1 had two keys pointed at it.

``` js
console.log(result.toString());
"Map { [object Object]: Map { key1: [object Object], key2: [object Object] }, [object Object]: Map { key3: [object Object] } }"
```

That looks like what we expect.

---

Perhaps you could write up a quick test case that fails for you? I think I'm just not seeing the error yet.
 Ahh yes. `toJS()` is lossy for a lot of reasons.

So in this case, we're using Objects as keys in our Immutable.Map, but when we call `toJS()`, it's converting back to a JS Object, it needs to convert the keys to strings so it can use them as JS Object keys. Both `Thing1` and `Thing2` will produce `"[object Object]"` when cast as strings. Since all keys have to be unique, the 2nd key for `Thing2` overrides the first from `Thing1`, and you only see that data.
 To some degree. Immutable collections implement a pretty reasonable `toString` which does its best to illustrate what's going on, but it does still involve casting everything to strings. You can see in my investigation, when calling `toString()` both object references get flattened to `[object Object]` and it's a little tricky to see which is which, but it at least illustrates the shape.
  That looks just fine to me. Is it doing what you want?

Since your setIn key path is short, you can also do:

store = store.set('customers', fromJS(data))
 That's correct
  has() and set() are both O(1) while union() and intersection() are O(N) in the current implementaion. 

If you can point me to research in making these ops faster than order N, I would love to see it. 
 Sure. That's probably still O(N) but may have a better performance factor. Sets are actually backed by the same structure as Map, a HAMT. It has a similar tree shape. I have an outstanding task to make an optimized version of map merge or set union that follows this. I'm not sure that will do much for intersection though. If you have more info let me know!
 I'm interested in seeing reference implementations of this. If they're actually referentially the same data then yes I believe you could get O(log N) union/intersection. However if they are simply value equal then there is no way to escape O(N) as you need to actually visit every node to determine a union or intersection.
 Consider creating the union of:

```
      13
    /    \
   8      17
 /  \    /  \
1   11 15   25
 \         /  \
  6      22   27
```

and

```
      13
    /    \
   8      17
 /  \    /  \
1   11 15   25
 \         /  \
  7      22   27
```

Despite only one value being different, you have to at least crawl the tree to 
find it. You can't determine from seeing that both trees have an "8" node that
you can stop crawling the tree. You must spend O(N1 + N2) time to determine the
union.

In a Red Black Tree, you also must then balance the result of the merge, which
is itself O(M \* log N)

HAMT might yield a different outcome considering that it doesn't care about ordering so it doesn't require a rebalance, but I think simply determining the union/intersection will require a full traversal of both trees with the exception of the case where both trees are structurally sharing common subtrees. For example, if the `17` branch in both trees was _literally the same memory_, then we could shortcut and be O(1) for that subtree.
 Tracking this now in #507 
  Interesting. So you use meta as a marker interface to see if some data has been validated or not already. What other common uses take advantage of meta?
 @swannodette I'm sure you can provide some good advice here. What are the benefits and pitfalls of meta in practice in most clojure apps?
 Closing this aging issue - perhaps something we could consider in the future.  Thanks for reminding me about this. I actually needed to update all copyrights, not just this block file, which I did in 257b92c6887ae787da9c94fbabe34056014ffc93
  Same as #282 where there is more info
  Huge bummer, but thanks for the report. What browser and version are you seeing this in, or if it's all of them, what cut of Linux?
 What workarounds are you aware of?
  Thanks for the report (and the pull request) ((and your patience)).

I'll dig into this and make sure this is fixed and incorporate your pr soon.
  Thanks for opening this. I agree we want to eventually get here.

Some subtasks:
- [ ] Deprecate all methods like `toMap()` in favor of passing instances to `Map()` constructors.
- [ ] Ensure common methods which return full structures are factored out (`groupBy()` is a good example) into helper functions instead.
- [ ] Find a new build path which allows for a single distribution file independent of node style requires.
- [ ] Investigate bytesize addition of Browserify and Webpack in partial-build mode.
 @pluma it won't break it no. But of course, if you require `"immutable/fromJS"` then you'll implicitly also be requiring `Map` and `List`.
 It's only 15kb if you serve the min file and your host uses gzip (they all do)
 I'll note that's 1/10th the size of most JPEGs on your site
 No worries, no harm. I just want to make sure the number is clear, and it's in perspective.

I just also want to caution looking at this task as a source a big win. In it's current form, this isn't going to do much for you, but what this task does do is allow for the library to expand and include new data structures without impacting byte size. That's going to be important as I plan to add SortedSet/Map and more useful structures in the future.

Currently the bulk of the library is distributed across three files: Iterable, Map, and List. List and Map both extend from Iterable, so at the very most you could drop from 15kb to 10-12kb if your application uses only Maps or only Lists. I also haven't evaluated how much weight using Webpack or Browserify would add to the size for partial builds vs the ultra-thin Esperanto packager currently used for full builds, my hypothesis is somewhere around 0.5-1kb, but this is something I'll investigate.
  Thanks for the report. I'll get on this
  This has pretty severe performance implications. I'm actually planning on moving away from the class semanic because of this recent change to the spec. I don't actually use the constructor function behavior in Immutable (you can call these functions with `new`, but the constructed object is discarded). Instead these should be viewed as _constructor functions_, rather than _class constructors_.
 But I definitely appreciate you investigating this.
 I am going to move away from classes in v4. They will officially be factory functions and the syntax will make that more clear. Also as part of the road to v4+, I'm doing some refactoring to make the code truly ES6 compliant, it's currently not so and dependent on a particular build pass.

In the meantime, I highly discourage using the src/ directory directly unless you're using the build tools that come in the repo. That codebase is not safe to use with Babel. Instead you should always use the dist/ directory.
 Closing this PR since new isn't the correct semantic for factory functions.
  Yeah, I agree that type-checking when used with Record feels crummy right now. It's a combination of the capabilities of the type-checkers (requires a lot of dynamism) and how Record classes are built.

I'm inclined to investigate any changes in the API for Record if it can help support better type definitions. I'm open to more ideas.
  Cursors will likely find their way into a separate file for distribution in the next version bump.
 Closed with #1137   Yes, this is expected. Immutable.js has optimizations in its methods to return `this` when the method would be a no-op, enabling reference equality checking to determine if no change was made.

It makes more sense when using `set` as the example:

``` js
var a = Immutable.Map({key: 'value'});
var b = a.set('key', 'value')
a === b // true
```
  Thanks @Dashed. Yes, the tricky thing here is that not everyone agrees on what "path" encoding should be used. Also note that encoding path as a string means that you cannot use it to access when a non-string key is used. Finally, what would `'a.1.b'` become? `"1"` and `1` are different keys! You either exclude numeric strings, or you exclude the ability to index into a List!

Despite the issues with this, I know that it's a valuable shorthand. My suggestion to those who want this shorthand is to use a locally scoped function that turns it into a key path, so they can use the semantics they care about. Since the function is so small, it's probably fine for it to live inline in your application instead of needing to live on npm.

``` js
function path(pathString) {
  return pathString.split('.').map(key => parseInt(key) || key);
}
```

Then you can use it for any `*In` function in the library:

``` js
nested.getIn(path('a.b.d.1.2.3'));
```
  An updated dist has been built, thanks for the reminder.
  I would start with the documentation at http://facebook.github.io/immutable-js/docs/

You'll find descriptions of each of these types.
 Yes I have an existing task to add more example code to the documentation.

For now, you probably only need to pay attention to List. It's also the most well documented. 
  This file is autogenerated. The readme and generation files need to be changed. Thanks for the report though, I'll look into this. 
 Fixed in latest docs
  You're spot on. Thanks for your careful reading and spotting this slip-up.
  Maybe submit a pull request since you've already written up custom implementations?

If the performance impact of this is negligible then having the additional behavior is nice. If it's expensive then perhaps it makes sense as an external utility function. 
 > If we were really ambitious we could have as a goal that List.if(1.2.3).push(4) should === List.of(1.2.3.4)

This is unfortunately not possible without some devastating performance issues as it would require these two operations to "know about" each other (read: some global cache). Instead, you should favor Immutable.is() for these kinds of comparisons.

> (the same way "123"+"4" === "1234" thanks to immutable string in JavaScript).

This actually uses a deep value equality check. It's likely that the two strings occupy different memory addresses, but JS knows that comparing strings means doing a character for character check if a memory address comparison fails.

---

On the whole, we're balancing for performance here. We pay a very small penalty in order to detect no-ops and return `this` in some operations, it pays off because we know it's a common next-operation to compare both the old and new versions.

In this case, building fromJS to be aware of references requires building up a cache of all visited objects by reference, which is quite a burden to put on this method which should be quite fast.

At the end of the day, you should not be relying on `===` reference equality so directly as not everything that is value equal can also be reference equal. `Immutable.is()` is not slow, and contains the `===` check internally as a first step anyhow, so is often equivalently fast. Slowing down other operations to make `Immutable.is()` faster is very likely going to be a net-negative on performance overall.

Also, I would be thrilled to be proven wrong on this. If you have code and benchmarks I'll happily entertain them. The smartest tricks often appear to be terrible ideas at first glance.
  I'm not sure I understand what issue you've run into. Could you maybe provide some sample code and explain how you expected it to work and how this library behaved differently?
 Hey Tom, you certainly shouldn't depend on that order. For very small sets of entires, Maps appear to have the same ordering as OrderedMaps, but once you go above a certain size, the ordering can change. 

I would suggest explicitly creating the OrderedMaps at each depth if you need to guarantee ordering. 

I like this suggestion, but I'll need to think about any externallies. 
 Sounds great
  Filter may be more difficult as it would require changing the structure as well. 

Could you add a portion to the benchmarks so we can test the before and after of this?

I'll look into why your build got so noisy.
  Good call, I'll check for null prototype as well.
  I'm excited to see more of what you've built, Tim! Mind writing it up for me in an email or something? lee@leebyron.com
 I'm still very concerned about the performance implications as well as creating an API that leads to anti patterns. 

For those +1ing, could you please add a use case you're trying to enable that's not currently possible by using Immutable.Record or the existing List and Map structures?
 I think that should be entirely possible by composing Immutable.js collections rather than extending them. You can check out OrderedMap as an example of this. It is a new kind of collection with new properties and some differing API, but is implemented by using List and Map
 I'm going to officially close this issue since we decided a while back that it wasn't worth the serious performance costs. We would rather have performant data structures rather than subclassable ones. 

This also encourages using plain functions for extended behavior, or composition for more advanced data structures, which are good patterns to follow
 Yes, that's a great idea. In the meantime, check out the source for OrderedMap and OrderedSet, both are "new" data structures built by composing List and Map
  This is a bit counter to the purpose of Cursors, which seek to be invisible and act as the types they wrap.

For shouldComponentUpdate, I recommend using `Immutable.is()` which will automatically handle Cursor unwrapping for comparisons.

If you want to deref regardless of Cursor for more specific comparisons, you can use `obj.valueOf()`. Regular types return themselves in `valueOf`, but Cursors return their `deref()`.
 Immutable.is should not throw. Thanks for highlighting this bug!
 Also yes, separate issue
  Sweet thanks
  Thanks for adding this. I'm a bit behind on reviewing PRs, but I promise to dig into it soon. 
 Closing in favor of @jeffbski's fix.
  I'm not sure this makes sense to add to a data collections library, but certainly could be awesome as it's own library! Sharing conventions with Immutable would allow them to interop as necessary (e.g. implementing `hashCode()` and `equals()`)
 #506 hints at the semantics necessary for object types to masquerade as value types from Immutable's point of view.
  I changed the new key to `"@"` which is even less likely to cause conflict. Thanks again for digging into this.
  Yes! I actually have an almost identical change sitting in a branch on my local machine to do this, and I've been building out the perf tests in order to measure exactly the question you're asking about implications.

> The rest params transform looks a lot like your arrCopy (minus the leaking of args because it is inline):

Yep! I added that change to 6to5!

So I'm all for 6to5, but just need more time to understand the implications first.
  Thank you!
  Thanks for the report, I'll look into this
 Can you clarify a bit with code you're using that's producing this case?

I assembled a small example which works this way:

``` js
var R = Immutable.Record({ x: null, y: null });
var data = Immutable.List.of( R({ x: R({ y: 1 }) }) );
// List [ Record { x: Record { y: 1 } } ]
var js = list.toJS();
// [ { x: { y: 1 } } ]
```

Were you expecting something else, or are you doing something else and expecting this?
  Let me investigate this a bit more, I'm surprised no tests failed as a result of this change. It's currently documented to behave as coded before this change.
 Yeah, this breaks tests for `updateIn`. I'll update the Travis CI script to ensure it builds the distribution before it runs tests to catch these.

If you run `grunt` before pushing, you'll see the affected test cases.
  Thanks for catching this.
  Closing this aging issue - sorry I wasn't able to be more helpful. Sounds like a browser limitation for maximum properties on an object  Not to my knowledge. Though if Chrome lets you configure this, I'd love to do so.
 Nice utility! Sometimes I use a similar one which calls toString().

I also spotted https://gist.github.com/darwin/2a5651f590a4e8d55c68 which only works in Chrome canary with some flags turned on today, and allows custom formatting of arbitrary objects. Super cool, I hope we can leverage this approach soon.
 Closing this aging issue - I'd love to see a separate npm package for this. Seems like `immutable-devtools` is a good start  Yes! Thanks for writing up the whole draft of this, this has been on my wishlist for a while and I appreciate you documenting up the approach.
  In theory I agree, however I'm not sure how to go about actually doing this.
 Currently all of the higher order functions like `map` and `filter` first create iterators, then populate new instances of the same class via that iterator. The new instance has no reference to the previous nor way of making the comparison that nothing has changed.

However, if you have an idea on how to do this, I would very happily take a look at a pull request.
  Can you explain the performance issue further or share a benchmark?

The replacement will not work correctly if your key-paths are Iterables instead of Array, and I would like to preserve that behavior.

If you share a benchmark I can attempt to solve for the performance issue while maintaining the iterable keypath property.
 Thanks
 Released as v3.6.2. Thanks for the quick report.
  Thanks for the red-alert! I'll get this fixed pronto
 Fixed in 3.6.1
  This is actually just JavaScript doing it's thing. JavaScript Object keys are always strings.

``` js
var obj = {42: "test"};
// get the keys using Object.keys()
var keys = Object.keys(obj).forEach(function (key) {
  console.log(key, typeof key);
});
// get the keys using for in
for (var key in obj) {
  console.log(key, typeof key);
}
```
 More fun facts about JavaScript:

These two lines are equivalent:

```
var obj = { foo: "bar", 42: "answer" }
var obj = { "foo": "bar", "42": "answer" }
```

And property access always coerces to string!

```
obj["42"] // answer
obj[42] // answer
```
 `Immutable.Map.get` accepts any kind of input because you can use anything as a key.

For example, what should this log?

``` js
var map = Map().set(1, "number").set("1", "string");
console.log(map.get(1));
```
 Note, this is also how ES6 collections work:

``` js
var es6Map = new Map();
es6Map.set(1, "number");
es6Map.set("1", "string");
console.log(es6Map.get(1));
```
 JS Objects just aren't Maps. They're collections of properties keyed by strings. ES6 collections escape this problem altogether by not providing any tools for converting to and from JS Object.

The fact that ImmutableJS provides `toJS()` and `fromJS()` is because they're legitimately convenient, but you still must be aware of the limitations.
 In applications I've worked on at Facebook and elsewhere, we just avoid using numeric keys or at least make strong assumptions that they are strings. As an example, Facebook's API provides a unique numeric-string ID for every object in it's DB. We occasionally send them as keys in a JSON payload and need to respect that they are strings on the client, not numbers. This ends up important for other reasons as at some point our numbers got larger than the 52bit range that JS numbers can represent and also we ran into some cases where we needed to base64 encode IDs and we didn't need to change any app infrastructure to do so.
 Funny story: we used to represent ids as numbers on the client instead of strings, we even ran `parseInt()` to get them. We had a shortcut function for linking to someone's profile, setting the URL to `"facebook.com/" + id`. At some point a bug elsewhere caused IDs to be formatted slightly differently so our number parsing started to return `NaN` and all links went to my old manager's profile.
 In my opinion, you should structure your app such that that `id` will always be the same type: strings or numbers, but not both at the same time. I think having to consistently remember to coerce your `id` variables to strings with `id.toString()` or to numbers with `+id` will just be an opportunity to forget to do that once and you'll introduce a bug.

It's totally possible to create an Immutable.js Map where the keys are numbers instead of strings, it's just not representable as a JSON Object. You could also go all-in on string `id` and ensure that's the case through your whole application.
 @cesarandreu do you mean a String Map where keys are always first coerced to String? This is how JS objects work. They're not indifferent to type, they always coerce to String, which is what leads to this common misconception. 
 Is the concern that a data type that restricts key type is desirable, or is the concern that JSON is a non-ideal serialization format?
 @geekyme are you seeing an instance where a value is being coerced? That sounds like a bug, could you show some code which replicates the issue?
  Can you post the code used to generate this output so I can reproduce and investigate?
 I'll investigate any performance issues here, but just a few notes on your test case code:

`withMutations` is only really useful when doing more than one mutation. It avoids creating an intermediate collection for code like `data.set('a', 1).set('b', 2)`. Of course, for a single `set`, there is no intermediate creation to avoid.

`setIn(... getIn(...))` can be replaced with `updateIn`. In your example, these two would be equivalent, but the second line using `updateIn` will be slightly more performant since it only needs to traverse down the key path once instead of twice.

``` js
data.setIn(["a", "b", "c"], bar(data.getIn(["a", "b", "c"])));
data.updateIn(["a", "b", "c"], bar);
```

Also, since your updateIn function is simply setting, you could simply further by using setIn directly.

Here is a reduced version of your same test case:

``` js
var Immutable = require("immutable"),
    Cursor = require("immutable/contrib/cursor");

var data = Immutable.fromJS({a: {b: {c: {d: 0}}}}),
    cursor = Cursor.from(data, update);

function update (nextData) {
    cursor = Cursor.from(nextData, update);
}

function foo (data) {
    return data.setIn(['a', 'b', 'c', 'd'], 3);
}

for (var i = 0; i < 1000; i++) {
    var before = Date.now();
    foo(cursor);
    var delta = Date.now() - before;
    console.log(delta);
}
```
 Note: I just realized you're using Cursor which has a more limited API. `setIn` doesn't exist directly, so for now using `withMutations` as you are will work around, but I will add this back soon.
 Also, running the above code, I do not see an increase in runtime with each loop. Are you still seeing it for your simplified case? Or is there a more complex case that shows this behavior?
 Aha, yes. Now I understand the issue.Each call here results in two mutations - the inner set and the outer set. 

I'm not sure if this is something that can be worked around by the library directly or not, I will investigate further
 Good catch.

What's happening here is that the inner `data.getIn` is returning a cursor and then setting that cursor into the structure in `mutableData.setIn`. So now your cursor contains a cursor :). On the subsequent update you'll have embedded a cursor to a cursor. On the 1000th iteration, you're modifying a cursor of a cursor of a cursor of a cursor etc 1000 times deep.
  This library implements persistent immutable data structures. You can read about this concept here: http://en.wikipedia.org/wiki/Persistent_data_structure

The core idea is that the immutable collections have a mutative API so they can be made useful in an environment where data needs to change over time, however each mutative call always returns the result as a new object - leaving the original object unchanged.

The key thing happening in the example in your comment is `map = map.set(...)`. Here, `map.set(...)` is returning a _new object_ and that new object is getting assigned to the variable `map`.

Here's an example that might better illustrate this core idea:

``` js
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 20);
map1.get('b'); // 2
map2.get('b'); // 20
```

Does that help explain what's going on?

I'm also curious how I could help improve the README if you were confused as to the purpose or operation of the library on first read.
 Also just updated http://facebook.github.io/immutable-js/ with the same changes.

Thanks again for bringing up this confusing example!
  Interesting!

This has come up once before and I ended up not following this path because using `has()` made things reasonable.

I imagine I will figure out the appropriate API once using more of Flow, as it cares a lot about nullability and having get() always return nullable is probably going to be pretty annoying.
 I suggest a utility function for this. I don't think it's the right call to expand the API surface area for this case - especially since many are concerned about byte size of the library.
  Event sequences are a bit of a different kind of beast from what Immutable covers. That's an example of a Stream or Observable, a concept that's out of scope of this library.

You should check out [RxJS](https://github.com/Reactive-Extensions/RxJS) which provides Observable and useful additions including Event sequences, it also includes the asynchronous versions of map/filter/etc that also are close those proposed in ES5 and ES6.
 Is there something specific you were looking for that relates Event sequences to Immutable collections?
 Unfortunately this is a different kind of lazy - asynchronousity. As you pointed out event sequences are lazy in that their values are spread out over time instead of being spread out in computation or memory. Supporting this use case would basically require re-writing all of the higher-order functions like map/filter/reduce to be asynchronous and work on a subscription rather than a computation.

Other than the names of the methods, I'm failing to see the similarity to the Immutable.js library.

For example - if you could produce a `Seq` from an event stream, what would it mean to call `toArray()` on it?
 It's usually helpful for me to start with a use case I want to enable to help articulate how the APIs should coincide. I'm not seeing one yet here.
 I would be curious to see a wrapped version first. Immutable exposes a lot so that it may be extended directly. If you built something like lazy-chain for Immutable that would be a great start to illustrate the usefulness of this.
 I'm looking forward to seeing what you build
  Good suggestion @chenglou I'll include this in the next release.
  This is a current limitation of the library. Lists aren't consumed as tuples. I agree with you that this should be possible though, so I'll leave this task open until I can investigate.
 This was fixed in the [v3.7.0](https://github.com/facebook/immutable-js/releases/tag/3.7.0) release 
  Yes! I have this working almost all the way using the really nice esperanto project. I've got some work to do to leverage import/export syntax correctly, since I use circular dependencies in a way that smash handles but ES6 does not. Then I am going to tackle this. 

I appreciate you opening the task to keep track! I'll post progress here. 
  ``` js
var iterator = myCollectionOrRange.values();
var step = iterator.next();
while (step.done !== true) {
  // do something with step.value
  step = iterator.next();
}
```
  Thanks for finding this and great suggestion on the fix. I implemented almost exactly what you recommended and added this example as a test case.
  Can you clarify - is this fixing an issue with typescript or an issue with browserify?
 Really strange. I'm curious, did you open an issue with browserify? This seems like a case they should be able to identify and correct for.
 Thanks for the investigation and fix by the way, clean and well explained.
  Closing as a dupe of #256 but thanks for the reminder to release a minor version on npm soon. 
  ES6 is the latest standard of JavaScript. The library is written in it as are the examples. While they can only run verbatim in the latest versions of Chrome or Firefox, they can be "transpiled" into ES3 which runs on all browsers being used today. The library itself is transpiled in this way for distribution on npm. 

The only feature of ES6 that are used in examples are Arrow Functions, which make code using inline functions much easier to read and understand. 

I'll keep this open to track adding a disclaimer about ES6 in the Readme
 Correct, @quarterto. Only a subset of ES6 features can be transpiled to ES3. Full featured ES6 can be supported by ES5. Immutable is written in this subset of ES6, and the feature in question (arrow functions) can be converted to ES3.
 Haha @paulcbetts caught you @rpflorence! :D

Arrow functions are one of my favorite features of ES6 and once you're used to them, make writing code with inline anonymous functions easier to read. It's not quite the same as JSX, though I definitely understand the comparison. JSX is an unofficial syntactical addition, but ES6 is the next official version of JavaScript which many modern browsers are now (partially) supporting.

I definitely understand the concern about adding the mental leap of understanding arrow functions to learning this library via the examples. However my hope is that the mental leap isn't too high and that once understood the rest of the examples will be much easier to read.

And if arrow functions aren't for you, that's just fine, you don't have to use them in your own code. Nothing about Immutable (or any other JS library for that matter) will require the use of them.
 Added some clarification to the readme and docs with e4666952f0718f3abf716bb9f2fe07f658f4a134.
  Only integer values are considered for the hash function. Decimal values should also rotate the hash. 
  Not always, no. Hash codes are inherently lossy - you're cramming unknowably large amounts of info into a 32 bit number. This is referred to as [Hash Collision](http://en.m.wikipedia.org/wiki/Hash_collision).

Here's the mental heuristic:

If two hash codes are unequal: the values are _definitely_ unequal.

If two hash codes are equal: the values are _maybe_ equal. 
 Also, what you've come across is an artifact of the hash code function: decimal values are discarded to compute them. I'll open a related issue to improve the hasher 
 #266 tracks it
  I'm also finding trouble coming up with a name for this which makes it clear that this will only delete the first instance of the value, not all instances of the value.

For now I don't think it's right to add it to the library since the helper function is quite small, and it's also unclear if the correct behavior is to throw or return the unchanged list. 

I'll keep it in mind in the future though.
  Good suggestion. I think default to no cache is still best to make chaining operations easier to build, but a cacheGets could be pretty interesting
 I would be happy to look at that PR!
 Sounds like the discussion in this issue has concluded so I am going to close it. Thanks folks!  Yes, all collections in this library, including Seq, implement the ES6 Iterable interface. 

One note is that they will follow the browser specific interface as some pre-ES6 browsers do not support Symbol. 

Here is a browser agnostic way to get an Iterator from an Iterable:

``` js
var iterator = iterable[typeof Symbol === "function" && Symbol.iterator ? Symbol.iterator : "@@iterator"]();
```
 ``` js
function getIterator(iterable) {
  return iterable[typeof Symbol === "function" && Symbol.iterator ? Symbol.iterator : "@@iterator"]();
}

var it = getIterator(iterable);

console.log(it.next());

```
 I'll consider this, but will probably stick to the ES6 API. It's agreed upon and it's uncommon to create them manually like this. 
 `values()`, `keys()` and `entries()` exist on all Immutable.js collections, mirroring the same methods on ES6 Map and Set. They've been in the library for some time.

However, this is not the same as the "default iterator" function (equivalent to `values()` for indexed collections and Sets, but equivalent to `entries()` for Maps).

These functions also are specific to collections and won't be found on any generic iterable where the `getIterator` function I provided above will always use the default iterator and will work for any generic iterable, not just those found in this library.
  Definitely not normal. When I run your code sample I get a Map back, which is what is expected, so I cannot reproduce this. What browser version are you using with what version of immutable?
  It would help to see some code which is causing this error, but my assumption is that you're returning an immutable Map from `getInitialState`. React expects `state` and `props` to be JS Objects when it operates on them internally.

It's semi-safe (in the current version of React at least) to return Map directly from getInitialState:

``` js
React.createClass({
  getInitialState() {
    return Immutable.Map();
  },
  ...
});
```

however, if you use mixins which provide `getInitialState` themselves, React will apply it's assumption that state is a JS object and call [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) with all values returned from all `getInitialState` implementations in order to merge them together. Since Immutable Map does not behave as keyed object, Object.assign will not do what you hope.

The solution is to either only return immutable Map from getInitialState when not using mixins, or to have a single key in your state:

``` js
React.createClass({
  getInitialState() {
    return { data: Immutable.Map() };
  },
  ...
});
```

Does this make sense?
 Thanks for bringing up this edge case, I updated the wiki page to better illustrate this.
  There is no way (intentionally) for immutable persistent data structures to contain circular references. Immutable structures can contain circular references, but in order to be persistent and take advantage of structural sharing, they need to be acyclic. The stack-overflow you link to illustrates this well - showing how a double-linked list needs to make a complete copy in order to perform an append operation.

There are some other problems that emerge from circular references in values, such as deep equality checking and hash-value computation.

Languages based on immutable structures handle this in different ways:

Scala has `lazy var` which is pretty much what you wrote up here. A deferred memoized function.

Clojure has `atom` which is a bit different (and easier to understand IMHO). Atom is an atomically locked mutable wrapper. Since JavaScript is single threaded, no locks are necessary so it's only a mutable wrapper. In other words: `{ value: "foobar" }`.

For equality and hashing, Atoms are treated as Objects not as Values. So `{ value: "A" } !== { value: "A" }`.

So you might treat this like:

``` js
var node0 = I.Map({ prev: null, next: {} })
var node1 = I.Map({ prev:  {value: node0}, next: {} })
node0.get('next').value = node1;
var node2 = I.Map({ prev: {value: node1}, next: {} })
node1.get('next').value = node2;
var node3 = I.Map({ prev: {value: node2}, next: null })
node2.get('next').value = node3;
```

---

However, both approaches: lazy function or atom object are totally fine! This data structure library has no opinion on either, you just need to be aware of their use so you can treat them appropriately:

``` js
// Lazy function
node3.get('prev').get();
// Atom object
node3.get('prev').value;
```
 For those looking for an implementation of Lazy evaluated variables, try this:

``` js
function lazy(fn) {
  var didRun;
  var result;
  return { get: () => didRun ? result : (didRun = true, result = fn()) };
}
```

Usage example

``` js
var lazyFoo = lazy(() => "foo");
console.log(lazyFoo.get());
```
 I'm currently not sure baking this concept into the library, and changing the `get` definition to evaluate the lazy function is the right thing to do, as it would have pretty serious implications and possibly introduce bugs or at the very least confusion on equality checking and hash computation.

At this point I think it's reasonable to assume if you're using lazy values to determine for yourself when the lazy function should be evaluated.
 I'll definitely considering adding true support for lazy values in the future, but I would prefer to see such a thing used outside the library first to better understand the implications before baking it in.

If you end up patching Immutable to add this functionality, I would be really interested in hearing about the unexpected issues and opportunities you run into.
 Circular references break a lot of promises that immutable data provides, so I don't think I plan on accounting for them. 

You can read a more lengthy explanation of the issues with circular references via manual mutation written up in the "transients" section of the clojure documentation. 
 Closing this for now - I think this is going to be really hard to do without language features.
  I really appreciate the pull request, but yes you've entered into dangerous territory when it comes to avoiding ambiguity.

Map can use anything as a key, strings and numbers, arbitrary objects and arrays, other Maps and Lists.

Here's a simple example which uses an array as a key:

``` js
var arr = [1,2,3];
var map = Map().set(arr, "123");
map.get(arr); // "123"
```

Here's an example where splat creates ambiguity:

``` js
var list = List.of("A", "B", "C");
var map = Map().set("A", Map().set("B", Map().set("C", "123"))).set(list, "abc");
var value = Cursor.from(map).cursor(list);
```

Is `value` a cursor to `"123"` or `"abc"`? While this contrived example illustrates how this might be confusing it's at least currently non-ambiguous. Currently this points to "123" because the keypath is always an iteration of key values. If it were _always_ a splat then it would point to "abc" - but because it could be either a splat or list depending on the value (or as proposed, number of arguments) then it becomes ambiguous.
  wasAltered isn't safe to use in client code right now. It's undocumented because it behaves differently in some scenarios and is used as an optimization internally for a few explicit paths. If you're using it, your code could break when updating to future versions. 

I'm trying to better understand the use case, I originally had an isMutable method and decided to remove it when some reviewers pointed out how it could be commonly abused.

One scenario I considered was having "asMutable" and "withMutations" provides special "builder" object with a different API. Instead of the full Map/Record/etc API, they would be write only and only have "set", "merge" and "delete" methods. This would just simply exclude the ability to have custom caching methods or any internal methods relying on immutability go awry. Thoughts?
 Can you share some code illustrating how you're using these methods? I may be able to give better advice
 I'm curious how close this contrived example is to your use case. Not to divert too far from what we were discussing, but in that example file, I bet you would see better performance from not caching the result since some math operations are bound to be faster than the cache lookup, let alone avoiding creating a new anonymous class.
 Closing this since it's aging, but caching utilities is still an open area of discussion
  Can I ask why you were expecting `undefined` as the return value?

I think right now, when providing `undefined` as a key-path, it's interpreted as the empty key path. I don't have a strong opinion about this being The Right Way, so I'm open to a discussion about it.

Another approach may be to consider `undefined` an illegal input and throw an exception instead. What do you think of that?
 Ok, I hear the consensus for this being illegal input and I agree.
  There's a common pattern used in the cursor callback which protects from accidental updating from an expired cursor:

``` js
var state = ...;
var cursor = Cursor.from(state, ..., function (newState, prevState) {
  if (prevState != state) {
    throw new Error('Attempted to alter an expired cursor.');
  }
  ...
});
```

I think this pattern is a nice protection against the type of ugliness that you're running into.

With this pattern, your first `p1 = p1.set(...)` will execute as expected, at which point `p2` now refers to an old version of your state ("expired") and is not safe to use as an update point.

To update from two cursors, you would need to recreate the `p2` cursor from the new state before using it to update the top-level state.

Does this make sense?
 Yeah, as it stands there is no way to use an expired cursor to update the top level data structure since the expired one does not relate to the new data structure.

Yes, you could create a new `p2`, but you could need to refer to the parent structure to create it. `p1` does not have the information necessary.

Your example:

``` js
var state = Immutable.fromJS(
  {points: [{x: 3, y: 0}, {x: 7, y: 0}]}
);

var points = Cursor.from(state, 'points', onChange);
function onChange(newState, prevState) {
  if (prevState != state) {
    throw new Error('Attempted to alter an expired cursor.');
  }
  state = newState;
  points = Cursor.from(state, 'points', onChange);
});

var p1 = points.cursor(0);
var p2 = points.cursor(1);

var newX = (p1.get('x') + p2.get('x')) / 2; // newX -> 5

p1 = p1.set('x', newX);

// p2 is expired now, so we need to make a new one:
p2 = points.cursor(1);
p2 = p2.set('x', newX); //state: "Map { points: List [ Map { x: 3, y: 0 }, Map { x: 5, y: 0 } ] }"

// note at this point, p1 is expired as well.
```

In practice, people often create cursors in the process of rendering components for React or another top-down renderer. Using one of the modification methods of a cursor then results in re-rendering from the top (and therefore all new cursors).

Using this pattern, there's another issue with updating from two cursors in quick succession. Updating the first could cause a re-render, so updating p1 followed by p2 could cause two re-renders without some other synchronising element.

---

My advice is to avoid this altogether by moving one level up when making edits with `merge` or `withMutations`.

In this example:

``` js
points.merge([{x: newX}, {x: newX}]);
```
 You should see if setIn and updateIn will do what you're trying to do.
 I'm not sure I understand the purpose of `dissect`, but most uses of `select` can be done via `updateIn` and `map`. 

For your example:

``` js
// 1. get the current diagram to operate on as a cursor
var diagramCursor = getTheDiagramToOperateOn(state);

// 2. operate 'under' the cursor
diagramCursor = dissect(diagramCursor,
  select('components',
    select('legs', function (leg) {
      if (/* this is the object I'm looking for */) {
        // then do some things here
      }
      return leg;
    })
  )
);
```

might instead be written as:

``` js
// 1. get the current diagram to operate on as a cursor
var diagramCursor = getTheDiagramToOperateOn(state);

// 2. operate 'under' the cursor
diagramCursor = diagramCursor.updateIn(['components', 'legs'], legs => legs.map(leg => {
  if (/* this is the object I'm looking for */) {
    // then do some things here
  }
  return leg;
}));
```

does that work for you?
 Closing this since it's aged
  Immutable works with anything which follows the iterable or iterator interfaces. So I might build Fibonacci iterator like so (ES6):

``` js
var x = 0, y = 1;
var fibIterator = {
  next() {
    [x, y] = [y, x + y];
    return y;
  }
};
```

Then I can use it anywhere Immutable expects a sequence of input, or I can explicitly turn it into a Seq:

```
var fibSeq = Immutable.Seq(fibIterator);
```

Note: iterators can only be run once. Iterable can create iterators on demand, so if you need to use the sequence more than once, define an iterable instead.

``` js
var fibIterable = {
  '@@iterator': function() {
    var x = 0, y = 1;
    return {
      next() {
        [x, y] = [y, x + y];
        return y;
      }
    };
  }
};
```

Does this answer your question? Would you like to see something more specific in the Seq API?
 Another methods which might satisfy this is Range + map:

``` js
var naturalNumbers = Immutable.Range(); // no args means 0 to Infinity
var squareNumbers = naturalNumbers.map(n => n * n);
```

I'm not too familiar with lazy.js's generators. I'll have to read up.
 From lazy.js's docs, here is lazy.js generator:

``` js
var fibonacci = Lazy.generate(function() {
  var x = 1,
      y = 1;
  return function() {
    var prev = x;
    x = y;
    y += prev;
    return prev;
  };
}());
```

note the parallels to JS ES6 Iterator that Immutable prefers.

Here's an Iterator Seq which will have the same behavior as the lazy generator above.

``` js
var fibonacci = Iterable.Seq(function() {
  var x = 1,
      y = 1;
  return {
    next() {
      var prev = x;
      x = y;
      y += prev;
      return prev;
    }
  };
}());
```
 Seq() accepts an Iterable or iterator, not a function. Note in my examples, I'm providing an object with a next() method (the iterator pattern). 

If you want to provide a function which is passed "n", then you should map from Range.  E.g. Your memoized fib example:

var __fib = Immutable.Range().map(fib)
  Currently the update function is called whenever any of the updating methods are invoked, regardless of if they resulted in a change or not. The user of the API is responsible for applying any optimizations when `newValue` is different from `prevValue` in the updater.

It may be reasonable to skip calling the update function when no change occurred, what do you think?
 After talking to some others, there's a sense that leaving it as is makes the most sense since adding this as an optimization is easy, but taking it away is not and potentially confusing.
  Sounds like #111.

Can I ask your use case? Since this has come up a few times, I want to take it seriously, but I also want to be sensitive to the use case of complex objects (including functions) as keys:

``` js
var fn = x => x % 2 == 0;
var map = Immutable.Map([[fn, 'isEven']]);
map.updateIn([fn], 'evenPredicate');
```

In that case, you have a `Map<function, string>` and updateIn should use the function as a key not as a mapping function.

I've also heard the argument that this could apply to `List` only, since only integers can be keys and there is no ambiguity, but then there is different behavior for the method on each.

All in all, a fairly tricky edge case to address, but this does seem like potentially valuable functionality. I'm just collecting use cases so I can think about the best way to introduce it that supports what people are after.

(Closing, to move open task to #111)
  Thanks for the report. Weird merge conflict ate it. I'll have it up in the next bug fix release asap
  This may be a bug, I will investigate
  :+1: good suggestion
  I'm not sure I agree with the condition here. I'm not sure why the default value being iterable or not should affect the semantics of the updater function.
 I'm not sure there's a smooth way out of this. It would be helpful to know all the use cases to support so that we can create the best API for all cases without creating too much confusion.

For the original `cursor.set()` case, I think it makes sense to ensure that setting `undefined` works correctly. Also `x.setIn([path], undefined)` should set `undefined` at that path.

Are there other use cases of `updateIn` that you're coming across where you expect an identity function to result in setting `undefined`?
 For the code sample there, what is the expected result?
 I'm not sure I agree with that. Perhaps this is just a point of confusion in the API. For this method, the `notSetValue` argument means the value that will be provided as input to the update function should a value not be found at that path. This is most often useful when the updater operates on a specific type of value, and you want to provide a default value of the same type.

For example, if I was counting frequency of words, I might have a Map of strings to numbers, and my update when I encounter another word might look like:

```
wordFrequency.update(foundWord, 0, count => count + 1);
```

For the first line of your last comment, I would expect no change to occur because it's an identity function, and that's one of the held properties of the update methods - identity functions should represent no change.

The second line of your code uses a variable named `notSetValue` in a different way (hence why I think this may be due to confusing documentation) - in that case it's implying "If a value was not set here, set it to this". That's the current implementation of `setIn`, actually.

Does that make sense?
 Thanks again for the thorough investigation and discussion. I added some preliminary improvements to the documentation for this method, but will keep thinking about how to improve it. This also led to a find and fix of a bug in setIn. This is how the library improves!
  Hmm, this is indeed a tricky case. We want to be able to differentiate between the value `undefined` and the concept of not being defined, given a function. Unfortunately we don't have discrete values to differentiate them, so this is pretty tricky.

@Dashed can your use case be solved by using `setIn` instead of `updateIn`? The fix there is quite clear, but I'm still not quite sure what the best way to solve `updateIn` is.
 I closed this with a fix to Cursor#set and Iterable#setIn as I think the appropriate solution for this specific case is to be using `set` instead of `update` when you explicitly want to set a value to `undefined`.

So, a variant of the original code which should behave correctly after this fix:

``` js
var map = Immutable.Map();

var cursor = Cursor.from(map, function(newRoot, oldRoot, path) {
    console.log('newRoot', newRoot.toJS());
    console.log('oldRoot', oldRoot.toJS());
    console.log('path', path);
});

// newRoot { a: undefined }
// oldRoot { }
// path [ 'a' ]
cursor.set('a', void 0);
```
  Nice. Good idea
  Does https://github.com/facebook/immutable-js/releases suffice?
 No problem! I'm glad I could answer the question
  The current purpose of Cursor is to provide a transparent wrapper around an actual value in order to globally track changes. Code which consumes the Cursor should not know that it consumes the Cursor.

Can you explain how you are using Cursor differently which supports making these properties public? Knowing the use case will help me understand the best way to expose this information.
  Thanks!
  Thanks for the report. I'll dig into this.
  Considering that we would be limited to strategies that are persistent, this might be a little bit hard to follow for most. Would specifying custom properties be sufficient? Such as saying "sorted" instead of "red-black tree". 

How would you envision the API for what you're suggesting?
 Closing this - a separate task tracks the desire to add sorted collections.
  I prefer not to take a dependency on another library and keep Immutable as simple as necessary. I also have worries about future conflicts or confusion since keys are often strings. Finally, map keys may be complex, not only strings, and this format cannot support those keys.

My suggestion for this case is to use a small wrapping function so you can use this notation:

```
var ptr = require('json-pointer').parse;
// ...
var cursor = Cursor.from(data, ptr('/a/b'), onChange);
var deepValue = value.getIn(ptr('/a/b/c'));
```

The other reason I prefer this approach is because it is easier to describe the types. If `getIn()` accepts `Array<any>` and `ptr` is defined as `ptr(path: string): Array<string>` then `getIn(ptr('/a/b/c'))` can be easily understood by a type analysis tool like Flow or TypeScript.
 This isn't a question of which dependency to take, but rather that this library seeks to remain dependency-less. 

Also, performance is a primary concern, and in past performance tests we found this parsing step to be a serious perf regression on getting values. 

If it's important to you to use a path notation, then more power to you, it's easy to compose functions together to do just that, but I don't think it's the right trade-off to introduce a performance regression for those who don't need this feature
  This is part of why I'm concerned about allowing `length` on `List`. It means something specific in JavaScript as part of "array-like" which implies bracket notation access with numbers.

For example, this idiomatic JavaScript code illustrates how a List could be misidentified:

``` js
  if (arraylike.length > 0) {
    var first = arraylike[0];
    console.log(first);
  }
```

A lot of the JavaScript core library treats "array-like" as a special case which can change behavior. We want to ensure that the JavaScript core library doesn't start treating `List` as an array-like, otherwise we will see a bunch of github issues opening like "JavaScript thinks my `List` is full of `undefined`".

Now, ideally we could just embrace this. We could make List an array-like, support `length` and more importantly support bracket notation for reading from the List. Unfortunately without [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) objects there is no way to do this. Proxies are only supported by a few bleeding edge new browsers and are not polyfill-able.

I'm absolutely open to suggestions about how to solve this.
 I truly agree, @astorije. I would love for a common interface, I just have yet to find a way to make that happen.
 According the ES6 spec, `Promise.all(List.of(p1, p2))` should work just fine:

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all

Promise.all is specified to accept an `iterable`, which all of the Immutable collections satisfy.

(Which means if you're using a Promise library, and this doesn't work, that library has a bug.)
 However, also note that the spec says that while Promise.all accepts an `iterable` of Promises, its result is an **`Array`** of the results of all the Promises. If you want the result of Promise.all to be an Immutable List, you'll need to explicitly construct one from the result.

Here's a helper function that will do that for you which you can use in place of Promise.all if you want to ensure it's Immutable List in, Immutable List out:

```
function immutablePromiseAll(promises) {
  return Promise.all(promises).then(Immutable.List);
}
```
 Here's a jsfiddle which should help as a basic test for this:

http://jsfiddle.net/exc8vbhc/1/

Currently it passes in latest Firefox but fails latest Chrome.
 Filed: https://code.google.com/p/chromium/issues/detail?id=441175
 The bug I filled with chromium is actually a v8 (hence node) bug. Node's Promise does not follow spec
  Thanks
  Yep, you want `set` and `setIn`
  I think the behavior should be same as `Math.max.apply(Math, list.toArray())` which is not order-dependent. So thanks for pointing out this discrepancy.

However, I'm not sure that NaN and friends should be ignored. NaN has significance when used in math operations - the result of a math operation in which NaN is an argument should always produce NaN. It's a way of bubbling error conditions up through nested operations.
  `instanceof` is just too underpowered to do what you want to do here. It requires a single chain of prototypal inheritance. We would just end up tipping the scale in each direction as we try to support every case.

The nice thing about React propTypes is that they are just validation functions in the form:

```
type validator = (props: Object, propName: String, componentName?: String): ?Error
```

So you can define your own! You don't need to use `React.PropTypes` for every case.

You can see how React defines the set it ships with here:

https://github.com/facebook/react/blob/master/src/core/ReactPropTypes.js

But let's see what we would want to do for Immutable types. We don't want to explicitly state that it wants a Cursor if we can avoid it (it should be transparent to our React components if we're providing values vs Cursors to values) so instead lets just check to see if it's Keyed:

```
function propTypeImmutableKeyed(props, propName) {
  if (!Immutable.isKeyed(props[propName])) {
    return new Error('Expected ' + propName + ' to be Keyed');
  }
}
```

Does this suffice?
 Tracking this in #509
  Don't worry. I'll make this happen soon, the docs aren't linked too yet because they're not quite done. 
  I'm getting really close too! It's gunna be a good thing
 Closing because http://facebook.github.io/immutable-js/docs/
  Can you provide some code sample illustrating the issue and what you expected? I don't completely follow.
 Gotcha, thanks.

I think the issue here is that there are only a few methods which are safe to use on mutable copies, and while remove is safe to use on mutable Map, it's not same on mutable List.

I'm not sure yet what the right fix for this is yet.

---

> Okay I realize this question may be semi-flawed CS-ically because we probably want to go with a whitelist approach of building a new list using .filter() or something rather than chaining removals, as positions change after every single remove mutation.

I think this is exactly right. Under the hood, `remove()` is a simple filter to exclude one index. Filters always create new collections and can't modify mutable versions.
  This is clever. Let me think about the implications of this a bit more.
 Yeah, I'm really sorry for not keeping you apprised, Tim. The benchmarking
suite was a pre-req for this to make sure we don't regress. I'm sure
there's a way to do it, and now we can measure different approaches!

Lee Byron
[ lee@leebyron.com | (317) 460-9114 | www.leebyron.com ]

On Mon, Jan 19, 2015 at 9:33 PM, Tim Griesser notifications@github.com
wrote:

> So I updated this to latest and ran that new perf suite, looks like this
> branch takes a pretty substantial hit ~50% or more on each of the tests.
> 
> So unfortunately this doesn't look like it's the best approach, though
> figuring out some way to do this eventually would be really cool - the
> ability to have custom types for Maps/OrderedMaps has proved quite
> convenient in our application.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/pull/227#issuecomment-70595441.
  Sorry for the delay in answering here.

I'm not sure what the value of `defaultItem` is, but if it causes the updating function to behave as an identity function, then no update will occur by design.

Since this task was opened, I've updated the documentation of `updateIn` to hopefully explain this behavior a bit more clearly.
 Updated the documentation recently to suggest using modern function param default values instead of notSetValue - it helps avoid this API corner case.  I just want to pick one and be consistent so you don't need to think so much about which to use.
 Sure, go nuts. You might want to start with the ones I've already written for Jasmine.

https://github.com/facebook/immutable-js/blob/master/__tests__/Conversion.ts#L24
 The day we can reasonably do array-like bracket access (ex. `myList[2]` instead of `myList.get(2)`) then I think we should support `length`. Otherwise, I fear that Immutable.js Lists would suffer from incompatibility with code that expects a non-zero length to imply that bracket access will work, which I think will be surprising in the worst way. Some minor awkwardness to avoid that pitfall is probably the right thing to do IMHO.
 There used to be a warning during the transition away from using it - but even that warning resulted in issues with integration in other codebases that sniff for types, such as the dev tool console.

If you're looking to avoid accidental usage issues, I strongly recommend using Flow or TypeScript  See https://github.com/facebook/immutable-js/wiki/Predicates
  map.keys() gives you an iterator of keys. 
map.keySeq() a lazy seq (Iterable) of keys. 
map.values() iterator of values. 
map.valueSeq() a seq of values. 

These exist for all collections, not just Map. Full descriptions of each are in the type documentation. 
  Yes, except it's JavaScript, so "homogeneous" only means something when a type system like Typescript or Flow is applied. JavaScript is dynamic with loose types.Â 

For example, you could type your example as List<any>, and in fact TypeScript or Flow would infer that without you having to type it.
 Another way to say this is that no runtime type checking is done by this library.Â 

Does that clarify?
  I agree this should be possible. Adding this to my TODO list.
 Merging into #301.
  Thanks for highlighting this. The correct fix is probably to make sure filter (and related methods) aren't methods of Record
 Merging into #505   I'll try to make this more clear in documentation, `b:` here points to a mutable object, so we can say that `map` is immutable but not _deeply_ immutable. It may contain references to mutable objects. The reference itself may not be changed, but of course the mutable object itself may change.
 A terse way to describe this same case:

``` js
var mutable = { foo: "bar" };
var map = Immutable.Map({ ref: mutable });
map.toJS(); // { ref: { foo: "bar" } }
mutable.foo = "baz";
map.toJS(); // { ref: { foo: "baz" } }
```
  A List is a concrete data structure. It actually stores values in memory. A Seq is a lazy operation representation. You can think of it as a very light-weight container of a previous Iterable and some operation to apply (map, filter, etc), that operation is applied only when necessary to get a value. Seq doesn't store any values itself. 

Most of the time you want to use List. Seq is useful for making complex operations from List to List more efficient. 

This library could exclude Seq and keep working just fine, it's a tool for performance. However List is vital to the library.

Does that answer your question?
  This also came up in #198 so I figured it's worth documenting this:

https://github.com/facebook/immutable-js/wiki/Converting-from-JS-objects

Let me know if that answers your question!
 And always does what you expect :)
 Good catch!

I updated the wiki
  document `valueOf`, `equals` and `hashCode`.
  This works today! If you have a case that isn't working correctly please let me know as that would be a bug.Â 

â€”
Sent from Mailbox

On Sun, Nov 23, 2014 at 6:19 PM, Dave Tonge notifications@github.com
wrote:

> Thanks for the library - I've been playing around with it, but for my use case I need the ability to use complex types as keys for maps, i.e. to use a Map as a key for another Map. 
> [ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) does this, as does [Mori](http://swannodette.github.io/mori/#hash_map). Do you know if this is on the roadmap?
> 
> ## Thanks 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/215
 Closing this issue since this implemented. If there is a specific bug please just reopen with a reproduction case!
  This is intentional. 

The only reason concat behaves the way it does is for behavior matching with Array, but it should really be treated as accepting `Iterable<T>` because of ambiguity pitfalls. unshift and unshiftAll are explicit about the type they accept: `T` and `Iterable<T>`, respectively. Strings are iterable, so this behavior is intentional. If you want an intelligent swapping of behavior, you should use a small helper function to check Array.isArray or something like it before using one or the other.

Stack() and Stack.of() have similar explicitness of the type they accept. Stack() accepts `Iterable<T>` while Stack.of() takes vararg `T`. So there are no ambiguous cases.
 If you want stack creation to treat the string as an iterable, use Stack() constructor, which will iterate out each character, as unshiftAll does. 
 For the use you're suggesting, I would recommend a helper function such as:

``` js
function listFrom(maybeList) {
  if (Immutable.List.isList(maybeList)) {
    return maybeList;
  } else if (Array.isArray(maybeList) {
    return Immutable.List(maybeList);
  } else {
    return Immutable.List.of(maybeList);
  }
}
```

This way you have clear control over each case and how it should behave relative to the type of input you expect for your function. You can of course swap out `Stack` for `List` above and have it behave the same.
  What if the return value wants to be falsey or undefined? It seems like this implementation would discard it.

For example, maybe I want to use this enhancement to make sure the cursor to my "a" key is always an even number. This test will fail, because the return value `0` is treated as falsey and so the new value will continue even though my validator said it should not.

```
var data = Immutable.Map({a:0});
var cursor = Cursor.from(data, ['a'], (newValue, prevValue) =>
  newValue % 2 === 0 ? newValue : prevValue;
);
cursor.update(() => 1);
assert(cursor.deref() % 2 === 0);
```
  Sorry for not seeing this before.

This seems like a good idea, but I'm a little bit concerned about applying the heavy weight of OrderedMap without option. I think it may be best to remain ordered though.
  Slick!
  This is great, thanks!

You've got it the right way, it's based on [JSON.parse/reviver](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter)
  Thanks.Â 

Feel free to propose a fix with pull request if you're up for it!

â€”
Sent from Mailbox

On Thu, Nov 20, 2014 at 6:36 PM, Francisco Ryan Tolmasky I
notifications@github.com wrote:

> In Immutable.d.ts the following is listed as an example for using fromJS:
> 
> ``` javascript
> Immutable.fromJS({a: {b: [10, 20, 30]}, c: 40}, function (value, key) {
> var isIndexed = Immutable.Iterable.isIndexed(value);
> return isIndexed ? value.toList() : value.toOrderedMap();
> });
> ```
> 
> If you try running this however, you get:
> 
> ```
> return isIndexed ? value.toList() : value.toOrderedMap();
>                                           ^
> TypeError: Object  has no method 'toOrderedMap'
> ```
> 
> ## In my own dealings with fromJS I also experience this. For arrays I'm getting a Seq that responds false with isIndexed.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/208
  Fixed in master, will be released on npm soon.
  Merging into #51
  Seems reasonable. Let me dig in to see just how difficult this will be :)
  Hell yes
 TypeScript predates Flow by a while, so when I started this project Flow didn't yet exist. Also, the type definitions are not here for the benefit of the library, but for the benefit of people using the library with these type checking tools. Since a lot of people use TypeScript (myself included) it felt like the right thing to do to include type definition files for it.

Once I get the Flow type definition files, the TypeScript ones will remain in the repository and up to date as well!
 Sorry for the delay. I'm excited to see progress on this. Nice work.

How have your flow definitions been working? Are there any holes?
 The flow team is working on the magic auto-conversion, but it's possible that it will be lossy, so the plan will be to update both manually.
 Supporting the *In methods would be awesome @samwgoldman, let me know if/how I can help you accomplish that
 Sorry this issue should be closed. Flow types were added in the last major version. 

See: https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow
  I'm not able to reproduce this issue. What environment are you using? (OS & Browser version)
 Also, can you post some code as a jsfiddle or requirebin that illustrates the problem?
 I think I might understand what's happening here, though I still haven't managed to get code to run which reproduces the error.

I'm not super familiar with Reflux, so let me know if this makes sense to you:

It looks like Reflux is supplying the Immutable instance by using setState, which React expects to be a simple object, as it will do a shallow merge into the previous state. Instead replaceState must be used.
 Here is an example: http://requirebin.com/?gist=e3673062232a500f1ecb
 Closing this issue then, since it's not an issue with Immutable, but with Reflux
  Is this a common pattern for you? I'm curious of a championing use case.
 Great example, thanks.
  How about this?

``` js
function tee(v) {
  console.log(v);
  return v;
}

Immutable.List([1,2,3,4,5]).map( x=> x + 1 ).map(tee).map( x=> x + 1 ); 
```

outputs:

```
2
3
4
5
6
List [ 3, 4, 5, 6, 7 ]
```

is that what you're looking for?
 Or if you want to print the whole list at that point, you could use the same printing identity function as a whole updater:

``` js
function tee(v) {
  console.log(v);
  return v;
}

Immutable.List([1,2,3,4,5]).map( x=> x + 1 ).update(tee).map( x=> x + 1 ); 
```

outputs:

```
List [ 2, 3, 4, 5, 6 ]
List [ 3, 4, 5, 6, 7 ]
```
 Closing this, reopen it if this didn't answer your question.
  Thanks!
  Currently there is not. I want to ensure that exotic objects (Date objects, DOM nodes, user-defined special things) don't get converted unintentionally.

However, the implementation of fromJS is really quite small, so making your own version with semantics custom to your environment would result in a fairly small utility function.

``` js
function fromJSGreedy(js) {
  return typeof js !== 'object' ? js :
    Array.isArray(js) ? Immutable.Seq.Indexed(js).map(fromJSGreedy).toList() :
    Immutable.Seq.Keyed(js).map(fromJSGreedy).toMap();
}
```

Or a version which turns array-like things into lists instead of strictly Array:

``` js
function fromJSGreedy(js) {
  if (typeof js !== 'object') {
    return js;
  }
  var seq = Immutable.Seq(js).map(fromJSGreedy);
  return Immutable.Iterable.isIndexed(seq) ? seq.toList() : seq.toMap();
}
```

Does this work for you?
  Now that we have `Immutable.isOrdered`, we should respect it as much as possible. For minimal impact, the initial implementation of ordered-ness for the lazy Seq type is always ordered, however it would be better to be smarter and inherit this property from the parent iterable.
  This is an area which needs better documentation. `splice` is actually not a mutative operation and can't be used within `withMutations`. 
 I'm leaving this open, and retitling it.
 `set` and `push` are the only safe operations to call within `withMutations`. In a future major version of Immutable, this example code will throw an error to make that more clear. Since these are unsafe to use in `withMutations`, they're simply not doing anything.

Also just to make sure you're aware of what's built here - you have an immutable list of mutable objects. For the example that you're illustrating here, it doesn't much matter. But if you ever edit any of those objects you are editing them wherever they are referenced since they're mutable.
 Link?
  Not newly broken... just poorly defined.

3.1.0 added a performance optimization which can possibly change the iteration order of it's keys. Since Map iteration order was always undefined, this should be safe.

The issue you found here is that our equality checking is asserting that iteration order is part of equality. Of course, if a Map has undefined iteration order, then you can't possibly compare the equality of two Maps. Oh shit!

Added an `Immutable.isOrdered` predicate to express at runtime which iterables have defined iteration order in d1c37bce449c52cf67156341e1dd0a3cbd57d570

Then `Immutable.is` and `myIterable.equals(other)` respects `isOrdered` in 79e903b986b2dcef24f5200287fc92c1b7d11810

Thanks for finding this!
 Released 3.2.0 with these revs.
  Yep. This is a tradeoff between possible leak (if it leaks is actually dependant on usage) and performance. OrderedMap#remove is currently O(log32N). We can guarantee limited memory consumption, but it would change OrderedMap#remove to be O(N).

Also, FWIW, this implementation is the same as Webkit's implementation of ES6 Map (a lookup table along with a sparsely-used list). https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/runtime/MapData.cpp
 I'm open to suggestions here.
 It was also broken before that change :)

There isn't an equivalent to replaceAndPackBackingStore but there probably should be. Thanks for pointing that out!
 Fixed by e1b5fe492e747c2d788326595e648e6e08a8c2e8
  Thanks for reporting this! JS arrays coerce numeric strings, so I did the same.
 This is more complicated. Integer and string keys are both valid for Map. "3" and 3.0 are distinct keys.Â 

â€”
Sent from Mailbox

On Thu, Nov 13, 2014 at 6:55 PM, Pedro Henriques dos Santos Teixeira
notifications@github.com wrote:

> great!
> Perhaps, could coerce for the case of integer keys in Map as well :)
> 
> ```
> Immutable.Map({3:10}).get(3)
> ```
> 
> ## => undefined
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/193#issuecomment-62988989
  Hmm. This one is pretty tricky, yes. Maps have no defined order, so sorting them isn't super useful. The same issue exists with Sets right now.

I like the idea of explicitly returning OrderedMap from a map.sort(), I'll find a way to do the same for Set.
  I would love to have this, yes.
 Closing this aging issue. (nice work, @glenjamin!)  Closed in 19ebae805ccb3d81cf4d66ebcef9377d32a0d79a
  Thank you!
  Good catch, and thanks again for sending the pull
  Great catch. Thanks!
  Thanks
  Yeah, it's treating these as "array-like" which is too aggressive for both fromJS and Map constructor.

This is ambiguous behavior, more than a bug, but it's certainly confusing and I agree with you that this confusion and ambiguity is pretty critical.

I'll get on this and make sure the fix is in the next point release
 I'm close to a fix to this, and expanding test coverage to ensure it's done correctly. I'll update here when I have this issue fixed and released.

I agree with you that `fromJS(boringValue).toJS()` should return something of the same shape. That's a totally reasonable expectation that I will add a test for so it's actually upheld.
 Fixed by def9a096d25928d809930aa64fa1e4f07424f460
  Ah, thanks. This was actually an intended change in v3, as it's a better enforcement that keys are strings and better mental model since Records are more closely related to Object than Map.

I will update the docs to make this more clear, that was my mistake.

Thanks for bringing this up!
 Should be fixed by 0c5ca8f344908e3c5b106bae7b008948e6a9f859
 I also made an edit to the Wiki to point this out.
  Going to close this since it can't be merged. I don't think I can handle the mental bandwidth of keeping more package managers up to date than we currently have.
  Good catch, thank you :)
  I'm sorry I've let this languish. I really do support this and want to get it right. I do want to do some light refactoring to make the implementation a bit more robust. I'm making this a priority. Thanks again for your patience, I know you've been waiting!
 335b312c3e80ed2051b62ae4f29ba34f2734d3e9 Adds this functionality, including borrowing your test cases.

However, it does not cover keyPath for Cursors. I'll follow up.
 And 0ca53e537b82c73dca7e190fa16f87f8453967f4 adds this to Cursor
  I will definitely document this! I imagine it's an uncommon case though. Usually you want to simply use object identity directly.Â 

If you find yourself implementing hashCode() make sure to also implement equals(other)
 If you want to use object identity, just pass the object into the set directly, no need to implement hashCode
 #506
  Closing this aging issue. 

This is still something we would like to get to in the future, but won't be able to make it happen soon.  VesaVesQ: @reactjs Kind of buggy header on Firefox Mobile (android) http://t.co/BU8ALznb1r
 Thanks for the additional report! I'll look into what's going on for FF
  Thanks, I took the tests from your pull, but needed to implement it slightly differently in order to solve another issue with Record in 0c5ca8f344908e3c5b106bae7b008948e6a9f859
  I really agree with a lot of what you're saying here. Thanks for spending the time to write it up. I'm interested in devoting v4 to a better Record API.

First, I agree that Records implementing the Map spec doesn't really make sense. If you're iterating over your record as if it's homogeneous, then you're probably doing it wrong. This was my mistake.

I think the Record prototype API should be a little fuller than what you're proposing, but not by much. I think I would propose:
- `get` â€“ safely access any field, in case it collides with a prototype method. Also allows use with `getIn` called by a parent.
- `getIn` â€” deep access
- `has` â€” maybe even call this `hasOwnProperty`. Not sure.
- `set` â€” persistent set
- `setIn` â€” deep persistent set
- `update` â€” has positive performance implications, allows point-free updater functions, and allows `updateIn` called from above.
- `updateIn` â€” deep persistent update.
- `hashCode` â€” treat Records as values
- `equals` â€” treat Records as values
- `toObject` â€” back to JavaScript land. Also, think of this as "toMutable"
- `toString` â€” obvi.

I'm also considering having Record be a base prototype, not extending Object.
 > This approach has a number of advantages. First of all, it becomes feasible to simply implement it with a vanilla JS object and Object.freeze. I'm not sure what the performance characteristics are, but I suspect that the structures underlying Map (and thus, the current Record) aren't that much more efficient than a simple shallow clone for very small amounts of fields (like is typical for records). set would just shallow-clone the object, overwrite one value (or more, maybe), then freeze the new object.

Unfortunately, Object.freeze carries an very significant performance hit. To the point where Map dramatically out-performs it. However, I do agree that a much simpler underlying (unfrozen) object likely wins the performance war. What I would love to do is benchmark the performance of gets and sets for these three cases (frozen obj, regular obj, Map). My expectation is that Map becomes more performant after some threshold of key size, and that we can internally intelligently switch to use Map only when copying huge objects becomes slower.
 > First, shorthand field access (record.fieldName) works on ES3 too (currently it is implemented with defineProperty so only ES5 browsers and up will manage)

Unfortunately, there's no way to enforce immutability for ES3 with shorthand property access. Object.freeze is ES5 only, along with defineProperty.

Our only two options here are to drop support for ES3 (predominantly IE8) or to offer an non-shorthand API (`get`/`set`). That's ultimately why I decided to also expose get/set and not only property access. If you only care about ES5 browsers, you can use property access!
 > Finally, somewhat offtopic, but why did you choose obj.set('field', value) over obj.set({field: value})?

Consistency with other uses of `set` both in this library and in ES6. Map and Set's `set` can't accept an object, because their keys can be anything, not just strings. Records must have strings, but keeping the API consistent was important. `Map` has `merge` which accepts an object. Maybe it makes sense to have something like `Record.assign` similar to `Object.assign` which conj's multiple records or objects together into a single Record which would support this case.
 > One other strong advantage of backing Record by a plain ES3 object, is that you can simply pass a Record to any library that expects an object (including when it uses hasOwnProperty or Object.keys and so on), and it'll just work. Sure, toObject isn't far away, but it's nice if it doesn't matter.

Totally agree. It would be excellent to ensure these properties.

> One thing about freeze and enforcing immutability: this is JavaScript. Even if we try, it's a dynamically typed language that allows a lot of stuff, way too much probably. As such, I'm not entirely sure that it's necessary to enforce immutability in production code. Would it be interesting to ship two builds of the library, one for development, and one for production? Much like React, the development library would do all kinds of checks and Object.freeze and all that (skipping it if not available), and the production library would just back Record with a plain old object, end of story. I guess we can assume that even if Object.freeze does not work on every browser, it works on every developer's most commonly used browser.
> 
> If all development and automated testing uses a version that enforces immutability, then maybe it's no disaster if production code doesn't.

Yes, we do this in React and also all over the place in FB production JavaScript. In dev mode, we are strict and throw exceptions loudly, and in production we're more likely to fail silently with the hope that nothing bad will happen that we didn't catch in dev.

In practice, this is pretty hard to manage outside of a larger software shop like Facebook. You really need significant coverage over your dev build to ensure all edge and corner cases are caught before production. This kind of discipline requires organizational work. Therefore, easy to fuck up. We even fuck it up once every few weeks, and need to hot-fix things that we should have caught in dev but didn't.

One step further into the future for Record is part of an ES7/ES8 spec that would enable VM optimizations and techniques for parallelization. One of the reasons to prefer immutable data in multi-threaded environments is you need no locks. JavaScript's WebWorker interface is simplistic to shield us from the perils of multi-threading, but a truly immutable value should be able to pass to and from WebWorkers without serialization overhead. I recognize that this is overkill when targeting ES3/5 browsers of today, but something I'm keeping top of mind.
 > in practice, what happens when code tries to mutate an immutable object?

IMHO immutability enforced, throw an error and stop execution.

I should clarify that the reason we don't use Object.freeze in production is purely because of the performance tax. I actually think Object.freeze's behavior of silently failing on mutation attempt is actually bad. It's really easy to think everything is working when it's subtly not working. Also, execution behavioral differences between development and production environments are often the source of great pain and frustration. "Bug repros in prod, but not in my dev environment" is a heart-sinking feeling where you know you're about to lose a day. I just want to avoid anything like that.

> I don't know about how these ES7/8 VM tricks work, but I assume it'll mean telling the VM "we promise, this won't go wrong"? In that case, it's still a userland promise so there's no real difference to passing an Immutable.Map or a plain old JS object.

If I can spec this, an ES7/8 environment could provide immutable Record as a VM promise, not a userland promise. That's the only way to let the VM optimize it (memory usage, access patterns, shared memory between threads). A polyfill of this for <= ES6 would offer immutability as a userland promise to provide the same developer API and behavior, but maybe not the same performance characteristics.
 As an example of prod/dev behavior - at Facebook we use a lot of `invariant()` style assertions which check a condition and throw an error if it's broken. We don't remove these in production despite the fact that removing them could save some download bytes and condition checking. The value of having the same behavior in prod overrides that.

I think I've got us on a tangent though :), we both agreed above that expecting usage of a development build to catch issues could be problematic enough.
 Thanks David, I think that's probably pretty close to what I'd like to do.
 @abergs - if each record in the collection was a modification of a previous record then this works today! Just sub `List` for "Collection".

Structural sharing is the result of (Representation A) + (Operation X) = (Representation B), so if you can express your 1000 similar records in terms of "previous-record + operation" then absolutely.

Otherwise, it's actually pretty hard to do the reverse, taking `B - A` to get `X`. It's possible, but you're likely to trade a 2-3x improvement in memory footprint for a linear (`O(N)`) degradation in runtime performance.
 @eteeselink good points, thanks again for your input. Conversion methods like `toObject` and friends will need to be there.

I will probably still implement by backing with `Map`.

> One goal I had was being able to pass a Record to any function that expects a plain old JS object, but it appears that that's nearly impossible to achieve.

This is indeed tricky. `Record` uses property accessor functions, which allows for the `myRecord.myField` expression, however it requires an ES5 runtime that supports this feature (e.g. not IE8). So fairly modern browsers will do fine with treating Record as a simple read-only object, but broad browser support requires using `get()`
 @Pauan mind sharing your perf script? It would be interesting to run it again since some perf improvements for small Maps have been added and I'm not sure if it was before or after your test.
 Merging this into #286.
  Fixed in 0c5ca8f344908e3c5b106bae7b008948e6a9f859
 Thanks for finding this and reporting it!
  ```
Immutable.List.of(1,2,3,4,5).splice(2,1)
"List [ 1, 2, 4, 5 ]"
Immutable.List.of(1,2,3,4,5).remove(2)
"List [ 1, 2, 4, 5 ]"
```

Previously, `remove(i)` behaved similar to Array's `delete arr[i]`, which is roughly synonymous with `arr[i] = undefined`, which is far less useful when working with a dense list.

Does this help clear any confusion?

But maybe you're referring to something else? If I can help clarify the docs, I'm happy to.
 fair :)
 Just edited it to read `list.remove()`
 Awesome, thanks!
 Thanks, will fix.
 Fixed in f93acade760c699151255edf80df45e770f65f03
    @wolffiex recently also pointed out some related issues with mergeDeep.

I'm digging into this now, and will write up more test cases
 Pop open that commit to see what was happening, if you're curious.
 Also relevant 1a707cbfd5a50f4f75aa61227b644f0ac03501d9
  The good news is that this is totally possible. You'll just need to write a little bit of a helper since typed arrays aren't designed to be built from iterables.

``` js
var ia = new Int8Array([0,1,2]);
```

Converting from a typed array to an immutable List is straight forward:

``` js
var list = Immutable.List(ia);
// List [ 0, 1, 2 ]
```

Converting back requires a little work:

``` js
var ia2 = list.reduce((ia, v, i) => (ia[i] = v, ia), new Int8Array(list.size));
// [0, 1, 2]
```

Does this cover what you need?
 Not currently, no. A lot of the performance benefits of typed arrays is the ability to be backed by a single buffer - but the data structures used here are trees of small arrays. It's unclear how much performance we could actually gain from using typed arrays.
 Closing this aging issue  Hmm.. I'll look into this for you. What you've typed up there seems very reasonable, but sometimes TypeScript requires some convincing.
 Ah yes, that example is valid ES6, but not TypeScript.

I haven't tried this, but perhaps this might work:

```
var _ABRecord = Immutable.Record({ a: 1, b: 2 });
class ABRecord extends _ABRecord {
    getAB() {
        return this.a + this.b;
    }
}
```

If not, I'll have to look into how to get this working in TypeScript in better form.
 Hey! I'm not sure yet actually and am open to suggestions.
 Latest type definitions are helping out quite a bit more, will be released soon  Thanks @tgriesser
  What ES6 code are you seeing?
 Ah, you're right, there are arrow functions in there! I will get a rev up to fix that. Thanks for letting me know!
 Fixed in master, I'll have a point release on npm a bit later
 3.0.1 is now on npm!
  Yep, this is intentional.
 Thanks @pluma, good explanation :)
 In a future release, I'll change the inspect string of Cursors to be "Cursor" instead of "Seq" to make this a little more clear.
  filter is a lazy operation, Sequence represents these lazy operations. To convert back into a real collection, use `toVector` so your example:

``` js
Vector([1,2,3]).filter(function(x){return x == 2}).toVector().set(1,'x')
// Vector [ 2, "x" ]
```
 By the way, this will change in the next major version of the library, lazy-by-default has confused a lot of people.
  Thanks!
  <3 browserify
  The uppercase file names were a mistake, they should be lowercase. This was supposed to be fixed in 2.5.1 but the 2.6.0 release was a regression.
  Vector is always dense.

What performance characteristics are you looking for in a different data structure?
 In data structure libraries, "List" often means "LinkedList". If you're looking for that (cheap O(1) LIFO) then `Immutable.Stack` might suffice for what you're looking for.
 Vector.remove() is similar to `delete array[at]` but only leaves the value set as `undefined`, `has()` will still return true, because Vectors are dense.

The difference between `remove` and `splice` is whether or not the indices after the removed indices shift down to fill the slot or not.

Almost all of the time, you can consider `vect.remove(index)` equivalent to `vect.set(index, undefined)`.
 I'm going to close this issue because it sounds like Vector supports the case you need.
 remove(x) should probably behave like splice(x,1) though. That is confusing at the moment. I'll fix that in a future major version.
 There is not a lot of advantage from it. It's a hold-over from when Vectors were modeling sparse collections, before v2.3. Now it's equivalent to set(i, undefined), which is less useful.
 Note: in v3, `remove(i)` is now equivalent to `splice(i, 1)`
  Thank you. I'm not sure wtf happened here.
 v2.6.1 is now out
  Thank you!
  Should now be fixed on npm with v2.6.1
  Thanks for the recommendation.
 I think this should actually be a filter predicate so it can apply not just to Map but to all Sequences.

You could use a simple predicate builder to implement `pick`:

``` js
function keyIn() {
  var keySet = Immutable.Set.from(arguments); 
  return function (v, k) { return keySet.has(k); }
}
```

so then you can do `myMap.filter(keyIn('a','b','c'));`.

For convenience, I just added `filterNot` in 163a40b8f8291f0dd448e5560d0a0c70e73dda39 to make negating predicates a little easier to do, so `.omit` becomes `.filterNot(keyIn(x,y,z))`.
 I think that's a great idea. I'll figure out what structure works best and then add this to it as one of the first examples :)
 Tracking that in #152
 Starting the seeds of a wiki to stash away this knowledge

https://github.com/facebook/immutable-js/wiki/Predicates
  ``` js
var x = Immutable1.Map({a: 1});
var y = Immutable2.Map({a: 1});
Immutable.is(x, y); // false
```
  This is actually not necessary. `NOT_SET` is never stored anywhere or returned back to user-land. It's only used within the context of a single call stack and only internally, so it's safe to have one global reference and reduce allocations for these operations. It's not the main blocker of #117 
 I like the `removed` argument though. I think that's clearer.
  Thanks for the report! I just fixed this bug in master and will have an npm version out soon
 I'd love to see an example of your flux stores!
  Good thinking, thanks for writing the test as well.

I think it may be easier to just remove the `toArray` (and `ObjectSequence#toObject`) methods entirely and rely on their base implementations.
  I've never seen this before and can't repro.Â 

What browser and OS version do you have?

â€”
Sent from Mailbox

On Mon, Oct 20, 2014 at 4:03 AM, Robert Nagy notifications@github.com
wrote:

> The workaround for now is to always `get` every value twice.
> 
> ``` javascript
> var value = map.get('key') || map.get('key');
> ```
> 
> ## I only get the problem in special cases and I haven't managed to create a small repro sample... not sure what is going on...
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/145#issuecomment-59727402
 I think we need to see more code to understand what's going on. `get()` has no side effects and so calling it shouldn't cause calling it a second time to behave any differently.

One possibility is that whatever JS VM you're using is making poor optimizations that are altering the runtime behavior. We've seen this before, but without code I can run to repro it, I won't be able to investigate.
 If you could provide a sanitized version of your production code for me to investigate within, or if you investigate yourself then please reopen this. Otherwise this isn't actionable without a repro case.
  thanks for the report. That should say "first()" I'll fix it!
 Improved in ed332199f41e5240676ef03ad023d122d91c47ec
 The reason it was wrong was due to recent changes to lazy sequence operations and the Readme wasn't kept up to date. Should be better now
  Sorry can you clarify? Are you suggesting that your code doesn't work? Are you looking for help simplifying the code?
 Hmm, I'm not seeing this issue reproduce. I wrote a test case to make sure mapping over a cursor returned more cursors in 3fba5a5e60d907d29e37121c78a71871d8ca3809 and the test passes.

Your example from above might work if you change it to:

```
var reactElements = cursor.get("values").map(function (subCursor) {
  return <Element className="foo" initial={subCursor} />;
});
```
 Expanded the test to cover Cursors to Vectors and not just Maps in 07348f43973e11d2f50c75c646d298b911422487, still passes. 
 No problem! I'm glad you got things working. 
  I'll look into this
 Indeed a bug. Thanks for the report!
 Merging into #141 
  Solved in 9e63cc0b6f3a310cfe73b0adf86daf72c847e769 - will be on npm soon
 Thanks again for the report!
  Thanks for the pull! Great find and fix.
  I fixed this in master yesterday. I'll get a fix release on npm today. Thanks for the reminder!
 Closing for now since it's fixed in master. stay tuned for npm
  Reopening. 

The cursors in this library are definitely far from good. Still "experimental" I guess. 

I have some ideas on how to solve this that line up well with the links and ideas shared here. Thanks for keeping the brainstorm alive, guys :)
 Yep! I'm working on v3.0.0 now which will introduce some API changes around Sequence construction and will expose the ability to create your own
 Hey @tgriesser - Immutable v3 is out now and exposes everything you should need to implement your own variant of Cursor. Check out the contrib dir to see the existing Cursor impl which has no internal dependencies.

Documentation is relatively limited right now, so if you come across anything that took a while to wrap your head around, please either let me know or write something up. It could be really awesome to have a wiki page describing how to extend Immutable.
 Yes, my hope was that would be implied by the contrib second-class :) I will add it to docs so it is explicit.
  This looks like an awesome tool, thanks for the suggestion!
 I'm getting started on this now, by the way. I intend to do it right.
 http://facebook.github.io/immutable-js/docs/ Feedback welcome. I plan to continue to improve based on feedback.
 Yes, adding contrib to the docs is on the plan :)
  Awesome thanks!
 I manually merged it. No big deal :)
  This isn't really viable because `Sequence` does not imply concrete backing data, only that the Collection is "sequenceable" (at some point in the future I may rename to `Iterable`, as its a clearer name). Not all Sequences (Iterables) could support a set() method.

If you're doing persistent mutations, then I would recommend using Vector and Map instead of Array and Object as they are concrete collections and will give you much better memory usage over time.
  This is expected. What you have made is an immutable map which contains a mutable object as a value, and your example code is mutating that contained mutable value.

If you replace the Immutable.Map() line with Immutable.fromJS(), it will deeply convert the js object into nested Immutable Maps. 
  Can I ask the use case?

â€”
Sent from Mailbox

On Tue, Oct 14, 2014 at 12:17 AM, plievone notifications@github.com
wrote:

> ## It would be nice to have the version number included in built lib?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/133
 Makes sense. I think a comment block is a good idea.
  Good catch. Thanks for the test!
  Hmm, I just pulled 2.3.0 from npm a couple times without any issues.

I'm closing this for now, but if you reproduce it from another machine or network, let me know and reopen this.
  :+1: 
  Definitely a bug, thanks for the report!
 Released in v2.2.2
  Really just avoiding the kitchen sink problem. It's easy to keep adding these sorts of convenience methods until the library grows huge and burdensome. I want to keep the mantra something like: what ES7 should consider adding to Array/Map prototype. 

For max:

mySeq.reduce((a, b) => a > b)
 This isn't to say I wouldn't add these methods, but the demand for them should be pretty high first. 
 I just realized my comment code sample was totally wrong. This will work though and reads pretty well:

mySeq.reduce(Math.max)
 FYI, I just added these (and minBy and maxBy) and will be in the next minor rev.
  Is there a branch of the project and a test I can run with node or something to repro this?

Unfortunately I'm not sure there's enough information here for me to go on.

From a cursory read of the stack trace it seems like it's not an issue with `Immutable.is`, but one of the map or filter functions previously used since those are lazy and wouldn't have fired until `Immutable.is` forced them to.
 Ok, let me know if you make any progress on a smaller test case
 Cool, let me know if you end up shrinking it any further or have any leads on what's up. I'll try to dig in and see what's going on
 This is now fixed in v2.2.3 which is just now on npm
  Totally on point and great tests. Thanks for catching this issue and for fixing it so quickly! Excellent work.
  You should use `Record` for this.

```
var World = Immutable.Record({
  rooms: Immutable.Map.empty()
});

var myGame = new World();
var firstGame = myGame.update('rooms', function (rooms) { return rooms.set('palace', 'cold and dark')});
...
```

If you use ES6 transpiler, you can really tighten this up:

```
class World extends Immutable.Record({ rooms: Immutable.Map.empty() }) {
  createRoom(name, desc) {
    return this.update('rooms', rooms => rooms.set(name, desc));
  }
}

var myGame = new World();
var firstGame = myGame.createRoom('palace', 'cold and dark');
...
```
 Record will give you a more efficient "clone" and abstract it away. Also, it will then provide an API designed to deal with immutable persistent data.Â 

Your approach is okay, but the root level is still a mutable object, and you will have to closely protect it from mutation.Â 

And yes, I agree that using Object.create is a bad idea, as each mutation will add to a chain and access will get slow and memory will leak.Â 

On Sunday, Oct 5, 2014 at 5:21 PM, jayrbolton notifications@github.com, wrote:

Ah, interesting, I hadn't seen Record. Do you see red flags in the strategy that I cited? I think I'm still favoring it because it feels very simple to the end user and is perhaps easier to make arbitrarily named methods that take any number of arbitrary parameters and update any arbitrary amount of entries in the record

One thing I did notice in mine is that I probably shouldn't use Object.create(), because that will create endless nests of proto -- instead I'll use just a simple shallow clone func

â€”
Reply to this email directly or view it on GitHub.
  Currently, Vector and ArraySequence, and therefore IndexedSequence, are aware of and handle sparse holey sequences. There is a difference between an index being set as the value `undefined` and an index just not being set at all.

This has a lot of negative side-effects. 
- There is no clear way to describe holes in iterators.
- The differences between ES3/ES5/ES6/ES7 spec for methods on Array are confusing with respect to sparsity. (see [Array.from](http://esdiscuss.org/topic/array-from-and-sparse-arrays))
- It introduces a performance penalty by requiring hasOwnProperty checks.
- Difficulty in predicting values like the lengths of some indexed-sequence operations.

I'm proposing a change to Immutable-JS to remove the concept of sparsity/holes from Vector. There will no longer be a distinction between `undefined` at an index and an unset index. `vector.has(index)` will be replaced with a much simpler `0 <= index < length` check, and _not_ check if the value at index is the `undefined` value.

This also means a change for `.entries()` and `.keys()` iterators on Vector. `.keys()` will now iterate all indices 0 .. length, and `entries()` will do the same, where undefined indices will yield `[4, undefined]`.

My understanding of the primary uses for sparse vectors is a numeric map. Luckily, `Map` allows keys of arbitrary type, including (actually, especially) integers. Preserving this use case.

Some consequences of this change:
- Map's iteration order is not sorted (SortedMap to come in the future). No remaining way to describe an index sorted sparse list.
- Lossy conversion between Map and Vector. `Map(Vector(Map({1: undefined}))).has(0)` returns true. 

---

This is a call for suggestions, concerns, use-cases I haven't considered here from those using this library.
 cc @DavidTimms @spicyj @Tvaroh @tgriesser @rockymadden 
 Thanks, that's useful context and a vote of confidence for this plan. The behavior is the same for holes:

```
> mori.clj_to_js(mori.js_to_clj([,,,1,,,]))
[null, null, null, 1, null, null]
```

I do think maintaining the difference between null and undefined is important to preserve the JavaScript semantics, but the hole-filling certainly will make Vector different from Array.
 I have an open task (though lower priority than some other tasks) to implement SortedMap using a balanced binary tree or RB tree, but your code sample certainly would hold anyone over who would rely on this combination of traits.
 @rockymadden by monads I assume you mean the Maybe/Option monad? I'm a huge fan of null-less languages, but unfortunately JavaScript doesn't have a type system which is really crucial to the successful use of it (I've tried).

I also think it's beyond the scope of these data collections to introduce Maybe/Option, but you could certainly use any JS implementation of them along side it!
 But I definitely agree with your sentiment that sparse arrays do a poor job of describing "lack of value", and the Maybe monad does a great job capturing that.
 @rockymadden I've implemented it myself with [loda-js](https://github.com/leebyron/loda-js). The pain point is that there is just no way to enforce it's use across a codebase, especially since all of the JS/DOM native APIs return null/undefined/-1 all over the place and you end up not getting all of the program-wide safety you want. But at least within your application code you can reap a lot of rewards.

---

Ok, I'm really happy to see near total agreement on this. I have some pending diffs I'll wait to land in case there's more comment on this, but right now consider this plan in motion.
 Diffs are in.
  Yeah, this is intentional. `splice` is a lazy operation that returns a (lazy) Sequence. This is still pretty confusing and I plan on either changing the behavior or more clearly explaining this in docs.
 Yeah this is definitely not ideal. 

My plan to fix this is to make sequence operations eager for persistent collections like Map and Vector, but preserve the lazy route for the performance tweakers. I'm still figuring out the best way to present this, but I'm on it. I don't want to leave the library in a state where this point of confusion is so common. 
 Merging into #38 which makes concat and splice eager for Vectors.
  Thanks for the report, I'll dig into this.

For my curiosity, what are you using the seq 3rd argument for? At present, I'm sort of dogmatically matching the JS existing HOF APIs, but I would love to gather more info to make sure I'm properly supporting the cases people care about.
 Yes, this is definitely a bug as I intend to stick to the JS API.

Of course, this use makes total sense! You're basically doing a look-ahead/look-behind.

Thanks for this extra context, this actually really helps in terms of how I'll fix the issue.
 I'll get it out on npm soonÂ 

â€”
Sent from Mailbox

On Mon, Oct 6, 2014 at 8:20 AM, David Timms notifications@github.com
wrote:

> ## Closed #121.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/121#event-174590403
  Coercing object keys as strings is a JavaScript behavior, not Immutable-js behavior. JS lets you use "naked" keys, letting the quotation marks be optional, however object keys are always strings, even if they look numeric.

However, Map and Object are not the same. Immutable.Map (and ES6 Map) accept arbitrary keys (strings, numbers, even objects) and so no key coercion is done for any of the Immutable.Map API.

If you want to be more cautious of your Map construction when intending to use non-string keys, use kv tuples in the constructor. 

Map([['a', 'letter'], [1, 'number']])
  Great clarifications here! Thanks :+1: 
  Hey @ihodes! Thanks for the pull. I modified it a bit before I landed it to handle a couple other edge cases and expanded the tests.

`Array#join()` is weird. Check out these edge cases the test runner caught that illustrates the extra checks.

```
> ["",""].join(null)
'null'
> [null,null].join("")
''
```

The joiner is only ever checked against undefined, the `null` value becomes the string `"null"`. However, values in the collection are checked against null and undefined, and become empty string. >_<
 I'm learning a lot about Javascript's core libraries by fuzz-testing them.
  Right now this would be pretty difficult because the implementation uses object identity for a couple sentinel values. If you ran two copies of Immutable, passing a collection created with one instance into a method from another instance, you could see issues.

I'm curious what your use case is though, perhaps I can investigate a limited way to enable this to unblock you, while staying conscious of the tricky cases.
 This is really useful to know, thanks for explaining. I'll try to chip away it over time for sure.
 Good idea
 @mystor that can become dangerous for other reasons. One version of Immutable-js may be incompatible with other versions.

One of the design goals of Immutable-js is that it plays nicely in a vanilla JS environment. The uses of `x instanceof Immutable.*` should be few and far between. If we can accomplish this, then two versions of Immutable should be able to co-exist - but they would each appear to each other as "vanilla JS object"

Can you give some more concrete examples of issues encountered when using two different versions of Immutable in the same runtime environment?
 Thanks. Tracking that one in #149 now
 Thanks, that's #150 
 Just fixed both #149 and #150 in master.
 Closing this out as we should have everything you need to interoperate between different copies of Immutable.

Note: v3 and v2.6 only interop for the issues solved in #149 and #150, but two copies of v3 should smoothly interoperate.
  Awesome work
  Thanks for the report. This one is a bit tricky to solve as Immutable.Map is trying to be as close to ES6 Map as possible, including the behavior when constructing with Arrays. I will likely make this case fail faster and provide a specific API for building from indexed sequences like Array.
 Closed, this is now fixed in v3
  Thanks for the report. This is a known problem that #38 will help address.
 Merging into #38 
  I like that idea!
 Good feedback, @xixixao. Something to consider for future versions.
  Right now there are not many ways to construct these directly. They are mostly used to represent the lazy sequence computations such as mapping or filtering a Vector.

Range() is one of the ways you can create a lazy sequence directly. I haven't yet added something akin to `generate` or `repeat`, but those will come soon.
 Closing this - but note that in v3 (released late last year), Seq got it's own API directly.

``` js
var lazySeqOfStrings = Seq(["a", "b", "c");
```

Then you can use the full collections API on these.
  This is a pretty interesting suggestion. Let me mull it over a bit.

One possible issue is that a function could possibly be a key itself, which could create ambiguity between using the function as a key vs using it as a mapper.
 Yeah, feature-creepy is part of what I'm worried about here. If you're only looking for the "all" predicate, then that's just `map`, right? Would this suffice for your example?

```
var m = Immutable.fromJS({
  books: { name: 'Somename', price: 15},
  magazines: { name: 'Anothername', price: 8},
})
var n = m.map(function (obj) { return obj.update('price', function (v) { return v + 0.9 })});
```

Or using ES6 arrow functions for legibility:

```
var m = Immutable.fromJS({
  books: { name: 'Somename', price: 15},
  magazines: { name: 'Anothername', price: 8},
})
var n = m.map(obj => obj.update('price', v => v + 0.9));
```
 updateIn(predicate, ... could be done with a small utility for map:

```
collection.map(mapIf(predicate, mapper))

function mapIf(predicate, mapper) {
  return v => predicate(v) ? mapper(v) : v;
}
```
 I've already come across a pretty reasonable number of real uses where functions are being used as keys into a map, so I'd rather not break those existing uses. I find global config flags easily confuse as they aren't colocated in the API with the behavior and changing that can result in dependent code which shares the Immutable library not behaving properly.

@nonuby thanks for illustrating this use case, that helps me understand what you're trying to do.

In the meantime, have you tried something like:

``` js
appstate.updateIn(['contact','item','deals'], deals => {
  var dealIndex = deals.findIndex(deal => deal.get('id') === cmd.dealId);
  return deals.updateIn([dealIndex, 'breakdown'], breakdown => breakdown.push(
    Immutable.Map(...)
  )
};
```
 Closing this since it's aging, but I think a utility function that performs this sort of operation would be useful.
  I agree this behavior isn't very clear right now and might not even be right.

For clarity as I improve things, can you say more about the use case you're having trouble with? I don't quite understand the JSON reference with relevance to equality checking.
 That sounds like a really interesting project! I'd love to see it.

If I understand correctly, it might help to write your own equality method for use in your language which first checks that the two have the same constructors (are of the same class) and then calls `Immutable.is`.

I'm not quite sure I follow about losing type information when modified. For example `myVector.push('x')` returns another `Vector`.
 Or another way to say that is - they should definitely have type information, but the `Immutable.is` function doesn't use type information to determine equality right now, instead only comparing equality of the contained items. (This might need to change anyhow)
 myMap.set(k,v) should definitely return another Map.

Only the sequence reductions like map/filter/etc should result in a lazy Sequence (which you can always reify by calling .toMap() or .toVector() on them)
 The lazy sequences are one of the main reasons why value equality checking doesnt look at the type. A lazy filtered Map should be able to be compared to regular Map. However, I still agree that it's confusing - so I really value this feedback.
 Keep me posted on your JSON Lisp, it sounds like a really awesome project
 Closing this, as I decided (for now) to keep the equality semantic of "same keys and values", so all empty collections will still appear equal.
  In general you shouldn't be concerned with a value being a cursor vs an original map, but certainly it could make sense to assert that your react prop expects an Immutable collection. I think instanceOf works just fine here, or you could provide any validation function:

```
propTypes: {
    appState: function (value) {
        // return true if value is acceptable. For example, value.has('foo') && value.has('bar')
    }
},
```
 I'm glad you're unstuck, I have no idea why the PropTypes.instanceOf is doing the wrong thing. Maybe worth opening an issue on @facebook/team-react ?
  Thanks for the report. I will fix this!
 I hate JavaScript sometimes.

```
> [1,2,3].reduce(function (x,y) {return x+y})
6
> [1,2,3].reduce(function (x,y) {return x+y},undefined)
NaN
> [1,2,3].reduce(function (x,y) {return x+y},null)
6
```
 Fixed by e034f5e3a57ad12601ed2c09debaf8bf10357475
 I believe you're right. I'll get that fixed
  This is by design, as `typeof value === "object"` is far too lenient and can often iterate through unexpected keys.

When an object has a constructor other than `Object`, it is almost always representing a Record and not a Map. The example you shared here of "Point" is actually a great example. Point is not well represented by a HashMap and much better represented as a Record.
 Check out `Record` in the type-definition documentation. Hopefully it better aligns to what you're trying to accomplish.
 Whoa, that's an interesting use case. I'll think about another way to detect Objects.
 By the way, this should now work as expected.

`Immutable.fromJS()` still looks for plain objects, but directly constructing a collection like `Map(myPoint)` or `Map(myObjFromAnotherGlobal)` should work as you originally expect.
  This is a bug, thanks for the report!
  I'll look into both fb's cdn and cdnjs. Great suggestion.
 I added the jsDelivr link to the Readme :)
  The original phase is correct, or I'm not seeing the typo. Can you explain?
 @spicyj I just made your recommended change to Readme. Reads easier and hopefully will solve this confusion that's come up a number of times.
  Thanks for the fix!
  Thanks!
  You are comparing next.id to next.id instead of prev.id to next.id, so it's expected that the list should remain stable when all comparisons are "equivalent"â€”
Sent from Mailbox

On Mon, Sep 8, 2014 at 10:17 AM, Clint Ayres notifications@github.com
wrote:

> ```
> > var data = [{id:2},{id:3},{id:1}];
> > var v = Immutable.fromJS(data);
> > var comparator = function(prev, next) { 
>   var b = next.get('id'); 
>   var a = next.get('id'); 
>   return a > b ? 1 : a < b ? -1 : 0;
>  }
> > JSON.stringify(v.sort(comparator).toJS());
> < "[{"id":2},{"id":3},{"id":1}]"
> ```
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/101
 Just saw your update on sorting cursors. I'll look into that. 
 Oh, I know what's happening here. Cursors only support Maps right now. I'll merge this into the task tracking Cursor support for Vector
 This works as expected as of v2.4.0
  This turned out to be a VM JIT issue which was fixed a few weeks ago.
  @plievone is correct. "undefined" is a valid key! deref() returns the original map. 

Is there outdated documentation leading you astray? Point it out and I'll fix it. 
 Closing this now that it's clear that cursor() returns a thing that looks like a Map, so get() with no key should definitely return whatever is set in the Map for the key `undefined`.
 Today, your example code should look like: 

```
Immutable.unCursor(
  Immutable.fromJS({}).cursor()
)
```

Which returns `Map {}`
  Thanks for the recommendation. Would you mind sharing some examples of what you're trying to do with Immutable that would be made easier with these methods, or the API you would expect?â€”
Sent from Mailbox

On Wed, Sep 3, 2014 at 11:31 PM, AlexGalays notifications@github.com
wrote:

> Hello,
> 
> ## I don't see any support for this very useful operations?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/98
 It looks like using flatten is a missing piece here. I'll look into that furtherâ€”
Sent from Mailbox

On Fri, Sep 5, 2014 at 1:34 PM, Tenor Biel notifications@github.com
wrote:

> :+1:
> 
> ## @leebyron I think all the flatMap method would need to be is a lazy-operation-optimized sugar method for `.map(myFunc).concat()` which is all flatMap is.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/98#issuecomment-54656502
 Map and concat are both lazy so the line you just wrote results in a lazy sequence itself!

I'll look into it further, but I want to make sure the API stays terse. If the pattern is common and tedious then it should be included, but if it's already easy to accomplish what you want without the dedicated method, then I would rather not include it.Â 
â€”
Sent from Mailbox

On Fri, Sep 5, 2014 at 1:34 PM, Tenor Biel notifications@github.com
wrote:

> :+1:
> 
> ## @leebyron I think all the flatMap method would need to be is a lazy-operation-optimized sugar method for `.map(myFunc).concat()` which is all flatMap is.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/98#issuecomment-54656502
 Aha. Sorry, I'm not a Scala person, and my mind didn't quite click on the equivalence of flatMap and bind. I'll definitely look into implementing the bigger picture here which is to allow Immutable.Sequence to behave as a Monad.
 `flatMap` has been in for a while now (and it's lazy!)
 Hey @stiff I'm a little confused by your example - is that what you're expecting to see or what you are seeing?

Here is what currently occurs:

```
> function a(x){return[x,x]}
undefined
> Immutable.fromJS([[1,2,3], [4,5,6]]).map(a)
"Seq [ Vector [ 1, 2, 3 ],Vector [ 1, 2, 3 ], Vector [ 4, 5, 6 ],Vector [ 4, 5, 6 ] ]"
> Immutable.fromJS([[1,2,3], [4,5,6]]).map(a).flatten()
"Seq [ Vector [ 1, 2, 3 ], Vector [ 1, 2, 3 ], Vector [ 4, 5, 6 ], Vector [ 4, 5, 6 ] ]"
> Immutable.fromJS([[1,2,3], [4,5,6]]).flatMap(a)
"Seq [ Vector [ 1, 2, 3 ], Vector [ 1, 2, 3 ], Vector [ 4, 5, 6 ], Vector [ 4, 5, 6 ] ]"
```

Were you expecting flatten() or flatMap() to deeply flatten?
 I've currently modelled flatten/flatMap against Scala's definitions. Please let me know if this is confusing (or incorrect). My goal is to translate this sort of behavior from existing languages into idiomatic JS.
 Great feedback. I'll investigate level/shallow and have flatten() deep by default.
 I've got a diff in master (not released in a version yet) e41d99e53a20bacfcfe7861bcb5be3abea95611d which changes the behavior of `flatten()` to follow the lodash/underscore precedent, and also supports a specific level of flatness ala Ruby.

It doesn't change the current behavior of flatMap, which as I understand today does what you expect it to do, correct?
  This is on my short list. Currently Cursor only supports nested Maps, but I intend on adding support for more types soon.
 Solved in [v2.4.0](https://github.com/facebook/immutable-js/releases/tag/2.4.0)
 data.cursor('x') does return a Cursor to a Vector there because Vector is an immutable collection.

Calling cursor() should always return the same type of thing as what the cursor would point to. In the case of regular JavaScript values, we don't have control over them, so it doesn't make sense to wrap them.
 Ah snap. Yes, you're right.
 @mikaelbr It is possible, but you certainly need to be aware of your data structure. I think this is a trade-off worth making. Now cursors can be treated as you would the type it points to. A MapCursor behaves as a Map. It's still possible to do top-down rendering with cursors, but you just need to be sure that when you call `cursor(x)` that you're not referencing a scalar.

I've also commented on your gist with a few edits you could make to make that code work correctly.
 @JaapRood @torgeir - I just pulled v2.4.0 from github and npm - it's definitely a breaking change that should have been a major version number bump.

Considering @mikaelbr already illustrates a very real case where the breaking change will require work to upgrade to this next version, I'll bring it back as v3.0.0 later today.
 cc @tgriesser - I know you're working with Cursors as well.
 Ultimately, I rolled back the change to cursor and went with a minimal fix to this issue.

I may consider changing Cursors in the future, but it seemed to make more sense to not mess with them for now.
  Thanks for the report. This should be an easy fix.
 Thanks again for reporting this!
  Thanks for the reminder. I intend to use semver but clearly I made a mistake when I added keySeq and didn't bump minor version.

I'll pay closer attention going forward!
  Thanks for the reminder to do this! I needed to change your bower.json file a bit, so I didn't merge your pull directly, but 4c6d4f94d28a543b1b46a35f0649ac28a3a16682 is essentially the merge of this. I also just released 2.0.17 which includes the bower manifest and registered it on bower.

Let me know if you run into any issues with using Immutable via bower!
  Thanks for the report. I'm looking into this now
 Thanks again. This issue was also appearing for `skip(N)` as well, this last commit fixes the issue for both.
  Whoa, bizarre. Thanks for the report I'll try to see what's going on.Â â€”
Sent from Mailbox

On Fri, Aug 29, 2014 at 9:30 PM, broberson notifications@github.com
wrote:

> Nicely spotted. 
> Fails in MobileSafari on iOS 7.1.2, works in Chrome for iOS.  
> 
> ## Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/92#issuecomment-53948424
 Hey @conradz - are you still reproducing this? I loaded your codepen on my iPhone (5S, iOS 7.1.1, Safari) and it's just reporting `done` without any errors. 
 If this is device specific, I'm going to throw blunt things in the general direction of Cupertino.
 It might be an issue introduced between iOS 7.1.1 and iOS 7.1.2. If I can't repro on 7.1.1 and once I update to 7.1.2 (doing this right now) and repro it, we'll have narrowed it down to that.
 My 5S running 7.1.2 also does not reproduce the issue :-1:  - What other devices are you seeing this reproduce on? You mentioned your iPhone also reproduces the issue, does it still? What model is it?
 Ok, I reproduce this on my iPad. Also failing on the 37th iteration. I'm digging in more now.
 TIL about the iOS JS debugger. If you hook it up to your laptop and open Safari's debugging tools, this error disappears. Going into debugger mode probably means your laptop's JSVM is running instead of iOS's. Heisenbug!
 @conradz I think you're correct. I think this is a bug in iOS 32bit JS JIT.

I've managed to ghetto log my way down to the source of the problem:

In `BitmapIndexedNode.prototype.get` on [line 1381](https://github.com/facebook/immutable-js/blob/master/dist/Immutable.js#L1381)  `(1 << ((hash >>> shift) & MASK)` at some point just starts evaluating to `1`, regardless of the values of `hash` and `shift`. My best guess is that the JIT is making bad assumptions, which would explain why the first dozen goes at it work just fine.

This is still heisenbuggin' because as soon as I do something like:

```
console.log('(1 << (('+hash+' >>> '+shift+') & '+MASK+')) = ' + (1 << ((hash >>> shift) & MASK)))
```

The problem goes away completely.

It's also sensitive to the context of everything running around it. I've tried isolating just this line but the issue stops reproducing then as well, so I'm having trouble creating a minimal failing case to file a Radar with.

I also haven't found a fix yet that doesn't require sticking a console.log in there :(
 BTW, I filed this to Apple as rdar://18220947 in case anyone from Cupertino is reading this and can help or bring advice as to how to fix this.
 I put a log right after line 1381, logging `(hash >>> 0)` and sure enough, after some iterations, it starts evaluating as `0`.
 Good suggestion, @tgriesser - https://bugs.webkit.org/show_bug.cgi?id=136508
 I've committed a workaround, but ideally I can figure out what's actually gone wrong here and end up with a better solution in code.
 This is now fixed in v2.1.0
  Excellent work! Thanks for including tests.
 Btw, I followed up with 3d16cc64afb101b2d8ca7ed807ba44340620ad32
 Also, I would LOVE to know what you end up building with this. 
 Let me know if there are any benchmarks that prevent you from doing what you want to do.
  Map.from is ~0.6x as performant as a manually written for loop within `withMutations`, it should have less overhead.
  Yes! I want to build this and SortedSet.
 RB Tree sounds like the right way to do this.

I'm putting this up for grabs for any adventurous contributors. Best way to learn about Persistent Immutable data structures is to implement them!  Good feedback
  Thanks for bringing this to my attention. I added a test case to test this in a broader way and actually found a handful of related issues as well. All fixed in the referenced diff.
  Correct - this is to ensure laziness. Wrapping them all in `toXXX()` would make them all non-lazy and become a performance burden.
 The general rule of thumb is that methods on Array which are mutative (set, delete, push, pop, shift, unshift) should have equivalent counterparts on Vector that are persistently mutative and return new Vectors with that mutation applied whereas methods on Array which are not mutative (filter, map, slice, concat) should have equivalent counterparts on Vector that return Sequences and are lazy. The current exception is `splice`, which currently returns a Sequence but should ideally return a realized Vector. It requires RRB trees and tracked in #38. After #38, I'll probably convert slice and concat to return Vector simply because this issue of confusion is legitimate and comes up fairly often.

To your other question: it depends. 

`concat` runs in O(1) - returning a Sequence which simply points to both the vector and the arguments passed to `concat`. `push` runs in O(logN) - returning a Vector by structural cloning which is not slow, but definitely more work than `concat`.

Sequences have O(N) `get`, and do not have `set`, but have efficient `O(N)` iteration. `seq.toVector()` is an O(N) operation.

If the Sequence constraints are sufficient for whatever it is you need to do next (like map/reduce or convert to an array), then yes, `concat` would be faster than `push`. However, if you need the result to be a Vector, because you're going to do further modifications or you need near-O(1) `get`, then `push` will be faster than `concat`.
 I agree that better clarity around this is still needed. Some of this clarity I hope to get from using RRB Vectors so slice/concat/splice become mutative and draws a more natural line between sequence and mutative methods. The rest is better documentation around this distinction and philosophy behind itâ€”
Sent from Mailbox

On Tue, Aug 26, 2014 at 10:30 PM, Niklas BostrÃ¶m notifications@github.com
wrote:

> ## In the end I guess that this is a speed versus usability thing.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/85#issuecomment-53528319
  This is expected. Set can only accept hashable values, which are either primitives or objects with a `hashCode(): int` method.
 Unfortunately native Set and Map's ability to accept any keys are very difficult to correctly polyfill as they take advantage of pointer identity which is only available within the VM, and not in JS land.

I'll ensure this is more clear in the documentation.
 Hey @alexeyraspopov I managed to add this functionality in 12c34bfcf4a9c176bc93d1e0a29456a09d9c0247 which will be part of an npm release soon.
  Closing as what we have today returns appropriately wrapped results.
  I think I understand what you're after - when iterating over a cursor, each entry returned should itself be a cursor (if relevant), yes? This is a great suggestion.
 Ok, I have a diff coming, but it doesn't solve your expected cases. And I don't think your expected cases should work.

Cursors should be lazy pointers to a value, and not a fully realized copy of the original. That means that any new cursors should be lazily created and therefore won't share pointer equality but will be value equal. As an example:

``` js
> var c1 = data.cursor();
> var c2 = data.cursor();
> c1 === c2
false
> Immutable.is(c1, c2)
true
```

This then also applies to your examples above which are expecting pointer equality, but will actually get two different cursors. However, you _would_ be able to do this:

``` js
c.get('users').every(function(user, index) {
   return user.deref() === c.getIn(['users', index]).deref();
});  // true
```

(Which is exactly what `Immutable.is` does for Cursors).
 3ae7fb1ae5a36c02c959c57f563d06e126cb2bfb Adds what you're looking for in the high level. Specifically, mapping over a Cursor to a Sequence and returning React elements should now do the right thing, giving each React element a Cursor rather than derefed values:

``` js
<div>
  {props.data.map(subData => <MyComponent data={subData} />)}
</div>
```
 Correct @Tvaroh, sorry for the post before test.

I'll work with the React team for a generic way to accept Immutable data structures as children.
 For reference I opened [react#2296](https://github.com/facebook/react/issues/2296) to handle this.
  Thanks for the report. I'll add this test and then dig in.
 I just added this test at 2c3978fd686f29a96e143888b0bd246ff7144387 using [jasmine-check](https://github.com/leebyron/jasmine-check) and it indeed fails. The smallest failing value is a map of 17 entries which means I've probably messed up an expansion from index node to array node, as that happens when the 17th entry is added.
 In fact - jasmine-check reduced the failing test to `{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"10":0,"A":0,"c":0,"B":0,"D":0,"e":0,"":0,"F":0,"G":0,"h":0,"j":0}` which uniformly covers the hash space. So good.

Ok, I've got a lead on the failure point. I'll get a diff up soon.
  Thanks for the report! This is a bugâ€”
Sent from Mailbox

On Fri, Aug 22, 2014 at 8:01 AM, Kevin Dangoor notifications@github.com
wrote:

> FWIW, I just wrote this utility function, but I'd rather not have to think about "when do I need to use this?"
> 
> ``` javascript
>     function updateOrSet(treeData, path, setterFunc) {
>         if (path.length === 0) {
>             return setterFunc(treeData);
>         } else {
>             return treeData.updateIn(path, setterFunc);
>         }
>     }
> ```
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/80#issuecomment-53071286
 Wait - @dangoor I cannot reproduce your issue. Your code example should work exactly as expected.

There is already a check: https://github.com/facebook/immutable-js/blob/master/src/Map.js#L91 which looks for falsey or empty key paths.

Can you ensure you're using the latest release of Immutable and re-test your reproduction case?
 @andreypopp can you reproduce this?
 Ok, I'm going to close. @dangoor please re-open or just shout if you think I'm closing in error.
  This is great, thanks! Can you also change:

temporary mutable copy of a collection and applying a batch of mutations in a highly

To

temporary mutable copy of a collection and _apply_ a batch of mutations in a highly 
 (Just append that to your last commit, rather than make a new commit with --amend)
  Thanks for the report!
 Also, just for my interest - what environment are you using? Node, Chrome, Firefox?
  Hi @ide!!!

Yes, let's consider this a bug. Any "mutative" action that results in a no-op should return self. 
 Based on your example though, it's working as expected. A "mutative" method will only return self when the set/merged values have pointer equality. 

In your example you have two instances of Set (which are value equal) since they are different instances the mergeDeep should return a new object. 

I tested this though and the bug does exist when there is pointer equality. 
 Yeah, that may be true. However, I think a common case of using mergeDeep is to merge two JSON bodies together - in which case it will walk down to scalars and those will `===` and you'll get the optimization. It's only when you're dealing with non-mergeable object pointers that you'll lose it. `Set` doesn't support deep merging currently (another to-do) - but if it did then this should behave as you expect.

I just want to avoid doing value equality checking on set/merge as it could potentially be expensive if the objects were quite large - and because set/merge is often done in batches, I want to keep that method pretty streamlined.
 Heads up that with this last diff, your example case still doesn't do what you expect because of the outstanding issue that Set is treated as non-mergable and thus uses pointer equality when merging.

``` js
> var set = immutable.Set('x')
> var map = immutable.Map({key: set})
> var map2 = map.mergeDeep({key: immutable.Set('x')})
> var map3 = map.mergeDeep({key: set})
> immutable.is(map, map2) // The new map has value equality to the old map
true
> map === map2 // Set pointer inequality caused a new value to be created.
false
> map === map3 // Set pointer equality resulted in no modifications
true
> map.key === map2.key // maps, not records, so both return undefined
true
> map.get('key') === map2.get('key') // two different Sets
false
> immutable.is(map.get('key'), map2.get('key')) // but with value equivalence
true
```
 Tracking set in #76 
 Ok, after 3e1e874af1863bb34d68b473692d03f57d35622e your example behaves as you expect.

Now that you've illuminated this one, I've seen a few other places where this bug exists. Thanks, James!
 And published as 2.0.14
 Send feedback as you have it! Miss you, man.Â â€”
Sent from Mailbox

On Wed, Aug 20, 2014 at 6:46 PM, James Ide notifications@github.com
wrote:

> ## awesometown
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/75#issuecomment-52860852
  Thanks for the report. I'll correct this.Â â€”
Sent from Mailbox

On Sun, Aug 17, 2014 at 1:59 PM, Simon Edwards notifications@github.com
wrote:

> I have typescript code which compiles fine using:
>     ///<reference path='./node_modules/immutable/dist/Immutable.d.ts'/>
>     import immutable = require('Immutable');
> But when this code is run via node it fails and complains that it can't find module 'Immutable'.
> The problem appears to be related to the use of upper and lowercase 'i' for immutable. If I put a symlink called 'Immutable' inside my node_modules directory and pointing to 'immutable', then my code starts up fine.
> 
> ## I'm using Linux and a case sensitive filesystem. This problem probably won't appear on case insensitive file systems.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/73
  Excellent feedback. Thank you!â€”
Sent from Mailbox

On Sun, Aug 17, 2014 at 12:15 PM, Tim Griesser notifications@github.com
wrote:

> Saw that you've added cursors to the library and were looking for feedback. Very cool.
> I've been working on an implementation of om-style cursors based on mori's data structures, using a custom build of mori which allows for extending [vanilla JS objects with cljs protocols](https://github.com/swannodette/mori/pull/108) (thanks to some great tips from @swannodette)
> https://github.com/tgriesser/mori-cursors
> One of the coolest things about the om-style cursor implementation IMO is the ability to treat them as basic persistent data structures, each time a value is returned (`get`, `get_in`, `assoc`/`dissoc`, any seqable functions, etc.), so long as the value isn't a primitive, you'll receive a new cursor of the appropriate type (`MapCursor` / `VectorCursor`) which continues to keep track of its path in the root object automatically.
> As far as I can tell, in the current implementation, you need to explicitly call `cursor` to create sub-cursors, and even then, it's a bit limited in scope with regards to being able to modify the local value of the cursor. 
> For example in the implementation I linked above, you could have something like (using immutable's api):
> 
> ``` js
> var data = Immutable.fromJS({
>   users: [{
>     name: 'Test',
>     accounts: { /* deep nested data */ }
>   }, {
>     name: 'User',
>     accounts: { /* deep nested data */ }
>   }]
> });
> var c = data.cursor();
> c.get('users') // would return a new VectorCursor, path ['users']
> c.getIn(['users', 0]) // would return a new MapCursor, path ['users', 0]
> c.getIn(['users', 0, 'name']) // would return 'Test', since name is a primitive
> // Returns a new MapCursor, path ['users', 0], just without the 'accounts'
> // map. This is useful in cases like React where you want to slice and dice into
> // sub-cursors with a limited scope of data for efficient shouldComponentUpdate
> c.getIn(['users', 0]).delete('accounts')
> ```
> 
> So the main idea is that the cursors should behave exactly like their respective data-structures from an API standpoint, only differing with the underlying "type" of the cursor, automatically keeping track of their path (which is hugely valuable).
> Another main difference between this implementation and the one I mentioned above, is the idea of a "root" cursor, which sub-cursors are created from / updating against. There doesn't seem to be much value of just locating/updating values if they aren't coming from a central "root" object. In OM's case, I believe this is an atom, in the project I linked above it's just a special `RootCursor` which also acts an EventEmitter. My implementation is also pretty basic compared to OM's, nothing about deref'ing / taking into account render states.
> 
> ## Really cool to see that you're adding them to this project though, I've found them invaluable when using persistent data-structures with React, interested to see what you think about these ideas.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/72
 I've started to add some of this feedback in. For example get() and getIn() now return Cursors when relevant.
 Closing this out since it's old and discussion has been slurped up. Thanks again for the feedback, guys! I'm excited to see more cursor implementations come to be.
  Thanks
  Try out React's `replaceState` instead of `setState`. `setState` expects a state "update" - explicitly an object of keys which it will "merge into" the existing state. Whereas `replaceState` actually takes an entirely new object which will become the new state.
 @samwgoldman has the right idea here. React is trying to move away from `replaceState` in the future, and in v0.13 `setState` can accept a delta function:

``` js
getInitialState() {
  return { data: Immutable.Map() };
}

...

this.setState(state => ({ data: state.data.set('x', 1) }));
this.setState(state => ({ data: state.data.set('y', 2) }));
```

The setState delta functions will be called in the order supplied.
 @andersekdahl at this time, no. You should bring that up on the React github issues if you want to discuss further.
  Let me consider this. Debugability is certainly a valid concern. Webpack, browserify, et-al should behave the same on an already minified source. The primary reasons to keep it small is an improvement on load and parse time and to provide a decent default behavior if browserify does not sent its results through a minifier.
 I like your suggestion of .min.js - so rather than changing package.json - I changed the build step. The end result is still what you're after.

Thanks again for bringing this up.
  As spec'd (kinda) in:

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable
http://wiki.ecmascript.org/doku.php?id=harmony:iterators
http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts
 0164a55a13a476516e3bdf7e5316a173974ad05a Adds Iterator methods to Vector, Map, Set, OrderedMap
 049eff1482884be0c4e74080c2c18acb9447f2d5 Adds ES6 Symbol.iterator polyfill
 Hey Joseph, what version are you using?â€”
Sent from Mailbox

On Fri, Aug 29, 2014 at 1:51 AM, Joseph Silvestre
notifications@github.com wrote:

> Hi,
> I'm not sure it's the right place to ask/tell but I've tried to use `orderedMap.values()` but the result does not seem to have a `done` property nor `next()` method. Is it a bug or am I just misusing it?
> 
> ## Thanks.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/68#issuecomment-53851968
 Not yet, but I have that on my short list!â€”
Sent from Mailbox

On Mon, Sep 22, 2014 at 8:54 PM, voodoohop notifications@github.com
wrote:

> ## is there any way to create a lazy Sequence directly from an ES6 generator?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/68#issuecomment-56465081
 As of v2.3.0, all Sequences can be iterated and all collections can be constructed from an Iterator or Iterable.
  Use `Record`!

Check it out in the API docs
â€”
Sent from Mailbox

On Fri, Aug 15, 2014 at 6:54 AM, Manuel Simoni notifications@github.com
wrote:

> Hi, I'm using immutable-js for all data structures in a project of mine and am enjoying it very much. The only thing that bothers me is that I lose type safety / information when using Maps as a replacement for JS objects.
> Say I use a map to store information about a Person (like name and age). Is there some way to make it a real Person object and not a Map, so my code can say `instanceof Person`, and maybe even call custom methods on it?
> 
> ## Or is there another way to get some level of type safety when using Maps?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/67
  They will not have pointer-equality as === enforces. Use `Immutable.is(v2, v3)` for value-equality.
 (Similar to `Object.is()`)
 `withMutations` isn't going to do much for you here since `slice` is not a mutative method (eg, method that returns the "mutated" collection), but lazy sequence generating methods.

However, the purpose of `withMutations` is to improve the performance of calling multiple mutative methods in a row (lazy sequence methods are already performant to call in a chain). `withMutations` still returns a "new" collection, which is exactly what persistent immutability is all about. Because of how JS evaluates `===`, only scalars like strings and numbers are evaluated for value equality and all objects are pointer equality.

Example:

```
[1,2,3] === [1,2,3]
// false

Imm.Vector(1,2,3) === Imm.Vector(1,2,3)
// false

Imm.is([1,2,3], [1,2,3]) // note: arrays are not immutable, they won't be treated as values.
// false

var arr = [1,2,3];

arr === arr
// true

Imm.is(arr, arr) // pointer equal
// true

Imm.is(Imm.Vector(1,2,3), Imm.Vector(1,2,3))
// true
```

Short of making a mutable collection, `===` will always return false for two different objects, even if they represent the same value.
 No problem!
  That TODO is suggesting something else - but I'm glad you've identified that the issue lives somewhere nearby!

Thanks for the report, I'll dig in.
 Hey thanks - also feel free to send pull requests as you review!
 I just added a more generic version of your test case in c1bdb78f62b79ada7e1a96feaac8b2f33914c94e which indeed fails as you've described it.

```
Vector â€º it unshifts multiple values to the front ( [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0] )
Expected: {0: 0, 33: 0} 
toEqual: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
```
 Thanks again for the report, this one ended up being pretty straight-forward to fix.
  Ah thanks for finding the repro case! I've heard reports of this stack exception but didn't have a small case yet. I'll dig into this.Â â€”
Sent from Mailbox

On Wed, Aug 13, 2014 at 7:43 AM, brandys11 notifications@github.com
wrote:

> I have noticed that when key with different hash is set to  `HashCollisionNode` new `BitmapIndexedNode` is being created with wrong hashValue for `HashCollisionNode` (hash value of new key is used instead of `collisionHash`).
> This piece of code leads to "_Maximum call stack size exceeded_"
> 
> ``` javascript
> var map = Immutable.Map();
> map = map.set('@', '')
> map = map.set(64, '')
> map = map.set(96, '')
> ```
> 
> ## The bug can be found here: [src/Map.js#L324-325](https://github.com/facebook/immutable-js/blob/95fdfa49b224dac7cc505f8063d6c891a67d7ed7/src/Map.js#L324-325)
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/64
 This will go out as one of the next point releases (sometime today)
  Thanks for the report! Just to be clear, you're only seeing this issue for OrderedMap - yes? Map and Vector are not suffering similar leaks?Â 

Also, just curious, what runtime are you using to get these numbers? Node? Chrome?
â€”
Sent from Mailbox

On Wed, Aug 13, 2014 at 5:59 AM, brandys11 notifications@github.com
wrote:

> Using `UnorderedMap` for longer time can consume lots of memory.
> For example this code: 
> 
> ``` javascript
> var map = Immutable.OrderedMap({'b': 'b'});
> for(i = 0; i < operations; i++) {
>     map = map.set('a', 'a');
>     map = map.delete('a');
> }
> ```
> 
> leads to this memory consumption :
> operations | Memory (kb)
> --------------- | -----------
> 1000 | 16000
> 10000 | 19000
> 100000 | 23000
> 1000000 | 58000
> 10000000 | 160000
> It is because indexes are created sequentially and calling `Vector.delete(index)` does not free any memory. 
> 
> ## The element `b` is there to ensure that UnorderedMap does not become empty and remove `Vector`.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/63
 Closing now, OrderedMap should no longer have this leak.
  Thanks. Tired eyes...
  Certainly an issue. The custom traceur runtime should be scoped to only apply to the guts of the library and shouldn't conflict. I will figure out what's going on here.
 Thanks again for the report - it should be fixed in v2.0.9 now on npm
 spicyj - jstransform was a little more limited in transform coverage and ended up outputting verbose transforms of "class" that didn't crush well. Traceur expects a massive external library which is a bummer but I made a custom version that's tiny and only supplies the few things needed.

I think we've talked about adding some customization to jstransforms treatment of classes which could make this work.

Ultimately it came down to minified & crushed size.
  Curious. Let me dig into this further and see what's going on. Thanks for the report.
 Thanks again for snooping this one out.
  Let's rename to "rest" and "butLast"
 Why close this, @rockymadden ?
 Okay, you should reopen so I don't forget about it. 
 Done! It's in 2.0.10
  Thanks Rocky! I've taken your pull and changed it a bit before landing it. I added a related test which was also failing but your pull didn't yet address. I also just pushed this as v2.0.7
  On your note about lacking in-practice examples - yes I agree. I'm hoping to see some of these evolve from community usage and will later consider making contrived cases and putting them in an `/examples` dir.
 So you're looking to maintain the order of this array of records but also have the ability to look up each one by id. Then yes, OrderedMap is what you want, but of course OrderedMap expects key/value pairs, not just an array.

Here's one way to do it - building up the OrderedMap manually. Let's call your posted data, `var data = [...];`.

First, let's show how we would do this very simply, but not yet efficiently:

``` js
var map = Imm.OrderedMap();
data.forEach(record => {
  map = map.set(record.id, Imm.Map(record));
});
```

The problem here is that we're creating a whole new Map for every set. Because of structural sharing this isn't as bad as it would be if we were really cloning the whole data structure, but we can still do better since we want to think of this as "one operation". You're idea to use `withMutations` is the right one!

``` js
var map = Imm.OrderedMap().withMutations(m => {
  data.forEach(record => {
    m.set(record.id, Imm.Map(record));
  });
});
```

This will be very performant, as it only ever creates a single map data structure.

Note that we had to use forEach and side effects to perform this task. That's really just perfectly fine, but if we wanted to do this in a more pure function style, we could use Sequence operations:

``` js
Imm.Sequence(data).mapKeys((_, v) => v.id).map(v => Imm.Map(v)).toOrderedMap();
```

This is a nice one-liner. It's almost exactly the same "under the hood" as the previous example using forEach. `mapKeys` to replace the array's indices with the `id` property of the record that we want for our OrderedMap. Then we `map` the JS object values to Immutable Maps, then we turn that lazy sequence into a concrete structure - our OrderedMap.
 Totally agree! It's on my list to make that .d.ts much easier to look at.
 I just pushed v2.0.8 which adds `mapKeys` which makes this even easier to write (edited above)
 Damn!
 Wait, what's wrong with the comment?
 oh yep. totally right. thanks, my eyes must be tired.
 fixed in master now
 It won't give the same result. Without `.map(v => Imm.Map(v))` you will have an immutable OrderedMap of mutable JS Objects. With it, you will have an immutable OrderedMap of immutable Maps.
  Can you separate this into two pull requests? One to fix the range bug and the other for adding new functionality. 

For the range bug, can you add a test case that fails without your patch and passes afterwards?
  Yeah, great idea. I prefer Clojure's naming convention here since it better pairs with the existing `first` and `last` methods. How about using `rest` instead of `tail` and `butLast` instead of `init`?

(I always found "init" confusing since it's a popular abbr. of "initialize")
 Thanks, you definitely picked up on the theme!
  Definitely possible! In this library, such 2-element tuples are called "entries" to match the existing JS definitions.

Say you have a sequence of tuples:

``` javascript
var rawTuples = [['a', 1], ['b', 2], ['c', 3]];
var seqEntries = Immutable.Sequence(rawTuples);
```

Now we can convert a tuples sequence into a k/v sequence (lazily):

``` javascript
var seqKV = seqEntries.fromEntries();
```

And then from this sequence we can convert it to a map:

``` javascript
var map = seqKV.toMap();
// Map { a: 1, b: 2, c: 3 }
```
 Recently, I changed the behavior of Map's constructor to accept these as well - as it matches the ES6 Map specification. So now simply `var map = Map(rawTuples)` will do what you expect.
  Yes, you can do any method within update, including delete.Â 

updateIn(['a','b'], map => map.delete('c'))â€”
Sent from Mailbox

On Mon, Aug 11, 2014 at 12:29 AM, Naresh Naredla notifications@github.com
wrote:

> var nested = Immutable.fromJS({a:{b:{c:[3,4,5]}}});
> Assume i am having above nested map...so i want  to delete key(c) and its values also..
> To update value we have updateIn() method,
> like that , is there any method to delete ?
> 
> ## How to do that ? could you please help me 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/53
  I'm not sure I understand the question, but certainly immutable-js supports applying diffs. I think `mergeDeep` is probably what you're looking for.
 Ah, I understand. I think that is out of scope for this project. Such a process should be equally applicable to non-immutable objects. You might want to look into `JSONPatch` to get started with this.
  Totally agree. Because of how immutable JS currently handles iteration this can't be done efficiently yet, but can be done. I'll look into adding these in a next minor release!â€”
Sent from Mailbox

On Sun, Aug 10, 2014 at 12:01 PM, Rocky Madden notifications@github.com
wrote:

> ## Sequence zip, zipall, and zipwithindex a la something like Scala would be delightful: http://www.scala-lang.org/api/2.11.2/#scala.collection.Seq
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/51
 Here's a question for you zip fans (cc @rockymadden, @stiff, @tolmasky)

Other languages provide the pair `zip` and `zipWith`, the latter taking a specific zipping function, much like clojure's `map`.

```
var a = List.of(1,2,3);
var b = List.of(4,5,6);
var c = a.zipWith(List.of, b);
// List [ List [ 1, 4 ], List [ 2, 5 ], List [ 3, 6 ] ]
```

So question: if there is also `zip`, what should the default zipping function be? `List.of` or "tuple" (`(...args) => args`).

I imagine this depends on what you plan on using zip for. It's often used in clojure to create k,v pairs to build maps from, in which case we would want "tuple", but of course if you're using it to build more immutable structures, you would want `List.of`.

Hidden option C is that `zip` is not provided at all, only `zipWith`, so you have to be explicit about this, very clear but a bit verbose.

Thoughts?
 Will be included in the next release
  The correct phrase here is "does no work". So this is not a typo. Perhaps it would be more clear as "performs no work"
  Haha you're right. This wasn't a typo. 
  Thanks!
  Is it possible? I'd love to be able to use immutable-js collections as keys or include them in sets.
 This is on my todo list :)
 fantastic, i cant wait. how are you going to do it?
 I'll borrow the hash algorithm from clojure's map, probably :)
 sounds good.
 Correct
 This is now closed by 12c34bfcf4a9c176bc93d1e0a29456a09d9c0247
  Hey, can you clarify your question? What do you want from the Vector?â€”
Sent from Mailbox

On Fri, Aug 8, 2014 at 10:26 PM, Naresh Naredla notifications@github.com
wrote:

> ## please reply me any one its important to me...please thank you
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/46#issuecomment-51677794
 So I'm still not 100% sure what you're asking, but it sounds like iteration in which case I think you're looking for `forEach` which might look like

vect1.forEach(function(value){ do work here });
 The reason `vect1.map(...)` will not call the values is that `map()` returns another lazy sequence, the function within is only called when necessary when the resulting sequence is operated on. The documentation for that method specifies that you should not rely on side-effects from that method.

`forEach` is a non-lazy operation, designed to provide side-effects.
  The minified version should actually change the delete references to property accessors (uglify manages our IE8 support). So if you use the distributed compressed library, you should get IE8 support.

However, I'm not sure the library is IE8 safe as there are some ES5 library function calls made that will probably need to be polyfilled. I have not yet tested IE8, so I can't tell you for sure.
 Are you seeing similar issues with IE8 from the compressed distributed build?
 Should now be fixed by c22e45d557d99e3104515ed8707ea68561746c6f
  Since that value is a mutable object, not an immutable map, the immutable API does not apply to it (see [Object's API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)). If your update backs up one level, then it points to the object instead of the key within the object:

```
var map1 = Immutable.Map({a:1, b:{d:2}, c:3});
var map2 = map1.update('b', function (value) { value.d = 1000; return value; })
```

However, note that this has mutated a mutable value, which your original `map` still points to, so in this case `map2 === map1`.

You could also return a copy of this object:

```
var map1 = Immutable.Map({a:1, b:{d:2}, c:3});
var map2 = map1.update('b', function (value) { 
  var newValue = {};
  for (var k in value) {
    if (value.hasOwnProperty(k)) {
      newValue[k] = value[k];
    }
  }
  newValue.d = 1000; 
  return newValue; 
})
```

And now `map2 !== map1` and `map1`'s mutable object has not been changed. However this highlights one of the use cases of Immutable Map. If you desired the second behavior, then using an immutable Map instead of a mutable Object as a nested value would provide an API much easier to work with:

```
var map1 = Immutable.Map({a:1, b:Immutable.Map({d:2}), c:3});
var map2 = map1.update('b', function (value) { return value.set('d', 1000); })
```
  I believe your second question is answered by #44 
  Hey @arnemart - I'm not familiar with cursors, can you fill in me on the pros/cons of this or what example code taking advantage of it might look like? I'm a little bit worried about adding more overhead to mutations but if it unlocks some awesome use cases then we should carry on.
 Cursors sound pretty cool, but it also seems (from my admittedly limited reading of om) that Cursors depend on data structures rather than vice-versa. In other words, it seems like what we would want to do here is build a tiny "Atoms and cursors" library which use immutable-js, rather than having cursors as a feature of immutable-js. Am I off-base?
 Nice!
 I'm glad you're enjoying them. They're definitely still experimental, so bring feedback as you have it!
  Thanks for the report - this definitely seems like a bug.
 Unfortunately I believe this is a wont-fix, unless someone can teach me something new about `console.log`. node looks for `inspect` because it's `console.log` is powered by `util.inspect`. In the browser I don't think we have an equivalent.

Fortunately, the workaround shouldn't be too much trouble. Just `console.log(myImmutableObject.toString())` or `console.log('' + myImmutableObject)`
 Note: when Direct Proxies are the norm (the distant future), this will work correctly :/
  Clever, thanks for sharing this. I'll investigate what adding this might look like. 
 Hey @jasonkuhrt - I'm a huge fan of functional libraries, and the functional tools you're talking about (I even have a project to add some haskell style functions and operators to JS called [loda](https://github.com/leebyron/loda-js)).

I'm not making a call on this yet, but so far I've been thinking that a functional API just isn't the right thing for this library, considering its design guideline is to mirror idiomatic ES6 JS which, unfortunately, doesn't favor the point-free functional composition style.

I really like the idea of building a sister library which provides a functional curried API for all of the Immutable collection prototype methods.
 I'd love to see what you end up with here, that sounds cool.

From a technical point of view, they need to be methods because there are different implementations of a method name for each type. Clojurescript makes point-free functions work via double-dispatch, so there are methods going on under the hood. I would probably recommend a similar architecture for a functional layer over this library, where the free functions simply called into the methods for free specialization. 

Example:

``` js
function map(fn) {
  return function(collection) {
    return collection.map(fn);
  }
}
```

The nice thing about this approach is that such a library of functions would work equivalently on both ES6 collections (Array, Map, Set) and Immutable.
 I'm actually going to close this issue. I think it's decidedly out of scope, but if no one else gets to it first, I probably will write a fp wrapper for this library in the not-too-distant future :)
 Share what you build! Looking forward to it.
  Not yet known, you're definitely giving it a good stress test. 

Is there a more contrived version of this that you can share so I can figure out what's up?
 Oh I just re-read this and realizing you said splice() not slice(). Yes, splice is quite inefficient. 
 If you're calling it repeatedly, you might try replacing .splice(...) with .splice(...).toVector()
 splice() is definitely an exensive operation regardless as everything after the splice point needs to be shifted (moved in memory) for regular arrays. The same is true for a HAMT.

I was thinking about this a bit and wonder if you might benefit from a different kind of data structure that's designed around making splice() fast. Linked lists are really fast at this if you're willing to give up O(1) access and immutability. Perhaps some kind of b-tree would be well adapted to immutable(persistent) form and deal well with splicing.

What's the specific use case here?
â€”
Sent from Mailbox

On Tue, Aug 5, 2014 at 1:43 PM, Nathan Sobo notifications@github.com
wrote:

> For now I'm just building a new vector as they're quite small.
> 
> ## Is this inefficiency inherent in the nature of the trie data structure you're using or something implementation-specific? Do the ClojureScript data structures exhibit this issue?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/38#issuecomment-51256755
 I'll definitely keep it in mind, so I'll keep this open. At the very least I think a real TODO is clarifying splice()'s use with withMutable and even finding incremental perf improvements.Â â€”
Sent from Mailbox

On Tue, Aug 5, 2014 at 3:04 PM, Nathan Sobo notifications@github.com
wrote:

> ## Yeah, great point. I'll just replace the entire `Vector` for now because it has so few elements. Thanks for your thoughts. Feel free to close this unless you'd like to look into improving `splice` so far as it's possible.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/38#issuecomment-51267032
 Interesting. I'll read up! Thanks guys.Â â€”
Sent from Mailbox

On Wed, Aug 6, 2014 at 6:23 AM, Alexander Semenov
notifications@github.com wrote:

> ## BTW, that official paper on RRB trees is lacking many details. I would recommend to look at this [thesis](http://hypirion.com/musings/thesis).
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/38#issuecomment-51333012
 My understanding was the constant perf hit only came if the RRB nodes are in the path, which means the result of slice/concat.Â 

I'm interested to hear more though.Â 

â€”
Sent from Mailbox

On Fri, Oct 31, 2014 at 10:51 PM, Scott Feeney notifications@github.com
wrote:

> @hypirion (author of the thesis above): didn't you say you found RRB-trees slower in practice (like, by a constant factor) than the Clojure-style vector for some operations?
> 
> ## I bring this up because if so, that may be an argument for presenting RRB-trees as an alternative implementation rather than replacing the current one.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/38#issuecomment-61359140
 Thanks @hyPiRion this is really helpful.
 Nice work @Pauan!

I haven't spent much time benchmarking or optimizing Immutable.js yet, so there are likely some wins to be had. A huge thanks to you and @swannodette for illustrating some baselines to strive for. It's always awesome and inspiring to see the headroom to strive to close :). However one thing I want to be cautious of, and part of why I've under-prioritized benchmarking, is comparing benchmarks to every day use. I don't think benchmarks are enough to prove or disprove an idea unless they closely mirror common use scenarios. AVL trees are really interesting and I'm looking forward to seeing how they may play a role in this lib, or at least in the new landscape of these structures as a whole. May I also suggest a composite test where reads and writes are interleaved at different frequencies? Most common use tends to read a lot more than write which is part of why Clojure/Scala/immutable chose to optimize for reads instead of writes
 Totally. The beauty of data structures is that there are so many variants and each one has its ideal use. 
 @swannodette Exactly my point. Clojure & ClojureScript's performance is the result of multiple smart people working diligently for quite a long time with production performance in mind. And it's seriously impressive and inspiring (like, literally inspiring, like literally inspired this project). My hesitancy towards benchmarks is simply to ensure they don't become the driving force for optimization work which in my experience on other projects has often led to _worse_ performance for production apps, or distraction from more important work. Always focus on production performance first. Immutable.js has a long road to follow, and many great ideas to borrow to get there (including this task). Putting together a benchmarking rig is on my todo list, with benchmarks designed to mimic common patterns, and I'll want to do that before going deep on performance tweaking, but production use and perf is still going to be my end-goal :). Not there yet!
 I had to make slice non-lazy to fix some behavioral issues, my intent is to make it lazy again in the future (and by lazy, I mean just a view on a backing List, same as subvec).
 Yeah, guys I'm gunna have to call this convo over (at least in this context) because we've gotten pretty off-topic from RRB trees :). You've both inspired me to a) investigate some alternative options for speeding things up and b) add a benchmarking harness of some kind to start tracking this stuff better.

When I get a benchmark harness up, I'll be psyched to get your feedback.
  This is a bit subtle, but splice is not available as a mutative method. It always returns a sequence. Because splice needs to push the indices of the elements after it, it always needs to create a new vector.

I agree that this behavior isn't super obvious though. I think the code you wrote should have done what you expected. Unfortunately right now it doesn't. The answer is to (outside of withMutations) do vect.splice(...).toVector()
 This behavior is also made clearer by RRB, so now tracking this in #38
  Yeah, I think this is out of scope for `immutable-js` because it's not intended to be a transport and there is no standard for this (and I don't want to force a proposed standard). For example, what if someone sets the key "type" on a map/set? There's then a collision.

I do recommend using something like transit-js for this. Or, a function to do this should be pretty straight-forward. Then our `fromJS` method should already support this by providing a `converter` function as the 2nd arg and checking for this "type" key.
  Thanks for the report, and for building this awesome benchmark! If you happen to hit this exception again, see if you can get the contents of the Map and the operation resulting in the exception and I will look into it.

I have yet to do any benchmarking for this young library, and I'm actually pretty impressed that it's doing as well as you've measured. I'll be using your benchmark while I improve the performance of this library.
 Also, you mention about this library - "The API is richer and will be familiar to OO programmers, but I disagree with many of the design decisions." - I'm interested to hear more of your feedback. Is this a general concern about OO vs functional APIs, or are there more specific parts you were referring to?
 Good feedback and great arguments here, and overall I tend to agree with you and with the general sentiment that OO APIs have some real drawbacks. I think I would apply this concern to pretty much all of JavaScript's (and most/all OO languages') core API design principles.

However the goal of this library (and a personal goal of mine) is to bring some of the ideas forged in functional languages to a vanilla JS environment with approachable APIs, which means prototypal OO methods.
 Thanks guys. I just haven't done any performance tuning yet. I definitely plan to do so. The first step is finding an accurate way to measure the performance across all runtimes.Â â€”
Sent from Mailbox

On Sun, Aug 17, 2014 at 1:57 PM, Chris Pettitt notifications@github.com
wrote:

> ## Commenting to follow this more than anything. I'm working on a persistent graph library and am seeing hamt outperform immutable by anywhere from 2 - 3.5x ops/sec. I would love to see immutable improve  - I prefer its API to the hamt API.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/35#issuecomment-52434765
 Hey @cpettitt I just released v2.0.12 to npm which has some considerable performance improvements.
  Excellent sleuthing and minimal fix. Thanks for including the test! I'm sure you just fixed a few other subtle bugs we haven't come across yet with this one. 
  Yes, this is documented on "length" in the API docs, but I definitely understand that this behavior can be non-obvious. 

The current way to do this is:

```
seq.filter(...).cacheResult().length
```

This issue is good feedback that this should be much easier to do. I'll find a way to make this work the way you expect
 And your intuition is correct that this is the result of sequences being lazy. Without actually performing the filter, we cannot know the length of the resulting sequence. 
 Just to be clear, the new way to do this is:

`seq.filter(...).count()`
 Or! `seq.count(...filter function...)` works great for your use case. 
  BTW, I pushed a version to NPM that fixes this issue last night
  I'll look into this thanks for the reportâ€”
Sent from Mailbox

On Fri, Aug 1, 2014 at 2:05 PM, Alexander Semenov
notifications@github.com wrote:

> Example:
> 
> ``` javascript
> // having a set of ids
> var ids = Immutable.Set('a', 'b', 'c');
> // and some data
> var data = Immutable.fromJS({a: {foo: 'bar'}, b: {foo: 'bar'}, c: {foo: 'bar'}})
> // let's get data items by id
> var items = ids.map(function (id) { return data.get(id); });
> // and group them by 'foo'
> var grouped = items.groupBy(function (o) { return o.get('foo'); })
> // let's take the first item
> var first = grouped.first();
> // and to string it (notice the absence of comma between inner maps)
> first.toString() // "Seq [ Map { foo: "bar" }Map { foo: "bar" }Map { foo: "bar" } ]"
> // finally convert to array
> first.toArray() // [undefined Ã— 3]
> // 3 times undefined??? WAT
> ```
> 
> If we add `toVector` call just after `groupBy`, this scenario works correctly.
> 
> ## I apologize for the long description, this thing was driving me crazy...
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/31
  Thanks!
  Definitely! This is high on my list of additions for the next minor release!
 Released in 2.0.6!
  The one liner would be:

``` javascript
newMap = oldMap.updateIn(['test1', 'test2'], x => x.set('d', 4));
```

@JannesMeyer does this do what you're looking for?
 I'll definitely keep in mind the suggestion to add convenience methods for more specific actions and for creating intermediate maps.

The main reason I haven't add this yet is that I was concerned it would be confusing in the case that one of the keys is numeric - should it create a Vector or a Map? Probably always a Map, but there may be a case where a Vector was intended but there's no way to make that happen. I still think this could be really valuable though, so I'll keep it in mind for a future minor-version.
 I'll open this back up. Good feedback.
 Done :)
 Nope, after this diff landed, you can now write:

oldMap.setIn(['test1', 'test2', 'd'], 4);
  Do you like this better than `filter().length()`? I really like this idea, but I worry that people already have ideas about count() being a simple getter that takes no args (from Java's collections API). 
 Oh you're totally right. Okay, I like this proposal. I'll make it so the predicate is optional, if you exclude it then it will calculate total length (lazily if possible)
 That's exactly what I'm thinking. 
  Thanks yous!
  This is great, I've been planning on something like this, but glad you're thinking in the same lines.

It would be even better if dist resulted in a single file which can be included directly, included by an AMD system, or required by Node. Also, let's leave out the version number from the file - that will allow the package.json to point to the fire directly and keep it consistently named. The npm package itself is versioned, so we shouldn't need this info repeated here.

Exciting!
 I think it might just require wrapping the result of ugly-browserify with an AMD wrapper.
 @Tvaroh - I just added similar benefit in 95fdfa4. It replaces the dist directory with a built and minified file that's wrapped in a universal module so it can be used by node, amd or a script tag.
  I'm not sure I understand, could you give a small code example of what you're intending to do, or how you might expect `update` to be used?
 Ok, I understand. This becomes shorthand for

```
m.set('key', m.get('key') ... );
```

This is nice. Currently you could do this with:

```
m.updateIn(['key'], function (value) { ... });
```

I'll consider adding this in a future update
  Thanks for this suggestion, I agree that the learning curve here is less than ideal. I really like the idea of a single method which casts back to the original concrete collection type, I hadn't thought of that! I'll have a think on what naming scheme or API might best encapsulate that.
 That is conceptually ideal, but Vectors are concrete fulfilled data structures while a Sequence is lazy - it doesn't actually refer to any data, so defaulting to a concrete type means that every time we call a method that returns a sequence, we would actually have to build a new data structure.

The main idea here, with lazy sequences, is that chaining them becomes O(1) and casting the result provides many options. If you wanted to first filter your vector and then return the result as an array, Sequences offer the ability to do that in 1 operation instead of 2 saving memory and time.

However, the totally valid point that @Tvaroh has brought up is that a **common case** is that a single sequence method is called and the desired resulting value is the same type as the original, and this flexibility makes the common case at best more verbose than desired and at worst confusing. I agree with the problem, but will need to think about the best way to solve it.
 Transducers are great, and I'm working on using their concepts internally, but I'm trying to keep the API in it's current form to be more idiomatic to a JS environment, which a transducer API unfortunately is not.

If you prefer the transducer API, then you can absolutely use it. Immutable-JS works well with the few transducer JS libraries out there.
 Closing now that v3 is out and these collection methods are eager by default so they now behave exactly as desired by the OP. Operations can be safely chained and type information is maintained because each operation is eager! In v3 you must explicitly use .toSeq() first to use the lazy view API
 I like lazy behavior, and have built this library to take advantage of it. Seq is included as the primary tool for doing so.

The reason operations were changed from lazy to eager in v3 is that it was the biggest source of confusion for newcomers to the library. Lots of old github issues are about confusion as to why the operations were not maintaining the type they started with.
  Thanks for the report, great find! I'll write a test for this and fix the issue.
  There are a few reasons for this, but the primary reason is that every getter needs to be defined on every instance. That means every time you do a set, the new map needs to call `__defineGetter__` for every possible key that could be gotten. This would make mutations O(n), and I'd like to avoid that. Another, lesser reason is that an Immutable.Map can possibly have non-string keys.

I do actually take advantage for property getters functions for [`Immutable.Record`](https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts#L1033) since the keys will always be strings and are pre-defined for each record type.
 That's correct @JannesMeyer - I'd love to experiment with Proxy support in the future, especially when ES6 is a little more broadly supported by both node and browsers, but since it can't be polyfilled it would unfortunately be an experimental feature for quite a long time.
 Map is API compatible with the ES6 Map, but not JS Object - unfortunately the language does not provide a capability to do that. There's some discussion in the JavaScript technical committee to find a way to provide read API compatibility performantly, but even with a decision made, it will be months or even more than a year from a first browser adopter, and many years until browsers with that feature are widespread to the point that we can rely on such a feature. 

Unfortunately that means custom data structures in JavaScript must have a different read API from Object and Array for the foreseeable future. 
  Thanks for the suggestion! I hadn't considered doing this before, but I definitely will start doing this for future versions.
 (I'll keep this issue open until I've integrated the grunt plugin and pushed the first github release)
 9552a11 is the first commit using grunt-release (which is **awesome** - thank you for the suggestion) and adds 2.0.4 (a few bug fixes, and `count()`!)
 I haven't gotten to WebJar yet. I'll reopen so I don't forget.
 I'm not sure what the WebJar artifact name guide is, I'll give you some context and let you make an informed decision.

On github, the project is called "immutable-js" because "immutable" is pretty broad, and github hosts projects of all sorts.
On npm, the project is called "immutable" because the "js" part is implied.
In spirit, the project is called "immutable", the "js" is added on when the context of being a JavaScript project isn't already implied.

My best guess is that WebJar is web specific enough that the "-js" isn't necessary.
 Thanks @guersam!
 Thanks @pluma :+1: 
  Thanks for this suggestion - I've been toying with the idea of doing exactly this but have held off before I have a performance testing set up in place (I wanted to avoid implementation complexity before I could measure it's value). I'm glad you've already found this change was worth it, that puts it higher on my list of priorities.
 In the meantime, `Sequence({k: 'v'})` results in something very similar to PersistentArrayMap for reads, but without the full map mutation API.

What I will likely do is make ArrayMap/HashMap an implementation detail of "Map" and just automatically convert between the types when the size of the collection gets past some tradeoff threshold.
 Very cool!
 I just added this in f7ec901e6e0d89caf69ba8a65f0c1c53cb137402 - but I'm open to feedback on improving it further! @swannodette if you see any missed opportunities, I'm all ears.
  Yeah, in truth these are more "inspired by" and less so conforming to the ES6 Map/Set API. For now it's less confusing to have one `keys` method rather than an additional `keySeq` - although I'm going to be paying close attention to how people use this library in their ES6 environments. It's not designed to be a full drop-in replacement for ES6 Map/Set because of these API variations.
 That is definitely a concern. But like I said - I haven't really seen much ES6 action yet, so based on people use it, I'll evolve it accordingly - that may result in making this change.
 This is now mostly solved with 0164a55a13a476516e3bdf7e5316a173974ad05a. There's still some work to be done, but this can now be considered closed :)
  Thanks Ben!
  Yes this is a typo on my part. I'll fix it!â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 11:26 AM, Kyle Dorman notifications@github.com
wrote:

> Hey, 
> Immutable looks pretty cool!
> While reading through the doc, I saw your merge example: 
> 
> ```
> var map1 = Immutable.Map({a:1, b:2, c:3, d:4});
> var map2 = Immutable.Map({c:10, a:20, t:30});
> var obj = {d:100, o:200, g:300};
> var map3 = map1.merge(map2, obj);
> // Map { a: 20, b: 2, c: 10, d: 1000, t: 30, o: 2000, g: 300 }
> ```
> 
> I think the resultant Map should be:
> 
> ```
> // Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }
> ```
> 
> Or is the obj meant to be in thousands?
> Cheers, 
> 
> ## Kyle
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/16
  Yeah I will probably hide toJSON and expose toJS which similarly does a deep conversion to plain JS objects, but doesn't muck with JSON.Â â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 11:32 AM, Felix Kling notifications@github.com
wrote:

> I also don't like this naming convention, but it actually has nothing to do with this library. `toJSON` is a special method that is used by `JSON.stringify` if it is available ([spec](http://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3)). Built-in objects, like `Date` [implement such a method as well](http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.5.44).
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/15#issuecomment-50659438
 Hide as in not document beyond "supports JSON.stringify"â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 11:40 AM, Felix Kling notifications@github.com
wrote:

> @leebyron : This was actually more of a reply to @benjamingr :) Not sure what you mean by "hiding" in this case. The method should definitely exist to make JSON conversion easier.
> 
> ## I just dislike the choice of the method name in general ;)
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/15#issuecomment-50660507
 toJSON is no longer described at all in the type definitions file, but continues to exist as an alias for toJS so that JSON.stringify still behaves correctly. I also changed fromJSON to fromJS to solve for the same ambiguity.

Thanks for highlighting this point of confusion, @benjamingr!
  Ya let's call it TypeScript
 Thanks!
  Intentional to match array join's default. Reasonable?â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 9:14 AM, Ben Alpert notifications@github.com
wrote:

> ## â€¦while Sequence.prototype.join defaults to `','` -- intentional?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/13
  Correct. All mutative methods return new collections. Add push() to this list. I thought I made that clear in that section of the readme but I can definitely improve it. It's a first pass as describing things.Â â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 9:10 AM, Matt Casey notifications@github.com
wrote:

> ## Either I am nit-picking or misunderstand the readme, but these two methods are listed as examples that would normally mutate a collection under "JavaScript-first API".
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/12
 Ahh. Yes, great point and currently confusing. I'll fix this.Â â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 9:18 AM, Isaac Salier-Hellendag
notifications@github.com wrote:

> ## I think @mattcasey is noting that native slice() and concat() are non-mutative, so listing them in a section that discusses "every method that would mutate the collection" isn't quite accurate.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/12#issuecomment-50638524
  Ill loosen it. There's no reason other than I looked over it.Â â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 8:50 AM, Jingwei Liu notifications@github.com
wrote:

> Maybe loosen restriction in package.json to support for Node beta?
> 
> ## Or is there any particular reason to keep these restrictions?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/11
  Yeah I prefer thinking of it as a namespace and keeping it capitalized, similar to React. I agree that if we change it in React then it should change here too.Â 

However this is just the readme, so feel free to define the var as lowercase in your own uses of it.Â 
â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 12:32 PM, Benjamin Gruenbaum
notifications@github.com wrote:

> At least he didn't name it `$`. I agree that whenever a function cannot be used as a constructor is it usually named in lowercase.
> 
> ## This project probably uses the same naming conventions as React, which also uses this naming convention so I'd rather see this naming stay or it change in both projects together.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/10#issuecomment-50667626
  Thanks for reading carefully!
  Yeah, please note the note about the issue with typescript right above that example. Typescript doesn't yet have npm resolution so you need to write out a file path. 
 I will try to make this more clear in the readme
 Thanks, I'll look into this and see if I can find a way to make this work.Â â€”
Sent from Mailbox

On Wed, Jul 30, 2014 at 7:40 AM, Panu Horsmalahti
notifications@github.com wrote:

> I think the main issue here is hat the declaration for immutable is not an ambient external declaration. (Although I just skimmed through the .d.ts file).
> Ambient external declaration files look like this:
> 
> ```
> declare module 'immutable' {
>     class Bar {
>         bar(): void;
>     }
>     export = Bar;
> }
> ```
> 
> ## TypeScript doesn't generate these automatically, but in another project I wrote a small script to convert TypeScript's definition files to ambient external declaration files.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/facebook/immutable-js/issues/8#issuecomment-50623600
 Let me know if you run into any other typescript issues.
  Thanks, fixed in #3
  Thanks, fixed in #3
  Fixed in #7
  Immutable.fromJS() and Immutable.toJS() do deep transforms to and from native JS deep structures but there is more work to be done here. setIn() deleteIn() and getIn() are designed to be used in nested structures.Â â€”
Sent from Mailbox

On Mon, Jul 14, 2014 at 10:43 PM, Michael Williams
notifications@github.com wrote:

> hi, `immutable-data` looks great! :)
> i'd imagine using this with nested objects (a "store" `Map` that contains many "model" `Map`s that may contain "relational" `Map`s, `Set`s, etc). however, it appears `fromObject` and `toObject` don't support serializing and deserializing these nested objects.
> 
> ``` js
> var x = Im.Map.fromObject({ a: { b: { c: 1 } } });
> // Map { "a": [object Object] }
> x.getIn(['a','b','c'])
> // undefined
> x.toObject()
> // { a: { b: { c: 1 }}}
> ```
> 
> and in reverse
> 
> ``` js
> var x = Im.Map.fromObject({ a: Im.Map.fromObject({ b: Im.Map.fromObject({ c: 1 }) }) })
> // Map {"a": Map { "b": Map { "c": 1 } } }
> x.getIn(['a','b','c'])
> // 1
> x.toObject()
> // {a: Map { "b": Map { "c": 1 } } }
> ```
> 
> ## is this something that might be within scope of `immutable-data`?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/leebyron/immutable-js/issues/2
  Really good thoughts, Cheng! The one little optimization I have here (and the reason clone is separate) is that if "as(Im)mutable" do not have clone semantics then the "asImmutable" call can "mutate" it's mutable self into being immutable for an extremely cheap operation for both memory and CPU.

I think if I decide to keep clone() then I will implement your proposal. I think the usage of clone() is dubious though and I may decide to remove it altogether.Â 
â€”
Sent from Mailbox

On Mon, Jul 14, 2014 at 12:24 AM, Cheng Lou notifications@github.com
wrote:

> `asMutable` and `asImmutable`behaviour aren't immediately obvious. How about `cloneAsMutable` and `cloneAsImmutable`?
> `clone` also isn't obvious and is only there to retain API parity with the mutable version of `clone`.
> 
> ## The first point is more than just bikeshedding the wording if, say, `cloneAsMutable` works for mutable collections. This way, you can safely remove `clone` altogether.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/leebyron/immutable-js/issues/1
 Right, we definitely want to avoid boilerplate isMutable() calls and the swift array pit of mutability despair. Mutability is certainly an edge feature here, filling the same need it fills in clojure, i.e. only to chain mutations within a pure function, but I agree that it's easier to mess up because we're not doing set! instead of set.Â 

Â Thanks for prodding at this issue guys I have some ideas for clarifying this and making it easier to understand the role of the mutable cases.
â€”
Sent from Mailbox

On Mon, Jul 14, 2014 at 3:29 PM, Ben Alpert notifications@github.com
wrote:

> ## (See also https://news.ycombinator.com/item?id=8028306.)
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/leebyron/immutable-js/issues/1#issuecomment-48948138
 Ok, I've committed c61c93802671cb675f502a3b00d3fdc99d3d4232 which removes `isMutable`, `asMutable` `asImmutable` and replaces the three with `withMutations` which I think better encapsulates the desired usage of the original three methods and has much less opportunity for abuse (pit of success and all that). I think it also reduces boilerplate quite a bit.

As an example, previously you might have done something like:

``` javascript
function setFooBar(map) {
  var newMap = map.asMutable();
  newMap.set('foo', 'baz');
  newMap.set('bar', 'fizz');
  return map.isMutable() ? newMap : newMap.asImmutable();
}
```

There are a few things dangerous about this (pit of failure):
- There is definite boilerplate and multiple pieces of it, it could be easy to forget a part.
- It's pretty trivial to forget the last line and leak mutable collections into the rest of your program.
- The last line's ternary is easy to mess up. If you simply used `map.asMutable()...asImmutable()` then you could incorrectly return an immutable collection when you passed a mutable one in. That's pretty subtle.

After c61c93802671cb675f502a3b00d3fdc99d3d4232 this becomes:

``` javascript
function setFooBar(map) {
  return map.withMutations(newMap => {
    newMap.set('foo', 'baz');
    newMap.set('bar', 'fizz');
  });
}
```
- Only one addition (function wrapper), hard to mess up.
- Much harder to return a leaked mutable collection, you would have to explicitly assign from within the closure.
- Respecting the mutability of the original collection is done for you.

c61c93802671cb675f502a3b00d3fdc99d3d4232 also removes `clone()` as it makes no sense when the expectation is that everything is immutable. Just use assignment!
/n    This pull request aims to help out a bit with issues #1240 and #1172 . It does 3 things:

1) Exposes `RecordInstance` for import
2) Changes the return type of some chainable functions to return `this & T` instead of just `this`
3) Uses the new `$ElementType<T, K>` for some better type safety

Note that I cannot seem to get `$ElementType<T, K>` to check `set` properly, but it works fine for `get`. I really don't know why it wouldn't work the same, so any assistance would be appreciated.  Fixing FromJS.isPlainObject for the cross window identity discontinuity. This fix will compare isPlainObject with deep prototype chain. I see @ihodes @leebyron @styfle are contributors, can you please review and merge
 @kozlitinaelja  @liubinyi - I see you contributed last changelist in this project, can you help us resolve this pull request ? isPlainObject should be returning false for the deep prototype chains,
however this PR is fixing one problem where you are comparing a plain
Object from a different type system. (for example an object defined under
an iFrame)

Look at this link for more information for this here.
http://tobyho.com/2011/01/28/checking-types-in-javascript/

I've also created a perf test for this change. Look at the test result
here. https://jsperf.com/check-performance-for-prototype-checking/1

-Jinal

On Thu, Jul 20, 2017 at 10:39 AM, Lee Byron <notifications@github.com>
wrote:

> Could you explain more the issue this is solving? isPlainObject should be
> returning false for deep prototype chains, correct?
>
> Also, could you include performance measurements for this change? This
> function is called quite a lot and is a potential performance bottleneck
> for the library
>
> â€”
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/facebook/immutable-js/pull/1271#issuecomment-316777230>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AF0OipLdSwEbQFCot2fsP7mIaq90GvlPks5sP5DFgaJpZM4OZInX>
> .
>
 I updated the perf test one more time with revised version, however its slower as you pointed out. 
Check that here. https://jsperf.com/check-performance-for-prototype-checking/9

What we are trying to solve is addressing this use case handled by this library.

el = document.createElement("iframe")
document.body.append(el)
el.contentWindow.Array instanceof el.contentWindow.Object // true
checkDeepPrototype(el.contentWindow.Array, Array) // true We are going to change our architecture so that we won't hit this problem.   the example code output seems not correct ...  <!--


                                STOP AND READ THIS BEFORE POSTING YOUR ISSUE


                                                  ---  Have a general question?  ---

First check out the Docs: https://facebook.github.io/immutable-js/docs/
And check out the Wiki: https://github.com/facebook/immutable-js/wiki/
Search existing issues: https://github.com/facebook/immutable-js/search?type=Issues&q=question
Ask on Stack Overflow!: https://stackoverflow.com/questions/tagged/immutable.js?sort=votes

 * Stack Overflow gets more attention
 * Answered questions are searchable
 * A whole community can answer

                                                          ---  Feature request?  ---

This library attempts to be as stable as possible so features have to meet a
high bar to be added. This library also prefers interoperability with other
libraries over continuous additions. Here are some tips to get your feature added:

 * Search existing issues and pull requests first.
 * Send a Pull Request! Start with API design and post for review early.

                                                             ---  Found a bug?  ---

Search existing issues first: https://github.com/facebook/immutable-js/search?type=Issues&q=bug
Please ensure you're using the latest version, and provide some information below.

-->
### What happened
Switching to Typescript 2.4.1 causes all ts tests to lock up/fail. It appears to be causing node to run out of memory.
This can also be reproduced by importing Immutable into a project using Typescript 2.4.1, in which case the reported error is:
```
<--- Last few GCs --->

  130691 ms: Mark-sweep 1317.5 (1434.2) -> 1317.5 (1434.2) MB, 2101.4 / 0 ms [allocation failure] [GC in old space requested].
  132883 ms: Mark-sweep 1317.5 (1434.2) -> 1317.5 (1434.2) MB, 2191.1 / 0 ms [allocation failure] [GC in old space requested].
  135075 ms: Mark-sweep 1317.5 (1434.2) -> 1317.5 (1434.2) MB, 2192.7 / 0 ms [last resort gc].
  137266 ms: Mark-sweep 1317.5 (1434.2) -> 1317.5 (1434.2) MB, 2190.7 / 0 ms [last resort gc].


<--- JS stacktrace --->

==== JS stack trace =========================================

Security context: 0x2b1da96c9e59 <JS Object>
    1: instantiateTypeNoAlias [/Users/tony/Projects/x/manage/node_modules/typescript/lib/typescript.js:~34242] [pc=0x3abaf24cf038] (this=0x2b1da96e4dc9 <JS Global Object>,type=0xd201c537129 <a TypeObject with map 0x2422a10a4c41>,mapper=0x1769d2598f09 <JS Function (SharedFunctionInfo 0x356acb1605b1)>)
    2: instantiateType [/Users/tony/Projects/x/manage/node_modules/type...

FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory
sh: line 1: 16214 Abort trap: 6           npm run lint-js
```

<!-- Shortly summarize what went wrong. Be sure to include not just what
  happened, but what you expected to happen as well. -->

### How to reproduce
Edit the package.json, switch the Typescript version to 2.4.1.

<!-- Provide enough information that someone else could produce the same error.
  Share code or even better, send a Pull Request with a new failing test case! -->
 cf. https://github.com/Microsoft/TypeScript/issues/17070 Try to disable the (new) StrictGenericChecks by adding `"noStrictGenericChecks": true` to your `tsconfig.json`.

see https://github.com/Microsoft/TypeScript/issues/16777  I'd like to propose using RunKit embeds for the examples in immutable's documentation. The way I've implemented it, the existing examples remain as is, but also have a "run it" button on the bottom right. When clicked, a RunKit embed is swapped in and the example becomes runnable and editable:

![gif1](https://user-images.githubusercontent.com/23753/27927823-da7c9be4-6241-11e7-987f-d8a214d2da9c.gif)

As you can see from the above gif, we've also taken the time to add native support for Immutable classes into RunKit, so that all the objects show up correctly (you can try this now [here](https://runkit.com/tolmasky/immutable-classes/branches/master/clone)).

Additionally, I made some custom assert.equals/etc so they show up nicely too:

![screen shot 2017-07-06 at 11 57 51 am](https://user-images.githubusercontent.com/23753/27928071-a95c4e00-6242-11e7-938e-a9189b910ba4.png)

Some technical details:

1. Its designed in such a way that if RunKit is down, the site behaves like before (so no absolute dependency).
2. I've modified the markdown parser so that if you add "\<!-- runkit:activate --\>" before a code snippet, it will be turned into a runnable snippet, and the others are left alone.
3. I've left some as not runnable, since they rely on the new unpublished 4.0.0 changes. Once 4.0.0 goes live, these could be made runnable too (or alternatively I could modify the examples to use the current API, but I decided to not make any content changes at all, just usability).
4. Some examples were not technically runnable on their own, as they do not contain the proper imports. RunKit has a solution for this called the preamble (where you can load code before the users code). I've kept these examples the same by using this feature and placing the imports in a not visible first cell. However, I am happy to simply add the imports to the examples themselves too.

The basic goal we're trying to accomplish is to make code immediately usable in docs, to shorten the time it takes to get familiar with a library. Lodash has been using RunKit on their documentation for about a year now, and Express recently incorporated RunKit into their Getting Started example as well. https://expressjs.com/en/starter/hello-world.html . Would love to see the same here, and I am happy to make any changes as necessary. 
  Fixes #1239  This allows use of the `has` method as a type guard, while still otherwise acting as a boolean. Resolves #1230.  The fix to issue #1220 is just to handle the case of a 0 length slice as a special case, and return an empty iterator.

Note : although the problem was detected using Seq.rest(), is much more general and applies to Seq.slice() also. 

Also I did not test the same scenario for other collections.

Added a issues.ts test file, which can be kept for non regression of thrown away. It fails on 4.0.0-rc2.

  Noticed this when I was reading over the flow type definitions.  1. Added fix for checking null or unfined during equality checking
2. Added tests for the check

Addresses #1202  @leebyron Thanks for the feedback. I made changes accordingly @kozlitinaelja Can you please take a look and let me know of any concerns?  ### What happened

http://facebook.github.io/immutable-js/docs/ 's links are all broken

### How to reproduce
1) Open http://facebook.github.io/immutable-js/docs/
2) Click any links on the right hand side. e.g. `Collection` links to http://facebook.github.io/Collection Check it again: 
![image](https://cloud.githubusercontent.com/assets/415057/24878951/20940280-1e03-11e7-8c98-2567337e6a85.png)
 @fikriauliya could you potentially reopen this issue?  I'm experiencing the same problem but only over a slow connection.

### How to reproduce
1. Set your browser to throttle (in Chrome devtools under the network tab set throttle to 2G)
2. Open http://facebook.github.io/immutable-js/docs/
3. Click any links on the right hand side. e.g. OrderedSet links to http://facebook.github.io/OrderedSet

<img width="640" alt="screen shot 2017-06-14 at 11 45 33 am" src="https://user-images.githubusercontent.com/1153686/27141913-8041a67a-50f7-11e7-92a4-315a7dd24ab8.png">  Note that this applies to all collections, not only maps.

**Code**
```
import {Map} from "immutable";

const m = Map({ a: 1 });

for (const [key, value] of m) {
    console.log(key, value);
}
```
**Actual**
```
TSError: â¨¯ Unable to compile TypeScript
src/test.ts (6,28): Type must have a '[Symbol.iterator]()' method that returns an iterator. (2488)
```

**Reason**
The type definition file for immutable.js doesn't include something like this (I'm not sure where would be the right place to put it though)
```
interface Map<K, V> {
  [Symbol.iterator](): IterableIterator<[K,V]>;
}
```

PS: Typescript 2.2.2, options are (tsconfig.json)
```
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "lib": [
      "es2016",
      "dom",
      "dom.iterable",
      "es2017.object"
    ],
    "noImplicitAny": true,
    "suppressImplicitAnyIndexErrors": true,
    "alwaysStrict": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "React",
    "noEmitOnError": false,
    "noFallthroughCasesInSwitch": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "sourceMap": false,
    "inlineSourceMap": true,
    "inlineSources": true,
    "strictNullChecks": true,
    "declaration": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false
  }
}
``` Check #1183     Hello there, just realized the property setter is not tested so this PR :)  Change definition for Record where constructor was specified with 'new'. @oreqizer This solution works a lot better for me.  The downside is it requires making a dummy instance of RecordClass for `typeof` to work. Example:
```
import { Record } from 'immutable';

const testRecord = Record({
  foo: '',
  bar: 0,
});

const dummyInstance = testRecord(); // can't use "new" here
const anotherInstance = testRecord();

// can't use typeof testRecord here
const testFunc = (inputRecord: typeof dummyInstance) => null;

testFunc(anotherInstance);
```
Semantically it makes sense that a record class is different than an instance of it, but it makes the code a little awkward.  Still, better than before where I had to create my own intersection type from RecordInstance to get this to work.

I've been trying to come up with a clean solution myself, but haven't so far. Whats stopping this from being released?

It looks like a reasonable approach.    This is the example in the docs at https://facebook.github.io/immutable-js/docs/#/Map/setIn
```javascript
const { Map } = require('immutable')
const originalMap = Map({
  subObject: Map({
    subKey: 'subvalue',
    subSubObject: Map({
      subSubKey: 'subSubValue'
    })
  })
})

const newMap = originalMap.setIn(['subObject', 'subKey'], 'ha ha!')
// Map {
//   "subObject": Map {
//     "subKey": "ha ha!",
//     "subSubObject": Map { "subSubKey": "subSubValue" }
//   }
// }

const newerMap = originalMap.setIn(
  ['subObject', 'subSubObject', 'subSubKey'],
  'ha ha ha!'
)
// Map {
//   "subObject": Map {
//     "subKey": "ha ha!",
//     "subSubObject": Map { "subSubKey": "ha ha ha!" }
//   }
// }
```

The output for `newerMap` should instead be:
```
// Map {
//   "subObject": Map {
//     "subKey": "subValue",
//     "subSubObject": Map { "subSubKey": "ha ha ha!" }
//   }
// }
```

The same applies for the setIn-Example for OrderedMap


Should you agree, I would make a PullRequest  Closes #1184

As part of the RFC to refactor Records [1], the methods `deleteIn` and
`removeIn` were removed but the Typescript and Flow definitions were
still present. This PR will bring back these methods to deeply
manipulate a tree of immutable records. This is especially useful when
you build a larger state out of immutable components and want to remove
a list entry deeply within.

[1]: https://github.com/facebook/immutable-js/commit/768151abf9e360b4d7a7e6e93e03470cd29ff5e9 I would need this. Is there anything blocking the merge?    It seems there is an issue with hash codes that are powers of 2 above 2**32--they cause infinite recursion.

Associated issue: https://github.com/facebook/immutable-js/issues/1176  It's unclear how to annotate Record instances with Flow types:

```js
// @flow
import {Record} from 'immutable';

const TestRec = Record({a: 0, b: 0});

// Flow gives an error for the `rec` argument's type:
//
//   RecordClass
//   Ineligible value used in/as type annotation (did you forget 'typeof'?)
//   TestRec
//
// Is there a type that can be used here? `typeof TestRec`
// does not work, nor do any other variations I've tried.
function handleRec(rec: TestRec) {
  console.log(rec.a);
}

const myRec = TestRec();
handleRec(myRec);
```

If it's possible, examples in the docs would be great. Or, if it's not possible, documentation about the limitations of Records + Flow types would also be great. Happy to help write docs if I can figure out what's going on. @jkk 
In case of TypeScript I'm using it like this:

```js
import * as Imm from "immutable";
interface ITestRec {
    field1: number;
    field2: string;
}

const TestRec = Imm.Record<ITestRec>({field1: 0, field2: "default text"});

function someMethod(rec: Imm.Record.Instance<ITestRec>) {
    console.log(rec.field1);
}
```

@leebyron 
Offtop: v4 is a lot better in terms of typescript integration. Thank you guys, it removed a lot of frustration, nice job! @EChikunov Unfortunately the equivalent in Flow doesn't seem to work.

I've tried a million variations, and also tried revising `immutable.js.flow`, but my static-typing skills are not strong enough. I'd absolutely love an example of how to do what @EChikunov did in flow, specifically the `rec: Imm.Record.Instance<ITestRec>` portion, since
```
export const NodeRecord = Record({
  id: ('': string),
  labels: (List(): List<string>),
  properties: (Map(): Map<string, string>),
});
```
Works pretty well for me, but it falls apart when I start doing things like
```
export const EntitiyRecord = Record({
  nodes: (Map(): Map<string, typeof NodeRecord>),
  relationships: (Map(): Map<string, typeof RelationshipRecord>),
});
``` Hey guys,

I was able to get Records to work with TypeScript with no additional interface types.

Here's the implementation: https://gist.github.com/johnfn/12defda0d0548a4b165201f77618f36c (It's quite long because I copied a lot from other immutable.js definitions. If anyone knows how to clean it up, please feel free to do so.)

Here's a typical use case:

```
const record = MakeRecord({
    a: 1,
    list: new Immutable.List([]),
    nestedRecordsWorkToo: MakeRecord({ c: 3 }),
    b: foo,
});

console.log(record.a); //.a autocompletes, as does all methods on the Record class.
```

One really cool thing about this implementation is that you can even have functions with a `this` parameter that refers to the current object. Dunno if you'll want this, but it was super useful for me. You just need to use an anonymous class. Example:

```
const fancyRecord = MakeRecord{new class {
    a = 1;
    get getterForA() { return this.a; }
});

console.log(fancyRecord.getterForA);
```

Hopefully these definitions are as useful for you as they are for me! This is what we do in my team at Facebook, although it's super hacky:
```js
class MyRecord extends Immutable.Record({
  foo: '',
  bar: 0,
}) {
  foo: string;
  bar: number;
}
```

What works:
 - Flow recognises `MyRecord` as a type
 - Flow knows that `.foo` returns a string and `.bar` returns a number

What doesn't work:
 - Pretty much everything else ðŸ˜› . `set`, `setIn` and friends are still untyped. How are people using Immutable with Flow without this?

I am probably missing something. But without Record type I am only able to use higher level collections such (as `List`) and the datum itself remains mutable. Is that right? @Daniel15 Angular Cli doesn't seem to compile this stuff I already have...! Is there any work around other then this..
```
import { List, Record } from 'immutable';
class MyRecord extends  Record({
  foo: '',
  bar: 0,
}) {
  foo: string;
  bar: number;
}
ERROR in Error encountered resolving symbol values statically. Symbol reference expected (position 17:31 in the original .
ts file), resolving symbol MyRecord in C:/xampp/htdocs/angular/src/app/app.ts
``` @EChikunov Your example doesnt work for me (TS 2.3.1, Immutable rc2). I get a `Property field1 does not exist on type Instance<ITestRec>`. Only way I could get this to work was make a union type with ITestRec:

```
import * as Imm from "immutable";
interface ITestRec {
    field1: number;
    field2: string;
}

const TestRec = Imm.Record<ITestRec>({field1: 0, field2: "default text"});

function someMethod(rec: Imm.Record.Instance<ITestRec> & ITestRec) {
    console.log(rec.field1);
}

``` For a more generic typescript solution I updated the record instance definition as such: https://github.com/facebook/immutable-js/compare/master...OpenTriply:recordTypes?expand=1

I'm not confident enough that all corner-cases are covered (although it works fine for me), so I haven't submitted it as PR.   @gajus I believe the 90% use case for immutable with flow is heavy use of `Map` and `List` collection types, which are all entirely immutable, as long as you instantiate them properly at every level of your data structure or generate them with `fromJS`. The types then look like:

```js
type Bar = List<Map<string, string>>;
type Foo = Map<string, number | string | Bar>;
const foo: Foo = Map({
  id: 42,
  qux: 'quux',
  bar: List([
    Map({ baz: 'baz' }),
  ]),
});
```

and every datum is 100% immutable. Flow will then be able to verify the safety of all of your operations on any instance of `Foo` and enforce providing default values where appropriate, though you wouldnâ€™t get any warnings if you had `const foo: Foo = Map({ isGood: false })`, even though boolean was not one of the union types specified for values of `Foo`.  Is that what your question was referring to? > I believe the 90% use case for immutable with flow is heavy use of Map and List

No, the question was how you'd describe Records and make them work with Flow.

If your code is 90% Map/ List then one of us doing something very wrong/ different, because pretty much everything relies on Records in my code base. Sure, Records are contained in Map/ List, etc. But if Records are not typed-checked, then it makes Immutable useless with types.

As I've mentioned in another comment, I've opted to completely drop Immutable from our workflow. Instead, I am enforcing covariance and `$ReadOnlyArray` with Flow. This is no where near as elegant as using Immutable, but until Record issue is solved, I put more importance on types than immutability. Chiming in to say that my experience matches @gajus. It sucks to have to choose between Flow and Immutable, but I made the same choice as him, and it's definitely cumbersome. Flow + Immutable Records would be a holy-grail combo. Hoping someone is able to figure this out (I wish it could be me, but I don't have the skills or time).  `Set([1, 2, 3, 4, 5]).count(x => true)` returns `0` instead of `5`.

I added this test to `__tests__/Set.ts`:
```
+  it('can count entries that satisfy a predicate', () => {
+    let set = Set([1, 2, 3, 4, 5]);
+    expect(set.count(x => true)).toEqual(5);
+  });
```

and get:
```
 FAIL  __tests__/Set.ts
  â— Set â€º can count entries that satisfy a predicate

    expect(received).toEqual(expected)

    Expected value to equal:
      5
    Received:
      0
```  Version: 4.0.0-rc.2

The flowtype definition for Map seems to have lost the size property:

```
src/components/Projects/Projects.js:91
 91:     if (newprops.personeeldata && newprops.users.users && Map.isMap(newprops.users.users) && newprops.users.users.size > 0) {
                                                                                                                       ^^^^ property `size`. Property not found in
 91:     if (newprops.personeeldata && newprops.users.users && Map.isMap(newprops.users.users) && newprops.users.users.size > 0) {
                                                                                                  ^^^^^^^^^^^^^^^^^^^^ Map
```  @leebyron I appreciate the love for TS here :+1:   ### What happened

Hi @leebyron , It seems so bizzare but all **is** fuctions are undefined.

I checked isImmutable, isCollection, isKeyed, isIndexed, isAssociative, isOrdered and isValueObject, they are all undefined.

I used node v7.5.0. Updated to latest version but still got error.

There is another issue opened (#1165) but reports only isImmutable undefined. Sorry for the direct mention but because of the severity of the situation, I thought It would be better this way.

Regards 4.0.0-rc.2 Sorry, I didn't use **rc** flag. It was not mentioned in docs on website.

I am really sorry, in a rush I mixed up version numbers. My installed version was ^3.8.1 but mistakenly reported 4.0.0-rc.2.

Please can you update documentation about **rc** flag so you don't have to deal with similar problems.

Thank you for your time and effort.  ### What happened

when calling `isImmutable(/* any value, ex: Immutable.Map()*/)` I get the following error:

```
Uncaught TypeError: isImmutable is not a function
```
### How to reproduce

The issue is reproducible even on the doc's console, or in Node, using the doc's syntax.

```javascript
import Immutable, {isImmutable} from 'immutable';
//or
const { isImmutable, Map, List, Stack } = require('immutable');

isImmutable([]);
 // or
Immutable.isImmutable(Immutable.Map())
```


What i noticed is that its not in the required Immutable object in the first place.
docs link:  https://facebook.github.io/immutable-js/docs/#/isImmutable Yes, isImmutable function is not exposed. 

`const { isImmutable, Map, List, Stack } = require('immutable');
console.log(isImmutable); //undefined` 4.0.0-rc.2 So if we're on 3.8.1 what is the suggested method for checking if an object is Immutable?

I'm running into this problem at the moment @rossPatton i looked it up from my old code, i used to use this method:
```javascript
Immutable.Iterable.isIterable(MY_ENTITY)
```

Since all immutables inherit from the `Iterable` object;
checking `isIterable` on any javascript type returns `true` if its immutable, `false` if its not.
 Thanks for the suggestion. The docs really confused me on this topic. I didn't realize the docs were for 4.0, even though that's not complete yet. why not update npm's package to lasted version ????  @Bamieh thanks for your solution, except it still returns true if I use, for your example `MY_ENTITY.asMutable()`, not sure what to do about that. @ElGoorf can you show some code, i cannot really understand your case. `asMutable` is a method on immutableJS objects, so having this function implicitly indicates that you are using an immutableJS entity. additionally, calling `asMutable` on an immutable object returns an immutable object, with the only difference that:

> Every time you call one of the above functions, a new immutable Map is created. If a pure function calls a number of these to produce a final return value, then a penalty on performance and memory has been paid by creating all of the intermediate immutable Maps.

so what you really get is an immutable object after all even after using `asMutable`.


 This is for unit testing and trying to track down bugs in code; I want to catch any functions which are returning Maps which have had `asMutable()` called on them, but not `asImmutable()`.  added links to header in docs #356    Both the ES6 source and `immutable.js.flow` declare `Map` as a class, and presumably sub-class-able.

However `immutable.d.ts` declares it as a module/function/interface, preventing sub-classing from it.

I'm using TS, and would like to sub-class Map.

Is Map not meant to be sub-class-able, or is the TS declaration incorrect? I looking to do the same as @papercuptech. Sub-classing is my biggest issue with Immutable.js. We had to implement Records everywhere to get typing information but I could still not sub-class from a parent record. 


```javascript
const parentRecord = Record {a:1,b:2}
class Parent extends parentRecord{
a:number;
b:number;
constructor(a:number,b:number){
    super(
        {a:a,b:b}
    )
  }
}
```

Now I want to extend this Parent class:

```javascript
const childRecord = Record {c:1,d:2}
class ChildClass extends Parent{
c:number;
d:number;
constructor(a:number,b:number,c:number,d:number){
    super(
        {a:a,
        b:b,
        c:c,
        d:d
      }
    )
  }
}
```

This obviously doesn't work but you can see what I'm getting at. Given it appears you are refactoring all this new code for Typescript what do you recommend moving forward for developers who want to use an immutable type but need to create a class hierarchy and get dot notation intellisense. @leebyron Got it. I just want to give my thoughts on this if that's OK. I believe I understand (I may not) that we have separate programming styles here with functional and object oriented. Although libraries such as this one have revealed an alternate reality to me which is we instead work on spectrum and you can incorporate each style into your code. With that being said I personally don't see the value of Immutable.js as a functional programming library (you may not either) but instead an awesome library that prevents me from passing all my objects by reference and tearing out all my hair :) I may be missing the point but that is the beauty I see here. This is why I get confused by your answer because to me I'm inches away from reducing massive amounts of my typescript code if I could inherit class properties while maintaining immutability. Now you may say that last sentence is impossible given the inherent mutation that I'm asking for but then you have to ask yourself what do developers like myself do? Is the answer to code in a functional style? Maybe but I believe the unexpected popularity of your Records type as you noted in your 2016 road map document is likely due to a number of the reasons I pointed out above.  ### What happened

After upgrading from `3.x` to `4.x` the `getIn()` method is not behaving as before and not as documented. It often returns `Invalid keyPath: Value at ["someKey"] does not have a .get() method: null` instead of handling null keys gracefully.

### How to reproduce

```
const ABRecord = Immutable.Record({ a: 1})
const myRecord = new ABRecord()
console.log(myRecord.getIn(['a', 'b']));
```

Returns
```
TypeError: Invalid keyPath: Value at ["a"] does not have a .get() method: 1
```

But I expected it to return `null` instead. @leebyron Thanks for the detailed explanation, however I believe there is still a bug as the code you posted:

```javascript
const ABRecord = Immutable.Record({a: null});
const myRecord = new ABRecord();
console.log(myRecord.getIn(['a', 'b']));
```

Also returns:

```
TypeError: Invalid keyPath: Value at ["a"] does not have a .get() method: null
```

Additionally, even if this is still intended behavior, I would highly recommend this breaking change get called out specifically on the 4.0 changelog as it was not clear from the current description and it's caused a lot of headaches for us during the upgrade process. It also happens on nested `Map` structure not only on `Record`. @leebyron would it be possible to have this behavior have a deprecation cycle for one major version where instead of `throw`ing a warning is logged? For example on our codebase we have 1000+ callsites of `getIn` to migrate before we can update.

Having a deprecation period with a warning for this will allow us to upgrade sooner and migrate the necessary codepaths with more confidence.  ### What happened

Calling `flatten()` on nested collection does not flatten the collection properly.

### How to reproduce
```
var immutable = require("immutable")
const list1 = immutable.List().push('a').push('b');
const list2 = immutable.List().push('c').push('d');
let map = immutable.Map();
map = map.setIn(['level1', 'level2branch1'], list1);
map = map.setIn(['level1', 'level2branch2'], list2);
console.dir(map.toJS());
console.dir(map.flatten(0).toJS());
```

Since each list contain 2 items, one would expect the flattened obj would contain 4 items.

What to expect:
```
Obj:
0: "a"
1: "b"
2: "c"
3: "d"
```

What actually happend:
```
Obj:
0: "c"
1: "d"
```

version: immutable@3.8.1

I assume this is because the key is not unique? But the `List` can always have duplicated keys during flattening, is there a way to avoid this? @leebyron sorry about the confusion, I updated the issue with version info and without `uuid` FYI, this example produce expected result:
```
var immutable = require("immutable")
const list1 = immutable.List().push('a').push('b');
const list2 = immutable.List().push('c').push('d');
let list = immutable.List();
list = list.push(list1).push(list2);
console.dir(list.toJS());
console.dir(list.flatten(0).toJS());
```

output:
```
Array:
0: "a"
1: "b"
2: "c"
3: "d"
```  It's a small PR to fix an unhighlighted example code and wrong variable names Done! :)  My app built fine with 4.0rc1, but fails with rc2, errors in the immutables type definition.
The immutables tests pass on my machine, and my app builds if I disable the `strictNullChecks` typescript flag.

tsc 2.1.4
node 6.9.5

```
node_modules/immutable/dist/immutable-nonambient.d.ts(2331,22): error TS2320: Interface 'Keyed<K, V>' cannot simultaneously extend types 'Seq<K, V>' and 'Keyed<K, V>'.
  Named property 'size' of types 'Seq<K, V>' and 'Keyed<K, V>' are not identical.
node_modules/immutable/dist/immutable-nonambient.d.ts(2441,22): error TS2320: Interface 'Indexed<T>' cannot simultaneously extend types 'Seq<number, T>' and 'Indexed<T>'.
  Named property 'size' of types 'Seq<number, T>' and 'Indexed<T>' are not identical.
node_modules/immutable/dist/immutable-nonambient.d.ts(2529,22): error TS2320: Interface 'Set<T>' cannot simultaneously extend types 'Seq<T, T>' and 'Set<T>'.
  Named property 'size' of types 'Seq<T, T>' and 'Set<T>' are not identical.
node_modules/immutable/dist/immutable-nonambient.d.ts(2620,20): error TS2430: Interface 'Seq<K, V>' incorrectly extends interface 'Collection<K, V>'.
  Types of property 'map' are incompatible.
    Type '<M>(mapper: (value: V, key: K, iter: this) => M, context?: any) => Seq<K, M>' is not assignable to type '<M>(mapper: (value: V, key: K, iter: this) => M, context?: any) => Collection<K, M>'.
      Type 'Seq<K, any>' is not assignable to type 'Collection<K, any>'.
        Types of property 'size' are incompatible.
          Type 'number | undefined' is not assignable to type 'number'.
            Type 'undefined' is not assignable to type 'number'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2761,22): error TS2430: Interface 'Keyed<K, V>' incorrectly extends interface 'Collection<K, V>'.
  Types of property 'toSeq' are incompatible.
    Type '() => Keyed<K, V>' is not assignable to type '() => Seq<K, V>'.
      Type 'Keyed<K, V>' is not assignable to type 'Seq<K, V>'.
        Types of property 'map' are incompatible.
          Type '<M>(mapper: (value: V, key: K, iter: Keyed<K, V>) => M, context?: any) => Keyed<K, M>' is not assignable to type '<M>(mapper: (value: V, key: K, iter: Seq<K, V>) => M, context?: any) => Seq<K, M>'.
            Type 'Keyed<K, any>' is not assignable to type 'Seq<K, any>'.
              Types of property 'flatMap' are incompatible.
                Type '<KM, VM>(mapper: (value: any, key: K, iter: Keyed<K, any>) => Iterable<[KM, VM]>, context?: any) ...' is not assignable to type '<M>(mapper: (value: any, key: K, iter: Seq<K, any>) => Iterable<M>, context?: any) => Seq<K, M>'.
                  Type 'Keyed<any, any>' is not assignable to type 'Seq<K, any>'.
                    Types of property 'concat' are incompatible.
                      Type '{ <KC, VC>(...collections: Iterable<[KC, VC]>[]): Keyed<any, any>; <C>(...collections: { [key: st...' is not assignable to type '(...valuesOrCollections: any[]) => Collection<any, any>'.
                        Type 'Keyed<any, any>' is not assignable to type 'Collection<any, any>'.
                          Types of property 'size' are incompatible.
                            Type 'number | undefined' is not assignable to type 'number'.
                              Type 'undefined' is not assignable to type 'number'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2910,22): error TS2430: Interface 'Indexed<T>' incorrectly extends interface 'Collection<number, T>'.
  Types of property 'toSeq' are incompatible.
    Type '() => Indexed<T>' is not assignable to type '() => Seq<number, T>'.
      Type 'Indexed<T>' is not assignable to type 'Seq<number, T>'.
        Types of property 'map' are incompatible.
          Type '<M>(mapper: (value: T, key: number, iter: Indexed<T>) => M, context?: any) => Indexed<M>' is not assignable to type '<M>(mapper: (value: T, key: number, iter: Seq<number, T>) => M, context?: any) => Seq<number, M>'.
            Type 'Indexed<any>' is not assignable to type 'Seq<number, any>'.
              Types of property 'concat' are incompatible.
                Type '<C>(...valuesOrCollections: (C | Iterable<C>)[]) => Indexed<any>' is not assignable to type '(...valuesOrCollections: any[]) => Collection<any, any>'.
                  Type 'Indexed<any>' is not assignable to type 'Collection<any, any>'.
                    Types of property 'size' are incompatible.
                      Type 'number | undefined' is not assignable to type 'number'.
                        Type 'undefined' is not assignable to type 'number'.
node_modules/immutable/dist/immutable-nonambient.d.ts(3153,22): error TS2430: Interface 'Set<T>' incorrectly extends interface 'Collection<T, T>'.
  Types of property 'toSeq' are incompatible.
    Type '() => Set<T>' is not assignable to type '() => Seq<T, T>'.
      Type 'Set<T>' is not assignable to type 'Seq<T, T>'.
        Types of property 'map' are incompatible.
          Type '<M>(mapper: (value: T, key: T, iter: Set<T>) => M, context?: any) => Set<M>' is not assignable to type '<M>(mapper: (value: T, key: T, iter: Seq<T, T>) => M, context?: any) => Seq<T, M>'.
            Type 'Set<any>' is not assignable to type 'Seq<T, any>'.
              Types of property 'concat' are incompatible.
                Type '<C>(...valuesOrCollections: (C | Iterable<C>)[]) => Set<any>' is not assignable to type '(...valuesOrCollections: any[]) => Collection<any, any>'.
                  Type 'Set<any>' is not assignable to type 'Collection<any, any>'.
                    Types of property 'size' are incompatible.
                      Type 'number | undefined' is not assignable to type 'number'.
                        Type 'undefined' is not assignable to type 'number'.
``` yes. Actually working on a pull request right now :-) the main fix is:

```diff
-      readonly size: number;
+      readonly size: number | undefined;
```

(assuming you agree with that fix)

it can't unify number and number|undefined for the size, so I put number|undefined everywhere.

In addition, I'm modifying the settings for the tests to enable strictNullChecks and noImplicitAny. actually it's worse than that.

The issue is multiple inheritance, like this:

    export interface Keyed<K, V> extends Seq<K, V>, Collection.Keyed<K, V> {

As in the message:

    Interface 'Keyed<K, V>' cannot simultaneously extend types 'Seq<K, V>' and 'Keyed<K, V>'.
      Named property 'size' of types 'Seq<K, V>' and 'Keyed<K, V>' are not identical.

If we have size nullable in Seq and non-nullable in Keyed then there is a conflict. Except if we can remove the size property entirely from Keyed? I just don't know the APIs enough.

That's the issue I hit. Actually looking at recent changes I'm not exactly sure what caused that issue to surface after rc1. But there are more issues with immutables and `strictNullChecks`, many probably considerably more ancient than 4.0rc1. 

It is possible to reproduce the issues by adding:

    strictNullChecks: true

to `options` in jestPreprocessor.js. With strict null checks, many tests that immutables have actually become unneeded (like tests to insert in map a null key, it becomes impossible with strict null checks). But there are more issues.

I think ideally immutables should build with strict null checks, because that option is more strict than the normal one. If it builds with strict null checks, it'll build without, but the reverse is not true.

I stopped working on my PR: I won't find the time, and I simply don't know enough about immutables itself... waiting for the fix    Can we add `Record#deleteIn` as well? We use this for deeply clearing `Map` properties in a large `State` record. It's also still present in the flow and ts types :)  Woot! Thanks a lot for this! It was a major blocker for us during migration to 4.0.0.  After the refactoring, extended records don't work anymore. I get the error `Expected polymorphic type instead of class type: Record.`.

Flow definition files don't help either.

Looking at the type-def tests it would seem that the only test covering extended records is:

```
class ABClass extends (Record({a:1, b:2}): any) {
  setA(a: number) {
    return this.set('a', a);
  }

  setB(b: number) {
    return this.set('b', b);
  }
```

This doesn't seem right. We should be able to define set properties with something like v3:

```
declare class extends Record<{ a: number, b: ?string }>
``` > Unfortunately in the previous version the any was implicit, so no type checking was occurring at all for Records

I might misunderstand something, but extended records seem to work in v3: https://cl.ly/jXBT So, I've managed to (partly) fix the issue of type-defs by adding a `T` to Record like so:

```
declare class Record<T> {
  static (spec: T, name?: string): RecordClass<T>;
  constructor(spec: T, name?: string): RecordClass<T>;

  static isRecord: typeof isRecord;

  static getDescriptiveName(record: RecordInstance<*>): string;

  get<K: $Keys<T>>(key: K): /*T[K]*/any;
}

declare class Record<T> {
  static (spec: T, name?: string): RecordClass<T>;
  constructor(spec: T, name?: string): RecordClass<T>;

  static isRecord: typeof isRecord;

  static getDescriptiveName(record: RecordInstance<*>): string;
}
``` I just bumped immutable on the main project and I receive these errors on non-extended records, e.g.: 

https://cl.ly/jXHq

```
constructor call: .../state.js:19
Constructor cannot be called on RecordClass: .../state.js:19

type application of identifier `Record`: .../storeDataSelector.js:9
Expected polymorphic type instead of class type: Record: .../state.js:10
```



Those are all over the code base. > So, I've managed to (partly) fix the issue of type-defs by adding a T to Record like so:

You said partially. Whats the downside to this? Extended records have some issues.

* subset functions of Iterable (eg. equals, has, etc) aren't visible to Flow (guessing it's an issue with the RecordClass definition)
* and in some cases when I use it in my React props it tells me to use typeof

Feel free to copy-paste it into immutable.js.flow and check it out. I'd love to find out why. I tried exposing `RecordInstance` from the flow type definitions and cast `Record` to `Class<RecordInstance>` while extending. I also added the properties directly to the inherited class, like this:

```js
class ABClass extends ((Record({a: 1, b: 2}): any): Class<RecordInstance<{a: number, b: number}>>) {
  a: number;
  b: number;
  //..
}
```

So far I think the main problem with this approach is that it

1. Does not check the `constructor` 
2. Methods like `.set()` are typed to return `this` which flow will pick up as `RecordInstance` as opposed to `ABClass`.

So this test example:

```js
class ABClass extends ((Record({a: 1, b: 2}): any): Class<RecordInstance<{a: number, b: number}>>) {
  a: number;
  b: number;

  setA(a: number) {
    return this.set('a', a);
  }

  setB(b: number) {
    return this.set('b', b);
  }
}

var t1 = new ABClass({a: 1});
var t2 = t1.setA(3);
var t3 = t2.setB(10);
// $ExpectError
var t4 = t2.setC(10);

var t1a = t1.a;
// $ExpectError
var t1a: string = t1.a;
// $ExpectError
var t1c = t1.c;
```

Will fail with
```
record.js:54
 54: var t3 = t2.setB(10);
                 ^^^^ property `setB`. Property not found in
 54: var t3 = t2.setB(10);
              ^^ RecordInstance


Found 1 error
``` That's because you're essentially telling the inference engine that the result of your class is a RecordInstance instead of ABClass i think.

Letting the Flow dynamically type check your class should work in theory:

```
type DefaultProps = { a: number, b: number };

class ABClass extends Record({a: 1, b: 2})<DefaultProps> {
  getA() {}
  getB() {}
}
```

This should properly extend the class and set the value for T declared in RecordInstance. @NullDivision I think flow is well aware of the ABClass  type since all tests with 't1' work as expected (even the first call auf 'setA') The problem is that methods like 'set' create a new record instance which flow does not recognize as ABClass but only as RecordInstance (the place where 'set' is defined)

I struggled with your ideas because  it appears that the newest version of flow only let you extend from "polymorphic types". That's why my approach required 'Class<>'  `React.Component<DefaultProps, Props, State>` seems to work perfectly fine on Flow v0.41.0 so I'm not really sure what you mean by only allowing extension on polymorphic types.

What if you try a signature of:

`class ABClass extends (Record({a: 1, b: 2})<{a: number, b: number}>)`

It would set the values for T in theory. I was able to get an explicitly typed version of Records working with TypeScript here: https://github.com/facebook/immutable-js/issues/1172#issuecomment-286985608 I'm not sure what to make of your TS definition but I wish you'd have used Record instead of MakeRecord. :D

However a takeaway that I see is that the use of Record, RecordClass and RecordInstance is kind of an overkill. What about merging RecordClass into RecordInstance? You could modify it to use Record instead, if you'd like! ðŸ˜„  @NullDivision when I try your addition to the `Record` type in the test file that is part of the repository:

```
record.js:41
 41: class ABClass extends Record({a: 1, b: 2})<DefaultProps> {
           ^^^^^^^ ABClass. Expected polymorphic type instead of
 41: class ABClass extends Record({a: 1, b: 2})<DefaultProps> {
                           ^^^^^^^^^^^^^^^^^^^^ RecordClass

record.js:41
 41: class ABClass extends Record({a: 1, b: 2})<DefaultProps> {
                           ^^^^^^^^^^^^^^^^^^^^ statics of this instantiation of function call. Expected polymorphic type instead of
 41: class ABClass extends Record({a: 1, b: 2})<DefaultProps> {
                           ^^^^^^^^^^^^^^^^^^^^ RecordClass

record.js:43
 43:     return this.set('a', a);
                ^^^^^^^^ property `set`. Expected polymorphic type instead of
 41: class ABClass extends Record({a: 1, b: 2})<DefaultProps> {
                           ^^^^^^^^^^^^^^^^^^^^ RecordClass

record.js:47
 47:     return this.set('b', b);
                ^^^^^^^^ property `set`. Expected polymorphic type instead of
 41: class ABClass extends Record({a: 1, b: 2})<DefaultProps> {
                           ^^^^^^^^^^^^^^^^^^^^ RecordClass

record.js:51
 51: var t1 = new ABClass({a: 1});
                  ^^^^^^^ constructor return. Expected polymorphic type instead of
 41: class ABClass extends Record({a: 1, b: 2})<DefaultProps> {
                           ^^^^^^^^^^^^^^^^^^^^ RecordClass

record.js:54
 54: // $ExpectError
     ^^^^^^^^^^^^^^^ Error suppressing comment. Unused suppression

record.js:58
 58: // $ExpectError
     ^^^^^^^^^^^^^^^ Error suppressing comment. Unused suppression

record.js:60
 60: // $ExpectError
     ^^^^^^^^^^^^^^^ Error suppressing comment. Unused suppression


Found 8 errors

````

I'm running flow `0.41.0`

Can you provide a working Gist or a PR so I can have another look? Getting the same error when trying to describe my Redux state as a Record:
```
type State = Record<{
  isLoading: boolean
}>;

const state: State = Record({
  isLoading: false
});

// -> RecordClass. Expected polymorphic type instead of class type: Record
``` I'm also getting same `Expected polymorphic type instead of class type: Record` when using `4.0.0-rc.2`. However, after reading pretty much all related tickets I'm still not sure whether I'm using the Record typings correctly.

I created a quick modification to tests to illustrate what I'm trying to do. I would expect those tests to run and all getters in `record-imports.js` to be covered by flow but they are not.

Relevant files are these
https://github.com/TomiS/immutable-js/blob/master/type-definitions/tests/record-imports.js
and 
https://github.com/TomiS/immutable-js/blob/master/type-definitions/tests/record.js#L9-L12
https://github.com/TomiS/immutable-js/blob/master/type-definitions/tests/record.js#L64-L66

Is this even nearly correct? How is the Record type meant to be used?
 We have a showstopper, here, it's not a minor issue. And it has been many months now.
Flow: Facebook.
Immutable: Facebook.
How come it has not been solved yet ?
Sorry for the gripe, but it had to be said. I agree this is an issue that severely weakens the usefulness of Flow for everyone using Immutable.js. I also understand this might be very difficult to solve because it requires deep understanding of both Immutable.js and Flow. The question is if there is a person with such knowledge within community who could help (I'm afraid I don't have the required skills yet) or does this require the golden touch of good ppl at FB? To be honest, I think this is pretty much a dead end.
Not blaming FB people here: it's just we all want to achieve on top of Immutable something that might be too complicated for a javascript type checker.
But there is good news. I've stumbled upon a fantastic library that IMHO deserves some light.
Please have a look:
https://github.com/pbomb/flow-immutable-models
This is, as far as I'm concerned, exactly what I needed.
You get models (backed by Immutable) that Flow (and IDEs!) can easily understand, even with nested structures. No hack, no tortuous type definitions. It's brillant. Please share !  Right now in TypeScript typings `Collection.filter` returns `this`,
which means it's a subtype of the containing class. I.e. if we have a
type `Collection<number, string>`, `Collection.filter` would return
`Collection<number, string>`.

It causes some issues like those:

```typescript
function foobar(): List<string> {
  const a = List.of<string | number>("a", 1, "b");
  const b = a.filter(i => typeof i === "string").toList();
  return b;
}
```

causes a type error:

```
Error:(689, 3) TS2322:Type 'List<string | number>' is not assignable to type 'List<string>'.
  Type 'string | number' is not assignable to type 'string'.
    Type 'number' is not assignable to type 'string'.
```

Same thing happens if we work with subclasses, like:

```typescript
class A {
}

class B extends A {
  public foo(): string {
    return "B";
  }
}

class C extends A {
  public bar(): string {
    return "C";
  }
}

function foobar(): List<C> {
  const a = List.of<A>(new B(), new C());
  const b = a.filter(i => i instanceof C).toList();
  return b;
}
```

shows an error:

```
Error:(702, 3) TS2322:Type 'List<A>' is not assignable to type 'List<C>'.
  Type 'A' is not assignable to type 'C'.
    Property 'bar' is missing in type 'A'.
```

Not sure what's the right solution would be. Maybe just add another
typing for `filter`, along with already existing one, which accepts
a value type in the returned collection, like I did in this
Pull Request?

Then, if you have a case like I described above, you can just provide a
type for M, like `foo.filter<string>(a => typeof a === "string)`.

What do you think? > Wouldn't this PR also result in problems? I would expect an error like: "Collection<string, C> is not assignable to type List" - Returning a different type would probably mean replicating this change across all types much like map<M>

Ah, right, it should be replicated across all types. Well, it seems like we could still keep `filter` method (without type arg) returning `this`, and replicate `filter<S>` (with type arg) returning some specific collection type for each collection type.

> Looking into TypeScript's own lib, it seems like https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts#L1097 might be leveragable.

You mean using guards in a return type of a predicate? Like:

```ts
filter(
  predicate: (value: V, key: K, iter: this) => boolean,
  context?: any
): this;
filter<S extends V>(
  predicate: (value: V, key: K, iter: this) => value is S,
  context?: any
): Collection<K, S>;
```

It seems like the problem with guard functions - you explicitly should specify that their return type is a guard. I.e. I can't use `filter` like:

```ts
const b = a.filter<C>((i: A) => i instanceof C);
```

it will complain like:

```
Error:(700, 25) TS2345:Argument of type '(i: A) => boolean' is not assignable to parameter of type '(value: A, key: number, iter: List<A>) => value is C'.
  Signature '(i: A): boolean' must have a type predicate.
```

I'd have to write it as:

```ts
const b = a.filter<C>(((i: A) => i instanceof C) as (i: A) => i is C);
```

requirement to always specify the type of the predicate could be annoying.
Thought since maybe it's sort of an edge case, and usually you'd use the `filter` without a type arg, maybe not that big of a deal :)


  (note: I've asked [a stackoverflow question on the issue](http://stackoverflow.com/questions/42744824/))

My issue with the current type signature for `concat` is that while it catches all the scenarios supported by the JS API, it's completely type-unsafe, including in its return type. The return type is the one that bit me, since it returns `Collection<any,any>`, if you don't cast after that, anything you'll do in a chaining call will compile without warnings, even if you use `noImplicitAny`.

The typescript compiler actually supports overloads and from my tests it actually picks up the more precise overload in my project and therefore gives me the precise return type of `Collection<K,V>`, giving me more type-safety.

I had also prepared another patch, with an extra overload:

```ts
concat(...values: { [key: string]: V }[]): Collection<any, V>;
```

with that extra overload (not really sure whether its definition is actually correct), and if you remove the original catch-all version, all the immutables tests actually pass, only one thing doesn't build:

```ts
let v2 = v1.concat(4, List.of(5, 6), [7, 8], Seq({a: 9, b: 10}), Set.of(11, 12), null);
```

and clearly no way to make that use-case type-safe. For the typescript bindings, it might actually make sense to enforce type-safety, and reject completely such scenarios. But if that's not an option, this PR already improves the situation at least on the return type, if not on type check of the parameters.
  I found that when using immutable.js v4, the TypeScript version needs to be higher than v.2.1.0, and need to use import instead of require  I just increased the immutables dependency to 4.0rc1 for my immutables-using typescript project. I'm getting build errors in node_modules/immutable/dist/immutable-nonambient.d.ts (full list at the bottom).

It seems to me the rename Iterable->Collection ( https://github.com/facebook/immutable-js/commit/c93bb75ef238371bf3003337c905b1eb31bc2045 ) was not done all the way for typescript bindings?

```
node_modules/immutable/dist/immutable-nonambient.d.ts(415,39): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(777,54): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(873,41): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(874,38): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(941,32): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(942,32): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1382,49): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1423,48): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1424,45): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1468,49): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1517,33): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1532,29): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1541,38): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1648,49): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1690,45): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1717,49): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(1796,40): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2035,30): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2036,34): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2049,22): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2050,22): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2061,48): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2062,52): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2066,44): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2070,44): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2075,22): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2076,25): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2077,24): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2078,28): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2083,25): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2084,25): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2127,8): error TS2304: Cannot find name 'Symbol'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2127,28): error TS2304: Cannot find name 'Iterator'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2221,45): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2284,51): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2307,44): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2349,56): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2374,40): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2415,51): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2441,38): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2509,49): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2566,45): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2666,51): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2670,8): error TS2304: Cannot find name 'Symbol'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2670,28): error TS2304: Cannot find name 'Iterator'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2694,44): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2886,56): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2890,8): error TS2304: Cannot find name 'Symbol'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2890,28): error TS2304: Cannot find name 'Iterator'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2916,40): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2960,51): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2964,8): error TS2304: Cannot find name 'Symbol'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2964,28): error TS2304: Cannot find name 'Iterator'.
node_modules/immutable/dist/immutable-nonambient.d.ts(2985,45): error TS2304: Cannot find name 'Iterable'.
node_modules/immutable/dist/immutable-nonambient.d.ts(3248,13): error TS2304: Cannot find name 'Iterator'.
node_modules/immutable/dist/immutable-nonambient.d.ts(3257,15): error TS2304: Cannot find name 'Iterator'.
node_modules/immutable/dist/immutable-nonambient.d.ts(3266,16): error TS2304: Cannot find name 'Iterator'.
node_modules/immutable/dist/immutable-nonambient.d.ts(3592,49): error TS2304: Cannot find name 'Iterable'.
```
 ok I understand. it does have a little minus for the user who's currently targeting es5, because AFAICT if you enable the es2015 lib, you let developers in your team use es2015 features, and your app will build, but it'll fail at runtime on environments not supporting the features:
https://github.com/frankwallis/plugin-typescript/issues/106

But yeah no way around it I guess, es2015+ is around and there is babel and so on.  It'd be great to have a method on `Collection`s that turns a `Collection<?T>` into a `Collection<T>` by filtering out `null` and `undefined` values.

You can trivially do this with `xs => xs.filter(x => !!x)` or something along those lines, but Flow isn't smart enough to infer the desired return type.

Currently we're doing this with a utility function, but it'd be nice to have it as a method so it can be called in a sequence of other chained methods.  I guess this is a typo :) just signed up the CLA. I guess the bot does not update that again  I saw this https://github.com/facebook/immutable-js/commit/0c12cea7376ace34feb6bfeb41d33f941b630c33 commit and think that this checks should be done also on developer side.

Also this PR should be updated after merge of #1140. > I think this might be too invasive. 

Agree. I thought it can be an overkill for a lib after I published PR.

We can keep only `pre-commit` hook and stale this PR until `fix lint` and `fix format` commits start to appear.

> what we really want is "pre merge" hooks where travis fills in.

I don't think that I understand what should go there  Hey. So I experimented with immutable and typescript.
So I have an idea how to make nested type safe immutable structures. And make typesafe mutations on it.
This here are some scratches.
```ts
import {Record, Map } from 'immutable';

class Y{
    x: string
}
class X {
    x: number
    c: number
}
class B {
    n: number = 34
    x: X
    y: Y
    z = Map<string, number>() as any as MyMap<number>
}
class A {
    b = IRecord(B)
    c: number = 12
}
interface MyMap<V> {
    [key: string]: V;
}

type IWrapper<T> = T & Wrapper<T>;

type Wrapper<T> = {
    set<K extends keyof T>(k: K, v: T[K]) : IWrapper<T>
    setIn<K extends keyof T, K2 extends keyof T[K]>(k: K, k2: K2, v: T[K][K2]) : IWrapper<T>
    setIn<K extends keyof T, K2 extends keyof T[K], K3 extends keyof T[K][K2]>(k: K, k2: K2, k3: K3, v: T[K][K2][K3]): IWrapper<T>
    setIn<K extends keyof T, K2 extends keyof T[K], K3 extends keyof T[K][K2], K4 extends keyof T[K][K2][K3]>(k: K, k2: K2, k3: K3, k4: K4, v: T[K][K2][K3][K4]): IWrapper<T>
   // .......
}
function IRecord<T>(t: {new() : T}): IWrapper<T> {
    const a = new t();
    const R = Record(a);
    const c = new R(a)
    return c as any as IWrapper<T>
}

const c = IRecord(A);
let c2 = c.set('c', 212)
let c3 = c2.set('c', 21232)
let c4 = c3.setIn('b', 'n', 1)
let c5 = c3.setIn('b', 'z', 'key', 12)
console.log(c, c2, c3, c4, c5)
```
Looks like the only requirement to declaring structures - don't forget to declare default values.
Do you like an idea?
Could it be merged to original immutable library in future after finishing it?
  See https://docs.travis-ci.com/user/deployment/script/ Also i suggest to add `tags: true` - so docs will be deployed only when new release is published.    Maybe this patch can be added to the flow typings as well?  The docs for Map::toObject() specify that:

"Throws if keys are not strings."

https://facebook.github.io/immutable-js/docs/#/Map/toObject

However, it does not throw for non-string keys:

```
const x = {};
const y = {};

const m = Map([[x, 11], [y, 22]]);

console.log(m.toObject());
//=> {"[object Object]":22}
```

Furthermore, it might not make sense to throw for all non-string keys - certainly keys with typeof "object" it is worth throwing, but for numbers, booleans, etc. which are consistently converted to strings, it would not make sense to throw.  This fixes many issues that were found in 0.21!  I think I said that `_: empty` works. Well, it no longer works. So I basically did a find and replace with `..._: []` which does work.

My Bad:(  Commented Stack.js data structure with description of each of the methods including the parameter types and descriptions and descriptions for the return (if there is one)  Hi,

I wonder why List don't have an alias of size : length. Arrays in javascript require require us to use "length" and immutable uses "size", with an alias, code could be compatible. I assume there's a reason, but maybe it's possible ? Do you think it would be a good idea ?

Thank you :)  Remove unused / upgrade old dependencies. Also add `ts-jest` and `npm-run-all`.
After this updates I will start working on #1111 > There's a bit too much happening in this PR. do you mind separating out the stuff unrelated to package.json dependencies and yarn.lock?

Yep. Sorry, I just can't stop sometimes. `dist/immutable.min.js` changed because of `uglify-js` update > Specifically the ts-jest changes are controversial and reduce test coverage, so I'd like to discuss those in isolation

Oh, it was recommended in jest [readme](https://github.com/facebook/jest#using-typescript) so i thought it's ok. 
  I'm glad I went through recent issues and saw a link to here. The comment in parenthesis is fixed in 0.21 (not remember when) but looks like class methods are still broken. I'll open an issue for this!

```js
function f(/* a */) {}
class X {
  f(/* a */) {}
}
```

outputs

```js
function f(/* a */) {}
class X {
  f /* a */() {}
}
``` Once https://github.com/prettier/prettier/pull/957 lands, 

```js
static of /*...values*/() {
```

will be normalized to

```js
static of (/*...values*/) {
```

so you'll just have to run prettier again on your codebase and it'll fix it. Can be closed now :)  Thanks for the real world usage. I filed a few issues on prettier repo for things we can improve!  Will this fix be available in a `3.x` release?  Hello,

when I install the latest version of Immutable from NPM, I get the 3.8.1 version which is somewhat outdated. Is there a chance that you will deploy a new version soon?

Thanks  1. Currently unit tests written partially in typescript and partially in javascript, personally - it's confusing. Is there any reason why it's like that?
2. Unit tests runs on built version only - before each test we have to run build. It's really hard to [test first](http://www.extremeprogramming.org/rules/testfirst.html). I understand why it's done like this, but since we're using stable tools (Rollup+BublÃ©) we can use source files to test?
3. Test tools still outdated. I'm using WebStorm, but it does not support `jest` so I tried to use Visual Studio Code with jest extension and it gave me "This extension relies on Jest 18+ features, it will work, but the highlighting may not work correctly." error. 

___

I stated working on #742 to make life easier for new contributors. (As for myself https://github.com/facebook/immutable-js/issues/806#issuecomment-284137939).

But now I'm struggling with testing my code.
____

Current status:

- [x] Lint tests (#1140)
- [x] Add tests for Typescript definitions (#1198)
- [ ] Run tests against `src` directory (depends on #1044) @leebyron thanks for explanation! I will dig more tonight. 

P.S. GJ with issues! This repo looks so lonely without you. >  just to bump up the version of Jest

Done and tested.

> Unit tests are written mostly in typescript because it's a two-in-one test, we're also ensuring the type definitions are correct. 

Now it's totally makes sense!

> I think it's important to maintain the tests as typescript when possible, and use plain JS tests only when explicitly testing something outside of the typescript coverage - it ensures we get good coverage.

We can do something like this:
1. `src/internal` - test non public code (like internal utils, collections), good for [test first](http://www.extremeprogramming.org/rules/testfirst.html) development.
2. `dist` - test public api (basically current approach).

> I would like to see improved is something similar to the flow type tests where comments can be inserted where static type check errors are expected.

It's doable, but I will start with typescript first cause I have more experience with it.

> to ensure the type definition files align with the source files. It also depends on a fairly major refactoring to actually ensure the src/ is valid ES2015 code

We also can add flow annotations to files (ofcourse start with @flow-weak). But I'm not sure is it's possible to generate `*.js.flow`  files flor `*.js` (like `*.d.ts` from `*.ts`)

____

## Roadmap:
1. Replace custom `jest` declarations with `@types/jest`
2. Modernize Typescript tests (maybe use `ts-lint`)
3. Use eslint in pure js tests.
4. ~~Create flowtype tests from typescript test.~~ Add dtslint tests. > What I meant was that the existing flow type tests have a // $ExpectError feature that's very useful for test writing and that feature would be a valuable addition to the existing typescript tests.

Oh, as I said before i'm not good at flow ðŸ˜…, I'll search for similar behavior in typescript tomorrow.

> Does eslint have a typescript compiler plugin? That would be a great way to unify them if possible

There are some solutions - [eslint-plugin-typescript](https://github.com/nzakas/eslint-plugin-typescript), [typescript-eslint-parser](https://github.com/eslint/typescript-eslint-parser). Both are very experimental so I never used them. >  flow type tests have a // $ExpectError feature that's very useful

Found it - [dtslint](https://github.com/Microsoft/dtslint#write-tests).  Awesome! Thank you for this :)  Thank you! Do you think this is the limit of where these flow definitions can get with current flow primitives?  ### What happened

Creating a list of lot's of small maps has significant overhead contrasted to native types. For significantly small maps (< 5 key/value pairs) the overhead can be as much as 10x native types.

### How to reproduce

[Codepen with a generation script](http://codepen.io/anon/pen/wJogjg?editors=0010). Tweaking `i` changes number of items in a list, tweaking `j` changes number of elements in a map.

For `i = 4000` and `j = 4` Chrome's heap snapshot shows a 10x difference in memory usage.

![image](https://cloud.githubusercontent.com/assets/22395836/23671505/8319cdd4-0339-11e7-9954-dc544f3ed8bf.png)

### Use case

I'm using maps to represent sparse arrays of tabular data, instead of the more conventional list of lists. Apologies in advance if there's a better fitting data structure that I should be using. Woops! Didn't make that clear, the codepen is referencing [3.8.1](https://cdnjs.cloudflare.com/ajax/libs/immutable/3.8.1/immutable.js) - will try to repro in master.  See #742  See #742, #1096 I didn't modify code to not create merge conflicts.

Preferred eslint rules marked as `warn`.

Run `npm run format && npm run lint:fix` to see the beauty.
  Do not forget to `yarn format` this after merge ðŸ˜Š > Some examples of rules that are broken pervasively in this codebase and are safe to turn off:

Done.

> I think the eslintrc should either turn things off or make them errors

Agree, I kept "worthy" rules as a `warn`s for discussion. Closing this from https://github.com/facebook/immutable-js/commit/bb2fbf1749a8dffc3efee3fc0033ba3d2457d252  See #742, #1096 Seems like `.travis.yml` can also be updated in favor to use better caching:
https://blog.travis-ci.com/2016-11-21-travis-ci-now-supports-yarn   - [x] yarn
- [x] remove jshint in favor of eslint
- [x] prettier
- [ ] transpile src with babel
- [ ] transpile docs with babel
- [ ] remove gulp in favor of npm scripts
- [ ] remove grunt in favor of npm scripts

See #742 And first problem.

 According to the [spec](https://tc39.github.io/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist)  - es6 classes can not be called as a functions.

Few solutions:
1. Make a breaking change and disalow `var map = Map()` syntax in favor of `var map = new Map()`.
2. Refactor all es6 classes to `Function.prototype` style.
3. Keep using `declassify` (but first - need to fix it for latest rollup).


 Done ðŸ‘. I'm closing this PR for now.  The key is to be able to save an immutable tree to a database while benefiting from the node sharing.

I have a big undo array, most of the items share almost everything. In the browser's memory it takes a small amount of memory - I want to get a string/binary form of that tree so it's size will be as close as possible to the size it takes in the browser.

Could this be possible in any way?

Thanks for this great project!  <!--
Found a bug?
`Immutable.hash() is not a function` - even though it is documented and exported, what is going on?

-->

### What happened

Would like to use `Immutable.hash()` to generate react keys is that a valid use case?
I found that `hashCode()` can be used instead on immutablejs data types, which might be just as good. Just wondering why the function is documented if it is not meant to be public, or why it isn't public?


### How to reproduce
```
import Immutable, { hash } from 'immutable';

Immutable.hash({1:1})
```
Thank you, and keep up the great work! Thank you for the clarification, looking very much forward to the next release! Is there a dev version / release candidate with which one can test this out? I tried switching to 4.0.0-rc.2 but I got too many typechecker errors and backed out.
Is 4.0 the next release planned? Or is there a 3.x-rc that could be used?
Thanks for your awesome work!

  In the following:
```
const s = [1, 2, 3];
Immutable.Seq(s).reverse().map(e => (console.log(e), e * 2)).reverse().toArray();
```
I expected the log to output 3, 2, 1 and the result of the call to be [2, 4, 6]. The result is correct, but the two reverses apparently cancel each other out.

I realize such are the perils of side-effects, but did not see any warnings about `Seq` expecting commutative transformations.

**Note**: I realize in this case I can just swap the second `reverse` and the `toArray` to get the desired ordering, but I still think this is a bug Well, it's not immediately apparent (to me at least) that this is due to laziness; though I guess that depends on your definition of "intermediate representation". To me I thought the chained calls were doing something like the following:

```
Immutable.Seq -> Sequence based on array s
.reverse() -> Sequence based on array s; iterating from the back
.map() -> Sequence based on array s; iterating from back; applying lambda
.reverse() -> Sequence based on array s; iterating from back; applying lambda; reversing
.toArray -> make it happen
```

In other words, I thought Seq as a sort thunk aggregator. I understand the principle, but I guess I had assumed `Seq` would materialize intermediate views to respect the order of chained methods. I think the current behavior is non-intuitive and should perhaps throw when it hits this problem (as a point of comparison, in Python `reversed` requires a materialized sequence and will throw if given an iterator)

At any rate, the behavior of `reverse` is inconsistent with that of `sort`, as the following example shows:

```js
Immutable.Seq.of([2, 'a'], [3, 'b'], [2, 'c'], [3, 'd'], [1, 'd'])
  .map((x, i) => (console.log('first:', x.join(',')), x.concat(i)))
  // Sort by first element; break ties by moving later element first
  .sort(([a1, _, a2], [b1, __, b2]) => (a1 - b1) || -(a2 - b2))
  .map(cs => (console.log('second:', cs.slice(0, 2).join(',')), cs.slice(0, 2)).join(','))
  .toArray();

/*
first: 2,a 
first: 3,b 
first: 2,c 
first: 3,d 
first: 1,d 
second: 1,d 
second: 2,c 
second: 2,a 
second: 3,d 
second: 3,b
*/
// Returns: [ "1,d", "2,c", "2,a", "3,d", "3,b" ]
```  So, I have a React app where everything is an Immutable object, rooted in the same place. I am thus using I.is() to know whether a tag needs re-rendering. However, it appears that you may end up with SUM(1 ...N) comparisons, where N = level of change to the tree. So for example, if you had something like:

````
A -> B -> C -> D -> E
   \ -> F -> G
````


A is the root of the tree, it splits off into two branches. Let's assume I change E to H. As such, that entire spine must become new as such:

````
A' -> B' -> C' -> D' -> H
   \ -> F -> G
````

So, if I had my react app:

````
<root A = { A }>

root's render:
   <B B = { B } />
   <F F = { F } />

etc.
````

In the componentShouldUpdate, it is doing a I.is() for each of the attributes. Initially, I.is(A, A'), This requires traversing every node, since you won't get a difference until E != H. The left node is easy, I.is(F, F) returns and no render is needed. HOWEVER, I.is(B, B') must retraverse nearly the entire spine (4 comparisons: B == B', C == C', D == D', E !== H). This causes a re-render, and thus now next tag I.is(C, C'), which is 3 comparions. And so forth. You end up with SUM(Level(change)) comparisons.

If we implemented a lazy Merkel hash on each node, the first comparison would of course requires 5 comparisons (all the way down until it found the difference), but then the next time through merkel !== merkel and we'd be done.   Fixes part of https://github.com/facebook/immutable-js/issues/705

The places I fixed were already documented w/ comments, I searched for "[K," and "(K," and filled in the appropriate stuff. The Iterable stuff wants two arguments to Iterable so I left them commented. I'm not sure what the fix for that is.

This should save you some typing anyway if you plan to do this. Thanks for looking at it. I'm not sure if I'm clear, did I do something wrong or just the infrastructure had a problem?  I would like to propose adding convenience methods for computing the mean and sums of numeric values in an `Iterable`:

* `mean()`
* `meanBy()`
* `sum()`
* `sumBy()`

While a similar proposal was rejected in #636 on the basis that same result could be accomplished via `.reduce()`, we already have similar convenience methods for `.min()`, `.max()`, and `.count()`, and the same argument could be made about those.

If there are no objections, I would be happy to propose an implementation in a PR.  `List.isList` shows a return type of `maybeList` in the documentation, but the examples clearly show it returning a `boolean`.  Immutable version 3.8.1

I must be doing something seriously wrong, or have missed something fundamental:

```
$ node
> var Immutable = require('immutable');
> var m = Immutable.Map();
> m.size
0
> m = m.update(42, "hello", (x => x));
Map {}
> m.size
0
```

Why wasn't "hello" inserted into the map? According to the [docs](https://facebook.github.io/immutable-js/docs/#/Map/update), update is:

> Equivalent to: map.set(key, updater(map.get(key, notSetValue))).

Let's try running that instead:

```
> m = m.set(42, (x => x)(m.get(42, "hello")))
Map { 42: "hello" }
> m.size
1
```

That seemed to work just fine! So why didn't "update" work? I've  investigated this a bit. The problem seems to be:

1. On [line 784](https://github.com/facebook/immutable-js/blob/master/src/Map.js#L784), it checks whether the new value is the same as the existing value. If it is, it considers no need to do anything. In this case, the existing value is the not-set-value. So it SHOULD still do something because the not-set isn't there yet.
2. On [line 98]( https://github.com/facebook/immutable-js/blob/master/src/Map.js#L98) if no value is set, it returns undefined. It should just return itself.
 If the current behavior is what is intended, then I must say it is very surprising.

I see that something is indeed mentioned under "updateIn", but the documentation for [Map.update](http://facebook.github.io/immutable-js/docs/#/Map/update) does not mention this. It should be mentioned there as well, and the line saying that update is

> Equivalent to: map.set(key, updater(map.get(key, notSetValue))).

should be removed, since it's clearly not true.

Thank you  (Sorry if this has already been asked for, I searched through but couldn't find any other GitHub issues)

I assume people are already familiar with these constructs, from other languages like Haskell, Scala or Elm.
Should they be added to Immutable.js? I suppose it's mostly a political/philosophical/strategical question. I imagine the implementation itself should be viable.

There are loads of articles online, enumerating all the reasons why monads are the greatest thing since sliced bread, I'm sure people are familiar with these too. There are also arguments about how monads play better together with type systems - Immutable.js is working quite well together with Flow and TypeScript nowadays, which certainly helps a lot.

Immutable.js is one of the (if not the) most widely used libraries to solve the immutability problem in JavaScript; there is a whole ecosystem around it, tools like Redux DevTools understand it, and so on. One could always point to one of the millions of npm libraries that implement monad data structures, use that one instead. But one would lose out on the ecosystem part of it - one of the benefits with Immutable.js is that many tools understand it.

Here are some things one would gain:

Having a Redux state tree with Option/Maybe monads, so you don't get runtime exceptions like `Cannot read property 'foo' of null`.

The Redux Devtools would actually understand what Maybe/Either constructs are, so it could show them in the UI in a way that makes sense (remember issues [like these?](https://github.com/gaearon/redux-devtools/issues/51)).

Performance optimisations could be made, for example if you have a map of Option/Maybe's of strings; if you use whatever monad library is out there, you will not benefit from Immutable.js' optimized equality checking, which would slow down operations like diffing a Redux state tree.

One other nice thing; compile-to-JS languages that only deal with immutable types (I'm thinking of Elm in particular here) could be set up to use Immutable.js as their core library, which would make it much easier to interop with JavaScript. One could imagine an Elm application that is compiled into a Redux/Immutable.js/React application, for example. > The Redux Devtools would actually understand what Maybe/Either constructs are, so it could show them in the UI in a way that makes sense (remember issues [like these?](https://github.com/gaearon/redux-devtools/issues/51)).

BTW, we managed to solve the UI representation, persisting and exporting for Redux DevTools extension, see [the release notes](https://github.com/zalmoxisus/redux-devtools-extension/releases/tag/v2.12.1). I like the suggestion though. > BTW, we managed to solve the UI representation

That's my point - since Immutable.js is so widely used, Redux DevTools spent time building a good integration with it ;-) Supposedly the same would apply for prospective Immutable.js monads.
  Small readability improvement  As said in #1050, the `Immutable.fromJS` current implementation to plain objects conversion, does not work as expected with objects with a custom `constructor` property. In reality the implementation just returns the same object passed as argument.

I fixed it changing the test for plains objects. Now it tests if the prototype of the object it's the same of `Object.prototype` (if the object has a different prototype it means that it is a class instance). Also, I added some tests cases for the solved problem.

I din't tested the performance impact, it will be more slow than the current implementation for sure. JSPerf points that the new implementation is about 45% slower compared to the current implementation Even that the new implementation is slower than the current one, it is quite fast (in practical terms the difference is just some milliseconds).
The performance test is floating between browsers, but the most modern implementations are really optimized.
JSPerf test: https://jsperf.com/plain-object-check Couldn't you check `value.constructor === Object || value.constructor === undefined` first and return early, falling back to checking the prototype only if it returns false? Then you would avoid the additional performance cost for most cases. I tested adding a condition for only when the object has a own constructor pass by the proptotype check, so the slow path will only hit when necessary, still 10x slower than the current implementation. Imho, in terms of performance, the "constructor is equal to" it's unbeatable.

JSPerf: https://jsperf.com/plain-object-check/6 (for some reason jsperf messed up with the order of test cases, the new implementation tests are tagged with `mixed check`)  If i write something like this:
```
interface SomeInterface {
  prop: any
}


const map = Immutable.Map<SomeInterface>({
  prop: 'hi'
})
```

and later want to convert it back using:
`const obj = map.toObject();`

My typescript IDE says that `obj` is of type `{ [index: string]: SomeInterface }` but why isn't it of type `SomeInterface` ? Am I getting something wrong or do I use `Map` the wrong way?
  I found that the definition of `Iterable#map` is missed in `immutable.js.flow`. But `Immutable.d.ts` has the definition for this method.

https://github.com/facebook/immutable-js/blob/29a5c55727c523b0d83c53c7ccd1032aaa579f49/type-definitions/Immutable.d.ts#L2155-L2158 Sorry, I has been a misunderstanding :bow:  I just noticed that the variance for collection types like List seem to be invariant in the flow declaration file:

https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow#L425

Since List is immutable what is the reason for not making it covariant?

That would mean instead of `class List<T>` why don't we have `class List<+T>`? 

This code illustrates this:

```javascript
let animals: List<Animal> = List.of();
let dogs: List<Dog> = List.of();

// why not allow this? 
animals = dogs;
```

I understand that there is a risk in doing the above for mutable data structures, but what is the problem here, as the data structure is immutable?

Have a look at this as a reference to variance in generics:
https://flowtype.org/docs/classes.html#polymorphism-and-type-parameter-variance

 Great, thanks a lot!  Following the issue #985
I'm testing this behavior on my project to deal with `merge` and `Record` on a redux store.

The goal is to not throw error when `set`or `merge` unexisting attribut(s) on Record to keep consistency with constructor, but also because it's hard to deal with `merge` for `Record` object.

```js
const MyRecord = Immutable.Record({ foo: null })
const record = new MyRecord({ foo: 5, bar: 10 })

record.toJS() // { foo: 5 }
record.set('bar', 10).toJS() // Error: Cannot set unknown key "bar" on Record
record.merge({ foo: 7, bar: 11 }).toJS() // Error: Cannot set unknown key "bar" on Record
record.remove('bar').toJS() // { foo: 5 }
```

Without this change, it's not easy to set new attributs from a data object. And it's useless to transform the data to `Record` before merging, because merging two `Record` mean only keep the second, without anything from the first.

```js
const MyRecord = Immutable.Record({ foo: null, bar: null })
const record1 = new MyRecord({ foo: 5, bar: 10 })
const record2 = new MyRecord({ foo: 8 })

record1.merge(record2).toJS() // { foo: 8, bar: null }
record2.toJS() // { foo: 8, bar: null }
```

(ps: I don't know why there is so much change in `immutable.js.flow`) â€¢ Why protect against misuse on `set` and `merge` but not on `constructor` and `remove` ?

â€¢ Why have a different behavior between `merge` and `set`, when currently, `merge` uses the Record's `set` function because this is the behavior on `Map`. I think having a different behavior between `set` and `merge` has more impact than changing the Record's `set.`  I noticed a lot of URLs were still on the old http which is no longer cool.
So I updated to https since it's 2017 :tada:

I also fixed a couple dead links for TypeScript ðŸ’¯   

<!--
Have a general question?

First check out the Docs: http://facebook.github.io/immutable-js/docs/
Or ask on Stack Overflow: http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
Stack Overflow gets more attention than this issue list, and is much easier to search.

Found a bug?

Please ensure you're using the latest version, and provide some information below.
-->

### What happened

When acting on a List of <=n elements, takeLast(n) creates a new List. This can, e.g., lead to unnecessary React rendering. Be nice if it could just return this.

I realize takeLast needs to operate on Iterables, so counting may not always be cheap, but at least when applied to a List it seems like this path could be optimized.
<!-- Shortly summarize what went wrong. Be sure to include not just what
  happened, but what you expected to happen as well. -->

### How to reproduce

foo = List([1, 2, 3])
bar = foo.takeLast(1000)
foo !== bar


<!-- Provide enough information that someone else could produce the same error.
  Share code or even better, send a Pull Request with a new failing test case. -->
 Ah, using slice(-1000) solves the problem  Looking at my build, currently Immutable takes up `139.14 KB`. I only use a few things from Immutable, so it would be nice to only pay for what I use.

# Proposed solution

Provide an `es6` build which compiles everything down except for modules, much like `react-router`, `reselect`, `redux`, etc. This way, the user can rely on their module bundler to perform tree shaking to only include what is neccesary.

Would this be possible to implement? Worth noting is that Immutable greatly benefits from gzipping, so the actual size comes down to 15.21 kb (with level 9 compression). 
That said I definitely think it would make sense to provide a build preserving ES modules for tree-shaking purposes (and/or the top-level API as individual CJS modules we could import selectively).  Both typings for flow and typescript returns an iterable when calling method inherited from iterable

Reproduced with Immutablejs v3.8.1 and flow 0.37.4

also reproduced for List on typescript

```{
  "resolution": "main",
  "tree": {
    "src": "https://raw.githubusercontent.com/alitaheri/immutable-unambient/3e5ef14e1677e2db90770b8263be889b71c4d444/typings.json",
    "raw": "registry:npm/immutable#3.7.6+20160411060006",
    "main": "immutable.d.ts",
    "version": "3.7.6",
    "name": "immutable"
  }
}
```  Printing out log in ngOnChanges of a component having inputs bound with @select immutables. It prints out a lot of times even when the app is idle.
<img width="755" alt="screen shot 2017-01-16 at 10 36 48 pm" src="https://cloud.githubusercontent.com/assets/19772006/21992577/fdd685fe-dc3c-11e6-85f2-07412961e5ec.png">
 I don't think this is an issue with immutable-js, rather with the way your app is using angular.  It would be useful to have access to the hash function in the case where one needs to ensure equality in custom objects. For example, if wanted to use `Immutable.Set()` to store a custom object, the set would contain duplicates:

```
class Principal {
  constructor(type, id) {
    this.type = type;
    this.id = id;
  }
}

const principals = [
  new Principal('type_0', 'id_0'),
  new Principal('type_0', 'id_0')
];

const principalsSet = Immutable.Set().withMutations((set) => {
  principals.forEach((principal) => {
    set.add(principal);
  });
});

principalsSet.size; // 2, but intend for it to be 1
```

In order for `Immutable.Set` to drop duplicate `Principal` objects, I would need to additionally implement `valueOf`, or both `equals` and `hashCode`, on the `Principal` class. Having access to `Immutable.hash()` would make this much easier.

I'm exposing the internal hash function along with the main `Immutable` API, however, it's worth considering exporting this as a standalone utility function.
 @leebyron I think that makes a lot of sense. Do you think this is should be extracted as another Facebook project, or would you consider relying on a 3rd party dependency, say if I were to create a new project with the current implementation of `Immutable.hash()` as the starting point? @leebyron any idea when there will be another `immutable-js` release? `v3.8.1` was almost a year ago, and there have been a lot of changes since then.  ### How to reproduce

```js
const Immutable = require('immutable');
const vm = require('vm');

console.log('OUT', Immutable.Iterable.isIterable(Immutable.fromJS({})) );

vm.runInNewContext(`
  console.log('IN', Immutable.Iterable.isIterable(Immutable.fromJS({})) );
`, {
  console,
  Immutable
}, {});

```

### Output

```
OUT true
IN false
```

### Expected output

```
OUT true
IN true
``` It all comes down to `value.constructor === Object` in [/src/fromJS.js#L39](https://github.com/facebook/immutable-js/blob/29a5c55727c523b0d83c53c7ccd1032aaa579f49/src/fromJS.js#L39). Outside of the VM it executes to `true` and inside the VM it executes to `false`.

I have tried adding `Object` to the sandbox, but it didn't change the outcome. Even this doesn't work:

```js
const vm = require('vm');

vm.runInNewContext(`
  const Immutable = require('immutable');

  console.log( Immutable.Iterable.isIterable(Immutable.fromJS({})) );
`, {
  console,
  require,
});

``` Interesting to note that the following evaluates to `true`:

```js
const vm = require('vm');

vm.runInNewContext(`
  console.log( test.constructor === Object );

`, {
  console,
  test: {},
  Object
});
```

which is expected, and would seem to indicate that Immutable.js plain object check should work too. Oh, I see:

```js
const vm = require('vm');

vm.runInNewContext(`
  console.log( {}.constructor === Object );
`, {
  console,
  Object
});

```

This evaluates to `false`. Thats explain why. Not sure how to fix it, though. @leebyron Is there any interest in getting this fixed?  I noticed this while making #1037. It seems like the changes that were merged in #1027 never got built.  I noticed that the documentation for the `insert`-method was missing a few characters. So I fixed it.  TypeScript supports non nullable types (optionally), and it's very
helpful to know when some function or method could return `undefined` as
well as a valid result.

This PR adds `| undefined` to the return types of the methods, which can
return `undefined` (like, `get`, `find`, etc). Hooray!!! Thanks!  ### What happened
Wrong type definitions on `Iterable.Map`, the mapper function have an undefined value which mess with typescript `strictNullChecks`, the source code is already fixed, it seems that the package was not published yet.

This is the code on `dist/immutable.d.ts` at line `1964` version `3.8.1`
```
    map<M>(
      mapper: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => M,
      context?: any
    ): /*this*/Iterable<K, M>;
```

### How to reproduce

- Install the package with `npm i -S immutable`
- Check the file `node_modules/immutable/dist/immutable.d.ts` at line `1964` 

It looks like the source is already fixed at [line 2155](https://github.com/facebook/immutable-js/blob/master/dist/immutable.d.ts#L2155) the only thing missing is the version increment and package publication  Looks like not that soon :\  I use Immutable.Record for building the state of my app. So, in one of my transformations I used `recordInstance.map()` call and faced with unexpected behavior: it returns undefined, though mapped immutable object has been expected. Plus, it mutates itself after each `.map()` call.

I described that issue in the simple example below:
```javascript
const {Record} = require('immutable');

const Circle = Record({ x: 20, y: 30, r: 50 });
const circleRec  = new Circle;

console.log( circleRec.map((item) => item * 2) ); // OUTPUT: undefined
console.log( circleRec ); // OUTPUT: Record { x: 40, y: 60, r: 100 }
```

Although, with `Immutable.Map` it works fine:
```javascript
const {Map} = require('immutable');

const circleMap = Map({ x: 20, y: 30, r: 50 });

console.log( circleMap.map( (item) => item * 2).toJS() ); // OUTPUT: { x: 40, y: 60, r: 100 }
console.log( circleMap.toJS() ); // OUTPUT: { x: 20, y: 30, r: 50 }

```

I also added [Live demo on jsbin](http://jsbin.com/tahiqiseja/edit?js,console).

As I investigated, the issue appears [there](https://github.com/facebook/immutable-js/blob/master/src/Operations.js#L802) (execution of `iter.constructor(seq)`: with `Map` it's ok, but with `Record` it returns nothing).  The call stack is next: `reify() -> mapFactory() -> map()`.

In my project I use `3.8.1`. Also tested on `3.0.0`, `3.7.6`. 
As platform used `Google Chrome  55.0.2883.95` and `node 7.0.0`.  Fixes the following typescript error:
All declarations of merged declaration 'Indexed' must be exported or not exported.

Typescript 2.1.4  ```js
//@flow
import type {Map} from 'immutable'

function test(state: Map<string, number>) {
    state. // can not get any tip
}

//@flow
import {Map} from 'immutable'

function test(state: Map<string, number>) {
  state. // yes, autocomplete tip
}

```

![image](https://cloud.githubusercontent.com/assets/533008/21467805/cef4acd0-ca34-11e6-8529-7acd614a9f7f.png)

![image](https://cloud.githubusercontent.com/assets/533008/21467808/de5c5ab0-ca34-11e6-8781-a0468a38dfd0.png)

```sh
# flow version
Flow, a static type checker for JavaScript, version 0.37.4
```

package.json
```javascript
{
  "name": "hello",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "dependencies": {
    "immutable": "^3.8.1"
  }
}
```

.flowconfig
```ini
[ignore]

[include]

[libs]

[options]

```  
[same question in stackoverflow](http://stackoverflow.com/questions/41299497/immutable-js-confused-when-use-get-method)


I'm using the immutable.js and redux in project, and I found an quite strange issue.

here is the code used in selector:
```
{
  dealDetail   : dealDetails.get(id.toString()).toJS(),
  dealTrackLog : dealTrackLogs.get(id).toJS()
}
```
First, the id is Number, in detail, I must pass string of id, and in trackLogs, on the contrary, it must be Number, otherwise will cause error, "cannot read property toJS() of undefined"

and I think the problem maybe in reducer, here is the code:

```
// dealDetailReducer
// const initialStateOfDealDetail = fromJS({})
let details = {}
action.data.details.map((detail) => {
  details[detail.id] = detail
})
return state.merge(fromJS(details))

 ...

// dealTrackLogsReducer
// initialStateOfDealTrackLogs = fromJS({})
if (state.get(action.data.id)) {
  // has id in state, update
  return state.withMutations(s =>
    s.update(
      action.data.id, 
      trackLog => trackLog.merge(fromJS(action.data.trackLogs))
     ) 
   )
}
// no id in state, just set, id : data 
return state.set(action.data.id, fromJS(action.data)
```

so, I'm hard to understand why and when to pass a Number/String ?
 @pannz Are you aware that `details[detail.id]` converts the id to a string? objects only take strings as keys.

Also, why are you creating a temporary `details` object at all? You could do:

```js
// dealDetailReducer
let res = state.asMutable()
action.data.details.forEach((detail) => {
  res = res.set(detail.id, detail)
})
return res.asImmutable()
```

Another thing, don't use `.map` for side effects. ;)  In the process of working on https://github.com/facebook/immutable-js/pull/1027, I found several flowtype inconsistencies. Some of these are easy fixes, others seem more complicated -- I can submit a PR to address some of these issues.

## Inconsistent Map / OrderedMap constructor behavior

This gives an error:
```javascript
// $ExpectError
stringToNumber = Map([['a', 'b']])
```
Whereas this does not:
```javascript
// FIXME: this should trigger an error -- this is actually a Map<string, string>
stringToNumber = Map(List.of(List(['a', 'b'])))
```
I'm not sure how easy this is to fix.

## Map / OrderedMap mergeWith definition is incorrect:

flow:

```javascript
mergeWith<K_,W,X>(
  merger: (previous: V, next: W, key: number) => X,
  ...iterables: ESIterable<W>[]
): Map<K,V|W|X>;
```

typescript:

```javascript
mergeWith(
  merger: (previous: V, next: V, key: K) => V,
  ...iterables: Iterable<K, V>[]
): Map<K, V>;
```

Note that in the flow definitions, `key` is a number, and an `iterable` is an array like object, whereas in the typescript definitions, `key` is of type `K` and an `iterable` is a map like object. 

I can submit a PR for this.

## Map / OrderedMap updateIn definition is incorrect:

flow:

```javascript
updateIn(keyPath: ESIterable<any>, notSetValue: any, value: any): Map<K,V>;
updateIn(keyPath: ESIterable<any>, value: any): Map<K,V>;
```

typescript:

```javascript
updateIn(
  keyPath: Array<any>,
  updater: (value: any) => any
): Map<K, V>;
updateIn(
  keyPath: Array<any>,
  notSetValue: any,
  updater: (value: any) => any
): Map<K, V>;
```

Note that the `updater` argument in flow is typed incorrectly. 

I can submit a PR for this.

## Map / OrderedMap flatMap weirdness

I expected this test to throw an error, but it did not:

```javascript
/**
 * FIXME: this should throw an error, it's an OrderedMap<string, string>
 */
orderedStringToNumber = OrderedMap({'a': 1}).flatMap((v, k) => (OrderedMap({ [k]: 'a' })))
```

Not really sure what's going on there, but I can probably look into.

## Flowtype definitions are looser than typescript definitions

This is more of an observation than an issue. Methods in the flowtype definitions that persist changes are allowed to introduce new types to data structures, whereas the same is not true of the typescript definitions. For example, this is the `Set#add` method in flow:

```javascript
class Set<T> {
  add<U>(value: U): Set<T|U>;
}
```

and this is the `Set#add` method in typescript:

```javascript
interface Set<T> {
  add(value: T): Set<T>;
}
```

So we can do the following in flow

```javascript
Set([1]).add('a');
```

but not in typescript. The above is also valid behavior in plain javascript for what it's worth, so the flowtype behavior seems closer to the javascript behavior than the typescript behavior.








 #1027 has been updated to address `mergeWith` and `updateIn` definitions for Maps and OrderedMaps. It seems there are still flowtype issues:

```js
let x: OrderedMap<string, string> = new OrderedMap();
x = x.update("hello", (x: any) => "hello"); // <- flow says it returns Map instead of OrderedMap
```

Immutable version: 3.8.1
  ### What happened

I wrote a super simple higher order function for `List.reduce` in order for reduce to be composable in a Ramda context:

```js
const reduce = reducer => initialReduction => list => list.reduce(reducer, initialReduction); 
```

With this style, if I wanted to concat a list of strings, according to the docs I'd simply have to explicitly give the `null` as `firstReduction`:
```js
const concatToString = reduce((acc, val) => acc.concat(val))(null);
```
From the [docs](https://facebook.github.io/immutable-js/docs/#/List/reduce):
> If `initialReduction` is not provided, ***or is null***, the first item in the Iterable will be used.

Turns out, that `null` (or `undefined` for what it's worth) is still passed as `initialReduction` which leads to unwanted behavior or even to errors. 

### Cause of error

https://github.com/facebook/immutable-js/blob/master/src/IterableImpl.js#L206

The check on L206 only takes the number of passed arguments into account, otherwise blindly assigns `reduction = firstReduction` (L209). 

### Possible solutions

a. Fix the docs
b. Fix the check
### How to reproduce

###### Premise
```js
const reduce = reducer => initialReduction => list => list.reduce(reducer, initialReduction); 
const addValues = reduce((a, b) => a + b)(null);
const concatValues = reduce((a, b) => a.concat(b))(null);

const listOfNumbers = Immutable.List.of(1, 2, 3)
const listOfStrings = Immutable.List.of('Hunter', 'S.', 'Thompson');
const listOfLists = Immutable.List.of(
  Immutable.List.of(1, 2),
  Immutable.List.of(3, 4),
  Immutable.List.of(5, 6)
);
```

###### Cases
```js
// Expected 6
// This works as expected as the numeric value of `null` is 0.
addValues(listOfNumbers);
// 6
```

```js
// Expected 'HunterS.Thompon' 
addValues(listOfStrings);
// 'nullHunterS.Thompon'
```

```js
// Expected 'HunterS.Thompon' 
concatValues(listOfStrings);
// Uncaught TypeError: Cannot read property 'concat' of null
```

```js
// Expected [1, 2, 3, 4, 5, 6] 
concatValues(listOfLists).toJS();
// Uncaught TypeError: Cannot read property 'concat' of null
```
  Unfortunately extending Set and Map caused issues with OrderedSet
and OrderedMap flow annotations. For example,

```
const orderedSet: OrderedSet<number> = OrderedSet.of(1,2,3);
```

was not valid, because `of` was incorrectly assumed to return a
`Set<number>` rather than an `OrderedSet<number>`.

The fix was to copy and paste the Set and Map flow annotations,
adjusting for OrderedSet and OrderedMap as appropriate.

See #1015 for more details.

----

Add negative flow test cases for OrderedSet and OrderedMap

One thing that came up as a result of this is that it seems
like the current flow definitions are laxer than typescript
definitions. For example, typescript's intersect looks like

```
intersect(...iterables: Array<T>[]): Set<T>
```

whereas flow's intersect looks like

```
intersect<U>(...iterables: ESIterable<U>[]): Set<T&U>
```

Also removed unnecessary OrderedSet overrides such as

  * delete
  * remove
  * clear

since we were already extending Set.

Also removed unused variables in immutable-flow tests. If there's a way to fix this without copy pasting flow annotations for Map / Set, I'm happy to update this PR as necessary. I made this PR because with immutable 3.8.1 I couldn't use `list.toOrderedSet` with flow. I'm currently working on false positives, will update this PR tonight or tomorrow. I've found a few edge cases that I'll add TODOs / FIXMEs with explanations. Updated PR with negative test cases, and removed some unnecessary variables / overrides. The flow definitions seems to be a little laxer than the typescript definitions, I'm not sure if this is by design, so I left it alone. To clarify on 

> The flow definitions seem to be a little laxer than the typescript definitions

I meant that methods that make persistent changes to the data structure in flow are allowed to introduce new types, whereas they are not allowed to introduce new types in typescript. For example, this is the `Set#add` method in flow:

```
class Set<T> {
  add<U>(value: U): Set<T|U>;
}
```

and this is the `Set#add` method in typescript:

```
interface Set<T> {
  add(value: T): Set<T>;
}
```

So we can do the following in flow

```
Set([1]).add('a');
```

but not in typescript. This behavior is also allowed in javascript for what it's worth. This seems like an inconsistency that I thought I'd bring up, and probably belongs in a separate issue.

 I made a gigantic issue here: https://github.com/facebook/immutable-js/issues/1029, let me know if you want me to split it up into mini issues. The `mergeWith` methods are included in #1029, but I'm working on that now and will update this PR with those changes. Updated with commits to add back the Import tests, and fix mergeWith and mergeDeepWith type signatures for Maps and OrderedMaps. I'm currently working on fixing `updateIn` for Maps / OrderedMaps in a separate commit. Updated with fix to `updateIn`  There is a [question](https://stackoverflow.com/questions/41222781/custom-fromjs-immutablejs-issue/41241727#41241727) in SO which talks about custom `fromJS`

`fromJS` is taken from the [Immutable docs page](https://github.com/facebook/immutable-js/wiki/Converting-from-JS-objects)

```
function fromJS(js) {
    return typeof js !== 'object' || js === null ? js :
        Array.isArray(js) ? 
            Immutable.Seq(js).map(fromJS).toOrderedSet() :
            Immutable.Seq(js).map(fromJS).toMap();
}

var output = fromJS({
    measurements: {
        length: 5,
        weight: 30
    }
}).toJS();
```
The above code outputs,

```
//output
[object Object] {
  measurements: [object Object] {
    0: undefined,
    1: undefined,
    2: undefined,
    3: undefined,
    4: undefined
  }
}
```

But it has to be printed as below.

```
[object Object] {
  measurements: [object Object] {
    length: 5,
    weight: 30
  }
}
```

What is wrong with the above custom `fromJS` function.

JSBin is [here](http://jsbin.com/zawixoj/edit?js,console)

**Note:** If we change the property `length` to `mLength`, it works as expected.
 @jaganathanb The problem seems to be here: https://github.com/facebook/immutable-js/blob/master/src/Seq.js#L359

`Seq` is creating an `ArraySeq` if the object passed has a property `length` that is a number, which seems to be bollocks. I'm not sure why it isn't using `Array.isArray`.

You could just write a version that doesn't use `Seq` for plain objects:

```js
function fromJS(x) {
  if (Array.isArray(x)) {
    return new List(x).map(fromJS)
  } else if (typeof x === 'object') {
    return Object.keys(x).reduce((acc, key) => (
      acc.set(key, fromJS(x[key]))
    ), new Map().asMutable())
  }

  return x
}
```

This is of course not optimal, but it should work. > @philpl "I'm not sure why it isn't using `Array.isArray`"

Because things like `NodeList`s and `arguments` aren't arrays, but are array-like. The issue here is that if there is a `length` property, to truly check if it is array-like the key of `length - 1` should be defined on the object:

```
var o = {
  '4': undefined, // array 'index' property, set to undefined 
  // to muck with simple checks like a[a.length - 1] != undefined. Muhaha.
  length: 5,
  width: 30
}; // o.hasOwnProperty(o.length - 1) === true, so object is truly array-like
``` @ShirtlessKirk True! I didn't think of those. In that case, I'll open a PR for the extra check.  Would love to do this:

```javascript
import { Map, Record } from 'immutable';
```

but at the moment, that's not spec compliant, since immutable only exports a default object.

Thoughts? Pardon if this has been discussed before and I just missed it. Thanks!

-----

Originally opened as #991, which got closed without discussion. Tests should be passing now.

I've checked in the rebuilt `dist` changes, as the contributing guide says to do, but this is creating a merge conflict. Please advise if I should revert.  Ah, duh. :) Updated.  I sort of expected this would happen. Is this normal? 

I just wished Immutable.setIn(...) was intelligent enough to keep track of cases where multiple parents reference the same object reference within the map tree, and update it along multiple paths up multiple parent chains. Unfortunately, this isn't the case.

http://jsfiddle.net/xryk992o/1/ This won't be expected behaviour as it goes against how persistent data structures work.

There's two problems with the example you provided; The first one is that `fromJS` just goes through an object or array recursively and converts it to an Immutable.js structure. This means that `d` will be already duplicated to begin with.

The second problem is that even if `d` in your structure would be the same shared Map, it would not update when `setIn` is called on one of its paths.

Consider what happens when you update a value in a persistent Map:

It will get the value at the specified key, then change that data, then set it on the Map, yielding a new instance of Map. Even though that `d` Map is shared, `setIn` will go down your path, it will create a new Map, then it will update the parent Maps. At no point does it know about the shared value. This happens because it's persisted, so we are not actually mutating it in-place.  Wrote assert functions for Immutable.List.foreach. Hope this is helpful!  I noticed that the contrast between the navigation links and the
background on the Immutable.js landing page is very subtle - by
using higher contrast we can increase usability and accessibility.

![screen shot 2016-12-07 at 1 56 57 pm](https://cloud.githubusercontent.com/assets/1114467/20994361/c3374ef4-bca4-11e6-924e-52deed33d563.png)

There is a handy tool for testing contrast for accessibility;
http://webaim.org/resources/contrastchecker/

![screen shot 2016-12-07 at 4 06 09 pm](https://cloud.githubusercontent.com/assets/1114467/20994381/dd11efc8-bca4-11e6-833e-6e3ecdf4dffe.png)

On the landing page the links are white on a light gray background.
We initially set the link color to match the main font color on the
page, which is #626466. However, this was not quite enough contrast.
Bumping the font color a step darker gave us #525455, which should be
very close but have a high enough contrast to be easily readable.

![screen shot 2016-12-07 at 4 10 10 pm](https://cloud.githubusercontent.com/assets/1114467/20994396/f441ef4a-bca4-11e6-94eb-2c4edcd7d6b1.png)

![screen shot 2016-12-07 at 4 09 04 pm](https://cloud.githubusercontent.com/assets/1114467/20994403/01bb0ddc-bca5-11e6-8822-571cbc3ef7c8.png)


The dark gray (#525455) on the light blue background was also not high
enough contrast, so we lightened the light blue background.

![screen shot 2016-12-07 at 4 26 21 pm](https://cloud.githubusercontent.com/assets/1114467/20994410/0b9af452-bca5-11e6-84ed-33d97fd679f9.png)

![screen shot 2016-12-07 at 4 27 01 pm](https://cloud.githubusercontent.com/assets/1114467/20994415/1222fa36-bca5-11e6-93ae-cb1e0d505934.png)

![screen shot 2016-12-07 at 4 27 12 pm](https://cloud.githubusercontent.com/assets/1114467/20994418/168804ea-bca5-11e6-9c0a-758edc1b8d1a.png)

We considered leaving the links white on the blue background, and only
changing them on the landing page where the background is light gray.
However, to get enough contrast with a white font the light blue
background would have to be darkened beyond recognition.

![screen shot 2016-12-07 at 4 52 22 pm](https://cloud.githubusercontent.com/assets/1114467/20994425/2243337c-bca5-11e6-845b-c60afd908e8c.png)

I'm open to adjusting this as needed, and thanks for your review!

More ideas:
- We could make the main copy font color match the nav links
- We could use a dark blue instead of dark gray for the nav links

PS - I don't know how to view the website locally, so I was just changing colors in the dev tools to test the effect. lmk if I can spin up the docs site locally to manually test this change.  `List.findIndex` returns `-1` if the item can't be found. If you then provide this index to `List.get`, it will return the last item! I would expect `undefined`. I expected parity with `[1,2,3][-1] => undefined`  Can someone explain this difference to me?

Defined this

		const JobCandidate = new Record({
			pk : null,
			user : null,
			offer : null,
			status : jobCandidateStatus.UNKNOWN,
			title : null,
			introduction : null,
			cv : null,
			dteCreate : null,
			dteUpdate : null,
		});

		JobCandidate.prototype.equals = function(that){
		  console.log('equals', this, that); //this is defined
			return !( (!this && !that) || (!this && that) || (this && !that) ) && this.pk === that.pk;
		};

		JobCandidate.prototype.hashCode = function(){
			return hash_int32array([this.pk]);
		};

Undefined this

		const JobCandidate = new Record({
			pk : null,
			user : null,
			offer : null,
			status : jobCandidateStatus.UNKNOWN,
			title : null,
			introduction : null,
			cv : null,
			dteCreate : null,
			dteUpdate : null,
		});

		JobCandidate.prototype.equals = (that) => {
		  console.log('equals', this, that);//this is always undefined
			return !( (!this && !that) || (!this && that) || (this && !that) ) && this.pk === that.pk;
		};

		JobCandidate.prototype.hashCode = () => {
			return hash_int32array([this.pk]);
		};
  Merging two different, but equal maps, result in the original map.
That's ok and expected.

`var x = IM.Map().set(1,2)`
`var z = IM.Map().set(1,2)`
`//to be true`
`x.merge(z) === x`

Merging maps, wich changes the orignal map meantime, but equals at the end results a new map.
That is unexpected.

`var x = IM.Map().set(1,2)`
`var y = IM.Map().set(1,3)`
`var z = IM.Map().set(1,2)`
`//should be true`
`x.merge(y,z) === x`
`//result is equal => true`
`x.merge(y,z).equals(x)`

The problems are MakeRef and SetRef. SetRef is irreversible when used once, so merging back to the original value dosn't reuse the original map.

Exists workarounds for this problem? I wouldn't consider this something you can bet on. Strictly speaking an operation on a persistent data structure should always yield a new instance. The refs are an attempt to optimise the performance. It tries to find out whether the value has actually changed. Now finding out whether the value has changed after two merges is actually an expensive operation.

Since the partials you are passing are merged separately, in-order, after the merge, there's no way comparing the changed values efficiently. I don't think this is something that should be worked around either.

In this case you're changing a value like this: `2 => 3 => 2`. Immutable.js shouldn't try to be slower to optimise this case, and this should really be something that you should take care of, if you really care about optimising this case. ;)  ### What happened
OrderedMap inherits its type from Map, which means the return value of all OrderedMap methods are of type Map.

One solution is to not inherit OrderedMap from Map and instead redefine all methods. I am hoping there is a more elegant solution using a `this` type, although a cursory attempt failed because this cannot be parameterized.

### How to reproduce
```js
[1, 2, 3]
  .reduce((acc: OrderedMap<number, number>, num: number) => {
    return acc.set(num, num)
  }, OrderedMap())
```
flow error:
```
Error:
  186:   }, OrderedMap())
            ^^^^^^^^^^^^ Map. This type is incompatible with
  184:   .reduce((acc: OrderedMap<number, number>, num: number) => {
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ OrderedMap
```
 I ran into the same issue with `OrderedMap` / `OrderedSet` / `toOrderedMap` / `toOrderedSet`. The easiest thing I can think of to fix this is to copy paste the typings of `Map` and `Set`, and adjust return values appropriately. Will have a PR up shortly.  I use the toJS() method to convert immutables back to raw JavaScript objects. For this I write the following sample code:

```
interface IImmutable1 {
    id: string;
    immutableList: Immutable.List<Immutable2>;
}

export class Immutable1 {
   private immutableRecord1 = Immutable.Record(<IImmutable1>{
       id: <string>null,
       immutableList: <Immutable.List<Immutable2>>null,
   });

   public getAsJavascriptObject(): IProductionRequestModelUpdate {
        return this._record.toJS();
    }
}
```

I use the immutable in the following way:
```
var immutableInstance = new Immutable1();
var rawObject = immutableInstance.getAsJavascriptObject();
```

The `toJS()` method converts the `Immutable.List<Immutable2>` to a simple array, **BUT** it does not convert the Immutable2 to a raw javascript object. So I will get an error, if I write the following instruction:

```
rawObject.immutableList[0].someProperty = "hello";   
// error, because rawObject.immutableList[0] is an Immutable and not a raw javascript object
```

What is the correct way to convert an immutable object which include a List of Immutables to an raw javascript object?

Thanks!! Can anyone confirm if this is a bug or expected behavior? Documentation suggests that toJS does deep conversion:

> All immutable Iterables can be converted to plain JavaScript Arrays and Objects shallowly with toArray() and toObject() or deeply with toJS().  It seems that this repo has quite a few issues, a ton of PRs, and no one official from Facebook working on it.

Is this the case? 

Thanks, (and hopefully) keep up the good work! Thanks for the response @leebyron!  From https://facebook.github.io/immutable-js/docs/#/List/get
```
Returns the value associated with the provided key, or notSetValue if the Iterable does not contain this key.
```

Yet, 
```
        const testing = Immutable.List([1, 2, 3, 100]);
        console.log(testing.get(-1)); // Outputs 100
```

I know this is correct behaviour based on #116 but these docs seem to read as though `-1` should return a `notSetValue`. 

Other documentation - such as for `set`, `delete` and `update` - makes this behaviour clearer.  Hi there,

I have encoutered what seems to be a bug in the sort() method for Lists. I have the following reducer in which listelements is a n immutable List. It handles a list of items from a restaurant and each category of dishes (pizzas, salads, drinks...) has a tipoOrden proprerty that I use to sort them (starting from 1). In this case, pizzas have tipoOrden: 2 and drinks tipoOrden: 6. 

When I have more than 7 items in the List, if I add a pizza it appears after the drinks. I have managed to solve this issue by changing the tipoOrden proprerty to a string (pizzas  have now tipoOrden:'2')

I guess that there might me some problem with sort()ing by a numerical proprerty and the item index.


```
    case ishopActions.ADD_TO_CART:
      return state.set('listelements', state.listelements.push(payload.element).sort(
        (a,b) => a.tipoOrden >b.tipoOrden
      ));
```
  ### What happened

When using `Map#setIn` and passing a `keyPath` that includes a numeric key, Immutable does not see that the key already exists and over-writes the `Map` at that `key`.

### How to reproduce

You can see this reproduced [here](https://jsbin.com/zarolikuqu/3/edit?html,js,console)
 +1 @horyd Have you found a workaround for now? I just made sure that whenever I was passing an integer through to `setIn` I made sure it was sent as a String instead :P  Maybe i am standing totally on the hose, but...

I would expect that shallowEqual from fbjs (https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js)
would return true for two equal immutable objects, but it does not.

Recompose (https://github.com/acdlite/recompose) provides a "pure"-hoc that uses shallowEqual, but i was suprised that my component rerendered, despite the fact that i used an Immutable.Map.

Is this the expected behaviour? Do I am missing something important here?
 +1, I'm running into the same issue when using `Immutable.Map` as a prop for a `PureComponent`.  I would like to suggest that this project is opened up to more contributors from the community.

The project has only ever really been developed by @leebyron but unfortunately he appears rather busy at the moment and unable to move the project forward. 

While the library may be considered feature complete there are a number of issues that have built up and been ignored. Many contain PRs that have also been ignored. 

I feel the project would be able to continue in a more healthy manner if it didn't depend on so heavily on a single person or organisation.

I understand this is a Facebook project but it has become quite a large project, important for many people. There are 15,556 stars at the time of writing.
 Thanks for considering this request. I'll do everything I can to help the process. As the person that created this issue I feel obliged to put myself forward but I hope more qualified contributors come forward.

Could you clarify your idea of the ecosystem? Are you proposing something like extensions to keep the core small and focused? It sounds like a good idea to me. I think this is a very feature stable library and the core of it should stay that way. 

Deciding the governance model will be important. Assuming people do step forward we'll need some agreement on how decisions are made so that it doesn't all fall on your shoulders, but also doesn't go away from your original vision entirely.
 There hasn't been a large number of people stepping forward as potential collaborators so I think the best thing is to convince some colleagues of yours, as you suggest.

I think the most immediate thing is just getting people to help with the large number of open issues and PRs and then we can see how it evolves from there.

  I have a general question and I did look around a bit before asking.

I really love Mori's zipmap operator (it allows to create a map from two arrays). I wasn't able to find a way to do exactly the same in one operation with Immutable.js. Is there anything similar? Is there a plan to add it? And I do know how to achieve the similar result using more than one step, but I love the verbocity of aforementioned zipmap. @leebyron How is this the same? ImmutableJS' `List#zip` provides a list of lists: 
```
var keys = ["foo", "bar", "baz"]
var vals = [1, 2, 3]
List(keys).zip(List(vals)).toJS() // => [ ["foo", 1], ["bar, 2], ["baz", 3] ]
```

`mori#zipmap`, on the other hand, provides an object/map:
```
var keys = ["foo", "bar", "baz"]
var vals = [1, 2, 3]
mori.toJs(mori.zipmap(keys, vals)) // => {"foo": 1, "bar": 2, "baz": 3}
```

https://jsfiddle.net/NeverwinterMoon/hbnzb2qq/

zipmap is very convenient for some cases in our code, but zip requires additional manipulations.  <!--
Have a general question?

First check out the Docs: http://facebook.github.io/immutable-js/docs/
Or ask on Stack Overflow: http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
Stack Overflow gets more attention than this issue list, and is much easier to search.

Found a bug?

Please ensure you're using the latest version, and provide some information below.
-->
### What happened

Unable to use a Map in a for..of loop in TypeScript because the iterator is not defined in the definition file.
### How to reproduce

``` ts
import {Map} from "immutable";

const m = Map({ a: 1 });

for (const [key, value] of m) {
    console.log(key, value);
}
```

Error

```
TSError: â¨¯ Unable to compile TypeScript
src/test.ts (6,28): Type must have a '[Symbol.iterator]()' method that returns an iterator. (2488)
```
 It's possible https://github.com/facebook/immutable-js/pull/942 would fix the issue but that PR has been unmerged for 3 months.
 Yeah, that was me actually - I've asked on twitter as well as I thought this was a very popular library but it seems to have died off. 
 +1 Can we get this fix in

@linusnorton @Strate  Could we merge #942  into here instead (in the _**types-2.0 branch**_, not master):
https://github.com/DefinitelyTyped/DefinitelyTyped/blob/36d40a63a05b5cb3413737fbdf7c9a2a26f211fd/immutable/immutable.d.ts
  Using Immutable@3.8.1, we accidentally passed in an array to Map.set, and see the inconsistent behavior as described in the following code:

```
var state = Immutable.fromJS({
  rootKey: {
    keyA: ['valueA']
  }
})
 state = state.set(['rootKey'], Immutable.Map()) // proper way is to use .set('rootKey')
console.log(state.toJS().rootKey) // empty object {}
console.log(state.get('rootKey')) // { keyA: ['valueA'] }
```

This creates mysterious bug and hard to debug.
We would expect either
1. an error/warning message when the the first argument of set is an array
Or
2. state.toJS().rootKey is the same as state.get('rootKey')
  <!--
Have a general question?

First check out the Docs: http://facebook.github.io/immutable-js/docs/
Or ask on Stack Overflow: http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
Stack Overflow gets more attention than this issue list, and is much easier to search.

Found a bug?

Please ensure you're using the latest version, and provide some information below.
-->

Searched around, and didn't find very much online. I found these, but nothing related to Immutable.
- https://github.com/brianc/node-postgres/issues/1062
- http://stackoverflow.com/questions/37997665/node-js-6-and-anonymous-objects
### What happened

I attempted to use the `fromJS` method to deeply convert a javascript object into an Immutable object. When the object contains a value that is labeled as "anonymous", the `fromJS` seems to skip trying to convert the value.
### How to reproduce

``` js
const obj = {
  child1: anonymous {
    id: '59869fcb-57af-437b-b5ad-a6bfcdec2f0f',
    createdAt: '2016-10-24T01:14:19.777Z' 
  },
  child2: []
}

const newObj = Immutable.fromJS(obj)

// result
console.dir(newObj.get('child1', { depth: null, colors: true })

 anonymous {
    id: '59869fcb-57af-437b-b5ad-a6bfcdec2f0f',
    createdAt: '2016-10-24T01:14:19.777Z' 
  }

console.dir(newObj.get('child2', { depth: null, colors: true })
List {
  size: 0,
  _origin: 0,
  _capacity: 0,
  _level: 5,
  _root: undefined,
  _tail: undefined,
  __ownerID: undefined,
  __hash: undefined,
  __altered: false }
```

As an interim solution, I serialize+deserialize the object with `stringify` and `parse` before passing it to the fromJS function. Obviously this solution blows, 
   Woops...didn't read too carefully. Closed.
  It seems that the Record type is completely under documented. Both in the documentation and flow files.

Since the Record type is an extension of the Map type (contains `getIn`, `hashCode`, etc.) I think this should be better documented to avoid confusion.
 I've run into this as well when using Flow. I've yet to find a good way of typing immutable objects the same way one can type the shape of plain JS objects.
 @iansinnott `Immutable.Record` (as opposed to `Immutable.Map`) is completely describable by Flow.

```
type MyRecord = Immutable.Record<{ id: number, name: string }>;

const MyRecord = Immutable.Record({ id: 0, name: undefined });
```

The problem is that while the Immutable declaration declares it as an Immutable.Record type it doesn't extend the Map type.
 Yeah I think we're talking about the same thing. It becomes an issue because although the shape of the record is typed it doesn't have the `get`, `getIn`, etc, methods which one usually uses. So flow ends up throwing invalid errors.
  Hello `immutable-js` team. Being currently designing a `Graph` data structure for JavaScript, I am trying to gather inspiration from a lot of sources and this library is definitely a fine one.

I see that the `size` member of `immutable-js` collections seems to be mutable. So I was wondering what were the reasons you did not choose to "protect" the member through a getter or else or even used a method returning the information. Just asking because I am pondering all those solution for the `order` and `size` of my graph and was wondering how you made this design choice.

Have a good day.
  Thank you for the amazing work on this project!
 @lacker Definitely not abandoned. I also can't re-open the issue since I'm not a maintainer on the project.

Having said that, can you give an example of how the other flow types are being tested? I took a cursory glance and didn't see anything. Thanks @lacker! Must have missed those when I looked before. Will update the PR soon and @ mention you when it's good to go. I'm currently working on a PR that wound up addressing this issue while trying to fix the flowtype definitions for `toOrderedMap` and `toOrderedSet`. See https://github.com/facebook/immutable-js/pull/1027 @howardjing Nice! I'll close this one in favor of your changes  ### What happened

When i use toIndexedSeq() or valueSeq() is always returns one more object.

`console.log("=========>", props.targets.toJS(), props.targets.toIndexedSeq().toArray())`

=========> Object {0: Object} [Map, Map]

My question is why returns 2 Map objects when must be only 1
  I find myself often checking whether variables are `null` or `undefined` before converting immutable objects to JS:

```
let category = page.get('category')
if (category !== null) {
    category = category.toJS()
}
```

I think shorthand for this would save a lot of lines of code. Something like:

```
const category = page.getJS('category')
```

Thoughts?
  A move function would be nice.
I've tested something like this : 

```
Immutable.List.prototype.move = function( fromIndex, toIndex){


  return this.splice(fromIndex, 1)
          .insert(toIndex, this.get(fromIndex));

}
```
  Would love to do this:

``` javascript
import { Map, Record } from 'immutable';
```

but at the moment, that's not spec compliant, since immutable only exports a default object.

Thoughts? Pardon if this has been discussed before and I just missed it. Thanks!
  Expose the `compareWith` function that allows you to set a custom function to use for `is()` comparison when comparing non Immutable objects as opposed to `equals()` or setting it to `null` to force strict object equality.

This solves this: https://github.com/facebook/immutable-js/issues/814

And any other situation where you don't want `equals` to be used on your objects. It does not change the behaviour of Immutable collection comparison nor does it cause any breaking changes to existing code. As the tests show.
 @lacker It is not pure to speak but then again neither is the default of using `.equals()` if it exists on the item. Which is the whole reason this needs to exist because sometimes you are using items that you don't control the `.equals()` function for. You can't override it because X library expects a certain behaviour from it.

This is still not pure with or without `compareWith` its just `compareWith` lets you work around the side effects if you need to. I am happy for another solution but nothing else is being suggested.

In short this is just a fix around the already un pure behaviour which has causes side effects. I'm with @georeith on this one. `equals()`'s current behavior is causing loads of problems for me as well, in terms of working with other libraries which also expose an `#equals()` function.  ### What happened

Getting this with Flow 0.33

``` js
 11: Immutable.Map().equals(Immutable.Map());
                            ^^^^^^^^^^^^^^^ Map. This type is incompatible with
 45:   equals(other: Iterable<K,V>): boolean;
                     ^^^^^^^^^^^^^ Iterable. See: node_modules/immutable/dist/immutable.js.flow:45
```

.flowconfig:

```
[ignore]
<PROJECT_ROOT>/node_modules/fbjs/.*
<PROJECT_ROOT>/node_modules/npm/.*
<PROJECT_ROOT>/node_modules/react-side-effect/.*
<PROJECT_ROOT>/node_modules/react-timeago/.*
```
### How to reproduce

``` js
const Immutable = require('immutable');
Immutable.Map().equals(Immutable.Map());
```

Should not be an error since Map extends KeyIterable which extends Iterable
 Same thing happens for list. I'm guessing the declarations for `Map` and `List` don't extend `Iterable`.

Reproduced with Flow v0.32.0.
 Is it because of mixins?

Flow inheritance:

```
_Iterable <- Collection (mixins KeyedIterable) <- KeyedCollection <- Map
_Iterable <- Iterable <- KeyedIterable
```
 Reproduced with Immutablejs v3.8.1 and flow 0.37.4

also reproduced for List on typescript 
```{
  "resolution": "main",
  "tree": {
    "src": "https://raw.githubusercontent.com/alitaheri/immutable-unambient/3e5ef14e1677e2db90770b8263be889b71c4d444/typings.json",
    "raw": "registry:npm/immutable#3.7.6+20160411060006",
    "main": "immutable.d.ts",
    "version": "3.7.6",
    "name": "immutable"
  }
}
``` ```List().equals(List())```

Flow: List. This type is incompatible with Iterable.


```
    "flow-bin": "^0.36.0",
    "flow-typed": "^2.0.0",
    "immutable": "^3.8.1",
``` @leebyron Do you think there could be a `3.8.2` release with this fix, as well as the ["default import" issue](https://github.com/facebook/immutable-js/issues/854)?

I tried out the latest `4.0.0-rc.2`, but I ran into some different problems with types. It would just be great if I could get flow working at 100%. Also I'm new to flow, and I just discovered that you can add a `$FlowFixMe` comment to ignore errors:

```js
// $FlowFixMe
import Immutable, { Map } from 'immutable'

// ...

// $FlowFixMe
if (map.equals(otherMap)) ...
```

Hopefully that will help any other perfectionists who want to go from 99.999% to 100% :)  I'm using React-Native and trying to create an equals functions for a Record like so:

```
Post.prototype.equals = (that) => !( (!this && !that) || (!this && that) || (this && !that) ) && this.id === that.id;
```

However, this is compiled to

```
Post.prototype.equals = (that) => !( (!_this && !that) || (!_this && that) || (_this && !that) ) && _this.id === that.id;
```

Note the _this. However, runtime _this is undefined and this is not. And so, I get an undefined error. This is solved by using function instead of arrow functions. Am I doing this wrong?
  Adds vanilla JS objects to flow typings of `Immutable.Map`'s `mergeIn` & `mergeDeepIn`.
 @alexfedoseev This repo is pretty much dead. I created a [PR](https://github.com/flowtype/flow-typed/pull/401) in flow-typed to add flow definitions for immutable there. 

My fork is [here](https://github.com/wokalski/flow-typed/tree/immutable-definitions). Feel free to submit a PR with your changes there.
 @lacker @wokalski Hey guys, sorry for being quiet, I stopped visiting this PR after some time and missed the activity here as my gh became too noisy these days.

According to [this comment](https://github.com/facebook/flow/issues/1996#issuecomment-230919868) serving shadow files w/ typings is still the way to go, so I guess this PR still makes sense.

AFAIU this PR is currently blocked by https://github.com/facebook/immutable-js/pull/878, let me know if I misread something and let me know what & when needs to be done here to get this merged. Thanks! @lacker Ok! I'll look into this on weekend ðŸ‘  @lacker @wokalski All done. 

One note: it's not related to this PR, but when I run `jest` on my local branch, it throws: https://cl.ly/iPtb
Possibly similar issue: https://github.com/facebook/react-native/issues/7802#issuecomment-235718897

 > I'm a bit confused. The diff shows that my changes are reapplied. Could you rebase the PR against current master? Possibly your fork's master is probably behind

@wokalski I think I rebased everything against master (flow tests weren't in my initial fork), let me check it one more time. > If you look at this file and the contents of the PR, you can see that something is off. Maybe conflict resolution gone wrong?

@wokalski That's weird, there was conflict only in `dist/immutable.js.flow`, which is generated file and it's regenerated anyway. Should I take contents of [this file](https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow) and just reapply my changes? @wokalski Just pasted contents and I see only my changes in diff: https://cl.ly/iPzf @wokalski Np, I replied to comments ðŸ‘  @wokalski Comments addressed. Also I updated `$ExpectError` regex: now it's possible to add comments to it ([example](https://github.com/facebook/immutable-js/pull/987/commits/2afb113e988e6a8149216bb95099f7e03915755b#diff-167148588528b5fa451dc535e9c29037R237)).

/cc: @lacker   ### What happened

Record keys seem to be enforced only on `set`, not during initialization (see steps below). I'd prefer it to not throw and/or you could configure whether or not it throws an error, but I found the inconsistency weird. Here's my use-case:

I'm using Records to store data returned from an API in a normalized store. If a record doesn't exists, I create one. If one does exist, I merge the data into the existing record. If the API has added keys that my client app is not aware of, on initialization everything works (just ignores the keys it's not aware of) but on the merge will throw.

As per [this dicussion (#573)](https://github.com/facebook/immutable-js/issues/573#issuecomment-131736533), the commenter says:

> Records are only meant to be used if you want to enforce a certain schema for your data while providing defaults when removing a key.

I'd disagree. For me, the enforcement of keys has actually caused more headache than benefit. I use Records so that I have the benefits of immutable data while still being able to use `.` access and destructure in a sane way throughout my app without needing to call `get` everywhere.

Thoughts?
### How to reproduce

``` node
$ node
> var Immutable = require('immutable')
undefined
> var MyRecord = Immutable.Record({ foo: undefined })
undefined
> var record = new MyRecord({ foo: 5, bar: 10 })
undefined
> record.toJS()
{ foo: 5 }
> record.set('bar', 10)
Error: Cannot set unknown key "bar" on Record
    at Record.set (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:3690:15)
    at repl:1:8
    at sigintHandlersWrap (vm.js:22:35)
    at sigintHandlersWrap (vm.js:96:12)
    at ContextifyScript.Script.runInThisContext (vm.js:21:12)
    at REPLServer.defaultEval (repl.js:313:29)
    at bound (domain.js:280:14)
    at REPLServer.runBound [as eval] (domain.js:293:12)
    at REPLServer.<anonymous> (repl.js:513:10)
    at emitOne (events.js:101:20)
```
 I just declare all the keys I need upfront. It forces me to think hard about the schema and you can build a simple helper function very easily.

``` js
> const makeSchema = (...rest: string[]) = rest.reduce((s, v) => Object.assign(s, {[v]: undefined}), {})
> var MyRecord = Immutable.Record(makeSchema('foo', 'bar'))
> var record: Record<{foo: number, bar: number}> = new MyRecord({ foo: 5, bar: 10 })
> record.set('bar', 10)
```
 I would do this, however I'm not in control of the schema since I'm using data from a third-party API. Adding new fields to an API response is generally considered backwards compatible since 99% of the time they will just be ignored. In this case, however, they will cause the code to throw.

To better illustrate my use-case, imagine I'm using an API and I know the response includes the `foo` field. In a recent API update, they started also returning the `bar` field:

``` js
$ node
> var Immutable = require('immutable')
undefined
> var MyRecord = Immutable.Record({ foo: undefined })
undefined
> var apiData = { foo: 5, bar: 5 }
undefined
> var record = new MyRecord(apiData)
undefined
> record.toJS()
{ foo: 5 }
> var updatedApiData = { foo: 10, bar: 10 }
undefined
> record.merge(updatedApiData)
Error: Cannot set unknown key "bar" on Record
    at Record.set (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:3690:15)
    at mergeIntoMap (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:1960:22)
    at /Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:3018:36
    at ObjectSeq.__iterate (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:420:13)
    at KeyedIterable.mappedSequence.__iterateUncached (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:3017:23)
    at seqIterate (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:606:16)
    at KeyedIterable.Seq.__iterate (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:276:14)
    at KeyedIterable.forEach (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:4383:19)
    at /Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:1963:19
    at Record.Map.withMutations (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:1355:7)
```
 I also think it is a little inconsistent that error is thrown ~~only on `merge`~~ on `merge` and `set` but not during initialization .

To overcome this issue, I'm doing this hack:

``` js
...
const updatedApiData = { foo: 10, bar: 10 }

record.merge(new MyRecord(updatedApiData))
```

But I'm not sure if it is the best approach. Maybe some function which filter properties from `apiData` before merging would be a better idea?
 Yeah, my above solution is stupid. It resets keys, not provided in `updatedApiData` to initial value.
Currently I'm filtering unwanted keys before merging them.
 I think I actually like the current behaviour. If your API endpoint returns too much data and you simply stuff it into a `Record`, then `Record` will quietly lop off all the extra data you don't need. If you knew you needed it, then you would put it in the spec, no?

@jcarbo  [Your example](https://github.com/facebook/immutable-js/issues/985#issuecomment-254020305) doesn't make sense to me. If the API starts returning more data, and you want to start using that data, why can't you update the `Record`? When would you be in control of the code that uses the `Record`, but not the `Record` definition?

If the Record definitions are maintained by the API-creator, then the user just needs to update his lib. If the Record definitions are created by the user, then he needs to update the Record before he can start using the updated API. 

The only scenario I can think of where this would be a problem is if there are 3 parties are involved: the API-creator, the lib maintainer, and the end-developer. @mnpenner - I can (and have been) updating the record... after realizing that some unrelated, non-breaking API update has broken my app. Here's a scenario:

### Initially
```
$ node
> let Immutable = require('immutable')
> 
> // GET /api/user
> let apiData = {
...   first_name: 'John',
...   last_name: 'Smith'
... }
> 
> // Record in my app
> let User = Immutable.Record({ first_name: undefined, last_name: undefined })
> 
> // Initialize a user
> let user = new User(apiData)
> 
> // Update a user
> user.merge(apiData)
Record { "first_name": "John", "last_name": "Smith" }
```

### API adds a field

This is a backwards-compatible change. An existing application will just be unaware of the new field and just ignore it. However, using records will cause a crash.

```
$ node
> let Immutable = require('immutable')
> 
> // GET /api/user
> let apiData = {
...   first_name: 'John',
...   last_name: 'Smith',
...   company: 'Smith Co.'
... }
> 
> // Record in my app
> let User = Immutable.Record({ first_name: undefined, last_name: undefined })
> 
> // Initialize a user
> let user = new User(apiData)
> 
> // Update a user
> user.merge(apiData)
Error: Cannot set unknown key "company" on Record
    at Record.set (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:3690:15)
    at mergeIntoMap (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:1960:22)
    at /Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:3018:36
    at ObjectSeq.__iterate (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:420:13)
    at KeyedIterable.mappedSequence.__iterateUncached (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:3017:23)
    at seqIterate (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:606:16)
    at KeyedIterable.Seq.__iterate (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:276:14)
    at KeyedIterable.forEach (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:4383:19)
    at /Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:1963:19
    at Record.Map.withMutations (/Users/jeffcarbonella/Documents/contactually/frontend/node_modules/immutable/dist/immutable.js:1355:7)
>
```

This is a simple example, so you could theoretically filter out undeclared fields. However, for me this is occurring during a `deepMerge` with nested records so that's really not a tenable solution. @jcarbo Oh..okay, I see the problem now.

That's kind of a tough one. On one hand, I agree with you that that should just work, but on the other hand, if fields quietly go missing, we would want to know about that, no?

What about `user.set`? Should that throw or not? If you're setting fields one-by-one from API data for some reason, then you would want it to quietly do nothing, but if you're explicitly trying to set a field based on some business logic, then you would want to know when you messed it up. But in this scenario, you could actually try/catch it if you needed to, but that's not true of `merge` (due to partial success/failure).

I think we might need some options or additional methods to handle this. I have the same issues with the same use case as mentioned above.
@jcarbo: Did you end up finding a good solution to this? Thanks @briantobo - I wound up replacing `mergeDeep` with my own recursive `mergeWith`.

Here's the code:
```js
const isMap = Immutable.Map.isMap
const isRecord = (a) => a && isMap(a._map) // There's no built-in `isRecord` :|
const isObject = (a) => typeof(a) === 'object'

function safeMergeDeep(a, b) {
  if (isRecord(a) && isObject(b)) {
    // Based on merge functionality in Map which record inherits:
    // https://github.com/facebook/immutable-js/blob/master/src/Map.js#L756-L778
    return a.withMutations(
      (record) => Immutable.fromJS(b).forEach(
        (value, key) => { record.has(key) ? record.set(key, value) : record }
      )
    )
  }

  return (a && a.mergeWith) ? a.mergeWith(safeMergeDeep, b) : b
}
safeMergeDeep(user, apiData)

// Note based on the examples above the following will still
// fail because you won't have a reference to `user`
// to know it's a record. This isn't an issue in my case since
// the record merging is happening within a nested map but if
// it were an issue you'd just need to use the
// functional style: safeMergeDeep(user, apiData)
user.mergeWith(safeMergeDeep, apiData)
``` Experiencing the same issue.

Even if you have the full controls of the schema on yours app and api ; adding an attribute on an existing ressource api that break the app is extremely harmful.

The app that consumes the api can be desynchronized with the api : browser cache, service workerâ€¦ Or more eloquent example : a (react-)Native app. The app the end-user uses isn't always up-to-date, that's why we version api and we need to think about it since v1 for a native app.

But, adding an attribute or nested ressource to an existing object isn't, usually, a breaking change. It's only ignored by old apps versions.
The actual behavior of `set` and `merge` of `Records` (that is inconsistent with Record initialization) is really annoying.

I'll also prefer that `set` and `merge` ignore unknown attributes. Just like on the `Record` initialization.  The way the docs for Immutable.js are written is difficult to understand for many JS developers.

Can you explain the nomenclature used so we can all more easily decipher the documentation and put this framework to more effective use?
 Yo are most welcome to contribute. :)
 I'd love to. My point is, I don't understand the docs to begin with and therefore can't contribute.
 Same problem. It looks like C++/Boost. It's just not expected for a dynamically typed language and it makes it harder to parse. In some (most?) cases i have not the slightest idea what is meant, and there are few usecases or examples. I wish it would be documented as virtually all other js projects are, like lodash, etc. I really wonder, why was this even necessary?
 I totally agree, and also there are no real world example that you can wrap your head around them.

I really like Underscore's documentation and subsequently, lodash and it helped understand both how the library works and made me better developer.
  <!--
Have a general question?

First check out the Docs: http://facebook.github.io/immutable-js/docs/
Or ask on Stack Overflow: http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
Stack Overflow gets more attention than this issue list, and is much easier to search.

Found a bug?

Please ensure you're using the latest version, and provide some information below.
-->
### What happened

I tried using `Map.of` in a flow-typed project, but got an error saying that the property `of` was not found in `Map`

<!-- Shortly summarize what went wrong. Be sure to include not just what
  happened, but what you expected to happen as well. -->
### How to reproduce

I'm using flow v3.8.1, but the definition is also missing in master.

``` javascript
const { Map: IMap } = require('immutable')
const foo = IMap.of('foo', 'bar')
```

Results in the following flow error:

```
 62: const foo = IMap.of('foo', 'bar')
                      ^^ property `of`. Property not found in
652:   Map,
       ^^^ statics of Map. See: node_modules/immutable/dist/immutable.js.flow:652
```

<!-- Provide enough information that someone else could produce the same error.
  Share code or even better, send a Pull Request with a new failing test case. -->
  It has become clear to me that `Seq.reduce` is not lazy. Currently reduceRight is simply the reverse of reduce. However, I read that in reduceRight _can_ be lazy: https://en.wikipedia.org/wiki/Fold_(higher-order_function)#Evaluation_order_considerations. Perhaps it is worth while to implement this.
 This concept works really well for languages like Haskell where recursion and lazy evaluation are built-in principles, but isn't quite so effective for languages without such optimisation. To write a (crude) right fold in JS:

```
reduceRight = (f, acc, [x, ... xs]) => x == undefined ? f(x, reduceRight(f, acc, xs)) : acc
```

In the `f(x, reduceRight(f, acc, xs))` call, the entire remainder of the reduction must be calculated to do this step because parameters are always evaluated before calling. You could get round this with some generator trickery, _but_ it isn't guaranteed that your folding function lends itself to laziness, so this isn't going to work in all cases and certainly won't look much like a right fold.

tl;dr - right reduction is _super_ cool in lazy languages, and not so cool in eager languages.
 So... why is it there?

I saw in Clojure they introduced 'reduced'. I guess you could add the same trick in JS, by evaluating an extra check function and exiting when it returns true. I don't see how a generator function could help, since that's already your input, right? @leebyron fair enough. The proposed kind of lazyness is outside the JS paradigm in any case, as it would yield values that need to be processed in a specific way.  @leebyron Thanks for Immutable! I've checked out numerous Stack Overflow questions, tutorials, and blog posts but can't find an answer to this question, which feels like it should be simple to resolve. I have a deeply nested object that looks like this: 

```
let options = fromJS({
      projects:{
        id: 1, 
        selected: true,
        option: "projects",
      },
      collections:{
        id: 2, 
        selected: true,
        option: "collections"
      },
      organizations:{
        id: 3, 
        selected: true,
        option: "organizations"
      }
    })
```

What I would like to do is change every selected value in this Immutable object to false. I've tried this to no avail: 

```
let options = this.state.options
options.forEach((val, option) {
  let option = option.get(option)
  let falseOptions = options.setIn([option, "selected"], false)
})

this.setState({
  options: falseOptions
})

```

This does not work as expected. Only the last object in the options object gets it's state changed. What is the best way to update multiple immutable values at once, and then pass those changes to the state?

Thanks in advance!
 I've sorted it out. The following works beautifully: 

```
let state = this.state.options
    state = state.map((options) => options.set("selected", false))
    this.setState({
      options: state
    })
```
  ### What happened

I'd like to ensure that an parameter passed to a function is of type `OrderedMap` and not just an ordinary `Map`. However, `OrderedMap` simply extends `Map`, and all of its member functions return type `Map`.
### How to reproduce

```
function mergeOrderedMaps<T, S>(
  map1: OrderedMap<T, S>,
  map2: OrderedMap<T, S>,
): OrderedMap<T, S> {
  return map1.merge(map2);
```

Result:

```
Map
This type is incompatible with
OrderedMap
```
 I've ran into this one as well. The type in question seems to be:

https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow#L538

As @rsolomon stated `OrderedMap` extends `Map`. I'm not sure if there is an elegant way to extend `Map` in such a way that all its methods return an instance of `this` as opposed to `Map`. Otherwise maybe a duplication of the `Map` type is necessary with every occurance of `Map` replaced with `OrderedMap`.

I would be happy to PR this with a bit of guidance on how to best implement the types.

P.S. It should also be noted that `toOrderedMap` currently returns `Map` ([source](https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow#L63)).
 @iansinnott I'm not sure how well it would work in Flow, but the typical solution to this kind of problem in Java is to use a recursive generic. For example, `Enum` is defined as:

``` java
public abstract class Enum<E extends Enum<E>>
    implements Comparable<E>, Serializable
```

Then `Enum` can treat type `E` as the type of `this`. Subclasses of `Enum` can then pass themselves as a type parameter.
 My suspicion is this line here:
https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow#L473

`myOrderedMap.set()` returns a `Map` instead of an `OrderedMap`
  ### What happened
- Sets of all sizes correctly deduplicate elements using identity equality
- Sets with size <= 8 correctly deduplicate elements using those elements' `.equals` method
- BUG: Sets with size > 8 _do not_ correctly deduplicate elements using those elements' `.equals` method
### How to reproduce

We ran the following test using karma and mocha to show the bug. The bug was also observed in a non-test environment.

```
class Model {
  constructor(value) {
    this._value = value;
  }
  get value() { return this._value; }
  equals(that) {
    return this.value === that.value;
  }
}

// show that equals works
const a = new Model('value');
const b = new Model('value'); // same as a
expect(a.equals(b)).equal(true); // equals works
expect(a.equals(new Model('something else'))).equal(false);

// persistently add 7 models to set
let set = new Immutable.Set();
for (let i = 1; i < 8; i++) {
  set = set.add(new Model('value' + i));
  expect(set.size).equal(i);
  expect(set.add(new Model('value' + i)).size).equal(i); // correctly deduplicates (size: < 8)
}
expect(set.size).equal(7);

const eighthModel = new Model('value8');
set = set.add(eighthModel);
expect(set.size).equal(8);
expect(set.add(new Model('value8')).size).equal(8); // correctly deduplicates (size: 8)

const ninthModel = new Model('value9');
set = set.add(ninthModel);
expect(set.size).equal(9);

// set is now of size 9, show what works and what doesn't
expect(set.add(ninthModel).size).equal(9); // reference equality DOES correctly deduplicate model 9
expect(set.add(new Model('value9')).size).equal(9); // THIS FAILS (the size becomes 10)
```

We have also noticed the same failure in `Immutable.Map`
 You need to implement `hashCode` on your model. After size 8 sets use a hash table to hold the items.
  ### What happened

One more issue and also not sure if it's Immutable.js interface or issue w/ Flow itself.
If one instance method is used twice in chain, flow thinks that values at different keys / keypaths are of the same type.
### How to reproduce

``` js
import { Set, Map } from 'immutable';

type Status = Set | boolean;
//                  ^
//                  Flow: Property `delete` not found in Boolean

type SetStatus = (status: Status, id: *) => Status;

const setStatusOff: SetStatus = (status, id) => (
  status instanceof Set ? status.delete(id) : false
);

type AcceptUpdate = (state: Map, id: number) => Map;

const acceptUpdate: AcceptUpdate = (state, id) => (
  state
    .update('isProcessing', (status: Status) => setStatusOff(status, id))
    .update('index', (index: Set) => index.delete(id))
//                                   ^
//                                   Flow: Property `delete` not found in Boolean
);
```

This construction works fine:

``` js
state
  .update('isProcessing', (status: Status) => setStatusOff(status, id))
  .updateIn(['index'], (index: Set) => index.delete(id))
```
  ### What happened

I'm not sure if it's Immutable.js interface issue or issue w/ Flow itself, but dynamic type tests doesn't work w/ static methods like `isSet`, `isMap` etc.
### How to reproduce

``` js
import { Set } from 'immutable';

type Status = Set | boolean;
type SetStatus = (status: Status, id: *) => Status;

const setStatusOn: SetStatus = (status, id) => (
  status instanceof Set ? status.add(id) : true // fine!
);

const setStatusOn: SetStatus = (status, id) => (
  Set.isSet(status) ? status.add(id) : true     // nope: Property `add` not found in Boolean
);
```
  ```
//record = some Record based object
//mp = Map with id-record key-value pairs

mp.forEach((record, id) => {
      state = state.mergeIn([path, id],record);
});

const expectedRecord = state.get(path).get(id); //should be Record, is Map
```
  I'm not sure which is correct, but I don't think these snippets should behave differently. I was trying to flatten a List of Sets into a single Set.

```
Immutable.List([
  Immutable.Set([ 1 ])
])
.flatten()
.has(1) // false
```

```
Immutable.List([
  Immutable.Set([ 1 ]),
  Immutable.Set([ 2 ])
])
.flatten()
.has(1) // true
```
  - Map is only called once (already fixed on #714)
- `.toObject()` returns a JS Object, not a `Map`.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 @leebyron do you need any help to review all PRs?
 LOL! Nice =)
  We use immutable and flow. Recently we had a bug because flow did not check that if getIn() has no `notSetValue` then the result could be undefined.

The current code :

``` typescript
// in immutable.js.flow
get<T>(searchKeyPath: ESIterable<any>): T;
getIn<T>(searchKeyPath: ESIterable<any>): T;
```

The right definition :

``` typescript
get<T>(searchKeyPath: ESIterable<any>): void|T; // or ?T
getIn<T>(searchKeyPath: ESIterable<any>): void|T; // or ?T
```

There is also an inconsistency between get(searchKeyPath, notSetValue) and getIn(searchKeyPath, notSetValue) that should be corrected :

``` typescript
getIn<V_>(searchKeyPath: ESIterable<any>, notSetValue: V_): V|V_; // or ?T
```
 ðŸ 
  It's easy to forget to set and fetch things via `set()` and `get()` and end up trying to do `myMap.a = 'stuff'`. It might be handy when a key is set on a map to prevent setting properties of the same name via [js getters and setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set).

```
{
  set: function (key, value) {
    var newMap = howeverYouCreateAMap();
    Object.defineProperty(newMap.prototype, key, {
      get: function () { throw "don't do that"; },
      set: function () { throw "don't do that either"; }
    });
    // other stuff
  }
}
```

I also noticed [this issue about proxies](https://github.com/facebook/immutable-js/issues/440), so it seems like it could roll nicely into that when it's available...
  Previously, `Iterable.splice(n, Infinity)` would return the original `Iterable` itself unchanged. 
This PR adds handling so that `Iterable.splice(n, Infinity)` removes the items accordingly.

One of my first open source PRs, so let me know if I missed something and I'll happily update it :)
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Oh, just noticed my PR also introduces some style changes (?) but since the lint passed I missed them lol 
Should I update that?
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  ```
const x = Map<string,string>();
x.set('y', 'bar').map((key, value) => 1)
```

In TypeScript 2 with strict null checking enabled and the current typings, the `value` parameter is inferred to be `string | undefined` because of these typings:

```
    map<M>(
      mapper: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => M,
      context?: any
    ): /*this*/Iterable<K, M>;
```

I believe the `?` is intended to mean "this parameter is optional". However, in practice it is equivalent to `value: V | undefined`, which is of course saying something very different. Parameters are already optional in TypeScript:

```
type x = (y: number) => number
const p: x = () => 1 // fine
const p: x = (y) => 1 // fine
```

By changing the typings to the following, `value` is correctly inferred as `string`.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Also fixed by https://github.com/facebook/immutable-js/pull/919
  In my app, the prop 'products' is a Immutable List as below 

```
  render() {
    return (
      <div>
        {this.props.products.map((product, index) => (
          <ProductView key={index} item={product} />))}
      </div>
    );
  }
```

after mapping of List instance, the return value is still a Immutable List. 
In lower-cost version of webview, it does not work.
So I can only change the List instance to pure javascript by toJS function. 
Who can explain the reason exactly? thanks in advance.
  Ran into this while profiling a hot path in our application where we follow the pattern `var thing = fooMap.get('key', new Immutable.Map())` in order to ensure we have an object to work with. The v8 profile flagged that line as a surprisingly high share of CPU load so I put together a quick [benchmark gist](https://gist.github.com/chandlerprall/857e91bc27c4a40845836dd1678ed60c) with various ways to format the line, my results:

```
// map has key and returns the value
baseline 169ms

// map has the key, but pass a new Immutable.Map() as the second parameter
successful accessor, always creating new map 539ms

// map has the key, fall back via || operator to a new Immutable.Map()
successful accessor, conditionally creating new map 417ms

// map doesn't have the key, pass new Immutable.Map()
failed accessor, always creating new map 667ms

// map doesn't have the key, fall back via || operator to new Immutable.Map()
failed accessor, conditionally creating new map 517ms

// map doesn't have the key, pass an existing empty Map as the second parameter
failed accessor, locally cached map 50ms

// map doesn't have the key, pass a an empty Map that was attached to Immutable.Map
failed accessor, immutable cached map 67ms
```

The results show that re-using an empty `Map` object is over 10x (in this microbenchmark) faster than calling `new Immutable.Map()`; I debugged the call to create an empty `Map` and verified it is properly re-using `EMPTY_MAP`, so it looks like this may all be due JavaScript's function call & stack overhead we know and love.

That said, I was wondering if you would be willing to include empty collections objects statically, something like `Immutable.Map.Empty` and `Immutable.List.Empty` which, while still somewhat slower (the last benchmark value above) it remains much faster than calling `new Immutable.Map()` and would allow us to not define a new empty `Map` in various modules.

You may argue this is over-optimizing (and it may be) but by passing the cached `Map` we had a noticeable impact on our server-side rendering.
 see https://github.com/facebook/immutable-js/pull/314
 Right, calling Immutable.Map() is expensive. Thus my question of can an empty Map, List, etc, be produced & exported on startup so applications can use that variable instead of calling Immutable.Map() ?
  I added `update` and `withMutations`. The definitions for `setIn`, `getIn`, and `updateIn` are going to be a bit trickier.

Looking here for functions not included in the documentations: https://github.com/facebook/immutable-js/blob/master/src/Record.js#L131-L146

FYI this PR contains a commit from https://github.com/facebook/immutable-js/blob/master/dist/immutable.js.flow
 @ccorcos This repo is not actively maintained as far as I can see. I created a [PR](https://github.com/flowtype/flow-typed/pull/401) in flow-typed to add flow definitions for immutable there. 

My fork is [here](https://github.com/wokalski/flow-typed/tree/immutable-definitions). Feel free to submit a PR with your changes there.
 @leebyron do you know if ImmutableJS is being maintained?
 @wokalski thanks! I'll check em out
 I'd love to see this implemented as well. I just setup Flow in my project, and it is counterproductive to keep seeing warnings that `withMutations` is not found in Record. @lacker flow-typed seems to be the new place to maintain 3rd party lib defs -- they have test setups and everything... Here's something interesting I've been experimenting with in my own code.  It's painfully verbose, but it typechecks extremely well.

```js
// @flow

import {Record as iRecord} from 'immutable'

declare class RecordAPI<T> {
  constructor(init?: $Shape<T>): void;
  get<A>(key: $Keys<T>): A;
  set<A>(key: $Keys<T>, value: A): Record<T>;
  hasIn(keys: Array<any>): boolean;
  update<A>(key: $Keys<T>, updater: (value: A) => A): Record<T>;
  updateIn<A>(path: Array<any>, updater: (value: A) => A): Record<T>;
  merge(values: $Shape<T>): Record<T>;
  withMutations(mutator: (mutable: Record<T>) => any): Record<T>;
  inspect(): string;
  toObject(): T;
}

export function Record<T: Object>(spec: T): Class<RecordAPI<T>> {
  return iRecord(spec)
}

type AddressInit = $Shape<{
  street: string,
  city: string,
  zip: string,
}>

class Address extends Record(({street: '', city: '', zip: ''}: {
  street: string,
  city: string,
  zip: string,
})) {
  street: string
  city: string
  zip: string
}

type UserInit = $Shape<{
  name: string,
  address: AddressInit,
}>

class User extends Record(({name: '', address: new Address()}: {
  name: string,
  address: Address
})) {
  name: string
  address: Address
  constructor({name, address}: UserInit = {}) {
    super({name, address: new Address(address)})
  }
}

const user = new User({
  name: 'Andy',
  address: {
    street: 'wherever',
    city: 'Austin',
    zip: 'TX'
  }
})

user.set('name', 2)

console.log(user)
console.log('user.address instanceof Address:', user.address instanceof Address)

const user2 = new User({name: 'Bob'})

console.log(user2)
console.log('user2.address instanceof Address:', user2.address instanceof Address)

``` Should this be rebased or closed?

I'd love to see the definition for Record's constructor (and the class it returns) improved in flow. Thanks for responding and tagging this issue @kozlitinaelja!

It would probably help the community a lot if we could get the flow definitions that are shipped with this package moved out into `flow-typed` so we have a path to keep them updated together (or even to allow us to change by hand in our `flow-typed` directory). @kozlitinaelja this PR is based off of https://github.com/facebook/immutable-js/pull/961 which simply defines types for the module default exports. So in fact, its only a 2 line change adding type definitions to `Record` for `update` and `withMutations`.

The other PR you mention does not fix these PRs and only tests the existing functionality. For example Record is a TODO: https://github.com/facebook/immutable-js/pull/878/files#diff-167148588528b5fa451dc535e9c29037R429


 @wokalski unfortunately, mystifying Flow errors occasionally occur when I use my `RecordAPI` type...I'm not sure if Flow object intersections still have bugs, but it sure seems like it.

The other problem with turning my suggestion into a PR is it's so verbose to use and I'm not sure I can make it work for both class extension and non-class extension usage of `Record()`.  Any thoughts? #1073 seems to be related to TS.

Records are still missing most of the definitions in flow:)
 Lovely. :)

Just in case its needed and you are not aware of it already, there is this gist on the subject:
https://gist.github.com/glenjamin/75a96b45f4bb5c6ac221815d28c548dd  This PR solves this issue:

https://github.com/facebook/immutable-js/issues/854

In the [Flow documentation](https://flowtype.org/docs/third-party.html#example) the show an example where you define library definitions in the `libs` option. So you may be inclined to use these type declarations by having the following in your flowconfig:

```
[libs]
./node_modules/immutable-js/dist/immutable.js.flow
```

The problem with this approach is that those type definitions are now global. Anytime you define a Map type, its going to defer to the Immutable Map and ever the window.Map type definition.

In a [separate part of the documentation](https://flowtype.org/docs/declarations.html#declaration-files) the talk about delcaration files using the `.js.flow` approach. Now instead of adding the files as a global declaration in libs, you can simply `import immutable from 'immutable'` and everything just works :)
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Just signed the contributors license agreement
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 I also want to mention that it would be great if we could somehow get some strong typing behind Map and List literals. For example, If I have something like `Immutable.toJS({a: 1, b: 'hello'})` where I could define this as a strict schema that can be validated by the type checker rather than everything be nullable generic Maps.
 @kozlitinaelja yes -- the definitions are still declared globally. Therefore, you can only have one Map which refers to the immutable Map and not window.Map.

https://flowtype.org/docs/declarations.html#declaration-files
 Are you doing `import Immutable from 'Immutable'`? In case anyone else lands here.  Doing...

`import * as Immutable from 'immutable`

is a workaround until there's a release that resolves the issue.  That got rid of the flow errors for me.  Continuation of [Twitter thread](https://twitter.com/leeb/status/767040753025429504) /cc @leebyron 

It would be nice to have a list of projects that use Immutable.js with links on GH and short description of some sort.

This list can serve as a good reference to new users who want to get started with Immutable.js, or take a look at how people solved typical problems, stuff like that.

Things to take into consideration:
- Projects come in all shapes and sizes, should we add some requirements for inclusion in such list?
- Projects usually belong to some categories: npm module, webapp/service, desktop app etc. Need a way to somehow categorize them.
- We need to encourage users to submit theit projects to the list, maybe put some call to action into readme?
 Just open-source projects, or any projects? We use immutable-js very heavily in ads frontend code at Facebook :smile: 

Anyone can edit the wiki (https://github.com/facebook/immutable-js/wiki), so creating a new wiki page is one possible approach.
 @Daniel15 Idea is to add projects that can be studied, so yeah, open-source ones will be better.
We can also add a section for closed-source ones, just for reference.
  It seems that if an immutable Map is initialized with an object that has integers as keys, the "has" function doesn't work as expected. Could be my ignorance.

```
var myObj= new Map({1:'foo'});
var state = {myObj};
var action = {payload:{id:1}};

state.myObj.keySeq().has(action.payload.id);//false
state.myObj.keySeq().has(action.payload.id+'');//false
```

I assume it has something to do with objects supporting only strings as keys, but accepting integers nonetheless.
 keySeq is not a set...
  Update typescript import syntax.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Yep sorry, mistake on the PR. Deleting.   Given the following code sample

``` js
const map = new Immutable.Map();
map.toJSON() === map.toJSON(); // returns false
```

`toJSON` returns new value every time, even though that's obvious that instance of _immutable_ map object should produce the same object every time.

I use `toJSON` call in my React+Redux application in the `connect` function to pass data from store to components and I see that non-equality of toJSON affects the performance of my app because it causes re-render even this was not necessary.
 The map is immutable, but the JS-object representation of it returned by `toJS/toJSON` is mutable, and so returning the same object every time wouldn't make sense.  If it did return the same object every time, then mutating the return value of one `toJSON` call would affect the result of all calls to `map.toJSON`, which is problematic:

```
const map = new Immutable.Map({x: 1});
const rawMap = map.toJSON();
rawMap.x = 2;

//This might be a completely different part of the source code
console.log(map.x); //1
console.log(map.toJSON().x); //2, this is rather unexpected
```

---

Rather than trying to insist that a mutable JS object be treated as immutable, perhaps instead you should use some form of memoization?  [reselect](https://github.com/reactjs/reselect) is a pretty standard choice for these sort of problems in Redux apps:

```
import { createSelector } from "reselect";

const mapSelector = (state) => state.map; //Or however your map is stored in your state

const mapJSONSelector = createSelector(
     mapSelector,
     (map) => map.toJSON()
);
```

Or even just a lodash memoized function: 

```
const getJSON = _.memoize(function (map) {
    return map.toJSON();
});
```

Either one of these will return the same JS object for a given Immutable map, as you want.
 @Retsam thank you for the idea of using reselect. That probably will work for me.

But still, I would like to consider adding this memoization directly into Immutable.js itself. I understand that output object can be changed by third-party code, but this is not an issue, because everybody can remove some properties on immutable instances as well:

``` js
var map = new Immutable.Map({key: 'value'})
delete map._root
map.toJSON() // prints empty object
```
 The difference is that `delete map._root` (or equivalent) is pretty clearly "evil": you're digging into a library's internals and mucking around with undocumented properties.  It's expected that that can cause unexpected things to happen.

But in my above example, on the other hand, there's nothing "evil" going on at all.  The "problem" line is `rawMap.x = 2`, but this is just setting a property on a normal, mutable JS object: that's a perfectly normal JS operation, and there's no reason why it should be allowed to cause unexpected behavior elsewhere in the codebase.  

To add this sort of memoization into ImmutableJS would be to insist that everyone treat the output of `.toJSON` as if it were an immutable object, but it's not an immutable object.  Heck, I think one of the primary reasons why people `toJSON` is because they want a mutable version of their immutable data structure.
 so why are you calling `toJSON()` in mapStateToProps instead of in `render()`?
  If there are two `Map` objects deriving from a common `Map` object ancestor, their underlying hash trie can be expected to be very similar. For example `const m1 = Map({...largeObject}); const m2 = m1.set('b', 11); const m3 = m1.set('a',12)` will produce maps `m1`, `m2` and `m3` that share most of the trie.

Entries with the same hashes can be expected to be on the "same" paths in both tries. In Immutable.js each parent-child node relation in a trie is associated with some 5-bit hash fragment. If two nodes in two different tries can be reached from the root of their respective tries by the same 5-bit hash fragments (in the same order), then any entry present in both tries will either be a child of both of those nodes or neither of them. (Property *)

The above two notions can be leveraged to efficiently produce shallow diffs between any trie based datastructures. Such a diff is a collection of added, removed and updated entries representing the changes needed to transform one provided datastructure into the other.

The diff is produced by synchronously traversing both tries. During such a traversal pairs of nodes (one from each trie) are marked as equivalent. The first pair of equivalent nodes are the roots of both tries (since they satisfy Property *). Then for each remaining equivalent pair, the child nodes are extracted together with the hash fragments associated with their parent-child connection. Any two child nodes (from different tries) with the same hash fragments are then marked as equivalent. For each child node with a hash fragment that doesn't exist for any relation in the other trie, all the entries "below" that node are known to be missing in the other trie.

I am aware that the concept of diffing has already bee brought up: https://github.com/facebook/immutable-js/issues/52. As far as I am aware the focus of https://github.com/intelie/immutable-js-diff is not on the efficient shallow diffs. The implementation of this diff algorithm is only possible with an insight into the internal structure of the tries that immutable.js uses. This is why I believe this code belongs here.

I believe this functionality is useful in declaratively built apps (approach encouraged by so many frameworks now). Recomputing data derived from an immutable.js object (for example through grouping objects from a `Map` by a specific attribute) can be computationally expensive. Thanks to the immutability memoization can be used to stop the computation if the result is already known. However if the input object is replaced with a new immutable.js object deriving from the previous one, the result must be recomputed in its entirety. Availability of an efficient diff can enable incremental updates of those derived objects. 

I hope you like my code. I added the `diffFrom` method to the `Map`. It can be easily adapted to the other datastructures. There is a optimization that can be made: The `added` and `removed` `Map`s don't have to be created from scratch. We could reuse the existing trie nodes to build those maps, thus reducing memory used.

Please tell me what you think
Thanks!
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 This article explains a contrived example of a use case that I think could benefit from something like this: https://hackernoon.com/an-artificial-example-where-mobx-really-shines-and-redux-is-not-really-suited-for-it-1a58313c0c70

The author of the article uses React components to turn the list of pixels into a hierarchy, but since Immutable already splits lists into shared hierarchies, it seems like it would make sense to re-use that logic to find out which components need to be updated. I'm imagining some kind of alternate version of `redux-react` that lets you subscribe to a specific path within the state rather than subscribing to the state as a whole, and uses trie-based diffing like this to efficiently diff the current and next state and find out which subscribers need to be notified.

I understand not wanting to put something like this in the core library since most people won't need it, but maybe it could be in a sub-module (e.g. `immutable/trie-diff`)? I found an open issue that I think this PR might be a good solution for: https://github.com/facebook/immutable-js/issues/541

Someone requested access to the Trie internals so they could more efficiently update large lists of React components, but that is obviously fragile because the internals could easily change. I think exposing an efficient diff implementation could be a high-level API that might allow people to do what they wanted to do by inspecting the internals.   Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  ### What happened

`Immutable.fromJS()` does not convert JS objects to `Immutable.Map` when placed inside an `Immutable.List` or `Immutable.Map`. The result is that `getIn()` and similar keypath methods fails when it encounters the plain JS object.

I typically encounter this when mixing plain JS and immutablejs in my Redux state object, since immutablejs does not play too well with TypeScript and other strongly typed transpilers.

```
// bar
console.log(Immutable.fromJS([{
  foo: 'bar'
}]).getIn([0, 'foo']));

// undefined
console.log(Immutable.fromJS(Immutable.List([{
  foo: 'bar'
}]).getIn([0, 'foo'])));

// undefined
console.log(Immutable.fromJS(Immutable.Map([{
  foo: 'bar'
}]).getIn([0, 'foo'])));
```
### How to reproduce

JS Fiddle:
https://jsfiddle.net/anjdreas/gp6sz7yc/7/
 The same with me.
  @leebyron this is a really awesome library, thank you for making it. I'd like to know if you have any resources for learning about datastructures/immutable datastructures as I really want to learn more about them. Resources like articles, videos, books (hopefully not too expensive ðŸ˜…), tutorials, courses, etc. If you can I would really appreciate it.
  Packages: Redux (3.0.0), React (15.2.0), React-Redux (4.0.0), and Immutable (3.8.1)
### What happened

When trying to access any methods on an `Immutable.Map` that's been passed down via `Props` from my Redux store, my app crashes.  I'm using `hot-reloader`, and as soon as it re-builds, my console spits out 2 warnings and an error:  

```
warning.js:44 Warning: There is an internal error in the React performance measurement code. Did not expect componentDidMount timer to start while render timer is still in progress for another instance.warning @ warning.js:44beginLifeCycleTimer @ ReactDebugTool.js:110onBeginLifeCycleTimer @ ReactDebugTool.js:221invokeComponentDidMountWithTimer @ ReactCompositeComponent.js:58notifyAll @ CallbackQueue.js:67close @ ReactReconcileTransaction.js:81closeAll @ Transaction.js:204perform @ Transaction.js:146perform @ Transaction.js:138perform @ ReactUpdates.js:90flushBatchedUpdates @ ReactUpdates.js:173closeAll @ Transaction.js:204perform @ Transaction.js:151batchedUpdates @ ReactDefaultBatchingStrategy.js:63enqueueUpdate @ ReactUpdates.js:201enqueueUpdate @ ReactUpdateQueue.js:25enqueueElementInternal @ ReactUpdateQueue.js:217(anonymous function) @ ReactMount.js:253scrollMonitor @ ReactMount.js:241_updateRootComponent @ ReactMount.js:252_renderSubtreeIntoContainer @ ReactMount.js:344render @ ReactMount.js:392render @ main.js:48render @ main.js:70(anonymous function) @ main.js:75hotApply @ bootstrap ad5d90aâ€¦:518cb @ process-update.js:52hotUpdateDownloaded @ bootstrap ad5d90aâ€¦:334hotAddUpdateChunk @ bootstrap ad5d90aâ€¦:306webpackHotUpdateCallback @ bootstrap ad5d90aâ€¦:27(anonymous function) @ 0.2552c86â€¦.hot-update.js:1
```

```
warning.js:44 Warning: React.createElement: type should not be null, undefined, boolean, or number. It should be a string (for DOM elements) or a ReactClass (for composite components).warning @ warning.js:44createElement @ ReactElementValidator.js:166renderError @ main.js:66render @ main.js:72(anonymous function) @ main.js:75hotApply @ bootstrap ad5d90aâ€¦:518cb @ process-update.js:52hotUpdateDownloaded @ bootstrap ad5d90aâ€¦:334hotAddUpdateChunk @ bootstrap ad5d90aâ€¦:306webpackHotUpdateCallback @ bootstrap ad5d90aâ€¦:27(anonymous function) @ 0.2552c86â€¦.hot-update.js:1
process-update.js:115 [HMR] Cannot check for update (Full reload needed)
process-update.js:116 [HMR] Invariant Violation: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object.
    at invariant (http://192.168.8.101:3000/vendor.ad5d90acbf535202d2ce.js:1393:16)
    at ReactCompositeComponentWrapper.instantiateReactComponent [as _instantiateReactComponent] (http://192.168.8.101:3000/app.ad5d90acbf535202d2ce.js:19109:103)
    at ReactCompositeComponentWrapper.performInitialMount (http://192.168.8.101:3000/app.ad5d90acbf535202d2ce.js:19562:23)
    at ReactCompositeComponentWrapper.mountComponent (http://192.168.8.101:3000/app.ad5d90acbf535202d2ce.js:19436:22)
    at Object.mountComponent (http://192.168.8.101:3000/app.ad5d90acbf535202d2ce.js:11586:36)
    at mountComponentIntoNode (http://192.168.8.101:3000/app.ad5d90acbf535202d2ce.js:24688:33)
    at ReactReconcileTransaction.perform (http://192.168.8.101:3000/app.ad5d90acbf535202d2ce.js:12607:21)
    at batchedMountComponentIntoNode (http://192.168.8.101:3000/app.ad5d90acbf535202d2ce.js:24709:16)
    at ReactDefaultBatchingStrategyTransaction.perform (http://192.168.8.101:3000/app.ad5d90acbf535202d2ce.js:12607:21)
    at Object.batchedUpdates (http://192.168.8.101:3000/app.ad5d90acbf535202d2ce.js:21773:20)

```

`Uncaught TypeError: Cannot read property '__reactInternalInstance$4heywo6qdln2sth55h7inyu8fr' of nullgetClosestInstanceFromNode @ ReactDOMComponentTree.js:107findParent @ ReactEventListener.js:39handleTopLevelImpl @ ReactEventListener.js:68perform @ Transaction.js:138batchedUpdates @ ReactDefaultBatchingStrategy.js:63batchedUpdates @ ReactUpdates.js:98dispatchEvent @ ReactEventListener.js:150`

After that, reloading yields the following warnings/errors:

```
Warning: There is an internal error in the React performance measurement code. Did not expect componentDidUpdate timer to start while render timer is still in progress for another instance.warning @ warning.js:44beginLifeCycleTimer @ ReactDebugTool.js:110onBeginLifeCycleTimer @ ReactDebugTool.js:221invokeComponentDidUpdateWithTimer @ ReactCompositeComponent.js:69notifyAll @ CallbackQueue.js:67close @ ReactReconcileTransaction.js:81closeAll @ Transaction.js:204perform @ Transaction.js:146perform @ Transaction.js:138perform @ ReactUpdates.js:90flushBatchedUpdates @ ReactUpdates.js:173closeAll @ Transaction.js:204perform @ Transaction.js:151batchedUpdates @ ReactDefaultBatchingStrategy.js:63batchedUpdates @ ReactUpdates.js:98_renderNewRootComponent @ ReactMount.js:285_renderSubtreeIntoContainer @ ReactMount.js:371render @ ReactMount.js:392render @ main.js:48render @ main.js:70(anonymous function) @ main.js:81__webpack_require__ @ bootstrap aa97362â€¦:585fn @ bootstrap aa97362â€¦:109(anonymous function) @ app.aa97362â€¦.js:6__webpack_require__ @ bootstrap aa97362â€¦:585webpackJsonpCallback @ bootstrap aa97362â€¦:21(anonymous function) @ app.aa97362â€¦.js:1
warning.js:44Warning: React.createElement: type should not be null, undefined, boolean, or number. It should be a string (for DOM elements) or a ReactClass (for composite components).warning @ warning.js:44createElement @ ReactElementValidator.js:166renderError @ main.js:66render @ main.js:72(anonymous function) @ main.js:81__webpack_require__ @ bootstrap aa97362â€¦:585fn @ bootstrap aa97362â€¦:109(anonymous function) @ app.aa97362â€¦.js:6__webpack_require__ @ bootstrap aa97362â€¦:585webpackJsonpCallback @ bootstrap aa97362â€¦:21(anonymous function) @ app.aa97362â€¦.js:1
invariant.js:38Uncaught Invariant Violation: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object.invariant @ invariant.js:38instantiateReactComponent @ instantiateReactComponent.js:86performInitialMount @ ReactCompositeComponent.js:388mountComponent @ ReactCompositeComponent.js:262mountComponent @ ReactReconciler.js:47mountComponentIntoNode @ ReactMount.js:105perform @ Transaction.js:138batchedMountComponentIntoNode @ ReactMount.js:126perform @ Transaction.js:138batchedUpdates @ ReactDefaultBatchingStrategy.js:63batchedUpdates @ ReactUpdates.js:98_renderNewRootComponent @ ReactMount.js:285_renderSubtreeIntoContainer @ ReactMount.js:371render @ ReactMount.js:392renderError @ main.js:66render @ main.js:72(anonymous function) @ main.js:81__webpack_require__ @ bootstrap aa97362â€¦:585fn @ bootstrap aa97362â€¦:109(anonymous function) @ app.aa97362â€¦.js:6__webpack_require__ @ bootstrap aa97362â€¦:585webpackJsonpCallback @ bootstrap aa97362â€¦:21(anonymous function) @ app.aa97362â€¦.js:1
invariant.js:38Uncaught Invariant Violation: React DOM tree root should always have a node reference.invariant @ invariant.js:38getNodeFromInstance @ ReactDOMComponentTree.js:166findParent @ ReactEventListener.js:37handleTopLevelImpl @ ReactEventListener.js:68perform @ Transaction.js:138batchedUpdates @ ReactDefaultBatchingStrategy.js:63batchedUpdates @ ReactUpdates.js:98dispatchEvent @ ReactEventListener.js:150
```

Any context in which I try to access a method creates this error, e.g., in a `console.log(Map.get('key'))`, or assigning a component prop to `Map.get('key')`.  

However, `console.log(Map)` works fine, and the console indicates that it's a regular `Immutable.js` map. 

What's even more bizarre, I think, is that the error happens even if I try the following:
1. invoke `.toJS()` and try to access the object properties via normal JS. Interestingly, no matter where in the chain from reducer to `console.log()` I do this, it still has the same result.
2. Assign each property to a new JS object. eg, 

```
let tempObj = {
propA: Map.get('propA'),
propB: Map.get('propB'),
}
```

On doing this, `console.log(tempObj.propA)` crashes in the same fashion.
### How to reproduce

I wish I could be of more help here, but I'm absolutely stumped at why this is happening or how to reproduce it in isolation.  

[I cloned my repo and added some detailed notes](https://github.com/brandonmp/immutable_bug) to the `readme`, and I'm happy to discuss w/ anyone that's interested.

The issue happened in a totally different part of the project the other day. I was able to code around it, but this time I figured it wasn't just a fluke.
 I've done some more tinkering/weeping w/ this. I was able to fix it for my purposes. 

I had the component structured like this (pseudocode): 

```
this.state={modalBody: null, isModalOpen: false}

// sets content to the state, which is passed via props to Modal 
handleClick(modalText)={this.setState({isModalOpen: true, modalBody: modalText})

// List render method
Immutable.List.map((item) => {
  <CustomListItem item={item} modalOpener={this.handleClick}  />
}

<Modal content={this.state.modalBody} open={this.state.isModalOpen} />

// <ListIitem>
_clickHandle() {
  this.props.modalOpener(this.props.item)
}

render() {
<ListItem 
  onTouchTap={this.clickHandle}
  primaryText={this.props.item.get('text')}
/>
}
```

^^(which is a pattern i got from an `eslint plugin` doc. Note that to avoid creating an instance of the click handler and dialog for each item generated by `.map()`, I've created an intermediate component. 

I **think** the problem lies in the fact that I was passing the `item` generated by `map()` outside of the `map()` anonymous function, but I've been unable to confirm this theory. 

However, when I changed it to something like this:

```
this.state={modalBody: null, isModalOpen: false}

// sets content to the state, which is passed via props to Modal 
handleClick(modalText)={this.setState({isModalOpen: true, modalBody: modalText})

// List render method
Immutable.List.map((item) => {
  <CustomListItem 
    item={item} 
    modalOpener={() => {this.handleClick(item.get('text')}}  
  />

<Modal content={this.state.modalBody} open={this.state.isModalOpen} />
}
```

...things work ostensibly fine. This is obviously not optimal as it's generating a `<Modal>` for every list  item (vice creating one just for the clicked list item), but it's working for now.

The other things I tried:
1. `forEach()` instead of `map()`. I thought maybe it had something to do w/ side effects, but no dice.
2. `connect()`-ing the `<Modal>` component itself to the `Redux store`, then just passing an ID string from the `.map()` function. Unfortunately this also crashed (just as before, I even tried creating a brand new `string` object to sever the tie to the original data structure, but nothin'-doin'.
  Could we add `.length` property to immutable structures, for ease migrate from arrays?
 +1.  As well as migration convenience, it would allow for easier function overloads like:

```
  static indexOf(cards:List<Card>, cardToFind:Card):number
  static indexOf(cards:Card[], cardToFind:Card):number
  static indexOf(cards:any, cardToFind:Card):number {
    for (let i = 0; i<cards.length; i++) {
...
```
   Reason to not to merge? Typescript has a `user defined guard functions`, which could be used to narrow type definitions. For example:
```ts
function handleCollection(c: List<any> | Map<string, any>) {
  if (isList(c)) {
    // c shluld be List<any> here
  } else {
    // c shluld be Map<string, any> here
  }
}
```
this is possible only if `isList` function defined as `isList(arg: any): arg is List<any>`. Return type `arg is List<any>` actually boolean, with extra semantic - it says that "if it is true, then arg has a type List<any>"   What's happening with this? Does FB accept PRs from outsiders?
 Description of issue here - https://github.com/facebook/immutable-js/issues/1003

This PR adds the necessary definitions to work with for of loops.  This overloading for proper return type of `concat` method.
This PR build on top of #925, for reduce amount of conflicts.
  ### What happened

When List is being emptied in a mutable state (`asMutable`) it can be emptied using
the `pop` method, which is still available while other classes only allow additive methods
in their mutable states. After a Mutable List was emptied using `pop` and is converted back
using `asImmutable`, the result is not the EMPTY_LIST reference, but rather a separate
instance.

This is since `asImmutable` is the same as Map's one, that just returns `this.__ensureOwner()` and doesn't check for `this.size === 0` before.
### How to reproduce

``` js
const filled = new List([ 'a' ]);
const empty = new List();

filled === empty // false: as expected
filled.clear() === empty // true: as expected

filled.withMutations(list => {
  list.pop()
}) === empty // false: oops
filled.asMutable().pop().asImmutable() === empty // false: oops
filled.asMutable().pop().asImmutable().size // 0: oops
```

I found this, while writing a project for extendable immutable types.

If this turns out to be a bug, I'd be glad to file a PR myself :)
  <!--
Have a general question?

First check out the Docs: http://facebook.github.io/immutable-js/docs/
Or ask on Stack Overflow: http://stackoverflow.com/questions/tagged/immutable.js?sort=votes
Stack Overflow gets more attention than this issue list, and is much easier to search.

Found a bug?

Please ensure you're using the latest version, and provide some information below.
-->
### What happened

remark
### How to reproduce

remark
  Hi,

It would be great to have a side effect method which returns the previous state, to be able to add some logs or others into chains.

for example : return fromJS(state).get('myList').filter(l => l.get('id')).log(list => list.forEach(elem => console.log(elem)));

I don't know if the philosophy around immutablejs can accept that, because it makes the transformation not pure, but I'd like to discuss about that.

So what do you think ?

Thank you !
  Unfortunately, in the project I am using does not support named imports https://github.com/ef4/ember-browserify#known-caveats

Willing to change what I did if needed!
 @rtorr This repo is not actively maintained as far as I can see. I created a [PR](https://github.com/flowtype/flow-typed/pull/401) in flow-typed to add flow definitions for immutable there. 

My fork is [here](https://github.com/wokalski/flow-typed/tree/immutable-definitions). Feel free to submit a PR with your changes there.
 It still does not have a default export if i am reading that correctly.  OrderedSet seems to not have zipWith, is this on purpose?

Thanks,

Francisco
  Gramar mistake
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  What is the alternate of doing splice operation in withMutations instead of using directly splice as that doesn't wok?
  Documentation for methods that have both a "Discussion" paragraph and an "Example" are missing the "Example" header.

For instance, compare the documentation for `merge`...
<img width="400" alt="screen shot 2016-07-16 at 12 30 29 am" src="https://cloud.githubusercontent.com/assets/7499938/16892411/6ff21ffa-4aec-11e6-8cac-c3468cc4b38a.png">
...with the documention for `mergeWith`...
<img width="400" alt="screen shot 2016-07-16 at 12 30 44 am" src="https://cloud.githubusercontent.com/assets/7499938/16892416/9fb0b0f8-4aec-11e6-9d5e-7a74d8bc659c.png">

**This PR corrects this by putting examples in a distinct `example` property of the doc definition when parsing the comment in `DocVistor`. This property is then used explicitly in `MemberDoc` and `TypeDocumentation` instead of rendering the example as a part of the description.**

It then also removes an explicitly added "Example:" header that is now redundant.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  Fixing a spelling mistake in the library description
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Woops sorry ! :-1: 
  Enable usage of polymirphic `this` type if applicable.
Remove `/*this*/` comments from places, where `this` type is not applicable.
 Documentation generator fails on this, could someone help?
 I am not close to documentation generator, unfortunatelly. I just migrate typedefinitions to latest version of typescript.  This is implements overloading for `map` methods for all concrete collection classes,
with proper return type.
 This make things closer to real world. map method actually returns same classes, with all methods, not base class No, `this` is not fit to this case. I will show you later consider the example:
```ts
interface BaseCollection<Key, Value> {
  map<U>(mapper: (v: Value) => U): this;
}
interface Map<K, V> extends BaseCollection<K, V> {
}
interface List<V> extends BaseCollection<number, V>{
}

const map = new Map<string, number>;
const mapped = map.map(v => String(v));
```
after this, `mapped` *actually* has a type `Map<string, string>`, but definition says that it has a `Map<string, number>`, because of `this` return type.
You could say that we could just return `BaseCollection<K, U>` from `map` method, and this is also wrong, because returned type actually is a `Map<K, U>`, with all extra methods of `Map` interface.  ### What happened

It's really strange thing. And I'm not sure where and how to fix that.
So - I'm using Immutable.js (3.8.1) and Angular (1.5.7). And when I create something link this:

``` js
angular.module('test', [])
.controller('TestCtrl', function($scope, $window, dateFilter) {
  var Record = $window.Immutable.Record;
  var Test = Record({0: 'Test'});
  $scope.today = dateFilter(new Date());
  var m = $window.Immutable.Map({0: 1});
  // Comment next line to fix the issue
  var t = new Test();
  $scope.todayEmpty = dateFilter(new Date());
  $scope.t = t;
}).run();
angular.bootstrap(document, ['test']);
```

angular's `dateFilter` starts returning empty strings on valid Date objects.
I've figured out that this code

``` js
// angular.js dateFilter
while (format) {
  match = DATE_FORMATS_SPLIT.exec(format);
  // match = _.cloneDeep(match); --> this is helps
  // but otherwise match is not array (or something)
  if (match) {
    parts = concat(parts, match, 1); // here it starts to return array with empty values 
    format = parts.pop();
  } else {
    parts.push(format);
    format = null;
  }
}
```

is broken after  `var t = new Test()`
And I can reproduce it only in Safari.

Here is the some examples:
Safari version: http://take.ms/tXQHy
Plunkr: https://plnkr.co/edit/5d3tclj8KFe5KnyB3aqe?p=preview
 reproduced! really weird behavior
  Please follow example:

``` typescript
let a = Immutable.List<string | number>()
declare function isString(a: any): a is string;
a.filter(isString) // result expected to be Immutable.List<string>
```

I've tried to implement that thing with adding overload for `filter` in `List` in that way:

```
filter<S extends T>(
  predicate: (value: T, key: number, iter: this) => value is S,
  context?: any
): List<S>;
```

And gulp task `typedef` fails with `Error: Not yet implemented: type constraint`. Could someone implement that feature?
  `Immutable.List([ 4, undefined, 5, 6, 3, undefined, 2, 1 ]).sort().toJS()` currently returns:
[4, undefined, 3, 5, 6, undefined, 1, 2]

This change alters the behaviour to work in the same way as native JS, which is:

`[4, undefined, 5, 6, 3, undefined, 2, 1].sort()`
[1, 2, 3, 4, 5, 6, undefined, undefined]

Fixes #930 
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Also `lodash/sortBy` has the same behaviour and sorts `undefined` to the end.
   Actually, result of consturctor of empty collection could be assigned to collection of any type.
 fixes #886
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Reason described at #886 @lacker this is about reduce code boilerplate/repeat. From type system point of view, empty collection could be assignable to collection fo any type. As empty array could be assignable to array of any type. This PR just fix it. Also:

```ts
interface State {
  list: Collection.List<string>
}

const state: State = {
  list: Collection.List() // fails to compile, compiles only with Collection.List<string>()
}
```  https://github.com/facebook/immutable-js/wiki/Immutable-as-React-state#updating-individual-values-in-immutable-state

Save future grief, explain in the documentation of Immutable how to update multiple values in a map.

There is no documentation whatever on this out on the Googles (minus one poor Stack Overflow answer).

It is unclear whether Map.update() is a chainable function 

```
    this.setState(({data}) => ({
      data: data.update('prop1', () => true).update('prop2', () => false)
    }));
```

or if you expect to actually have to do a full merge just to be able to update two properties on a map?

Also, in the documentation linked above, it appears to imply that a user should use List methods to update properties on a Map (in [the section on updating a collection of values](https://github.com/facebook/immutable-js/wiki/Immutable-as-React-state#updating-collections-of-values-in-immutable-state))

Cheers
 This topic should be cleared up a bit more too I agree. Having a nested map is kind of a default scenario for react state no? It would be nice to have an example about that. 

Also this is a really funky looking syntax, having expression on the right side of the fat arrow, an object, hence the curly braces, but to not to treat it as a function scope, it is surrounded with normal parenthesis... 

Plus there should be an explanation why shouldn't(?) you write just:
`this.setState({
     data: this.state.data.set('prop1', false)
 });`
 Hey @leebyron - the one reason I didn't update the docs is because I was thinking there might be a better way to do this with objects instead of chaining, by passing an object to update rather than having to call it a bunch of times:

```
    this.setState(({data}) => ({
      data: data.update({
        'prop1': () => true,
        'prop2': () => false
      })
    }));
```

It might arguably be a "better" way of doing it, so I didn't want to mislead anyone that they had to chain.

Anyhow thanks for addressing this!  TypeScript 2.0 provides a new `--strictNullCheck` option that adds non-nullable types. In order to use this option with Immutable.js, we need to fix the parameter-types of closure-parameters like mappers, predicates and groupers in the Immutable.d.ts type-definitions. 

The parameters of these closures are now marked as optional in the type definitions. Because of that, TS thinks that those parameters might not be passed to the closure, so it always adds an explicit `| undefined` to those types. These parameters are always filled though. Parameters to closure-parameters should not be explicitly marked optional.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Full non-nullable support needs more work though.

The definitions are currently "waiting" on the closed issue: Microsoft/TypeScript#285. Can we fix the definitions using the special `this` type or do we need to support older TypeScript versions?
 BTW: The current pull request is still backwards compatible. Real non-nullable types support is not backwards compatible unfortunately ðŸ˜ž, so we at least have to wait until TS 2.0 is stable.
 I think that this change sould not be described as "to support TS 2.0". It should be described as "keep typungs closer to real world", and it could be merged before stabilization of ts 2.0
 You are right. Although I created this PR to fix the most common problem I had with the typings when using TS2.0 with  `--strictNullCheck`, it does make sense without TS2.0.
 Amazing, thank you for doing this. I really hope we can get this merged!
 TypeScript 2 is out, and `strictNullChecks` has officially landed! Immutable data and strong non-nullable types are an amazing combination, but the current definitions, as mentioned, are causing some pain.

Here is some code of mine that no longer compiles when `strictNullChecks` are turned on:

``` typescript
items
  .filter((item) => item.get('type') === filterKey)
  .sortBy((item) => item.get('name'))
```

I get 2 `Object is possibly 'undefined'.` errors refering to the `item.get` calls. This is the best workaround that I could come up with, which is not very good:

``` typescript
items
  .filter((item) => (item && item.get('type')) === filterKey)
  .sortBy((item) => item && item.get('name'))
```

Considering how common operations like `.map` and `.filter` are, immutable-js and `strictNullChecks` feel, to me, unusable together at this point. I'm going to give the fork a try for a while and see if I can find some valuable feedback to give.
 We'd also gain increased type safety from updating the type definitions:

``` ts
const result = Map<number, number>([[ 1, 2 ]]).get(1)
result // is number, with upgraded type definitions this would be number | undefined
```

Any ideas what is blocking progress on this? How can we help? I would really like to use immutable JS together with the increased type safety brought by `strictNullChecks`.
 Any updates on when this will be released and ready to use? I think that this library should stop to provide types itself and move types to DefinitelyTyped repository  The sidebar in the documentation is always positioned at the top of the document, making navigating the docs extremely difficult.  

I recently used Stylish (a chrome plugin that lets you change styles on pages) to make this change myself, and thought that other people might enjoy it as well. 
 Oh, I see.  Well i'll be 1 vote for a fixed sidebar.  I think having the sidebar unreachable while in 99% of the "Pages" of the docs is worse than having to scroll 2 separate containers in the case when the sidebar is larger than the rest of the page.
  I'm starting to work on a PR that will support Circular References in Immutable. If anyone wants to join in on the fun. Please, do not hesitate to discuss in this thread, let's try to make this happen! ðŸŽ‰ ðŸŽ‰ ðŸŽ‰ 
  It seems mergeIn is missing from Set. This seems like an omission.
  I'm not sure if it's a bug, but it's really strange

```
const data = Immutable.fromJS({data: 'data'})

const data2 = data.set(['data'], 'data2') // I know it's wrong, setIn should be here, but not throwing any error
console.log(data2.get('data')) // data(that's right)
console.log(data2.toJS().data) // data2(that's wrong)
```

version 3.8.1
 reproduce in [here](http://jsbin.com/yoqudi/edit?html,js,console,output)
  Since a new version of TypeScript with --strictNullCheck will be released soon it would be cool to have support for this in Immutable.js typings.

https://github.com/Microsoft/TypeScript/pull/7140
 Something like this? #919 is a start, but full non-nullable types support needs more work I'm afraid. 
 #919 was merged, but this only fixes the closure parameters. The remaining issue is with the return types:

``` js
listOfNumbers.get(5) // returns 5, should return 5 | undefined
```

What work is involved to get this done? Is it simply a case of updating the type definitions? This might get tricky because `arrayOfNumbers[index]` has type `number` even if `arrayOfNumbers` is `number[]` (!), and this is intentional (https://github.com/Microsoft/TypeScript/issues/9235) although it's at least quite controversial if you ask me.

```typescript
const array: number[] = [];

array[5000] = 5;

const a = array[0]; // a is a `number`, not `number | undefined` !!!

const b = List().toArray();

// **EDIT**: this is not actually accurate for JavaScript:
// b.forEach(v => { /* v has `number` type but can have `undefined` value! */ } );
// b.map(v => { /* v has `number` type but can have `undefined` value! */ } );
// ...
```

So one has to decide should Immutable.js mimic this behavior or should it have more type safety? 
If we choose type safety then which way? Make all methods like forEach, find, map, sortBy, ... to go with `T | undefined` for values because Immutable.js iterates over undefined after List resize? `mapper: (v: number | undefined, k: number | undefined) => M` for `Set<number>`? Does it make any sense? What about `toArray()` and `toObject()`? 

Or should we instead change all mutation methods which may potentially introduce undefined values to return List<T | undefined>? Like `set`, `setSize`, or List constructor:

```typescript
function of<T>(...values: T[]): List<T>;
function List<T>(): List<T>;
function List<T>(array: Array<T>): List<T | undefined>;

interface List<T> extends Collection.Indexed<T> {
    // ...
    push(...values: T[]): List<T>; // push can't add undefined values, so we keep List<T> type
    set(index: number, value: T): List<T | undefined>; // can't guarantee that new list won't have undefined values
    setSize(size: number): List<T | undefined>; // can't guarantee that new list won't have undefined values
}
```

I don't know...

**EDIT**: I wasn't quite accurate: JavaScript actually does not iterate over undefined values if one does `a[50000] = 1`, and Immutable.js behaves in a different way. Still there's a question about type of value parameters in iteration methods. > So one has to decide should Immutable.js mimic this behavior or should it have more type safety?

Interestingly, TypeScript's built-in signature for ES6 `Map` and `Set` does include `undefined` in the `get` signature: https://github.com/Microsoft/TypeScript/blob/445421b68b23a3fcb1a64d9541f31b5e0131ed34/src/lib/es2015.collection.d.ts#L5 All of this looks quite messy to me. For example, forEach of Javascript array and forEach of Immutable.js List have different semantics:

```typescript
const array: number[] = [];
array[3] = 5;
array.forEach(v => console.log(v));
// Output:
// 5
```

vs

```typescript
const list = List<number>().set(3, 5);
list.forEach(v => console.log(v));

// Output:
// undefined
// undefined
// undefined
// 5
```

I don't see a particularly good way to make it both null-safe and not annoying to use in real life.  Any ideas? Another issue: Immutable.js is using .d.ts file to build documentation by using custom TypeScript syntax processor which is based on TypeScript version 1.3 embedded into the source tree (https://github.com/facebook/immutable-js/blob/master/pages/third_party/typescript/package.json). Obviously it breaks down when I add `| undefined` types because TS 1.3 doesn't even support union types yet! Just plugging in modern TS 2.1 won't simply work because doc generator is based on TypeScript.SyntaxWalker which apparently has been removed from TS (https://github.com/Microsoft/TypeScript/issues/1728).

TL;DR: you can't just upgrade typings with union types, non-nulls, tuple types, `this` types, etc. without breaking documentation generation. Looks like a lot of this is already in git and not released, noticed thanks to https://github.com/facebook/immutable-js/issues/1034 @leebyron What does "soon" mean in this context?  I'm getting TS compiler errors because the definition for predicates have nullable parameters, when in reality they don't.  If a release is coming in a day or two, I'll wait.  If not, I'll have to figure out a way to manually bring the updated definitions into my project.  Hi,
look at the example:

``` js
Immutable.List([1, 2]).withMutations(list => {
    list.map(a => a * 2);
}).toString();

// expected result
List [ 2, 4 ]

// actual result
List [ 1, 2 ]
```

It is the same with Map structure.
 How does one achieve what the OP desired to achieve when they posted the code above? One possibility:

```
Immutable.List([1, 2]).withMutations(list => {
   for (let i = 0; i < list.size; i++) {
      list.set(i, list.get(i) * 2);
   }
}).toString();
```  It's included in the [List docs](http://facebook.github.io/immutable-js/docs/#/List/updateIn).

It doesn't accept an index as a parameter, and passing `[ 0, 'prop1', 'prop2']` as a `keypath` (0 being the index of the item to update), throws an 'invalid keypath' error. Passing the index as a string causes the same error. 

I'm confused as to how someone would use `updateIn` on a List.
 [SO to the rescue!](http://stackoverflow.com/questions/29589753/how-to-update-element-inside-list-with-immutablejs)
 I actually read that a couple of days ago, and it's part of the reason I
asked this question. You'll notice that none of the answers actually use
`updateIn`. Again, I don't really see how its signature can be used with a
list. Maybe there's something I'm not seeing?

On Thu, Jul 7, 2016, 8:13 AM Even Stensberg notifications@github.com
wrote:

> SO to the rescue!
> http://stackoverflow.com/questions/29589753/how-to-update-element-inside-list-with-immutablejs
> 
> â€”
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/facebook/immutable-js/issues/911#issuecomment-231060351,
> or mute the thread
> https://github.com/notifications/unsubscribe/AE5vabWGqVTVLAGgkh74Cpa20L0lXHiAks5qTO1tgaJpZM4JFqou
> .
 correct! However, I don't know if indexes are supported, for now, regular keypaths are ok :)
  I found that @leebyron has said in the past that the least efficient operation in immutable are the `fromJS()` and alike conversions. I'm working on an application with GraphQL and currently we use `fromJS()` to convert the JSON payloads to `immutable`. Is there a better conversion strategy than using `fromJS()`?
  ## The Problem

As a simplified example, consider the following `ABClass`, which extends from `ABRecord` (itself instantiated with `Record({ a: 1, b: 2 })`):

``` ts
const ABRecord = Record({ a: 1, b: 2 });

class ABClass extends ABRecord {
  a: number;
  b: number;

  setA(a: number) {
    return this.set('a', a);
  }

  setB(b: number) {
    return this.set('b', b);
  }
}
```

Because the return type of `Map.set` is specified explicitly as `Map<K, V>`, the following attempt at chaining the method calls will alert the TS compiler:

``` ts
const ab = new ABClass({ b: 3 });
const ab2 = ab.setA(5).setB(6);
console.log(ab2.a, ab2.b);
```

As a result, we must cast the return types of `ABClass.setA` and `ABClass.setB` methods explicitly to `ABClass` in order to satisfy the TS compiler.

---

The situation is more complicated when calling `withMutations`:

``` ts
const ab3 = ab.withMutations(
  mutable => mutable.set('a', mutable.a + 1).set('b', mutable.b + 1));
```

The above example fails to compile because `mutable` is typed to `Map<string, any>`, which does not have the properties `a` and `b`, so we have to either access them with `get`, or cast mutable to `ABClass`, as well as having to cast the return type that will be assigned to `ab3`.
## The Solution

This PR addresses those problems, by using polymorphic `this` return types for `Map.*` methods that result in a new `Map` of the same type.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 As it currently stands `DocVisitor#isAliased` assumes that `this.aliases` isn't empty, and runs a check based on that assumption. I can't see how verifying that assumption before doing a check could lead to adverse behaviour.

Without this check, the `typedefs` task fails with the following error:

```
[23:44:11] TypeError: Cannot read property 'OrderedMap' of undefined
    at DocVisitor.isAliased (/Users/Merott/Workspace/Projects/immutable-js/pages/lib/DocVisitor.js:45:38)
    at DocVisitor.visitFunctionDeclaration (/Users/Merott/Workspace/Projects/immutable-js/pages/lib/DocVisitor.js:87:41)
```

I assumed that any breaking changes would be picked up by existing tests.

Could this change cause problems? Let me know and I'll investigate.  It's hard to reproduce at this time, but running intensive queries causes a stack overflow, especially in node. The problem could lie in the recursive call of flattenDeep.
 I seem to have blown my cover... I'm using Immutable to write data-intensive queries. :)
 @leebyron I changed this code in my fork where I only allow flat sequences. My idea is that once you start using hierarchical structures one should switch to vecs / maps.  I just started working in Immutable, and I've hit some cornerstones. I'm insecure about several things, and I hope that you'll help out with me figuring out how it works :) ( I've also asked on SO, but people doesn't answer seriously ) 
1. To update state in Redux with Immutable, do I call `state.merge(something)` or `state.update(...)`
2. When structuring my changed values, what is the best way to do that? I most certainly know that I have done something and most likely everything wrong, so I hope that you will correct me on this. 
3. How do I call `update` /  `updateIn` on flat objects? 

Thanks for helping me out! Here's the sc.

<img width="738" alt="skjermbilde 2016-06-28 kl 11 17 21" src="https://cloud.githubusercontent.com/assets/16735925/16410382/8bc81626-3d22-11e6-962b-6b3592237c2d.png">
 I always use update/set, to modify exclusively the portion of the state that needs to be modified. In your  example, you don't show how your previous state looks like, so I'm not sure what is the best here :/
 Previous state is empty, it gets populated by a payload in the first reducer, if I have got the concept right :) @AugustinLF 
 If the state is empty, then it doesn't matter, you can even directly `return updatedState`. But this think work only if the content of the state doesn't have any influence on the updatedState
 Updated state is the new state @AugustinLF , you canÂ´t set it directly
 No but you can just return it. a reducer is a `(state, action) => newState` function. `Map().merge(fromJS({a: true}))` is shallow equal to fromJS({a: true}). So in your case, you can simply do (since state is an empty Map):

```
case POPULATE:
  let updatedState = fromJS({data: action.payload.meetingNote});
  return updatedState;
```
 @AugustinLF  @leebyron  thanks! Flat object would be like this:

``` js
updatedState: {
        data: someval,
        more: false,
        less: ...
}
```
 Okay, so here's how it looks now. Is there any optimizations needed to be picky now? Also, I really want to have each action return the state & not `updatedState`. Do I use `state.set(updatedState)` on all my reducers or do I use `updateIn` or similar? I'm adding a optional question at the end here, asking the following: I'm unsure about updating multiple values through `update`, how do I do that?
<img width="811" alt="skjermbilde 2016-06-29 kl 07 24 13" src="https://cloud.githubusercontent.com/assets/16735925/16441418/9d6602f0-3dca-11e6-85b8-2b0911bbfdd8.png">
  This is rather easy question. Would it be good  to have more examples in the docs? ( More JS examples)
 100% agree. The Doc is bad and it doesn't helpful mostly.
 References:

Immutable
![image](https://cloud.githubusercontent.com/assets/697301/16652464/1eef67a4-444b-11e6-9535-00129d8bd512.png)

Underscore
![image](https://cloud.githubusercontent.com/assets/697301/16652471/29c02a74-444b-11e6-886f-63379cfb7ced.png)

Lodash
![image](https://cloud.githubusercontent.com/assets/697301/16652483/3583b13c-444b-11e6-9577-f24e90301a60.png)
 I agree, the lack of examples in the documentation makes it really hard to use this library. Considering this is replacing basic JS data structures, it should be rather easy to make examples.  Github â†’ GitHub
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Got a bit of a weird issue. I try to install immutable 3.8.1 but seem to get 3.7.6

```
"dependencies": {
"harmony-proxy": "^1.0.1",
"immutable": "^3.8.1",
"lodash": "^4.2.1",
"lodash-es": "^4.2.1",
"normalizr": "^2.0.2"
```

  },

I get on one project this one, and on another directory the same project gets the other one.

<img width="636" alt="correct" src="https://cloud.githubusercontent.com/assets/384959/16274802/969e050a-387d-11e6-8017-6435bec26f38.png">
<img width="634" alt="wrong" src="https://cloud.githubusercontent.com/assets/384959/16274803/96a0cc54-387d-11e6-8676-4ed5b52a28f6.png">
  When I run this code:

``` javascript
var foo = { a: { name: 'Mehdi' } },
    a1 = Immutable.Map(foo).get('a'),
    a2 = Immutable.Map(foo).get('a');

console.log(a1 === a2); // -> true
```

But I expect to be: false

While:

``` javascript
var foo = { a: { name: 'Mehdi' } },
    foo1 = Immutable(foo),
    foo2 = Immutable(foo);

console.log(foo1 === foo2); // -> false
```
 Immutable isn't changing any of the regular Javascript semantics here, everything looks fine. 

In the first example, the `foo` object is passed into Immutable, which doesn't change it at all, so that when it's accessed later with `.a` the nested object is still equal by reference.

In the second example, two instances of `Immutable` are created, which are separate objects, and thus aren't equal, as far as Javascript is concerned.

Looks like what you want is the [`.fromJS()`](https://facebook.github.io/immutable-js/docs/#/fromJS) function, which will deeply convert the input objects.
 Thanks for your comment, First of all I done a typo fix. `Immutable(foo).a` -> `Immutable.Map(foo).get('a')`. Actually the old one is the syntax of [seamless-immutable](https://github.com/rtfeldman/seamless-immutable) library.

Yes, Immutable doesn't change JavaScript semantics and doesn't change `foo`.

> In the second example, two instances of Immutable are created, which are separate objects, and thus aren't equal, as far as Javascript is concerned.

Yes I agree that the second example is correct, But both the `Immutable(foo)` in the first example also must not be the same, because they are two instances of Immutable witch are separate objects, just like the second example. So I think it will be more clear that `.get('a')` of the both to be not equal by reference.

I know that `Immutable.Map(foo).get('a')` just returns an plain object and not an `Immutable.Map`. But I think it's not a good reason to consider the `a1` and `a2` to be equal by reference. I think **its a bit confusing**.

If you run this examples by [seamless-immutable](https://github.com/rtfeldman/seamless-immutable) library, both results will be false.
 Try using `Immutable.fromJS()` to get similar functionality to `seamless-immutable`, and see if that works.
 > I know that Immutable.Map(foo).get('a') just returns an plain object and not an Immutable.Map. But I think it's not a good reason to consider the a1 and a2 to be equal by reference. I think its a bit confusing.

Pardon me for interrupting, but it's been 17 days and OP has not responded but did change the title.

I think what @ianstormtaylor is trying to say is not that `Immutable.Map(foo).get('a')` should return an immutable Map. `.get('a')` precludes that, but that shouldn't `Immutable.Map(foo)` create an immutable instance _based on_ but not equal to `foo`? In that case, `a1` and `a2` are indeed different.

The problem I believe is from immutable.js being shallow, and `fromJS` is the way around it. It makes sense that immutable.js would keep the given reference until it changes in some way as opposed to automatically making an immutable clone.

Haven't run this, but according to the [docs](https://github.com/facebook/immutable-js/#the-case-for-immutability) I think the official intended route would be more like this:

```
var foo = { a: { name: 'Mehdi' } },
    a1 = Immutable.Map(foo).get('a'),
    a2 = a1.set('a', a1.get('a'));

console.log(a1 === a2); // -> should be false, but may require something different than the current value being set to get a different one.
```

In all of the examples they pass in an anonymous object that is mutable and is implicitly always still mutable.

Even more applicable actually is [this section](https://github.com/facebook/immutable-js/#equality-treats-collections-as-data):

```
var map1 = Immutable.Map({a:1, b:1, c:1});
var map2 = Immutable.Map({a:1, b:1, c:1});
assert(map1 !== map2); // two different instances
assert(Immutable.is(map1, map2)); // have equivalent values
assert(map1.equals(map2)); // alternatively use the equals method
```

It has nothing to do with immutable that they are two instances, those are two separate objects that happen to have the same deep values!

```
var a = {a:1, b:1, c:1}
var b = {a:1, b:1, c:1}
a == b //false
a === b //false
```

Perhaps it should be more like:

```
var source = {a:1, b:1, c:1};
var map1 = Immutable.Map(source);
var map2 = Immutable.Map(source);
assert(map1 !== map2); // two different instances
...
```
  Ignore the `.idea` folder to avoid tracking changes as a result of using the JetBrains WebStorm IDE.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Thanks! Great tip and noted (I didn't know that!)
  Using 3.7.6 but also tested this on 3.8.1 (latest so far)
### What happened

I was trying to flatMap over an immutable list containing immutable records. The custom record has 3 keys. I noticed that the count of the result was way bigger than the number of items in the list, even though no arrays were returned. If the flatMap function just returns the item, for a list of 2 items, the result should have 2 count. The result is 6 items because the keys in the record are destructured into 3 items each, for a total of 6.
### How to reproduce

Here's the code I used:

``` javascript
var Rec = Immutable.Record({a: 1, b: 2, c: 3})
var list = Immutable.List([new Rec(), new Rec()])
var result = list.flatMap(function(item) { return item });
result.count() !== 2;
```

I've narrowed it to this line of code in flatMapFactory function:

``` javascript
var coerce = iterableClass(iterable);
return iterable.toSeq().map(
  function(v, k)  {return coerce(mapper.call(context, v, k, iterable))} // <-- problematic here
).flatten(true);
```

The problem is that `Immutable.Iterable.Indexed` don't wrap the records properly. `Immutable.Iterable.Keyed` works for obvious reasons. I shouldn't have to use a map as the collection just so the flatMap works with records.
### How to get around

The fix for now is to just wrap records in arrays, e.g. `return [new Rec()]`
  #### Summary

After some thought and benchmarking, `withMutations` turned out to be a performant way of implementing `deleteAll`. I tested against some other implementations such as mapping the keys to an object and merging, creating a new map for each key (obviously slow), and filtering the map by keys that did not exist in the provided iterable. They all resulted in slower benchmarks.
#### Questions
1. I see `iter`, `k`, and `v` being used throughout the codebase, while the contributions state to not use abbreviations, I avoided them wherever possible, is this a rule I should be following?
2. Should I be using `forceIterator` on the `keys` parameter or is my usage of `IndexedIterable` applicable here?
3. In `withMutations` I use `remove`, is it okay even though it is an [undocumented behavior](https://github.com/facebook/immutable-js/issues/228#issuecomment-67554984)? It works correctly for `Map` in this case.
4. I have never worked with `TypeScript` or `Flow` before, did I identify the supported types properly?
5. Should we keep the behavior of returning the current `Map` when no `keys` are passed in or assert that the `keys` parameter is defined and throw if it is not defined? i.e. `Map().deleteAll() // The required parameter keys was not provided.`
6. Do we want to also provide the alias `subtract` for this method on `Map`?
#### ToDo
- [x] Add tests
- [x] Add documentation with an example
 This PR looks good to me, and would be helpful for me in my usage of the library. Maintainers, anything holding it up from being merged (other than the merge conflicts)? 

I'm happy to adopt the PR and fix the merge conflicts if there are no other outstanding issues with it. @qrohlf I've resolved the merge conflicts. @leebyron I made the requested changes other than implementing `deleteAll` for List.

I attempted to add support for `deleteAll` to List, yet I get a different result for `remove`. The examples below should help with illustrating the issue.
```javascript
List(['a', 'b', 'c']).deleteAll([0, -1]).toArray()
// [ ] 
```

```javascript
List(['a', 'b', 'c']).remove(0).remove(-1).toArray()
// [ 'b' ]
```
This is due to my use of `withMutations`, avoiding it alleviates the issue above. I am pretty sure #228 speaks on this more.

I can implement this without `withMutations`, but I would like to hear what you would like to do next in this situation before I move forward. Thank you for the advice and your time.  IterableImpl.js 

```
function quoteString(value) {
  return typeof value === 'string' ? JSON.stringify(value) : String(value);
}
```

I think it should be 

```
function quoteString(value) {
  return typeof value === 'object' ? JSON.stringify(value) : String(value);
}
```
  These links at the bottom of https://facebook.github.io/immutable-js/ were broken since they're relative and https://facebook.github.io/immutable-js/LICENSE and https://facebook.github.io/immutable-js/PATENTS don't exist.

This fixes the issue by using the full link instead of the relative link. I poked around regenerating the hg-pages for you guys, but couldn't find an obvious way to do it so heads up someone will have to regenerate them. =]
 Thank you for your pull request.  As you may know, we require contributors to sign our Contributor License Agreement, and we don't seem to have you on file and listed as active anymore.  In order for us to review and merge your code, please email cla@fb.com with your details so we can update your status.
  #### Summary

Fixes the short page issues mentioned in #852. Didn't mean to push aside #873 but the ability to click on the links in the disclaimer was only part of the problem. An example of this issue on the production documentation site can be seen [here](http://facebook.github.io/immutable-js/docs/#/Record.Class).
#### Features
- [x] Disclaimer is fully visible with clickable links.
- [x] Sidebar is visible and not cut off.

![Example of Short Page Fix](http://i.imgur.com/JM7dEcG.png)
#### Manual Tests

Firefox 47
Chrome 50
Safari 9.1.1
on El Capitan 10.11.5 
 @lacker I tested this ontop of the CSS changes in #873 and it appears to work fine. If you see any weirdness let me know, tested it on macOS Sierra and Windows 10 too.  I'm thinking about writing an app that would use Immutable.js and `Worker`s heavily.  Immutables would be the ideal data structures for safe and efficient communication of large amounts of data between threads, since no copying would be necessary.

Obviously it's not currently possible to share immutables between threads or transfer them quickly like objects that implement the [Transferable](https://developer.mozilla.org/en-US/docs/Web/API/Transferable) interface.  (I assume the browser will copy them when sent in [`postMessage`](http://devdocs.io/dom/worker/postmessage), but I haven't tested it to make sure.)

However, since sharing Immutables between threads should be safe in theory, it would be valuable if Browsers one day make that possible.

Is anyone who's involved in browser/spec development aware of plans to enable sharing read-only objects like immutables with `Worker`s by reference?
 Some discussion has begun on the subject of `Persistent Immutable Data Structures`. It is definitely on people's minds, but it hasn't been fleshed out yet afaik. One good discussion on the subject is [this](https://esdiscuss.org/topic/es6-es7-es8-and-beyond-a-proposed-roadmap#content-12) one.
 Cool, glad to hear other people want this to become a possibility!
  Failing test for #869 
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
    Hi,

How to get the values as Strong-Type? not as string

Like:

```
s {
 isMe: true,
 anotherVar: 'some' 
}

```

`let isMe= mapObj.get(s => s.isMe);`
  Hi,

While coding reducers for redux, I always have to deal with merges of refreshed data and saved data ; to do this, I use a combination of map and concat with filter, this is an example :

``` javascript
function databases(state = [], action) {
  switch (action.type) {
    case DATABASES_REFRESHED:
    let dbs = fromJS(state);
    let newDBs = fromJS(action.databases);
      return dbs
              .map(db => newDBs.find(database => database.get('name') == db.get('name'), this, fromJS({})).merge(db))
              .concat(newDBs.filterNot(db => dbs.find(database => database.get('name') == db.get('name'))))
              .toJS();
      break;
    default:
      return state;
  }
}
```

I use this combination in every reducers, and it would be great if Immutable.js would implement a updateOrPush method on List to let people merge data easily.

function updateOrPush(findClosure, mergeConflictResolver, data): updatedList

If this already exists, it's not obvious in the documentation because I can't find it.

Thank you for your great work !
  `toOrderedSet` and `toOrderedMap` [were updated in the typescript definitions](https://github.com/facebook/immutable-js/pull/761), but not the flow ones.
 @leebyron The changes in the above referenced PR caused the flow checks for draft-js to break. The changes here fix some of these. But there are more issues cropping up which have to do with incompatible types. Locally I tried copying over all the methods (minus the update methods) from the `Map` to the `OrderedMap` type and update the return values. Is this the correct way to deal with this?

If so, I can update this PR to include those changes as well!
 I'm going to accept the PR to switch Draft to `~3.7.4` to sidestep this. Would be awesome to be able to switch it back soon.
 @johanneslumpe  This repo is not actively maintained as far as I can see. I created a [PR](https://github.com/flowtype/flow-typed/pull/401) in flow-typed to add flow definitions for immutable there. 

My fork is [here](https://github.com/wokalski/flow-typed/tree/immutable-definitions). Feel free to submit a PR with your changes there.
 @lacker I just submitted a PR that address this issue along with OrderedMap / OrderedSet typing issues: https://github.com/facebook/immutable-js/pull/1027  `SetIterable` is a subtype of `Iterable` by setting `T=K` and `T=V`. There is a similar relationship between `SetCollection`/`Collection` and `SetSeq`/`Seq`.

This is actually problematic and prevents us from soundly defining methods on `Iterable` which change either `K` or `V`, like `map` and `flatMap`.

Here's a subset of type definitions that I can use to show the problem:

``` js
interface Iterable<K,V> {
  map<M>(
    mapper: (value: V, key: K, iter: this) => M,
    context?: any,
  ): Iterable<K,M>;
}

interface Set<T> extends Iterable<T,T> {
  map<M>(
    mapper: (value: T, key: T, iter: this) => M,
    context?: any,
  ): Set<M>;
}
```

I should be able to define a function that operates on arbitrary `Iterable`s, but if that function maps over the iterable, we end up with unsound behavior.

``` js
function f(iter: Iterable<string, string>): Iterable<string, number> {
  // what does this return? if we pass a set, this function's type is wrong
  // if we pass any other iterable, this function's type is OK
  return iter.map(s => s.length);
}
```

I don't have a solution to this, but one idea is to override `Set`'s `map` function to return an `Iterable` and not a `Set`. This would make `map` also obey a commonly assumed law: `x.map(f).size = x.size`.

`Set` could also provide an alternate `mapSet` function, or similar, that does what `Set.prototype.map` does today.
 Since a `Set` is "keyed" by number when iterated over, wouldn't it be possible to preserve the soundness of `.map` by simply providing the specific type of `K`:

``` js
interface Set<T> extends Iterable<number,T> {
  map<M>(
    mapper: (value: T, key: number, iter: this) => M,
    context?: any,
  ): Set<M>;
}
```
  I'm using `Flow` with `Immutable` but I found numerous false positives when I was working with it. 
By _false positives_ I mean cases where types were ignored. Most of the time it resulted in types dropping their generic definition (from `T<K,V> -> T`).

This is `WIP` because:
- tests for `Iterable` and `Seq` are not implemented yet
- `merge` on maps ignores types when given a `ESIterable`. It only infers types from plain objects.
- after initialization without type (for instance by calling `Map()`) and setting a value on empty object it doesn't correctly infer types

```
var map: Map<number, string> = Map().set(1, '')
```

This might be a flaw of Flow so feel free to point it here.

---

In f31e5c2 I copied the definition of `$Iterable` to `immutable-js`. I did it for two reasons:
1. It didn't work
2. `$Iterable` is private

---

Tests for `Iterable` and `Seq` are not implemented yet. I had some problems implementing tests for `Iterable`. Ideally I would like to cast some concrete type to it, but I'm not sure how to do it.

Is the type of `Map<K,V>` `Iterable<K,V,void,void,void>`?

---

**Next steps:**
- If tests receive a ðŸ‘ðŸ» I'm going to implement tests for other types.
- ~~I believe I found a bug in Flow. Namely argument of union type is not correctly resolved. I am not sure how to phrase it in order to file a bug in flow. An instance of this problem can be seen [here](https://github.com/facebook/immutable-js/blob/ea507393e1ff306025938341d07d8153b2bf95ce/type-definitions/immutable.js.flow#L503). `ESIterable` is casted to `{ [key: string]: T }`. How do I name this, _`casting`_?~~
 pinging @marudor as a major contributor to this
 Added some comments - otherwise looks nice.
 Thanks for the review. I would like to note that the test for `Map.merge` doesn't pass because types are ignored. I would love to get some help fixing this.
 ping @marudor 
 Closing. Work on this will be continued [here](https://github.com/flowtype/flow-typed/pull/401)
   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  The Record type refs work as of Flow version 0.24.2.

The .equals method on `_Iterable` was causing Set.equals to not accept another Set. This seems to fix it.
 Fixed outstanding issues. Added the `getIn` and `setIn` methods for Records.
If you have any suggestions for improving the type definitions let me know.

@tallixun would love another review
 Hey @nmn. I would love to see your PR merged. However, there are a few method definitions missing. So far I found:
- `Record#updateIn()`
- `Record#toJS()`
- `Record#toObject()`
- `Record#update()`
- `Record#withMutations()`
- `Record#delete()`
- `Record#merge()`

I think it would make sense to extend from `KeyedCollection`, since this is also the way it is implemented: https://github.com/facebook/immutable-js/blob/master/src/Record.js#L18
  I was having trouble following some of the function definitions, so I wrote a test script to work them out and copied the working code into the docs.

A few screenshots:

<img width="1068" alt="screen shot 2016-05-12 at 11 18 03 am" src="https://cloud.githubusercontent.com/assets/146112/15221374/2f3c1afa-1839-11e6-93c0-6a133f677560.png">
<img width="1027" alt="screen shot 2016-05-12 at 12 00 43 pm" src="https://cloud.githubusercontent.com/assets/146112/15221376/2f4f1fe2-1839-11e6-8450-c4a097bae44f.png">
<img width="1198" alt="screen shot 2016-05-12 at 11 59 48 am" src="https://cloud.githubusercontent.com/assets/146112/15221375/2f479e02-1839-11e6-881c-bdb30350e66f.png">
<img width="1028" alt="screen shot 2016-05-12 at 12 02 48 pm" src="https://cloud.githubusercontent.com/assets/146112/15221452/7586a8ea-1839-11e6-9866-3e0bd2be471a.png">
 Thanks for the review, @lacker !! Updated with your comments, let me know if I need to do any squashing :)  Now you can't click `issues` link because of overlapping.
<img width="673" alt="screen shot 2016-05-12 at 15 09 23" src="https://cloud.githubusercontent.com/assets/492261/15215619/b0bff3c0-1853-11e6-909e-ee1c3dc8fdcb.png">

Fixed by adding `z-index` property to the footer with a value bigger then the sidebar has.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  How about an immutable implementation of the Priority Queue data structure might come in handy for  some people.

I tried to do a heap based implementation using the Immutable List but I got O((logn)^2) (well ~c_log_2(n)_log_32(n)) bound for pop and push. Surely there should be a better way of doing it.
Something based on the binomial heap.

Interested in what is others think of this?
 @leebyron 

I have been working on a prototype for an immutable Heap/Priority Queue implementation. Before I go too far down the rabbit hole I would like your input.

First off, there are two possible access paradigms that we must consider. The first being strictly a Heap structure which resembles the Stack in it's basic operations: `peek()`, `push(priority, item)`, and `pop()`. The second (and more useful) option would be to combine some Map functionality, namely keyed entries, with the basic Stack operations to support `get(key, nsv)`, `update(key, nsv, fn)` and related operations on both the entry itself AND the associated priority. I have chosen to pursue the more complicated second option, as it more fully captures my needs (namely updating existing priorities) and what I believe the community needs/expects.

### Goals
Explicit functionality and performance goals:

- O(1) `peek()`, `first()`, and/or `head()`
- O(log32(N)) `pop()`
- O(log32(N)) `get*(key)`, `set*(key, [priority, value])`. Same big-O bounds as Map. For `set*(...)` a change to value can be done without changing the nodes' internal ordering, but a priority change will require the use of internal siftUp/Down operations.
- O(N) for each collection in `merge*(...collections)`. Same big-O bounds as Map (I assume as it isn't explicitly stated in the docs).
- O(TBD) iteration, we get most sequence and search operations for free once an iterator and iteration scheme is defined. This will depend on whether iteration should maintain heap ordering or first-come-first-serve ordering. I look forward to discussion on this issue.

> Note: There have been [previous efforts](http://www.brics.dk/RS/96/37/BRICS-RS-96-37.pdf) to create purely functional heap/priority queue implementations. However, they do not address efficient lookups of existing elements in the heap for updating purposes. Likewise, other more advanced heaps like the [Fibonacci heap](https://en.wikipedia.org/wiki/Fibonacci_heap) are not applicable because they require a pointer back to the parent, violating the acyclic requirement of a Directed Acyclic Graph (DAG) which underlies all of Immutable-js. Nevertheless, I have used ideas from theses sources, such as structural bootstrapping and tree decomposition, to inform/inspire my prototype.

### Implementation

#### Node Types
The proposed Heap would be comprised of 3 node types (names are negotiable):
1. `ValueNode`: Leaf node containing key, keyHash, priority, and value properties.
2. `HashCollisionNode`: Modified leaf node containing `[k, [p, v]]` entries that have identical keyHashes (similar to the [`Map.HashCollisionNode`](https://github.com/facebook/immutable-js/blob/master/src/Map.js#L484)). Entries are stored in an binary heap ordered array rather than by insertion order. Array size is unbounded as we cannot know a priori the number of hash collisions. This node's priority and value are set as the current first entry's priority and value, so as to provide efficient lookups.
3. `HashBucketNode`: Non-leaf node containing pointers to child nodes of any type. It is comprised of depth/shift integer and two identically sized arrays each with a max size of [TrieUtils.SIZE](https://github.com/facebook/immutable-js/blob/master/src/TrieUtils.js#L15). The first array is the subqueue array which is a binary heap array, ordered on node priority. The second is the hash redirect array where each slot corresponds to a secondary hash (more on this below) on the child node's keyHash and each value is that node's index in the subqueue array. A slot is initially empty, then is filled with a ValueNode, and if another node maps to that slot then a new HashBucketNode is created as the new child with both ValueNodes in the new child HashBucketNode. The depth/shift property is incremented for each child HashBucketNode and serves as a way to prevent child keyHashes from mapping to the same location at every depth. Like the HashCollisionNode, this node's priority and value are set as the current first node's priority and value.

#### Hash Redirect Slot Hashing
A HashBucketNode's hash redirect array has a max size of [`TrieUtils.SIZE`](https://github.com/facebook/immutable-js/blob/master/src/TrieUtils.js#L15) and maps a particular range of keyHashes to a heap subtree or leaf. An incrementing depth/shift value is provided for each child HashBucketNode, starting at 0. The proposed equation is below:
```javascript
function rotatorHash(shift, keyHash) {
  const truncatedHash = keyHash & 0xFFFFFFFF;
  return Math.abs((truncatedHash << shift) | (truncatedHash >>> -shift)) % SIZE;
}
```
In Javascript bitwise operations are limited to 32 bits even if a number is actually represented with more. This can result in some odd behavior for numbers > 32 bits, hence the mask/truncation operation. Effectively all the bits shifted off the end are shifted back on to the front of the hash, then the whole value is modulo'd with the `TrieUtils.SIZE` to ensure it maps only to the specified range of buckets.

The "rotation" method was chosen as it maintains a uniform modulo distribution at deeper levels of the tree. For example, if a simple left shift was performed at the 31st level, all values would begin with either a 0 or 1 and hence would only map to one of two buckets, artificially limiting our bucket space. Like all shift based hashes, this effectively limits the tree depth to 32 levels with deeper levels becoming degenerate cases with only one usable slot. And while 32^32 is quite a large size, the keyHashing method is open sourced and there are pathological cases where an attacker could force all keys into a single bucket and force a depth > 32 levels.

If anyone has a better suggestion I would love to hear it, but keep in mind that whatever the scheme is, it will need to be deterministic for a particular depth or parent slot due to the proposed implementation of the `merge*(...)` functions (see below).

#### Methods
I believe these to be the basic operations that underpin all other immutable-js operations (please let me know if I missed anything). Below is rough pseudo code on how to implement these operations:

##### peek()/first()/head()
return `[root.priority, root.value]`.
If root is a ValueNode the priority and value correspond to it's own properties. If either a HashBucketNode or a HashCollisionNode, the root's priority and value are the priority and value of the head node which corresponds to the node with the min/max priority. On every modification, the priority and value are reset on all affected composite nodes, if necessary.

##### pop()
```
1. Start at root
2a. If HashBucketNode: recurse on subqueue[0], goto step 2*.
2b. If HashCollisionNode or ValueNode: end recursion, goto step 3*.
3a. If HashCollisionNode: copy node, in copy: set entries[0] to entries.last, delete entries.last, heapify (binary heap siftDown operation), return copy or undefined if entries.length === 0, goto step 4.
3b. If ValueNode: return undefined.
4. Will always be a HashBucketNode:
  - If return value === undefined: set subqueue[0] to subqueue.last, delete subqueue.last, heapify subqueue and update hash redirect array accordingly, return copy or undefined if subqueue.length === 0.
  - If return value is node: set subqueue[0] to returned node, heapify subqueue and update hash redirect array accordingly, return copy or undefined if subqueue.length === 0.
  Repeat until back at root.
5. Set root to final returned node and return new Heap instance.
```

##### get*(key, notSetValue)
```
1. Start at root
2a. If HashBucketNode:
  - if this.hashRedirect[rotatorHash(this.depth, key)] !== undefined recurse on this.subqueue[this.hashRedirect(this.depth, key)], goto step 2*.
  - else return notSetValue
2b. If HashCollisionNode: perform linear search through entries
  - if entries has entry with matching key: return entry[1], i.e. [priority, value] of [key, [priority, value]]
  - if no matching key: return notSetValue
2c. If ValueNode:
  - if key matches this.key: return [this.priority, this.value]
  - else return notSetValue
```

##### set*(key, [priority, value])
doubles as `remove*(key)`
```
1. Start at root and compute keyHash
2a. If HashBucketNode:
  - if this.hashRedirect[rotatorHash(this.depth, keyHash)] !== undefined recurse on this.subqueue[this.hashRedirect(this.depth, keyHash)], goto step 2*.
  - if [p, v] !== undefined: copy, create new ValueNode, insert new node at end of subqueue, heapify (siftUp), update hashRedirect accordingly, return copy, goto step 3.
  - else (![p, v]): return this (unmodified), goto step 3.
2b. If HashCollisionNode: perform linear search through entries
  - if entries has entry with matching key:
    - if [p, v] !== undefined: copy this, in copy: update priority and value as necessary, if priority changed remove previous entry, replace with last element and siftDown, then insert new entry at end and siftUp, return copy
  - else: copy this, in copy: remove previous entry, replace with last element, and siftDown, return copy, goto step 3.
  - if no matching key:
    - if [p, v] !== undefined:  copy this, in copy: create new entry, push to end and heapify (siftUp), return copy, goto step 3.
    - else: return this (unmodified)
2c. If ValueNode:
  - if key doesn't match this.key and [p,v] === undefined: return this (unmodified), goto step 3.
  - if key matches this.key: return copy of this, goto step 3.
  - if keyHash matches this.keyHash: create new HashCollisionNode with [this.key, [this.priority, this.value]] and supplied parameters [key, [priority, value]], return new node, goto step 3.
  - else: create new HashBucketNode and new ValueNode with supplied parameters. Pass new ValueNode and this to HashBucketNode, return new HashBucketNode, goto step 3.
3. Will always be HashBucketNode:
  - if returned node === recursed node: return this (unmodified).
  - if returned node !== undefined: copy this, in copy: remove previous/recursed node from subqueue, put subqueue.last in removed location and siftDown, insert returned node at tail and siftUp, update hashRedirect accordingly, return copy.
  - else: remove previous/recursed node from subqueue, put subqueue.last in removed location and siftDown, update hashRedirect accordingly, return copy.
  Repeat until back at root.
4. Set root to final returned node and return new Heap instance.
```

##### merge*(...collections)
I will be a little bit more vague on this method as I haven't developed a prototype implementation yet. For each collection in collections, we need to recursively merge the HashBucketNodes at each level. If both nodes at the same level with the same parent keyHash slot are HashBucketNodes, then for every keyHash slot which exists in one node and not the other we can insert the a reference to the node/subtree as is. For every keyHash slot which exists in both we will need to recurse on those nodes. This is where the deterministic depth based rotator hash comes into play. We know that the slot hashing scheme is consistent across all nodes at a particular depth and so we can insert/combine nodes at the same level without introducing inconsistencies into our slots. If the two nodes are both HashCollisionNodes with the same keyHash, then insert the node with the fewer elements into a copy of the one with the greater number and heapify. If they have different keyHashes then insert references to them into a new HashBucketNode. If they are both ValueNodes with matching keys, then return a reference to the other node. If their keys don't match insert references to them into a new HashBucketNode. If one node is a HashBucketNode and the other is a HashCollisionNode or ValueNode, then recursively merge those nodes into the appropriate keyHash slot of a copy of the HashBucketNode. And if one node is a HashCollisionNode and the other is a ValueNode with matching keyHashes, construct a new entry from the ValueNode and insert into a copy of the HashCollisionNode. If their keyHashes don't match, create a new parent HashBucketNode for them. Upon returning from a child node, the calling HashBucketNode should heapify it's subqueue and hashRedirect accordingly. If there is a more efficient batch heapify function please let me know.

##### Iteration
TBD. If first-come-first-serve a simple DFS would suffice to iterate over all [key, [priority, value]] entries. If heap/priority based will require some level of virtual popping or actual popping and reordering (which would be O(N*log32(N)), which is not ideal). I know this is very long and dense. Over the next few days I will be working to clean up the language a bit and to provide clarifying pictures.

Please let me know if there is anything that needs further explanation and I'll take care of that first.  According to the doc, array functions like map() or filter() should return _a new Iterable of the same type_.

```
map<M>(
  mapper: (value?: V, key?: K, iter?: Iterable<K, V>) => M,
  context?: any
): Iterable<K, M>;
```

But it happens that they always return an Iterable<K, M>. We start with a List() or Map() and end up with an Iterable that we have to cast or it breaks the flow (following methods expect a List() or Map()).

My best guess is that it should be like this:

```
map<T extends Iterable<K, V>>(
  mapper: (value?: V, key?: K, iter?: T) => any,
  context?: any
): T;
```

I haven't tried it though and I don't think that's exactly right.

Would you accept a pull request for this?
 ```
declare function transformVToM(v: V): M;
let a: Map<K, V>
a.map(transformVToM) // should return Map<K, M>
```

with your proposal, result of a.map would be `Map<K, any>`, isn't it?
 Well, as I said I don't think my proposal is _exactly_ right. You're right, your example should return a `Map<K, M>`.
 I think that better solution would be adding `map` declaration to each concrete collection classes. Yes, more "duplicate", but better typings.
  I'm not sure if this is a bug or if it is the intentional behaviour, but I think that if this is the intentional behaviour it should be noted in [the documentation of the map method of the Stack](https://facebook.github.io/immutable-js/docs/#/Stack/map).

I find it odd that the iterator of the `map` function of the `Stack` is reversed. For example, I would expect the result of the following instructions to be equivalent:

```
Stack.of('a','b','c').map(
  (x, idx, iterable)=> iterable.get(idx) + (iterable.get(idx + 1) || '')
).toArray();
// Returns: ['a', 'ba', 'cb']

Stack.of('a','b','c').toArray().map(
  (x, idx, array)=> array[idx] + (array[idx + 1] || '')
);
// Returns: ['ab', 'bc', 'c']
```
  Flow uses parameter: ?type for nullable types (instead of parameter? :type as used before.
I came across the warning when checking react-native
(react-native/Libraries/CustomComponents/Navigator/Navigation/NavigationRouteStack.js:121)
and slice was passed a nullable value which resulted in errors.
 @leebyron  sorry to ping you directly, it just has been a week and I figured it won't hurt ;)
Any chance for this getting in soon?
 @TobiasBales, I've been using `parameter?:  type` for optional parameters in my code and it works fine.

`parameter?: type` â€” The parameter is optional, but when given it must have a type.
`parameter: ?type` â€” The parameter is not optional, but is nullable
`parameter?: ?type` â€” The parameter is optional, and nullable

unless there are other changes you want to still get merged, I would suggest closing the PR.
 https://github.com/facebook/react-native/blob/master/Libraries/CustomComponents/Navigator/Navigation/NavigationRouteStack.js#L120

begin and end which are passed to Array.prototype.slice are both nullable, which results in the error.
Then maybe the better option would be to make it optional and nullable?

I will gladly amend the commit to include both
 Nullable and optional mean different things. So it really depends on a case-by-case basis.
In the function body itself, nullable and optional result in similar type-checking concerns but it really makes difference at the call-site.

That said, the example from the React-Native code looks wrong to me. Perhaps that's a place for a PR!

As an another example let me explain what the difference is:
1. With Nullable Types:

``` typescript
slice(begin: ?number, end: ?number): RouteStack {
    var routeNodes = this._routeNodes.slice(begin, end);
    var index = Math.min(this._index, routeNodes.size - 1);
    return this._update(index, routeNodes);
}
/// 
slice(null, null) // legal
slice() // ERROR
slice(1, null) //legal
slice(undefined, 2) // legal
slice(2) //ERROR
```
1. With optional params:

``` typescript
slice(begin?: number, end?: number): RouteStack {
    var routeNodes = this._routeNodes.slice(begin, end);
    var index = Math.min(this._index, routeNodes.size - 1);
    return this._update(index, routeNodes);
}
/// 
slice(null, null) // ERROR
slice() // legal
slice(1, null) //ERROR
slice(undefined, 2) // ERROR
slice(2) // legal
```

Does that make sense?
 Yeah it does and I am aware of the distinction.
I guess I didn't think about the optional parameter aspect (when I started the pr) that was used.

My thought (after your comment) was, that slice(begin?: ?number, end?: ?number) would be the more flexible and correct (since slice does accept null values) solution.
The same can be achieved by passing 0 as first argument, so it might just not be necessary.
The question becomes if you want to build an api that is "cleaner" (by avoiding null arguments) or one that leans more toward Array.prototype etc like behaviour (by accepting null where the originals accept null) and communicating that by the used types.
  Feature request: add general purpose comparator for (flat) sets, in addition to equals(). The goal is to compare 2 sets (Seqs) for greater-than, less-than, greater-than-equals, less-than-equals, and combine tests with or / and.
 @leebyron I don't mean strictly numerical comparison, more like an intersection / distinction on values in a Seq, based on generic comparisons. The algorithm can be a written as a reduction over Seqs, so I figure it belongs in userland anyway. Also, it would make more sense on Sets I suppose.  I've noticed that people new to functional style programming are usually not familiar with the API of `groupBy`. Therefore, added an example to demonstrate it. 

I was hoping to add a few more examples to the docs. Would it be better to submit them as one PR or should each be a separate PR? 
  3.8.0:

``` javascript
Immutable.Seq([1, 2, 3, 4]).findLastEntry(i => true)
=> [ 0, 4 ]
```

3.8.1:

``` javascript
Immutable.Seq([1, 2, 3, 4]).findLastEntry(i => true)
=> [ 3, 4 ]
```

Seems to be caused by using toKeyedSeq instead of toSeq [here](https://github.com/facebook/immutable-js/commit/5eaf97f93bbb300d91d8ac77dd68355b034f4d3c#diff-11243f5857d9d9e7c1a844a8580fe4b6R4512).
  I understand that since Immutable is transpiled, much of this is a fiction. I'm only looking for "correctness" because flow isn't as forgiving.

The [module entry](https://github.com/facebook/immutable-js/blob/137a9cc/src/Immutable.js#L26-L46) exports only a `default`, implying that the correct usage of Immutable is:

``` js
import Immutable from 'immutable';
```

However, the [flow definition](https://github.com/facebook/immutable-js/blob/137a9cc/type-definitions/immutable.js.flow#L634-L663) exports each data structure and helper function as a named export. Implying that the correct usage of Immutable is:

``` js
import {Map, fromJS} from 'immutable';
```

This seems a bit odd since many of the exports correspond to common globals. So to avoid shadowing globals (and creating confusion when seeing `Map` buried deep in code), one would have to use Immutable like this:

``` js
import {Map as ImmutableMap, fromJS as ImmutableFromJS} from 'immutable';
// or
import * as Immutable from 'immutable';
```

So which is correct? The module entry or the flow definition? Or can we have both- Can Immutable export both a default and named exports?

Other discussions: #854 and #855.
 In the current versions I'm running- flow `0.29.0` and Immutable `3.8.1` on node `6.3.0`, checking

```
import Immutable from 'immutable';
```

results in a "This module has no default export" error, whilst

```
import * as Immutable from 'immutable';
```

runs fine. I guess that decides the issue, then? I have never had any issues using `import { Map } from 'immutable'` in this context, either.
 I believe this should fix it: https://github.com/facebook/immutable-js/pull/961
 @ccorcos: The issue is a little more nuanced than just missing Flow definitions for a default export.

There are huge semantic differences between named and default exports. However, transpilers blur the line because (depending on the implementation), among other reasons, they allow you to treat a module of named exports as a single default export.

Right now there are multiple inconsistencies:
- The actual implementation only exports a default (`src/Immutable.js`).
- The flow and typescript definitions only have named exports.
- The documentation is written to imply only a default export.

Correcting this is trivial, however, a decision must be made about what is the "correct" export of Immutable. The options are:

(A) Only a default export of an object with everything on it.
(B) Only named exports.
(C) Both a default export with everything and named exports.

Once one is picked, all of the inconsistencies can be fixed. Your PR (#961) is making the decision that (C) is the way to go. Fine. But then the PR is incomplete because the implementation (`src/Immutable.js`) then needs to have named exports, and the documentation needs to be updated too.
 I worry that this also hasn't quite solved the issue raised above:

"This seems a bit odd since many of the exports correspond to common globals. So to avoid shadowing globals (and creating confusion when seeing Map buried deep in code), one would have to use Immutable like this:

```
import {Map as ImmutableMap, fromJS as ImmutableFromJS} from 'immutable';
// or
import * as Immutable from 'immutable';
```

"

I feel like this current solution makes it very easy to abuse this to write code that obfuscates code through shadowing globals. Perhaps the better solution might be (A) simply because it makes it more difficult to write bad code. That being said, being forced to import everything isn't necessarily best case either. 
 Interesting... I didn't realize theres an ambiguity around `import { X } from './x'` working for both `export X` and `export default { X }`.

At the very least, I think the flow type definition should represent the codebase (otherwise the type checker doesnt work!). I can change that in the PR.

But as a general discussion, I think destructuring the default export when you import is probably not a good idea. But the `stage-0` babel plugin apparently does that just fine. I believe the point of non-default exports is for tree shaking and stuff like that. So I think we should do that. `import * as Immutable from 'immutable'` is kind of annoying though. But I suppose it would encourage you to just import what you need: `import { fromJS, Map, List } from 'immutable'`. If there's an objective argument for why thats better, I think thats the way to go. The namespace issue with window.Map can be resolved as @DavidSnider mentioned -- I think code aesthetics should be a deciding factor here.
  I've configured system.js to run in the browser with bower-traceur, but I can't seem to import from src. Perhaps this could be solved by calling super() in extended classes, but I didn't get through all of them yet.
 I understand this is due to the factory style but IMO it shouldn't interfere with ES6 modules. Perhaps using something like dojo/compose would be an option.
  In order to fix around a hunded typescript warnings did the following:
a) Moved exported functions over the modules (fixes a warning "Function statement FOOBAR must be located prior to module declaration in the same source file to be merged properly")
b) Marked Indexed as export (fixes a warning about all or none Indexed module definitions must be export)
c) Added Immutable. prefix to Iterator so it doesn't crash with for example core-js
  I got a bit confused seeing `Immutable.Map.of()` was not available in the console until I realised the docs had a previous version of Immutable.
  ### What happened

The documentation does not mention the difference between `Iterable.Indexed.map()` and `Iterable.Keyed.map()`, or even that there is a difference (see also #697).

The missing information is the mapper function passed to `Iterable.Indexed.map()` can return arrays of the form `[key, value]`, while `Iterable.Keyed.map()` cannot. In order to accomplish the same result, one must use `Iterable.Keyed.mapEntries()` instead, which is currently not documented at all (see #857).
### How to reproduce

1) go to https://facebook.github.io/immutable-js/docs/#/Iterable/map
2) note the lack of documentation regarding key functionalities mentioned above
  ### What happened

There is no documentation for `Map.mapEntries()` on https://facebook.github.io/immutable-js/docs/#/Map
### How to reproduce

1) Go to https://facebook.github.io/immutable-js/docs/#/Map
2) Ctrl+F for 'mape'
3) Notice, no matches found
  As said in #505 some functions of Record don't behave as expected. They plan to be removed, but for now, it's confusing for anyone not aware of the problem (you can easily lose a couple of hours because of that), so warning the user should be reasonable way to let them know.

You mention "other API methods", but not knowing which ones you're talking about, I'll add them later if needed :)
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Hey, sorry for not updating before, since I didn't get any feedback on the PR, I dropped it! I amended my [commit](https://github.com/AugustinLF/immutable-js/blob/feature/deprecateRecordMap/src/Record.js#L150), but I think that since you closed the PR, it doesn't show up anymore.

I can rebase my branch on top of master if you want!  ### What happened

I was using Flow with Immutable without problem but since definitions were added I'm getting this error everywhere:

```
src/Services/SchemaConverter.js:2
  2: import Immutable from 'immutable';
            ^^^^^^^^^ Default import from `immutable`. This module has no default export.
```
### How to reproduce

Simply import Immutable and enable Flow on the file
 I just remembered, I think they wrote the type defs this way because Flow unfortunately doesn't allow a class to be a static property of another class right now.  There are some notes in [immutable.js.flow](https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow) that will hopefully wind up in the docs soon.
 Is there any simple workaround for dealing with the large number of Flow errors about this in preexisting code?  If not, I really don't think the flow defs should be included in the official release until they work correctly with preexisting code that has followed the long standing import conventions in the docs.
 as annoying as this might be for those using the default export, please don't remove the flow type annotationsâ€”they're incredibly valuable. i've already been able to fix a couple edge-case bugs in my app because of them!
 Yes, but the annotations could easily be moved to a well-publicized branch until they're a bit more mature, so that people can `npm install facebook/immutable-js#flowtype` for example
 I created a PR for this fix: https://github.com/facebook/immutable-js/pull/961
  What's the expected behavior when comparing two unordered `Map` objects using `<`, `>`, etc.? Is there a defined way it should behave? I noticed an instance of the result being different when using version `3.8.0` vs `3.8.1`.
   Actually this will introduce some problems.
Thats why I left them as Map/Set for now.
But the main signatures for Maps/Set is the same for Ordered.
So it shouldn't be a problem to leave them.
 I also hit on this problem

@marudor  on the project https://github.com/facebook/draft-js with immutable '3.7.4' the flow build works just fine.

But since the dependency on the package.json is set as '^0.7.4' the version that gets installed via npm install is ''3.8.1" which is incompatible and fails 
 I fixed the merge conflicts in this PR / added tests / updated annotations for OrderedSet and OrderedMap in this PR: https://github.com/facebook/immutable-js/pull/1027 @kozlitinaelja #1027 is merged into master, which is a superset of this PR. I think this PR can be closed.  I wanted to try the changes with the new version quickly, but saw that in the console it was still running the 3.7.6 version.

Not sure if there is something else to change, and everything was working fine locally.
  Can you push https://github.com/facebook/immutable-js/releases/tag/v3.8.1 to npm?

Thanks!
  Hero looks as intended in Chrome, not Fx:
![fb-immutable-firefox](https://cloud.githubusercontent.com/assets/1308419/14614871/566d9518-0560-11e6-9d97-1e0295aabd10.jpg)
  Similar to typescript
  filter is no longer declared on Iterable.
This is to degrade the Type of a Iterable to any. Mainly to allow following:

``` javascript
function foo(): List<number> {
   return List([undefined, 1, 2]).filter(i => i); //List no longer contains undefined. Without degrade to generic List it would error.
}
```

flatten is also declared on each Class to return the "correct" type. Before Iterable was returned. This results in missing chaining.

``` javascript
List().flatten().map() // Errored before as map is not defined on Iterable
```

get no longer returns ?T but T.
Technically it is not correct, but it allows common use cases and is in sync with the typescript libdef.

Also fixed bugs with get introducing undefined into the Type of a Iterable. (Ordering of overloaded function declarations is important)
 The typo with push is fixed.
map is actually not defined on Iterable. 

For filter and flatten I've included examples in the PR description.
Filter can change the Types that an Iterable includes. The most important one being undefined.
filter can change a type from ?T to T. That's often quite important.
I degrade it to a non specific Iterable (Or Map, List, Set and so on)

Same for flatten.
It can change the Types of the Iterable. But we can't really see or know if they do. So we degrade and leave it to the user to know it.
 Well - the filter treatment in flow core is flawed in the same way.
Imagine:

``` javascript
const arr = [1, 'foo', 2, 'bar', 3, 'batz'];
const numberArr: number[] = arr.filter(x => Number.isInteger(x)); // Error, string is not compatible with number
const stringArr: string[] = arr.filter(x => typeof x === 'string'); // Error, number is not compatible with string
```

Actual results of both filter match the type. Flow doesn't know that though. It still assumes Array<number | string>;
 I would rather degrade I think.
But to match flow core I think changing it to this again should work for now.
This is probably more a question for flow and the way the main lib should go.
We should not introduce different behavior for essentially the same function.
  This PR adds a watcher for any file in the `/type-definitions/` folder and rebuilds the docs on changes. This makes it easier to work on docs and seeing the results without constantly having to rebuild manually.
  There's a div with class `coverFixed` that hangs around, and blocks half the page (making links not clickable). See below.

![screen_shot_2016-04-17_at_12_04_41_pm](https://cloud.githubusercontent.com/assets/12532733/14589358/be2c06a2-0494-11e6-9d8a-e77d83f79022.png)
  Related issue: https://github.com/facebook/immutable-js/issues/742
### Introduction

I started implementing the tests using Mocha instead of Jest. I figured it'd be a good idea to send a preliminary PR and do things in the open. This way, I'd like to get as much feedback on it as possible before we convert too many tests. 
### Changes so far
- Added `npm` script (`npm run testmocha`) to run Mocha tests. The Mocha tests are also written in TS like the current tests. The code is compiled using [`ts-node`](https://github.com/TypeStrong/ts-node).
- Added watcher to re-run tests on file changes (`npm run testmocha:watch`). This is to make my life a little easier when converting the tests, and we can remove this when the tests are fully converted (although having a watcher is always nice, so we could leave it in).
- Tests are all in the `test/` directory, adhering to Mocha's convention. This also makes it easy to run the Mocha and Jest tests side-by-side, and to port them over incrementally.
- [`mocha-testcheck`](https://github.com/leebyron/mocha-check) is used for the generative testing, replacing `jasmine-check`.
- Some code styling was applied: making use of whitespace where applicable and using `const` and `let` where appropriate (not sure if you're okay with this @leebyron, if you'd rather convert the tests verbatim, let me know).
### Current issues
- The `Map` test has two failing test cases (`accepts flattened pairs via of()` and `does not accept mismatched flattened pairs via of()`) where `Map.of()` seems to be undefined, while it is defined in the Jest test. Any idea why that might be? I'm importing the exact same `immutable` as the Jest tests are, yet it still seems to be different for some reason.

---

I'll update this PR with more converted tests and any questions I might have regarding failing tests.
 Huh, that's strange. Running the tests that use `Map.of()` on another machine works just fine, the `Map.of()` isn't undefined there. I'll investigate when I get home, but it looks like we're good to go for now. All tests for `Map` have been ported, and pass!
  As discussed here: https://github.com/facebook/immutable-js/pull/805#issuecomment-210793138 the new Record libdef broke old code.
I've relaxed it again to any. We will loose comfort but it will not error.
Ideas to improve exist, can't do them yet though.

Also fixed errors I've introduced with the last PR. (minor)
 I can check on Monday if you release 3.8.1
 Thank you so much for the fix!
  I've took a quick look and changed some stuff.
In general very solid.
I've removed the booleany = any type as mixed is favored over any for this. It's used for checks that require a truthy or falsy value. Flow doesn't have them, but mixed allows the return values to be any but won't loose any types. Any would loose them.
  I want an immutable object with typed properties (TypeScript). I want something like a Record, but without default values.

In Scala we have case classes that do this. Would it be possible to add this type to immutable-js?
 @OliverJAsh is this in TypeScript?

Did [this comment](https://github.com/facebook/immutable-js/issues/341#issuecomment-177268163) not work out for you?
 Yes, it is in TypeScript. Thanks for the link, I'm trying to make sense of it all but a lot of it is going over my head. Seems like it should be simpler?
 @OliverJAsh the immutable aspect you require does not _require_ ImmutableJS. You can use the type checking of TypeScript to achieve the same thing (indeed there is a performance benefit to doing so).

Consider:

``` ts
class A1 {
    private name: string;
    private age: number;
    private hobbies: Immutable.Set<string>;

    constructor() {
        // could set defaults here... or take parameters
        // to assign
    }

    Name(): string {
        return this.name;
    }

    SetName(v: string): A1 {
        if(v === this.name) {
            return this;
        }
        let res = this.dup();
        res.name = v;
        return res;
    }

    Age(): number {
        return this.age;
    }

    SetAge(v: number): A1 {
        if(v === this.age) {
            return this;
        }
        let res = this.dup();
        res.age = v;
        return res;
    }

    Hobbies(): Immutable.Set<string> {
        return this.hobbies;
    }

    SetHobbies(v: Immutable.Set<string>): A1 {
        if(v === this.hobbies) {
            return this;
        }
        let res = this.dup();
        res.hobbies = v;
        return res;
    }

    private dup(): A1 {
        let res = new A1();
        res.hobbies = this.hobbies;
        res.age = this.age;
        res.name = this.name;
        return res;
    }
}

let x1 = new A1();
let x2 = x1.SetName("Paul");

console.log(x1 === x2); // false
console.log(x1.Name()); // undefined
console.log(x2.Name()); // "Paul"
```

Here the model class `A1` is "immutable" in a roughly equivalent sense to the API exposed by containers etc in ImmutableJS.

You will notice the primitive properties (`string`, `number`) can be typed as such because a string value is immutable. `Array`, `Object` etc are mutable, hence you must use an ImmutableJS container for the types of such properties (e.g. `Hobbies`).

If you are using the latest [`nightly`](https://github.com/Microsoft/TypeScript/wiki/Nightly-drops) version of TypeScript you can avoid methods for the getters and do the following:

``` ts
class A1 {
    private name: string;
    private age: number;
    private hobbies: Immutable.Set<string>;

    constructor() {
        // could set defaults here... or take parameters
        // to assign
    }

    get Name(): string { // getter
        return this.name;
    }

    SetName(v: string): A1 { 
        if(v === this.name) {
            return this;
        }
        let res = this.dup();
        res.name = v;
        return res;
    }

    get Age(): number { // getter
        return this.age;
    }

    SetAge(v: number): A1 {
        if(v === this.age) {
            return this;
        }
        let res = this.dup();
        res.age = v;
        return res;
    }

    get Hobbies(): Immutable.Set<string> { // getter
        return this.hobbies;
    }

    SetHobbies(v: Immutable.Set<string>): A1 {
        if(v === this.hobbies) {
            return this;
        }
        let res = this.dup();
        res.hobbies = v;
        return res;
    }

    private dup(): A1 {
        let res = new A1();
        res.hobbies = this.hobbies;
        res.age = this.age;
        res.name = this.name;
        return res;
    }
}

let x1 = new A1();
let x2 = x1.SetName("Paul");

console.log(x1 === x2); // false
console.log(x1.Name); // undefined
console.log(x2.Name); // "Paul"
```
 @leebyron Is there any reason why `44b20e4` hasn't landed yet?
 > A default value must always exist, because you can always do myRecord.myField and it must return something, even if that something is undefined.

The constructor could error if not given all the specified parameters. Then if you don't have a `remove` method, only `set`, then no default values are needed to fall back on.
  To make them more consistent with the docs for `findLast` and `findLastEntry`, added the word `first` to make explicit that `find` and `findEntry` return the first element for which the predicate returns `true`.
  The link in the README (this one: https://www.npmjs.com/package/immutable/1.4.1) is a 404. I suggest linking to the repository itself, at your convenience.
  I am currently accessing an array with get() and then using length to get the length of the array. Which makes sense but I keep getting the following error requesting me to use 'size' or 'count()'.
If I call count or size on the iterable, it returns the size of the object as a whole and no the valueNode I am interested in. Is there a way of circumventing this issue?
 Samedi issue here..
I've posted something on stackoverflow for more details: http://stackoverflow.com/questions/36630133/immutables-and-redux-length-throwing-warning
 Getting the same error in my `react-native@0.25.1` setup.

```
2016-05-05 11:26:56.671 [warn][tid:com.facebook.react.JavaScript] iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. get@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:39715:145
http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120679:2652
isArrayLike@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:124753:2076
isArrayLikeObject@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:124777:2799
isArguments@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:124688:25
indexKeys@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:121421:2094
keys@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:126259:35979
baseGetAllKeys@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120469:3439
getAllKeys@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:121284:530
baseClone@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120320:147
http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120321:123
arrayEach@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:119532:2463
baseClone@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120321:10
http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120321:123
arrayEach@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:119532:2463
baseClone@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120321:10
http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120321:123
arrayEach@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:119532:2463
baseClone@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120321:10
http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120321:123
arrayEach@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:119532:2463
baseClone@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:120321:10
cloneDeep@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:124568:16403
render@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:117634:30
_renderValidatedComponentWithoutOwnerOrContext@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19940:40
_renderValidatedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19960:78
ReactCompositeComponent__renderValidatedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
_updateRenderedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19913:61
_performComponentUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19897:34
updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19826:35
ReactCompositeComponent_updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19758:25
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:32101:41
_reconcilerUpdateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31736:53
_updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31871:56
updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31846:29
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31444:24
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
_updateRenderedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19915:39
_performComponentUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19897:34
updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19826:35
ReactCompositeComponent_updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19758:25
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:32101:41
_reconcilerUpdateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31736:53
_updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31871:56
updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31846:29
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31444:24
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
_updateRenderedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19915:39
_performComponentUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19897:34
updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19826:35
ReactCompositeComponent_updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19758:25
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
_updateRenderedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19915:39
_performComponentUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19897:34
updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19826:35
ReactCompositeComponent_updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19758:25
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:32101:41
_reconcilerUpdateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31736:53
_updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31871:56
updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31846:29
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31444:24
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
_updateRenderedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19915:39
_performComponentUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19897:34
updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19826:35
ReactCompositeComponent_updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19758:25
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
_updateRenderedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19915:39
_performComponentUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19897:34
updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19826:35
ReactCompositeComponent_updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19758:25
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:32101:41
_reconcilerUpdateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31736:53
_updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31871:56
updateChildren@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31846:29
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:31444:24
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
_updateRenderedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19915:39
_performComponentUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19897:34
updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19826:35
ReactCompositeComponent_updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19758:25
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
_updateRenderedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19915:39
_performComponentUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19897:34
updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19826:35
ReactCompositeComponent_updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19758:25
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
_updateRenderedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19915:39
_performComponentUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19897:34
updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19826:35
ReactCompositeComponent_updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19758:25
receiveComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18220:38
_updateRenderedComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19915:39
_performComponentUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19897:34
updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19826:35
ReactCompositeComponent_updateComponent@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
performUpdateIfNecessary@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19774:27
performUpdateIfNecessary@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18235:46
runBatchedUpdates@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18799:45
perform@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19124:24
perform@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19124:24
perform@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18756:42
flushBatchedUpdates@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18817:26
ReactUpdates_flushBatchedUpdates@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4954:26
wrapper@[native code]
closeAll@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19190:29
perform@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:19137:24
batchedUpdates@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:26968:26
enqueueUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18846:36
enqueueUpdate@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18436:29
enqueueSetState@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:18602:18
setState@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:12162:31
keypadIsHide@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:1371:18
keypadIsHide@[native code]
http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:1359:32
emit@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:5993:40
__callFunction@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4462:34
http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4362:30
guard@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4313:7
callFunctionReturnFlushedQueue@http://192.168.2.134:8081/index.ios.bundle?platform=ios&dev=true:4361:12
callFunctionReturnFlushedQueue@[native code]
apply@[native code]
```
 thanks @leebyron that's latest public stable of `react-native` and it has a dependency on `immutable`.
  The immutable-js docs were recently updated.  One of the changes causes inherited methods to be omitted.  For example, although `Map` extends `Collection.Keyed`, none of the methods from the `Collection` classes appear on `Map`'s doc page.

Perhaps inherited methods can still be shown, but in a different color or tagged?  I miss being able to see them.
  - Before: `Iterable::take(Infinity)` returns empty iterable.
- After: `Iterable::take(Infinity)` returns iterable of previous size.

[Fixes #829]

I couldn't make all tests pass on master, but here are the two relevant tests:

```
â¯ node_modules/.bin/jest __tests__/slice.ts
Using Jest CLI v0.4.19
 FAIL  __tests__/slice.ts (1.232s)
â— slice â€º take â€º it converts to array with correct length
  - Expected: 0 toEqual: 6
        at Spec.<anonymous> (/Users/nico/workspace/immutable-js/__tests__/slice.ts:141:41)
1 test failed, 0 tests passed (1 total)
Run time: 1.472s
```

and

```
â¯ node_modules/.bin/jest __tests__/IterableSeq.ts
Using Jest CLI v0.4.19
 FAIL  __tests__/IterableSeq.ts (0.248s)
â— IterableSequence â€º it is stable
  - Expected: {

    } toEqual: {
    | 0: 0,
    | 1: 1,
    | 2: 2,
    | 3: 3,
    | 4: 4
    }
        at Spec.<anonymous> (/Users/nico/workspace/immutable-js/__tests__/IterableSeq.ts:16:52)
1 test failed, 0 tests passed (1 total)
Run time: 0.487s
```

If anything is missing, maybe I forgot a test), I'm happy to update this PR!
 Awesome, @nicolasbrugneaux & @leebyron, thanks for the fast turnaround! ðŸ˜„ 
  In one of the recent documentation updates, we lost documentation for mapEntries.  I don't see any discussion anywhere saying it's being deprecated, so maybe it just slipped through the cracks?
  Hi,

I have interface like this:

```
export interface IApplicationState {
  visibility: string;
  context: IContext;
}
```

In my service I have public var:
`public state: Map<String, IApplicationState>;`

how can i read this object?
console.log('res: ', this.state<IApplicationState>.visibility); 

any ideas?
 You read values from a `Map` by using the `.get()` method and passing in a key. In your case, this would be `this.state.get('visibility')`, I think.

For example:

``` js
import {Map, List} from 'immutable';

const cat = Map({
  name: 'Pliskin',
  appearance: Map({
    type: 'tabby',
    color: 'black'
  }),
});

console.log(cat.name); // undefined!
console.log(cat.get('name')); // 'Pliskin'
```

See https://facebook.github.io/immutable-js/docs/#/Iterable/get for more information.
   `.updateIn()` allows you to access nested data structures in your `List`. For example:

``` js
const cats = List([
  Map({
    name: 'Pliskin',
    appearance: Map({
      type: 'tabby',
      color: 'black'
    }),
  }),
  Map({
    name: 'Miller',
    appearance: Map({
      type: 'tabby',
      color: 'black'
    }),
  }),
]);

const updatedCats = cats.updateIn([0, 'appearance'], appearance => appearance.set('color', 'orange'));

// Alternatively:
const updatedCats = cats.updateIn([0, 'appearance', 'color'], color => 'orange');
// You should probably use `.setIn()` here instead if you're just setting a value, though!
```
  Let me preface this by saying that clone was removed in a previous version, and this essentially is the same function as clone. However, I'm going to provide a simple use case and argument why this function should exist.

For immutable objects, one might think that the 'state' of an object is frozen. Normally, when people think of this, they think that the properties of the immutable object are frozen. However, I tend to think a little bit beyond that fact and I also like to think that the point in time that the object was created at is also captured in an immutable object as well. That is, I view two immutable objects with identical properties as being frozen that are created at two different times to be different. Of course, this is a different definition of immutable objects as given here.

Of course, there are consequences to the above that may make certain usages of immutable objects harder to work with: I mean, there are definitely cases where you want to have two immutable objects as being declared as equal even if they are created at two different points in time; this is totally correct. I'm not looking to change this aspect of immutable objects.

However, I'm looking for the alternative to declare that I want a new immutable object with the same properties at a different time. In this sense, I'm declaring that the immutable object has changed, namely the timestamp when the immutable object is considered up to date.

Having a touch method (equivalently clone) allows me to do just this. I'm finding it incredibly difficult to replicate this functionality otherwise, and since there are no formal timestamp properties of immutable objects (to my knowledge), I'm unable to declare an operation that notifies that an immutable object is up-to-date, and refresh the objects.

The use case here is to have a react-redux component update when the element changes. This use case is arising from the fact that I'm storing objects in certain locations of an immutable JS object that fundamentally cannot be immutable (they are ES6 class objects, and aren't fundamentally data; this might be a violation of immutable's philosophy, but sometimes these design decisions have to be made). I want a way of notifying the store that the object has been updated, based solely on when I consider the object to be up-to-date, and this can be independent of the standard equality operation on immutable objects.

I can understand thinking that clone has no place in an immutable API, and in some regards maybe it doesn't, but at least consider this use case.
 Hello Lee,

At first glance, a clone method sounds like it should be just an identity function, given that we are working with immutable structures. However, there's two caveats here based on how it's implemented in JavaScript:
- We can still add mutable sections to immutable objects.
- Equality of objects can be defined in multiple ways. In javascript, equality is typically defined as a "reference equality", meaning that two objects with the same values aren't considered equal unless they are the same object. Immutable employs a different form of equality checking, which checks to see if the corresponding values are equal between the two objects. Both are equally valid, depending on the context.

A clone method would create an object that, when compared to the original object, satisfies the immutable.js definition of equality, but not the Javascript reference equality check.

One application of this is:
- Given that you are storing a reference to a mutable object in your immutable structure (which sometimes cannot be avoided without great difficulty).it is helpful to have a way to notify that the contained mutable structure has changed, especially in the context of Redux components, where reference equality is exploited to notify that state has changed. A clone object operation is helpful here. (Although I refer to it as "touch" in reference to similar considerations for file system updates.)

If I was to think of a simple way of implementing this, I would probably say

`Map.prototype.clone = function () {
   return this.toMap()
}`

And similarly for other immutable.js objects as well.
 @jamespedid 

> However, I'm looking for the alternative to declare that I want a new immutable object with the same properties at a different time. In this sense, I'm declaring that the immutable object has changed, namely the timestamp when the immutable object is considered up to date.

Why not create a higher level immutable object that contains your current immutable object but also has a timestamp field (could implement this via a record for example). The clone functionality you require could then be achieved by simply updating the timestamp on the higher level immutable object to the current time.
 @myitcv While this is a simple workaround, it really begins to clutter the extraction of data out of immutable objects, and potentially doubles the number of objects there. While the objects are small, this approach is less ideal than being able to declare that an object has been touched, even though immutable's data structures might not be privy to that information.
 > and potentially doubles the number of objects there.

What calculation leads you to this conclusion?

In my proposal, touching the timestamp would simply create one additional object, the top level immutable object. The contained immutable object would not, by definition, change (because you have changed the data "underneath" it)
 @myitcv Each object has its own wrapper; not two clones of the same object. Sorry if that wasn't clear. It's a few more small objects in memory, not a huge deal in that regard. I'm more annoyed with having to wrap the object or otherwise maintain a timestamp.

To be clear, are you suggesting that the addition of a touch/clone function would be bloat? This library already has some syntactic sugar around it, such as update, toMap, etc, and I see the clone operation in the same way; I would rather use those functions to clone objects instead of maintaining a wrapped object with a timestamp.
 @jamespedid 

>  I'm more annoyed with having to wrap the object or otherwise maintain a timestamp

If you don't have control over the creation of objects (and therefore their types) you are dealing with then this may be a cost you have to bear.

> are you suggesting that the addition of a touch/clone function would be bloat

Yes, sort of. Because `clone`, `dup`, whatever we may call it, won't actually do any of those things. The function (let's call it [`touch`](http://www.computerhope.com/unix/utouch.htm) for the sake of analogy with the Unix program) will simply give you a new instance of the top level immutable object; but it's contents will have not changed in any way. So by the semantics of the Immutable JS library then these two top level objects should be the same object.

It's not so much bloat as you introduce something that is incongruous as far as the library and its intended semantics are concerned.
 +1.

You're overstating the confusion. Record objects with identical content but different JS references already exist, and need to be understood if you're using things like React PureComponents.   Since method 'map' was introduced only in ES5, we need to fix description
  Apologies for the newbie question, however, Im struggling with this:

My state is like this:

```
import { List as list,
         Map as map } from "immutable";

const initialTabState = list.of(
    map({
        tabClass : "tabPreview tab activeTab",
        tabName : "Preview"
    }),
    map({
        tabClass : "tabBody tab",
        tabName : "Body"
    }),
    map({
        tabClass : "tabSleeve tab",
        tabName : "Sleeve"
    })
);
```

In my reducer function, I get 'typeError' when I do this:
`console.log( "Initial State is...", initialTabState.isList() );`

And how do I 'read' the value of third Map obj nested within the 'initialTabState' if I was to read it in console?

Thanks for the help
 If you want to read the third value you can do `initialTabState.get(2)`, and if you want to read a nested value you can do `initialTabState.getIn([2, 'tabName'])`, passing it an array, and same works for setting values.
  Just a small question about `Repeat`. I'm just wondering if this thought makes any sense.

``` js
const _list = Repeat(0);
const zeroArray = n => _list.take(n);

console.log(zeroArray(10) === zeroArray(10));
```

Currently the last statement logs `false`, but naively I thought it'd be `true`, am I missing something there?
  For some reason
    I'm building a simple react/flux application using the store from flux/utils and, of course, Immutablejs.
When the application boot initially the state retrieved from store is an Immutable.map but after a dispatch the map turns magically to object keeping all the map properties but throwing an exception when I try to get a key value.

My dispatcher:

```
export function dispatch(type, action = {}) {

    if (!type) {
        throw new Error('You forgot to specify type.');
    }

    // In production, thanks to DefinePlugin in webpack.config.production.js,
    // this comparison will turn `false`, and UglifyJS will cut logging out
    // as part of dead code elimination.
    if (process.env.NODE_ENV !== 'production') {
        // Logging all actions is useful for figuring out mistakes in code.
        // All data that flows into our application comes in form of actions.
        // Actions are just plain JavaScript objects describing â€œwhat happenedâ€.
        // Think of them as newspapers.
        if (action.error) {
            console.error(type, action);
        } else {
            console.log(type, action);
        }
    }
    debugger;
    flux.dispatch({ type, ...action });
} 
```

my store

```
class TabStoreClass extends Store {

    constructor(dispatcher, store) {
        super(dispatcher, store);
        this._store = store;
    }

    getStore() {
        return this._store;
    }

//Register each of the actions with the dispatcher
//by changing the store's data and emitting a
//change
    __onDispatch(payload) {

        const { type, activeKey } = payload;

        switch (type) {
            case ActionTypes.CHANGE_TAB:
                this._store = this._store.update("activeKey", (activeKey) => activeKey);
                this.__emitChange();
                break;
        }
    }
}
```

and the component:

```
export default class AppContainer extends Component {

    constructor(props) {
        super(props);
        this.state = TabStore.getStore();
    }

    componentDidMount() {
        TabStore.addListener(this._onChange);
    }

    componentWillUnmount() {
        TabStore.remove();
    }

    _onChange = () => {
        this.setState(TabStore.getStore());
    }

     render() {
         // AFTER A DISPATCH THE STATE TURNS TO OBJECT!!!!
         console.log("state", this.state);

         return (<BLA></BLA>)
     }
}
```

 [Image](http://postimg.org/image/7ke95f7of/) of the error as well.

Am I doing something wrong (for certain) or is it a bug?
  Can we get immutablejs integrated with [Typescript community stubs](http://definitelytyped.org/guides.html)? I would really help with the intellisense and autocompletion features?
 @tusharmath - there is no need for a type definition (that's what's DefinitelyTyped is about, type definitions) to be hosted on DefinitelyTyped for intellisense or auto-completion to work. The type definition simply needs to be referenced in some way, directly or indirectly, by `tsconfig.json` (or similar) and intellisense/auto-completion (assuming you're using some sort of 'standard' TypeScript setup) will simply work.

In some ways your request is related to #779, but this isn't a blocker - you can make it work, albeit somewhat manually for now.
  I recently ran across the Clojure(Script) library [Specter](https://github.com/nathanmarz/specter) which adds querying and transforming functionality to Clojure's immutable data structures. For instance, a simple example from their docs:

```
(transform [ALL :a even?]
              inc
              [{:a 1} {:a 2} {:a 4} {:a 3}])
[{:a 1} {:a 3} {:a 5} {:a 3}]
```

There appears to be a lot of other functionality there, too, especially for querying and transforming nested data structures.

Obviously one can do this with the current version of Immutable.js, and I'm not sure if this is better included or as an add-on, but I found it very, very interesting and thought I would mention it here.
  Just like `merge` but with ability to remove non-existent values. Use case: new collection was received and we need to update Map/List/... but we want to save equality if no changes. Like `merge` do:

``` javascript
var base = Immutable.Map({x: 1, y: 2});
var same = base.merge({x: 1, y: 2});
var changed = base.merge({x: 1, y: 3});
same === base // true
changed === base // false
```

Example:

``` javascript
var base = Immutable.Map({x: 1, y: 2});
var same = base.replace({x: 1, y: 2});
var changed = base.replace({x: 1, y: 3});
var removed = base.replace({x: 1});
var added = base.replace({x: 1, y: 2, z: 3});
same === base // true
changed === base // false
removed === base // false
added === base // false
```
 And of course it will be nice to have `replaceDeep`, `replaceIn` and `replaceDeepIn`.
 Is what you are proposing essentially:

``` javascript
if (Immutable.is(base, replaced)) {
  base = replaced;
}
```

? It would help if you showed what `changed`, `removed`, `added` contain to make it clearer.
 Sorry I was not very clear. `replace` is like `merge` but with ability to remove non-existent keys/list elements from current Map/List.

``` javascript
var base = Immutable.Map({x: 1, y: 2});

var added = base.replace({x: 1, y: 2, z: 3});
// added contains {x: 1, y: 2, z: 3}
// replace added new 'z' key just like merge

var replaced = base.replace({x: 5, y: 2})
// replaced contains {x: 5, y: 2}
// just like merge

var removed = base.replace({x: 1})
// removed contains {x: 1}
// key 'y' removed
```

More real life example:

``` javascript
var initial = {
  eclair: {api: '2.0', name: "Eclair"},
  honeycomb: {api: '3.0', name: "Honeycomb"},
  ice_cream_sandwich: {api: '4.0', name: "Ice Cream Sandwich"},
  lollipop: {api: '5.0', name: "Lollipop"}
};

var supportedDroids = Immutable.fromJS(initial);


// update from backend
var update1 = {
  eclair: {api: '2.0', name: "Eclair"},
  honeycomb: {api: '3.0', name: "Honeycomb"},
  ice_cream_sandwich: {api: '4.0', name: "Ice Cream Sandwich"},
  lollipop: {api: '5.0', name: "Lollipop"}
};

var sameSupportedDroids = supportedDroids.replaceDeep(update1);

// map is the same
// sameSupportedDroids === supportedDroids


// second update from backend
var update2 = {
  ice_cream_sandwich: {api: '4.0', name: "Ice Cream Sandwich"},
  lollipop: {api: '5.0', name: "Lollipop"}
}

newSupportedDroids = supportedDroids.replaceDeep(update2);

// map changed
// newSupportedDroids != supportedDroids
```
 Cool, that's what I thought it does. I think what you want would be more clearly expressed this way:

``` javascript
// ...
if (!Immutable.is(sameSupportedDroids, update) {
  sameSupportedDroids = update;
}
```

Hope that helps.
  I had a List, and needed to see if the List contained a certain immutable object, and if so what the index was. 

StackOverflow led me to the `findIndex` method, which works great. 

It seems to not be included in the docs at all though. It's not mentioned on [List](https://facebook.github.io/immutable-js/docs/#/List) or [Iterable](https://facebook.github.io/immutable-js/docs/#/Iterable). 

Am I missing something? Is there a reason it's not doc'd?
 http://stackoverflow.com/a/29655323/233902
 Right, it's mentioned in a StackOverflow answer. I would expect it to be listed in the generated method API docs, no?
 Yes, me too. 
 thanks! 
  The result of `groupBy` is strange and I think wrong when your `groupBy` key is an array or an object.
I found #325 but it seems thats it's more than that when you have non-empty objects / arrays.

Here the jsfiddle exemple: https://jsfiddle.net/bLr50640/3/

Thank you !
 The wrong results are l.11 and l.16.

The `size` result is wrong.

If you run then `result.forEach((v, k) => { console.log(k, v); })`, you have the following output :

``` js
Object {a: "1", b: "1"} Wt {size: 1, _origin: 0, _capacity: 1, _level: 5, _root: nullâ€¦}
Object {a: "1", b: "2"} Wt {size: 1, _origin: 0, _capacity: 1, _level: 5, _root: nullâ€¦}
Object {a: "1", b: "2"} Wt {size: 1, _origin: 0, _capacity: 1, _level: 5, _root: nullâ€¦}
```

with the same keys on the second and third iteration instead of 

``` js
Object {a: "1", b: "1"} Wt {size: 1, _origin: 0, _capacity: 1, _level: 5, _root: nullâ€¦}
Object {a: "1", b: "2"} Wt {size: 2, _origin: 0, _capacity: 2(?), _level: 5, _root: nullâ€¦}
```
  I have come across an Issue where a library I am using implements `.equals()` on its objects. These are internally crucial to the functioning of the library, however they should not be used by ImmutableJS, just because two items are what the library considers equal doesn't mean I want them to be considered the same by ImmutableJS.

I want these to only be equal if they reference the same object. Is there any way currently to do that? If not this should really be optional as a lot of people using external modules do not have full control over the object prototypes and `.equals()` is going to be fairly prevalent that I imagine a fair few libraries will have side effects with ImmutableJS.
 As a counterpoint, I implemented `.equals()` (and friends) in [`results`](https://github.com/uniphil/results) specifically for compatibility with Immutable. It's nice to be able to do that without introducing a dependency on Immutable, but I suppose it could do bad things if you didn't expect it.
 It could use a shared symbol rather than a fixed string.
 @leebyron I don't see why it couldn't be optionally disabled. A setting on Immutable, or the ability to specify your own function name for this that just defaults to `equals`:

``` js
const set = Immutable.Set();
set.compareWith('equals');
```

to change on an individual basis or change it globally:

``` js
Immutable.compareWith('equals');
Immutable.compareWith(null); // Just do strict object equality
```

This doesn't have to be a breaking change. But as it stands it makes ImmutableJS unusable with certain other libraries. Internally you can check for instances of an `Collection` and still use the regular function names.

There are other benefits to this approach too which allows you to use other libraries that have built in comparison methods with names other than `equals`. The current solution seems far too rigid in this age of a thousand NPM packages.
 Any updates on this? @georeith's solution seems reasonable.
  I have two structures:

```
NEXT Map { "entries": List [ "Trainspotting" ], "vote": Map { "pair": List [ "Brak", "Forest Gump" ], "history": List [ Map { "X": 3, "Y": 1 }, Map { "Trainspotting": 3, "Shawshank": 1 } ] }, "key": "val" }
EXPE Map { "entries": List [ "Trainspotting" ], "vote": Map { "pair": List [ "Brak", "Forest Gump" ], "history": List [ Map { "X": 3, "Y": 1 },Map { "Trainspotting": 3, "Shawshank": 1 } ] }, "key": "val" }
```

So they are seemingly the same (note the missing space in bottom one). But when I run toJSON() method on them:

```
 AssertionError: expected { Object (entries, vote) } to equal { Object (entries, vote) }
      + expected - actual

                   "ownerID": {}
                 }
                 "size": 2
               }
      +        {
      +          "__altered": false
      +          "__hash": [undefined]
      +          "__ownerID": [undefined]
      +          "_root": {
      +            "entries": [
      +              [
      +                "Trainspotting"
      +                3
      +              ]
      +              [
      +                "Shawshank"
      +                1
      +              ]
      +            ]
      +            "ownerID": {}
      +          }
      +          "size": 2
      +        }
             ]
      -      {
      -        "Shawshank": 1
      -        "Trainspotting": 3
      -      }
           ]
           "pair": [
             "Brak"
             "Forest Gump"
```

The piece of code that changes the Map is:

```
  const tally = voteState.has('tally') ? voteState.get('tally') : false;
  console.log('TALLY', tally); // TALLY Map { "Trainspotting": 3, "Shawshank": 1 } <--- so it's a map

  const resultState = state
    .setIn(['vote', 'pair'], entries.take(2))
    .setIn(['entries'], entries.skip(2))
    .removeIn(['vote', 'tally']);
  if (tally) {
    return resultState.updateIn(['vote', 'history'], new List(), history => history.push(tally)); // <---- it's somehow turned into plain JS object here?
  }
```

What am I doing wrong? It seems like a bug. (note the missing space in the dumped structure in first code block. 

The full code can be seen in https://github.com/tomasfejfar/redux-voting/commit/d76b11f4e6cce5b364afa0638291b4e57bc21746
 It's here https://github.com/tomasfejfar/redux-voting/commit/d76b11f4e6cce5b364afa0638291b4e57bc21746#diff-28a6632d75cca173e3381ccb03a73e50L73
  I saw at the bottom of your docs

> Documentation
> 
> Read the docs and eat your vegetables.
> 
> **Docs are automatically generated from Immutable.d.ts. Please contribute!**
> 
> Also, don't miss the Wiki which contains articles on specific topics. Can't find something? Open an issue.

So do you (Facebook) use YUIDoc, Docco, JSDoc or https://github.com/documentationjs/documentation ?

Please let me know! I would love to use something similar.
 Looks like this file gives me some clues:
https://github.com/facebook/immutable-js/blob/master/gulpfile.js

but if you could give me a definitive answer that would be really nice.
 I understand the convenience for auto-generated docs, but:

```
findKey(
  predicate: (
    value?: T,
    key?: number,
    iter?: Iterable.Keyed<number, T>
  ) => boolean,
  context?: any
): number
```

This is rather illegible to me, and is kind of a bummer when I'm trying to learn Immutable. I assume `?` means optional? What is `T`? `context` accepts any type of object.. but what is `context`? What does it mean, how do we use it?
 What's the best way to contribute examples? (and where should they go?) It might be cool to have a "cookbook" section that has some basic common usages, like using with Redux.
 Related: you can use the `gulp dev` task to fire up a local server that serves the docs. Check out https://github.com/facebook/immutable-js/pull/844 for LiveReload functionality when changing the type definitions found in `/type-definitions/`.
 @leebyron I've started to put something together. Please feel free to correct/optimize any of these!

https://gist.github.com/ffxsam/6c9c4fca019eac0dec045ef303affa3c
 Hopefully I'm not being too presumptuous here, but..

Since Immutable is under the umbrella of Facebook, and the devs working on these projects are employees of (and hence paid by) FB.. is it possible someone could be tasked with writing up new documentation? Three times now I've almost given up on using Immutable because it's _so_ frustrating to grasp the docs. I'm not alone in this sentiment:

http://stackoverflow.com/q/29589753/5228806 (see the comments)
 I have been using this library in all projects over the last year, and almost every time I reach for the docs, I think the same thing.  This documentation has to be a serious barrier to entry for (at least) new users.

Having complete docs with a similar structure to lodash/ramda etc... would be extremely useful.
And would encourage lots more people to use the library in their projects. 

Title -> Type Definition (non-TS) -> Description -> Example

The library is innovative on its own, the docs don't need to be, IMO.
 I feel the original concern raised by @ffxsam  wasn't addressed completely, it was focused on that confusing syntax and what it means.  Honestly, I think the docs would greatly benefit from adding examples, but also from removing this kind of stuff:

> sort(comparator?: (valueA: T, valueB: T) => number): Iterable<number, T>

If it stays, the first section of the docs should be an intro to this notation, why it's used, and how to use it, as requested in #298 
 Learning Typescript does not take that long. Type Definitions are a great way to learn any API Surface.
They made my life much better. Also there are a _lot_ of comments in the Immutable one:
https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts

What I agree with is that there should be more examples.
  With Map:

```
var map = Immutable.Map({one: 'one', two: 'two', three: 'three'});
map.keySeq().last();
// 'three'
```

With List though:

```
var list = Immutable.List(['one', 'two', 'three']);
list.keySeq().last();
// -1
```

Am I missing something or is this in fact a bug? 
  As noted in #734 it is now possible to tell TypeScript where to find type defs in `package.json` by setting the `typing`s property.

However the `immutable.d.ts` file is an ambient module (exports a module path name as a string). This is why pull request #779 didn't work. What is needed is a plain module that directly exports all the members of the namespace (there is no need for a top-level layer of wrapping as that is supplied by the external module).

There doesn't appear to be a way to define a module in one file and reuse it in both ambient and non-ambient contexts. So I've added a trivial bit of regex find-and-remove to the existing gulp task 'typedefs' to generate `dist/immutable-nonambient.d.ts`, and amended `package.json` to expose via the typings property.

This means `immutable.d.ts` can continue to be maintained as it is, as long as the two significant bits of wrapping are left as they are. Maybe they should have comments around them in `immutable.d.ts` to warn people against changing them?

Another option is to make the non-ambient version be definitive, as it only needs to be prefixed/suffixed as follows to make the equivalent of the existing ambient version:

```
declare module Immutable {

    // non-ambient file content goes here
}

declare module "immutable" {
  export = Immutable
}
```

Also I haven't removed the `typescript` property in `package.json` in case it is important for backward compatibility. It appears to be harmless.
  I use List/Map collections in my Redux store, and have problem with maintaining map sizes (i need last 5-6 records only)

First attempt to resolve this problem was to create helper function:

``` javascript
static sliceMap(map, maxSize = 5) {
    if (!ImmutableUtils.isImmutable(map)) {
        return map;
    }

    if (map.size <= maxSize) {
        return map;
    }

    return map.slice(map.size - maxSize);
}
```

And use it like 

``` javascript
let newMap = ImmutableUtils.sliceMap(oldMap);
```

But It's not good solution for me, as i have to call this method every time when i need to mutate map

---

Second attempt was to create new class and extend it with map, override `set`/`setIn`, but super methods will always return new map instance, so it was just pointless

---

So the only solution that is see to create new collections like: `LRUMap`, `LRUList` and else inspired by https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/map/LRUMap.html

---

**EDIT**

Found final solution for my problem

``` javascript

let data = Immutable.OrderedMap(); data.toString();

// "OrderedMap {}" - we need OrderedMap (for ... you know ... ordering)
data = data.set(1, 1).set(2, 2).set(3, 3).set(4, 4).set(5, 5).set(6, 6).takeLast(5); data.toString();
// "OrderedMap { 2: 2, 3: 3, 4: 4, 5: 5, 6: 6 }" - look good enough
data = data.set(2, 3).takeLast(5); data.toString();
// "OrderedMap { 2: 3, 3: 3, 4: 4, 5: 5, 6: 6 }" - here we got problem, key '2' took it's previous position
data = data.delete(2).set(2, 3).takeLast(5); data.toString();
// "OrderedMap { 3: 3, 4: 4, 5: 5, 6: 6, 2: 3 }" - that's better
data = data.delete(3).set(3, 4).takeLast(5); data.toString();
// "OrderedMap { 4: 4, 5: 5, 6: 6, 2: 3, 3: 4 }" - yep
data = data.delete(7).set(7, 7).takeLast(5); data.toString();
// "OrderedMap { 5: 5, 6: 6, 2: 3, 3: 4, 7: 7 }" - finally

// working example

static handleFetchSuccess(state, {response, id}) {
        return state
            .update('dataLoading', item => item.delete(id))
            .update('data', item => item.delete(id).set(id, fromJS(response)).takeLast(10));
}
```
 @leebyron Thanks for your response,

Implementing LRU will require update `Collection` every time when user `get`s data from it, so it's impossible to keep `Collection` immutable in this case.

My bad, did't do researches before asking question, but still, what about `LimitedMap`?

I really interested in this feature and after some researches of `immutable-js` I have a solution proposal:

``` javascript
import { LimitedMap } from 'immutable';

const ShortMap = new LimitedMap(5, 'ShortMap');
let shortMap = new ShortMap({1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f'});

shortMap.toString(); // "ShortMap { "2": "b", "3": "c", "4": "d", "5": "e", "6": "f" }"
```

As you can see, definition look like you did it for `Record`s,
That's allow to define own `Map`/`List`/ `Set` classes with limited sizes.

So I wanted to know your opinion about that. Should I create PR to start implementation, or it's better to keep it as separate lib? (e.g. 'immutable-limited-collections')

---

Here `LimitedMap` example

In `OrderedMap.js` export its `prototype`

``` javascript

var IS_ORDERED_MAP_SENTINEL = '@@__IMMUTABLE_ORDERED_MAP__@@';

export var OrderedMapPrototype = OrderedMap.prototype;
OrderedMapPrototype[IS_ORDERED_MAP_SENTINEL] = true;
OrderedMapPrototype[DELETE] = OrderedMapPrototype.remove;
OrderedMapPrototype.removeIn = OrderedMapPrototype.deleteIn;

```

`LimitedMap.js` - it's basically refactored copy of `Record.js`

<details>
  <summary>Implementation</summary>

``` javascript
import { OrderedMap, OrderedMapPrototype, emptyOrderedMap } from './OrderedMap';
import { DELETE } from './TrieUtils'

export class LimitedMap extends OrderedMap {

    //noinspection JSAnnotator - suppress `Missed superclass's constructor invocation` error in webstorm
    constructor(limit, name) {
        var hasInitialized;

        var LimitedMapType = function LimitedMap(values) {
            if (values instanceof LimitedMapType) {
                return values;
            }
            if (!(this instanceof LimitedMapType)) {
                return new LimitedMapType(values);
            }
            if (!hasInitialized) {
                hasInitialized = true;
                LimitedMapPrototype._name = name;
                LimitedMapPrototype._limit = limit;
            }
            this._map = OrderedMap(values).takeLast(limit);
        };

        var LimitedMapPrototype = LimitedMapType.prototype = Object.create(LimitedMapPrototype);
        LimitedMapPrototype.constructor = LimitedMapType;

        return LimitedMapType;
    }

    toString() {
        return this.__toString(limitedMapName(this) + ' {', '}');
    }

    // @pragma Access

    has(k) {
        return Boolean(this._map) && this._map.has(k);
    }

    get(k, notSetValue) {
        return this._map ? this._map.get(k, notSetValue) : notSetValue;
    }

    // @pragma Modification

    clear() {
        if (this.__ownerID) {
            this._map && this._map.clear();
            return this;
        }
        var LimitedMapType = this.constructor;
        return LimitedMapType._empty || (LimitedMapType._empty = makeLimitedMap(this, emptyOrderedMap()));
    }

    set(k, v) {
        var newMap = this._map;
        var limit = this._limit;

        if (newMap) {
            newMap = newMap.asMutable(); // I wanted to use `withMutations` here but `takeLast` doesn't work in it

            if (newMap.has(k)) { // we don't want to replace previous value, so remove it before setting new
                newMap.delete(k);
            }

            newMap.set(k, b); 

            if (newMap.size > limit) {  // this part maybe need to be optimized 
                newMap = newMap.takeLast(limit);
            }

            newMap = newMap.asImmutable();
        }

        if (this.__ownerID || newMap === this._map) {
            return this;
        }

        return makeLimitedMap(this, newMap);
    }

    remove(k) {
        var newMap = this._map && this._map.remove(k);
        if (this.__ownerID || newMap === this._map) {
            return this;
        }
        return makeLimitedMap(this, newMap);
    }

    wasAltered() {
        return this._map.wasAltered();
    }

    __iterator(type, reverse) {
        return this._map.__iterator(type, reverse);
    }

    __iterate(fn, reverse) {
        return this._map.__iterate(fn, reverse);
    }

    __ensureOwner(ownerID) {
        if (ownerID === this.__ownerID) {
            return this;
        }
        var newMap = this._map && this._map.__ensureOwner(ownerID);
        if (!ownerID) {
            this.__ownerID = ownerID;
            this._map = newMap;
            return this;
        }
        return makeLimitedMap(this, newMap, ownerID);
    }
}

var LimitedMapPrototype = LimitedMap.prototype;
LimitedMapPrototype[DELETE] = LimitedMapPrototype.remove;
LimitedMapPrototype.deleteIn =
    LimitedMapPrototype.removeIn = OrderedMapPrototype.removeIn;
LimitedMapPrototype.merge = OrderedMapPrototype.merge;
LimitedMapPrototype.mergeWith = OrderedMapPrototype.mergeWith;
LimitedMapPrototype.mergeIn = OrderedMapPrototype.mergeIn;
LimitedMapPrototype.mergeDeep = OrderedMapPrototype.mergeDeep;
LimitedMapPrototype.mergeDeepWith = OrderedMapPrototype.mergeDeepWith;
LimitedMapPrototype.mergeDeepIn = OrderedMapPrototype.mergeDeepIn;
LimitedMapPrototype.setIn = OrderedMapPrototype.setIn;
LimitedMapPrototype.update = OrderedMapPrototype.update;
LimitedMapPrototype.updateIn = OrderedMapPrototype.updateIn;
LimitedMapPrototype.withMutations = OrderedMapPrototype.withMutations;
LimitedMapPrototype.asMutable = OrderedMapPrototype.asMutable;
LimitedMapPrototype.asImmutable = OrderedMapPrototype.asImmutable;

function makeLimitedMap(likeLimitedMap, map, ownerID) {
    var limitedMap = Object.create(Object.getPrototypeOf(likeLimitedMap));
    limitedMap._map = map;
    limitedMap.__ownerID = ownerID;
    return limitedMap;
}

function limitedMapName(limitedMap) {
    return limitedMap._name || limitedMap.constructor.name || 'Record';
}
```

</details>
 It has been a long time since then, i've tried max heap, btree, and Java TreeMap, and found it useless for current task - because of runtime normalization. 

Everything that I need is limited size, and strict ordering. So I dropped the idea of new implementation and keep using `OrderedMap` + `takeLast`.

But it was a previous story.

____

Recently I start working on custom caching collections and implemented custom `LinkedMap` with es6 `Map` inside of it. And after some time I found that I need to store Immutable collections as keys and I remembered current issue. 

Basically this `LinkedMap` works like `OrderedMap` with three differences:
1. It has limited size. ðŸ‘
2. It **always** adds value to the end, even if it's already in map. ðŸ‘
3. It's not immutable. ðŸ‘Ž

So I guess it will be more efficient than using `OrderedMap` (with `Map` and `List` inside of it).
___
And finally -- **Proposal**.

Add new `LinkedMap` collection with:
* `Map` interface.
* **Strict** ordering.
* `setFirst` and `setLast` methods.
* `set` will behave as `setFirst`.
* Custom Class Builder (like `Record` constructor) to allow:
   * Limited Size
   * Anything else in the future.

For example:
```
import { LinkedMap, LinkedMapBuilder } from 'immutable';

const lm = new LinkedMap().set(1, 0).set(2, 0).set(1, 0); // LinkedMap { 2: 0, 1: 0 }

const CustomLinkedMap = LinkedMapBuilder({ maxSize: 2 }, 'CustomLinkedMap');
const clm = CustomLinkedMap().set(1, 0).set(2, 0).set(1, 0).set(3, 0); // LinkedMap { 1: 0, 3: 0 }  This pull request includes type definitions, and adds a step to the build process to copy the type definitions to `dist/`. With the definitions file in `dist/`, users who import Immutable and who use Flow will pick up the type definitions automatically.

This is intended to address issue #203.

An important caveat when using these definitions is that the types for `Iterable.Keyed`, `Iterable.Indexed`, `Seq.Keyed`, and so on are stubs. When referring to those types, you can get the proper definitions by importing the types `KeyedIterable`, `IndexedIterable`, `KeyedSeq`, etc. For example,

``` js
import { Seq } from 'immutable'
import type { IndexedIterable, IndexedSeq } from 'immutable'

const someSeq: IndexedSeq<number> = Seq.Indexed.of(1, 2, 3)

function takesASeq<T, TS: IndexedIterable<T>>(iter: TS): TS {
  return iter.butLast()
}

takesASeq(someSeq)
```

This is because I have not been able to work around issues Flow has with a class holding a reference to its own subclasses, and with overriding static properties with values that have different types. (E.g., `Seq.Keyed` is not the same type as `Iterable.Keyed`, but `Seq` is a subclass of `Iterable`.)
 +1 This is very useful. 
Btw, I thinks you could also add a flow type file for `contrib/cursor`
 @hallettj Keen to get flow working in our codebase at work so I took this for a spin as it's looking promising judging by conversation over at #203.

Hit a blocker straight away though with the `Record` type. The following doesn't type check:

``` javascript
import {Record} from 'immutable';

const Project = Record({
    id: undefined
});

const myProject = new Project({
    id: 1
});
```

will give the error:

```
test.js:7
  7: const Project = Record({
                     ^ function call
 12:    id: 1
            ^ number. This type is incompatible with
  8:    id: undefined
            ^^^^^^^^^ undefined
```

Am I missing something extra to get flow working here? I saw the paragraph in #203 about Records but it seems to me like the above (standard way of using records) should still work alongside being abl to generate a stricter type with the desired record shape?

_I guess this highlights another requirement for this PR... Docs! :)_

I will update this with any other findings I might make.
 @Chrisui Does this work?

``` js
const Project = Record({
    id: (undefined: number|void)
});
```
 @samwgoldman yup!

So many nifty little tricks hidden away with flow! (okay they may not be "hidden", that "nifty" or "tricks" but to me they are! :))
 @samwgoldman Is there any way we can support the following?

``` javascript
import {Record} from 'immutable';

function createApiRecord(values) {
  const NewRecord = Record(values);

  return class ApiRecord extends NewRecord {
    static TYPE = values.type;
  };
}

const Project = createApiRecord({
  type: 'project',
  id: (undefined: string|void)
});

const myProj = new Project({
  id: '1'
});
```

Current errors:

```
test.js:8
  8:   const NewRecord = Record(values);
                         ^^^^^^^^^^^^^^ function call
 10:   return class ApiRecord extends NewRecord {
                                      ^^^^^^^^^ identifier `NewRecord`. Expected polymorphic type instead of
 10:   return class ApiRecord extends NewRecord {
                                      ^^^^^^^^^ function type
```

The purpose of this is to provide some introspection to our records. Ie. nicer to do `type === Record.TYPE` than `type === (new Record()).type`
 @tsing: Thanks for the feedback! I don't use the cursor feature. (I prefer to use my own [lens library](https://github.com/hallettj/safety-lens).) I'm not inclined to write type definitions for a module that I do not plan to use. But if you or someone else want to add definitions for cursor types, I think that would be done by creating a file `contrib/cursor/index.js.flow`.
 > I guess this highlights another requirement for this PR... Docs! :)

Speaking of which... are there any? :) How are Records supposed to work?

For the following file:

```
// @flow

import { Record } from 'immutable';

const Project = Record({
  price: 123
});
const test = new Project({
  price: /not a number/
});

// I think all of these should be errors:
test.set('price', 'definitely not a number');
console.log(test.doesNotExist);
console.log(test.id.substr(1));
```

I only get a single error:

```
$ flow check

immutable-test.js:40
 40:   price: /not a number/
              ^^^^^^^^^^^^^^ RegExp. This type is incompatible with
 36:   price: 123
              ^^^ number

Found 1 error
```

I've also tried the syntax outlined in https://github.com/facebook/immutable-js/issues/203#issuecomment-187175318, but it doesn't seem to fair any better in catching these issues.

Is Record support just not there yet?

```
$ flow version
Flow, a static type checker for JavaScript, version 0.23.0
$ npm list | grep immutable
+-- immutable@3.8.0
```
 First off, thank you so much for that work, it is super amazing to have flow definitions in immutable js now!

With the flow definitions that were floating around previously we could define a record as an ES6 class and have flow correctly typecheck it. Now with immutable 3.8.0 and flow 0.23.0 this doesn't work any more.

``` js
/* @flow */

import { Record } from 'immutable'

export default class Person extends Record({
  name: null,
  email: null,
}) {
  name: string;
  email: string;
}
```

```
  5: export default class Person extends Record({
                                         ^ function call. Expected polymorphic type instead of
  5: export default class Person extends Record({
                                         ^ function type
```

Can anyone point me in the right direction in order to fix this?
 @jareware: There are notes on the limitations of record type-checking in [this comment](https://github.com/facebook/immutable-js/issues/203#issuecomment-187175318) from the discussion on #203. That is certainly not the best place for that information.
 > With the flow definitions that were floating around previously we could define a record as an ES6 class and have flow correctly typecheck it. Now with immutable 3.8.0 and flow 0.23.0 this doesn't work any more.

@MSch : Thanks for the heads-up! I am looking into it.
 @hallettj I think this was already fixed in https://github.com/facebook/immutable-js/pull/841 - at least my usage of Records typechecks again
 Hello, I am a little lost in all the comments and versions.

With the current flow and current head of your fork, how do the Records work and what they check and what they don't check?

Why is, for example, the Record signature

```
static <T: Object>(spec: T, name?: string): /*T & Record<T>*/any 
```

? When I uncomment the annotation as 

```
static <T: Object>(spec: T, name?: string): T & Record<T> 
```

it seems to work better.
 Also, shouldn't Iterable's (and therefore, Map's) `get` be like this

```
get(key: K): ?V;
get<V_>(key: K, notSetValue: V_): V|V_
```

instead of this

```
get(key: K): V;
get<V_>(key: K, notSetValue: V_): V|V_
```

?

Flow's Map has this

```
get(key: K): V | void;
```

I can't tell what's the difference between `V | void` and `?V`, it seems the same to me.
 @runn1ng wrote:

> Why is, for example, the Record signature

I put in the `T & Record<T>` return type, but it was commented out in c28c8ae3. Based on the code comments it looks like there are some problems with existing code. Hopefully the type will be changed back, or changed to something more accurate, when those problems are sorted out. I'm guessing that will require updates to Flow.

In the meantime you can get that type by putting explicit annotations in your code:

``` js
const MyRecord = Record({ /* whatever structure `MyType` has */ })
const myRecord: MyType & Record<MyType> = new MyRecord({ /* whatever */ })
```

Btw, @marudor, I love the changes that you made to the type definitions! I'm going to have to remember that trick with type parameters on `_Iterable` the next time I come across a similar problem of circular references.

> Also, shouldn't Iterable's (and therefore, Map's) `get` be like this

I agree that using `?V` as the return type for `get` would be more accurate. On the other hand it would force `undefined` checks to an extent that might be more annoying than helpful. There is much precedent for partial function types for data structure access (partial meaning a type that claims to return a value, when there are cases where it might not actually return a value). The choice of using a partial function or forcing a check for `undefined` is a judgment call. My own preference is to have both options: an unsafe partial function, and a safe version that does the same thing, but that expresses that the return value might be `undefined`.

> I can't tell what's the difference between `V | void` and `?V`, it seems the same to me.

Those types are nearly the same. I believe that `?V` is actually a shorthand for `V | void | null`. In most cases having the `null` alternative is not a problem, even if the function never actually returns `null`. I tend to use `?V` for brevity, even though it is slightly less precise than `V | void`.

_Edit_: My Record example was not actually correct.
 Thanks for the comments!

> There is much precedent for partial function types for data structure access (partial meaning a type that claims to return a value, when there are cases where it might not actually return a value). 

Hm. What I _do_ like about Flow is that it doesn't have partial function types and I cannot accidentally have undefined/null by mistake. And I am not sure about the precedent - as I said, in Flow's own Map, the returning type is `?V`.

But otherwise the definition file is great, I am using it right now.
 I actually talked with @leebyron about the ?V vs V on get.
We decided to go with V (for now)
One reason was to not break existing code.
Previous Immutable libdefs all had V instead of ?V.
And just as @hallettj said it was more annoying than helpful to have all the checks for undefined/null.
  Failing test for #803
 I forgot all about this! Yeah I can give it a whirl later this evening. @lacker conflicts resolved! Oh, I never provided a fix, just a failing test. I brought the initial bug up in #803, and it was requested that I provide a failing test to illustrate the behavior (I think @leebyron asked me via Twitter). I'd be happy to provide a fix if I can find the time to dig in. I'm not currently depending on immutablejs at the moment, so it's a bit low priority, so if nobody else can get to it it's not a huge deal.  I'm curious if this project is referencing any standards outside the JS standards for things like Maps and Lists. I want to improve Ramda.js to work well with Immutable, but I want to make sure I'm doing things right -- is there some central agreed-upon spec for things like List.slice or Map.get?
 Ok. Very pragmatic. Thanks!
  Why:
Website was linking to 404 pages.

How:
Change links to absolute links rather than relative links since the website has a different root than the Readme file. 
  Since TypeScript 1.7 there is a special type called `this` which can be used to simplify work with extended records:

``` ts
class Store extends Record({}) {

}

let store = new Store({});

// store is `Store` here

let newStore = store.withMutations(store => {
    // store is `Map` here!
    // so we can't access store instance methods anymore :-(
})

// newStore is `Map` here! not desired behavior
```

All we need to do to fix this issue is use `this` type:

```
withMutations(mutator: (mutable: this) => any): this;
```

It can be done in all the signatures that return a copy of an object.
 Is anyone working on this? Seems like it would fix the huge pain of working with records in TypeScript. With this change, this now correctly typechecks:

``` typescript
import * as I from 'immutable';

const StateRec = I.Record({
  a: 1,
  b: 'foo'
});

// We can define a class for this record extending I.Record.Class to specify
// the properties:
class State extends StateRec {
  a: number;
  b: string;
}

// state is an instance of the State class
const state = new State();
const stateP = state.set('a', 2);

// This fails to typecheck currently, because `stateP` is `Map<string, any>`
// However, if we simply change the declaration of Map.set to be:
//     set(key: K, value: V): this;
// it works just fine :)

console.log(stateP.a); 
```

Unless I'm missing something this is basically just a find-replace job on various methods that return updated versions of the same structure (`set`, `setIn`, `update`, `remove`, `merge`...).

I'd like to be able to add some sort of TypeScript test cases to the repo to make it easier to work on this going forward, but I can't find a good way to add type samples to the repo that can actually import `dist/immutable.js` and `dist/immutable.d.js`. For now I'm just using a separate folder with the module `npm link`-ed in so I can do `import * as I from 'immutable'` as usual.
 did a quick proof-of-concept branch: https://github.com/thomasboyt/immutable-js/commit/82d860587c6a17547c11bdbd10771a0c23ff624a
 @thomasboyt Any update as to the status of this?  I am working with a pretty easy structure

```
[{
    "id": 1,
    "name": "Example",
    "parent_id": null,
    "order": 0,
    "is_open": false,
    "is_directory": true,
    "meta": {
        "revision": 0,
        "created": 1456997356672,
        "version": 0
    },
    "$loki": 1,
    "children": []
}, {
    "id": 5,
    "name": "Double dip",
    "parent_id": null,
    "order": 0,
    "is_open": false,
    "is_directory": true,
    "meta": {
        "revision": 0,
        "created": 1456997356672,
        "version": 0
    },
    "$loki": 5,
    "children": []
}]
```

However what I get back from `Immutable.fromJS(...)` is a List with two BitmapIndexedNode
 I haven't found the direct cause, but the structure appears not to matter. It's when you have more than 8 items.

```
{
  one: 1,
  two: 2,
  three: 3,
  four: 4,
  five: 5,
  six: 6,
  seven: 7,
  eight: 8
}
=> ArrayMapNode
```

```
{
  one: 1,
  two: 2,
  three: 3,
  four: 4,
  five: 5,
  six: 6,
  seven: 7,
  eight: 8,
  nine: 9
}
=> BitmapIndexedNode
```
 Thanks @leebyron   https://facebook.github.io/immutable-js/docs/#/List --- this lacks heaps of methods of the `List` class, eg: `List.sort`
 yeah looks like the docs are no longer showing inherited methods. this is not a fun change :(
 +1
 You can still find them in the Collection section. But yes, I agree, makes it a pain to try and find for specific methods.
 Or the Iterable section, which is the obvious place to describe specialized APIs like `.get()` ...
I guess I'm glad to see this issue, because y'all make it sound like it used to be better... and could be again?

Is this ["... unbreaking generation of new docs when ..."](https://github.com/facebook/immutable-js/commit/aca20705ee96bb00b038b24a531d9f92014ffdf2) a _good_ sign?
 +1
 +1 this is a step backwards for docs
 How about a simple toggle so you can choose whether to view inherited
methods or not?

On Fri, Mar 11, 2016, 7:49 PM Daniel Steigerwald notifications@github.com
wrote:

> I think it's much more concise now. I really like it. Maybe some link to
> inherited methods could be useful.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/issues/798#issuecomment-195618399
> .
 Are we ever getting back the documentation? Cant even find mapKeys() anywhere... @leebyron 
  It seems that causing Immutable to hash `Infinity` triggers an infinite loop (makes sense I suppose :smirk:).

I can reproduce in Chrome and Firefox from the console on [the doc site](http://facebook.github.io/immutable-js/).

``` javascript
m = Immutable.Map({test: Infinity});
m.hasCode() // spins forever
```

I haven't really dug into the hasher. If it's not possible to hash infinity, I'd at least expect to see an exception.

cc @marcneuwirth
 Haha, nice one. If hashing `Infinity` takes forever, does hashing `-Infinity`... reverse time? Let's not even try it just to be safe ;)
 thanks @leebyron ðŸ‘ 
  ``` javascript
var list = Immutable.fromJS([1, [2, 3]]);
list.flatMap(s => s);
```

The above code throws an `Uncaught TypeError: Expected Array or iterable object of values error`

Contrast this with:

``` javascript
var list = Immutable.fromJS([1, [2, 3]]);
list.map(s => s).flatten(true)
```

Which returns `[1, 2, 3]`.

Alternately if you create `list` with `Immutable.List` as opposed to `Immutable.fromJS` the second snippet will return a new list with the same data as the original.

Is this intended behaviour? In Ruby and Clojure, flatMap works on a list that as a scalar in it. 

``` ruby
list = [[1, [2, 3]]
list.flat_map {|s| s}
```

Returns `[1, 2, 3]`
 Fair enough! The only thing I'd say then is that the docs say that flatMap is `Similar to iter.map(...).flatten(true)`. Which is true, but maybe there should be another sentence or two explaining why they're not exactly the same. Just my two cents. Thanks!
  Updated record tests
Fixes #558 and #536
  This addresses #456.

It maintains key as the third argument in the merger to avoid breaking code.

This has added some messy overloading on mergeDeepWith to be able to pass the keyPath recursively and still be able to pass in n iterables to merge. I'd love recommendations to make it better.
 This is exactly what I'm looking for, will this be merged at some point?
 Hey @kozlitinaelja I tried to do a rebase and it ended up changing way more than the original PR. I haven't kept up with the changes since thie PR was originally put up. I put up the new change set here if you'd like to take a look: https://github.com/rickyvetter/immutable-js/tree/keypath2

If you know what's making the rebase do all of the extra changes and it's easy to fix, let me know! This was more of an exploration on how to do this in the first place. I know a couple other people were looking for this feature, but I'm not sure this was implemented in the best way. Happy to drop this PR as well if it doesn't look like it works. Definitely makes sense. Thanks for the feedback! I won't be able to work on this in the short term, but I hope someone else might be able to work with this idea :)  Hopefully this will help people new to the library to avoid silly mistakes.

See this issue for more background information https://github.com/facebook/immutable-js/issues/791
 @leebyron thanks for a great library and happy to help.
  Multimaps can be created and used via wrapping code around a Map of Lists, but it would be nice if this could become a native type so we could get convenience functions for deep persistent changes and such.

https://en.wikipedia.org/wiki/Multimap
  If i want to do something wacky when i merge a map, I use `mergeDeepWith`. But when I encounter a List within those Maps, I want to do something else that requires both of those Lists (eg prepend the second to the first). Only thing that comes to mind is running a forEach & basically writing my own merger. Is there a cleaner way?
 @leebyron It is my understanding the custom merger is only called when previous and next conflict. Is this not true? If not, what is the default implementation? Thanks!
  I found your nice lib and it would be nice that you can implement an ObservableCollection like that one in C#.

Cheers

Chris
  Is this possible or on the roadmap?

Something like: https://github.com/mikolalysenko/functional-red-black-tree
  as of now link for immutable.min.js is broken on
http://facebook.github.io/immutable-js/ but README has correct link
so this replaces broken with correct one

**Overview**

```
<a [-href=\"./dist/immutable.min.js\">dist/immutable.min.js</a>\nor-]{+href=\"https://github.com/facebook/immutable-js/blob/master/dist/immutable.min.js\">dist/immutable.min.js</a>\nor+}
```

<img width="1275" alt="fix_immutable_link" src="https://cloud.githubusercontent.com/assets/2534747/12941813/f5a41204-d010-11e5-8f6c-cdd38d03ea17.png">
 @leebyron No problem. Thanks for fixing. 
  I use immutable.js in angular2 app. When i import `Map` in my file, typescript compiler is blocking and i have to restart it. This error happens when i add `/// <reference path="../../node_modules/immutable/dist/immutable.d.ts" />` in `tsd.d.ts` file. Without this reference typescript compiler doesn't block but i get warning errors for every function or class that i'm importing from immutable.js
  This adds an eslintrc file, extended from the fbjs-scripts base eslintrc (which React and Jest also use). I disabled rules that were currently failing, and the `src/` directory lints with no errors.

It doesn't add any automated linting yet, but does allow editors configured for linting to lint individual files.

Related to #742.
  Jest 0.4.x only works on Node 0.12.x and below, so Immutable JS tests can't be run on newer versions of Node.

I started looking into this, and found that while Jest 0.5.x works fine, 0.6.0  and above breaks various tests:

```
$ npm test

> immutable@3.7.6 test /Users/tboyt/Coding/immutable-js
> ./resources/node_test.sh

Using Jest CLI v0.8.2, jasmine1
 PASS  __tests__/updateIn.ts (0.814s)
 PASS  __tests__/Set.ts (0.181s)
 PASS  __tests__/IterableSeq.ts (0.134s)
 PASS  __tests__/slice.ts (2.206s)
Running 31 test suites.../Users/tboyt/Coding/immutable-js/contrib/cursor/__tests__/Cursor.ts 7:24 Exported external package typings file '/Users/tboyt/Coding/immutable-js/node_modules/immutable/contrib/cursor/index.d.ts' is not a module. Please contact the package author to update the package definition.
 FAIL  contrib/cursor/__tests__/Cursor.ts
â— Runtime Error
Error: Compiling /Users/tboyt/Coding/immutable-js/contrib/cursor/__tests__/Cursor.ts failed
    at compileTypeScript (/Users/tboyt/Coding/immutable-js/resources/jestPreprocessor.js:61:9)
    at Object.module.exports.process (/Users/tboyt/Coding/immutable-js/resources/jestPreprocessor.js:74:43)
    at module.exports.config.scriptPreprocessor.config.preprocessorIgnorePatterns.some (/Users/tboyt/Coding/immutable-js/node_modules/jest-cli/src/lib/transform.js:133:33)
    at Loader._execModule (/Users/tboyt/Coding/immutable-js/node_modules/jest-cli/src/HasteModuleLoader/HasteModuleLoader.js:176:25)
    at Loader.requireModule (/Users/tboyt/Coding/immutable-js/node_modules/jest-cli/src/HasteModuleLoader/HasteModuleLoader.js:760:14)
    at jasmine1 (/Users/tboyt/Coding/immutable-js/node_modules/jest-cli/src/testRunners/jasmine/jasmine1.js:233:16)
    at /Users/tboyt/Coding/immutable-js/node_modules/jest-cli/src/TestRunner.js:261:14
 PASS  __tests__/Range.ts (0.399s)
 FAIL  __tests__/concat.ts (1.859s)
â— concat â€º it concats arrays to indexed seq
  - Expected: {
    | 0: 1,
    | 1: 2,
    | 2: 3,
    | 3: 4,
    | 4: 5,
    | 5: 6
    } toEqual: {
    | 0: 1,
    | 1: 2,
    | 2: 3,
    | 3: 4,
    | 4: 5,
    | 5: 6
    }
        at Spec.eval (__tests__/concat.ts:43:40)
â— concat â€º it concats values
  - Expected: {
    | 0: 1,
    | 1: 2,
    | 2: 3,
    | 3: 4,
    | 4: 5,
    | 5: 6
    } toEqual: {
    | 0: 1,
    | 1: 2,
    | 2: 3,
    | 3: 4,
    | 4: 5,
    | 5: 6
    }
        at Spec.eval (__tests__/concat.ts:48:46)
â— concat â€º it concats multiple arguments
  - Expected: {
    | 0: 1,
    | 1: 2,
    | 2: 3,
    | 3: 4,
    | 4: 5,
    | 5: 6,
    | 6: 7,
    | 7: 8,
    | 8: 9
    } toEqual: {
    | 0: 1,
    | 1: 2,
    | 2: 3,
    | 3: 4,
    | 4: 5,
    | 5: 6,
    | 6: 7,
    | 7: 8,
    | 8: 9
    }
        at Spec.eval (__tests__/concat.ts:63:43)
â— concat â€º it can concat itself!
  - Expected: {
    | 0: 1,
    | 1: 2,
    | 2: 3,
    | 3: 1,
    | 4: 2,
    | 5: 3,
    | 6: 1,
    | 7: 2,
    | 8: 3
    } toEqual: {
    | 0: 1,
    | 1: 2,
    | 2: 3,
    | 3: 1,
    | 4: 2,
    | 5: 3,
    | 6: 1,
    | 7: 2,
    | 8: 3
    }
        at Spec.eval (__tests__/concat.ts:68:43)
 PASS  __tests__/Stack.ts (2.413s)
 PASS  __tests__/merge.ts (0.085s)
 PASS  __tests__/List.ts (6.508s)
 PASS  __tests__/flatten.ts (0.264s)
 PASS  __tests__/Map.ts (7.944s)
 FAIL  __tests__/ArraySeq.ts (0.096s)
â— ArraySequence â€º it maps
  - Expected: {
    | 0: 2,
    | 1: 4,
    | 2: 6
    } toEqual: {
    | 0: 2,
    | 1: 4,
    | 2: 6
    }
        at Spec.eval (__tests__/ArraySeq.ts:21:19)
 PASS  __tests__/OrderedMap.ts (0.033s)
 PASS  __tests__/Seq.ts (0.027s)
 PASS  __tests__/Record.ts (0.026s)
 PASS  __tests__/zip.ts (0.766s)
 PASS  __tests__/count.ts (0.029s)
 PASS  __tests__/Equality.ts (3.248s)
 PASS  __tests__/MultiRequire.js (0.11s)
 FAIL  __tests__/groupBy.ts (0.038s)
â— groupBy â€º it groups indexed sequences, maintaining indicies
  - Expected: {
    | 0: {
    | | 1: 2,
    | | 3: 4,
    | | 5: 6
    | },
    | 1: {
    | | 0: 1,
    | | 2: 3,
    | | 4: 5
    | }
    } toEqual: {
    | 0: {
    | | 1: 2,
    | | 3: 4,
    | | 5: 6
    | },
    | 1: {
    | | 0: 1,
    | | 2: 3,
    | | 4: 5
    | }
    }
        at Spec.eval (__tests__/groupBy.ts:19:114)
 PASS  __tests__/ObjectSeq.ts (0.024s)
 PASS  __tests__/OrderedSet.ts (0.029s)
 PASS  __tests__/ListJS.js (0.07s)
 PASS  __tests__/Conversion.ts (4.134s)
 PASS  __tests__/RecordJS.js (0.153s)
 PASS  __tests__/get.ts (0.021s)
 PASS  __tests__/sort.ts (0.031s)
 PASS  __tests__/interpose.ts (0.02s)
 PASS  __tests__/IndexedSeq.ts (0.043s)
 PASS  __tests__/KeyedSeq.ts (1.305s)
 PASS  __tests__/Repeat.ts (0.024s)
 PASS  __tests__/splice.ts (1.375s)
 PASS  __tests__/minmax.ts (5.137s)
 PASS  __tests__/join.ts (3.348s)
6 tests failed, 1 test suite failed, 427 tests passed (433 total in 35 test suites, run time 15.815s)
npm ERR! Test failed.  See above for more details.
```

It looks like Jest is transforming the objects it's trying to assert in an unexpected way, since the pretty-printed objects in don't match up to what's actually being tested.

Of course, the easy fix to is to just use Jest `0.5.x` (which is what I'm doing so I can test without installing nvm and setting up Node 0.12), but long-term it might be better to make sure this works with current versions of Jest.
  ``` js
> var f =Immutable.List([[[2,[3,{a:[45]}]]]]).flatten()
> f
List [ 2,3,[object Object] ]
> f.toJS()
[ [ [ 2, [Object] ] ] ]
```

3.7.6
 @jcalfee , `Immutable.List` does not convert nested objects into `Iterable`s, and `Immutable.List#flatten` would not flatten the nested arrays in this case because they are not `Iterable`

It would work as you expected if you used Immutable.fromJS instead of Immutable.List

``` js
var f =Immutable.List([[[2,[3,{a:[45]}]]]]);
Immutable.Iterable.isIterable(f.get('0')); // false

var f1 =Immutable.fromJS([[[2,[3,{a:[45]}]]]]);
Immutable.Iterable.isIterable(f1.get('0')); // true
f1.flatten().toJS(); // [2, 3, 45]
```
  Merging an object created with fromJS that has a deeply nested array behaves unexpectedly. Merging an object created with Map works expectedly.

```
// Good
var x = Immutable.Map({a: {b: {c: [10, 40], c2: true}}});
var y = Immutable.Map({a: {b: {c: [10], c2: false}}});

console.log(JSON.stringify(x.mergeDeep(y)));
// {"a":{"b":{"c":[10],"c2":false}}}

// Unexpected results
var a = Immutable.fromJS({a: {b: {c: [10, 40], c2: true }}});
var b = Immutable.fromJS({a: {b: {c: [10], c2: false }}});

console.log(JSON.stringify(a.mergeDeep(b)));
// {"a":{"b":{"c":[10,40],"c2":false}}}

```
 @dsteinbach , I believe that's the expected behavior.

`Immutable.Map`, unlike `Immutable.fromJS`, does not convert deeply nested values into `Map`s and `List`s.

``` js
var x = Immutable.Map({a: {b: {c: [10, 40], c2: true}}});
Immutable.Iterable.isIterable(x.get('a')); // false

var a = Immutable.fromJS({a: {b: {c: [10, 40], c2: true }}});
Immutable.Iterable.isIterable(a.get('a')); // true
```

And `mergeDeep` would try to merge nested items only when they are instances of `Iterable`.

In your sample code, the `unexpected results` case is actually expected.
As merging arrays `[1, 2, 3]` with `[3, 4]` would result in  `[3, 4, 3]`. This is similar to merging objects `{'0': 1, '1': 2, '2': 3}` with `{'0': 3, '1': 4}`, resulting in `{'0': 3, '1': 4, '2': 3}`

Though it might be correct as per spec (I'm not sure which, but the guys created this are definitely smarter than me :D :), it really messes up arrays in my use case of `mergeDeep`. I had to work around for mergeDeep to completely replace arrays when it finds one instead of trying to merge.

https://github.com/facebook/immutable-js/issues/762
  Hi, 

I just found another issue, would you please help? Thanks.

Following the guide from http://facebook.github.io/immutable-js/docs/#/Record, I subclassed Record and created my own Record:

``` javascript
class ABRecord extends Record({a:1,b:2}) {
  constructor() {
   super();
 }
  getAB() {
    return this.a + this.b;
  }
}

```

While the doc reads "Record Classes can be extended as well, allowing for custom methods on your Record. ", I assume this is just like a normal class, so I did some operations and created some data in constructor:

``` javascript

class ABRecord extends Record({a:1,b:2}) {
  constructor() {
   super();
   // do some operation, for example, check network status
   this.networkstatus = operationfunc();
 }
  getAB() {
    return this.a + this.b;
  }
}
```

The problem is that, after I used set(), the networkstatus is undefined in returned instance:

``` javascript
var myRecord = new ABRecord(b:3);
var newRecord = myRecord.set('a',100);
newRecord.networkstatus  -----> undefined
```

After investigation, the following code is the cause in Record.js:

``` javascript
function makeRecord(likeRecord, map, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._map = map;
  record.__ownerID = ownerID;
  return record;
}
```

So it used Object.create() to create a new instance, while the constructor is not called.

I assume it is worked as designed, however, I think it would be better, at least, to document this behaviour in the doc. This way, user can know what needs to be done and what not in constructor. Thanks.
  I see that `Immutable.Set` is not using SameValueZero comparison, which is in the es6 specification http://www.ecma-international.org/ecma-262/6.0/#sec-set.prototype.has

This isn't really an issue or problem, just wondering the reasoning behind this design.

Here's an example.

``` javascript
a = {test: 1}
b = {test: 1}
set = Immutable.Set([A])
set.has(B) //=> true
```
  Hi,

This is really a great library, which is quite useful! Thank you for developing such cool immutable classes.

While these classes changed my programming life, I met some issues to do with Serialisation/Deserialisation. Would you please help? For example, I need to store TodoItems(stored in OrderedMap) into LocalStorage, and then read them out next time. 

1) If I use OrderedMap.toJS() to store it as strings using JSON.stringify() in LocalStorage, and read it out using JSON.parse and Immutable.fromJS(), the set order is missing.
2) While OrderedMap can store number as key and JS obj can not, how to serialise OrderedMap would be a problem. For example:

``` javascript
> omap1
OrderedMap { "1": 4, "a": 1, "b": 2, "c": 3 }
> omap1 = omap1.set(2, 5)
OrderedMap { "1": 4, "a": 1, "b": 2, "c": 3, 2: 5 }
> omap1 = omap1.set(1, 6)
OrderedMap { "1": 4, "a": 1, "b": 2, "c": 3, 2: 5, 1: 6 }
> omap1.toJS()
{ '1': 6, '2': 5, a: 1, b: 2, c: 3 }
```

As a result, { '1': 6, '2': 5, a: 1, b: 2, c: 3 } can not be deserialised into { "1": 4, "a": 1, "b": 2, "c": 3, 2: 5, 1: 6 }.

My current workaround(I think) is:
1) To serialise the OrderedMap manually( one by one and also serialise the set order) and deserialise it out manually( read one by one), which is really annoying. 
2) Use List instead...
3) Fork the whole library and implement the my own serialse()/deserialise() method in OrderedMap

Please let me know if I missed something or there is a better way to achieve it. Thanks very much.

BTW, I didn't try OrderedSet yet, probably I will meet the same issue when using OrderedSet? :-(
 Look at http://stackoverflow.com/a/5525820/1709679 

> An object is a member of the type Object. It is an unordered collection of properties each of which contains a primitive value, object, or function. A function stored in a property of an object is called a method.

So even if you will make Serialisation manually, in some browsers ordering still can be wrong
 hi @umidbekkarimov , thanks very much for your comments.

By reading the link you provided, I can see the ordering in "Object" is not guaranteed. I can understand this point and I am looking for another way to resolve this problem. By mentioning "make Serialisation manually", I mean, it can be implemented by a map and a list. You can see the source code of OrderedMap. That list is used for storing the orders(It can be just an Array) while the map stores the unordered key-value datas. The map and list can be serialized/deserialized by using JSON.stringify/parse. 

So...while object can not guarantee the order, I believe the OrderedMap can achieve it, since OrderedMap is not just a simple object.
 @TheLevenCreations ok, I get your point now, and as I think - the best solution is to convert `OrderedMap` to `List` and use arrays (keep it simple stupid) when you store data as json, and map it back to `OrderedMap` when you transform back without any serialisation/deserialisation routine that already given by `JSON` class

---

Also, just noticed in your post 

> As a result, { '1': 6, '2': 5, a: 1, b: 2, c: 3 } can not be deserialised into { "1": 4, "a": 1, "b": 2, "c": 3, 2: 5, 1: 6 }.

This is little tricky ~~bug~~ **feature** in `OrderedMap`/`Map` classes, that allows you to use any js type as a key, but when you use `#toJS()` method all keys will be converted to string.

Try in your console

``` javascript
> var a = { "1": 4, "a": 1, "b": 2, "c": 3 }; a;
{ '1': 4, a: 1, b: 2, c: 3 }
> a[2] = 5; a;
{ '1': 4, '2': 5, a: 1, b: 2, c: 3 }
> a[1] = 6; a;
{ '1': 6, '2': 5, a: 1, b: 2, c: 3 }
```

So if you can not achieve this with native `Object`, you also can't achieve it with `#toJS()`

---

So immutable js classes give you great tools for managing your collections, but in the end when you have to store data in file/local storage/cookies or send it to server api and you have to deal with JSON Object that also unordered

http://stackoverflow.com/a/4920304/1709679
 hi @umidbekkarimov , thanks for the response and also provided links.

Yeah, I agree with your opinion. So each time I meet the situation "store data in file/local storage/cookies or send it to server api", I have to convert it to another data set, eg, List or Array or raw Object. That's not an easy work. For example, as you mentioned "This is little tricky bug feature in  OrderedMap / Map  classes, that allows you to use any js type as a key", should "1" be parsed to js number 1, or js string 1, or Regex? Probably needs to iterate every js raw types.

I think it would be great if
1) immutable js can provide such APIs, for example, serialize(). Or, just an utility function like fromJS(). 
2) document how to resolve such situation, to avoid improper use of toJS()/JSON.stringify for OrderedMap/OrderedSet.
 Hi @TheLevenCreations take a look at [transit-immutable-js](https://github.com/glenjamin/transit-immutable-js)
  How about having a `Record.isRecord` function like we have `Map.isMap`?

Suggested usage:

``` js

const CustomType = new Record({});
assert(Record.isRecord(CustomType));
```

Thoughts?
  What are you think about implement method split to List? I am very often use it. If you agree that this method is helpful I make PR with implementation based on reduce
  The seq documentation section listed below:

> For example, the following performs no work, because the resulting Seq's values are never iterated:
> 
> var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8)
>   .filter(x => x % 2).map(x => x \* x);
> Once the Seq is used, it performs only the work necessary. In this example, no intermediate data structures are ever created, filter is only called three times, and map is only called twice:
> 
> console.log(evenSquares.get(1)); // 9

I think evenSquares here is incorrect should be OddSquares. Also, can someone explain how the seq's values are never iterated, yet filter is called 3 times, and may called twice?
 +1

its confusing
 @ericlau-solid it should be oddSquares indeed.

Chain is registering some kind of mutation to Seq values, but is only processed when the Seq is used (read). To get the resulting value on index 1, it only needs to calculate two values, thus filter will be called 3 times as the "2" value is omitted and map twice, as it will square just "1" and "3" provided by filter fn.

Haven't seen the internals, but i guess the chain is smartly preprocessed in reverse order so every fn knows how many values it needs to provide for the next one in queue.
  Hi,

Any ideas how can I update an OrderedMap but changing the index but keeping the insertion position?
Something like a replace method:

```
var m = Immutable.OrderedMap({ a: 1, b: 2, c: 3});
m = m.replace('a', { d: 4});
// { d: 4, b: 2, c: 3 }
```
  I've been pulling my hair over this one, how can i get the first item of a collection and parse one of the values? I was thinking `.toJS()` turns it into a mutable object but i guess thats not the case. 

example:

```
var recommendations = Immutable.fromJS([{ searchLocations: ['brooklyn', 'manhattan', 'new jersey']}, {...}, {...}])
var rec = recommendations.get(0).toJS()

// stuck here i can't do anything besides read the value
console.log(rec.searchLocations.join(', ')); // should output brooklyn, manhattan, new jersey
```

here are my reducers

```
    case DISLIKE_SUCCESS:
    case LIKE_SUCCESS:
      return state.update('recommendations', (stack) => stack.shift())
        .set('isFetching', false)

    case USER_RECOMMENDATIONS_SUCCESS:
      return state.update('recommendations', (stack) => {
        stack.pushAll(action.payload)
      });
```

and here is the initial state

```
const InitialState = Record({
  recommendations: Stack()
});
```
  Example code:

```
new Immutable.List().reduce((left, right)=>left.concat(right));

undefined
```
 document says "if initialReduction is not provided, or is null, the first item in the Iterable will be used." So this behavior is native, isn't this?
  evenSquares was referenced in an example but should be oddSquares.
  It would be nice to be able to do this:

``` javascript
let newObj = oldObj.set({ a: foo, b: bar })
```

instead of

``` javascript
let newObj = oldObj.set(a,foo).set(b,bar)
```

This would be analogous to

``` javascript
let newObj = Object.assign({}, oldObj, { a: foo, b: bar })
```

This would presumably more efficient as well, since only one new object has to be created.
 merge would work well, but this suggestion seems good for me!
 Merge behaves differently e.g. when the values merged are lists. It converts list values into immutable List. That is more behavior than I want :)
 +1, would be nice to have this feature
 This is specially useful on deep structures which often happen in a redux reducer for example. I find myself doing the following:

``` js
return state.withMutations(map =>
   map.set('step', 1).setIn(['data', 'type'], action.schemaType)
);
```

Would be much better and clean to simply do:

``` js
return state.set('step', 1).setIn(['data', 'type'], action.schemaType)
```

Not a big deal though, and technically it might not be possible since each operation should be an immutable one. 
  `cursor/index.d.ts` definitions are inaccessible from other ambient external modules. This is needed, for example, to write definitions for `immstruct`.
 Any movement?
  There's a `tsd` definiton manager that makes using libraries a lot easier. Though it uses a DefinitelyTyped repo. Unluckily, Immutable.js [is not there](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/CONTRIBUTORS.md).

Could you send a PR to DefinitelyTyped, please? I would do that myself, but I'm unsure if it's legal.
 Any movement?
 I think this isn't in DefinitelyTyped because a [immutable.d.ts](https://github.com/facebook/immutable-js/blob/master/dist/immutable.d.ts) is being shipped with the node package, so one in DefinitelyTyped is not necessary (the Typescript compiler should check node_modules for typings). Unfortunately something is wrong with how the typings are set up and the typescript compiler gives me a `error TS2307: Cannot find module 'immutable'.` error
 @TheTedAdams Have you ever used `tsd` to say it's not necessary? :)

And nope, TypeScript doesn't have to check anything except of project source code and a bunch of external definitions. That's why they're called external.

I've fixed that error and sent a PR two weeks ago. Facebook guys just don't even have enough time to leave a single comment.
 Yes I use TSD (Although it was recently deprecated so I need to make the switch to Typings).

I just don't see the use of having duplicated d.ts files in node_modules and typings folders. My understanding is that the DefinitelyTyped repository is to fill in for libraries that do not ship with their own typings. If the immutable authors are going to maintain their d.ts files in their own repo and ship it to npm it seems unnecessary to also maintain a second copy in the DefinitelyTyped repo.

That being said, I'm no expert, if you have a reason to have the .d.ts in node_module and typings then sorry to bug ya :)
 @TheTedAdams The problem is that we need to maintain typings in a controllable, predictable way. If we have to point to an unknown, mutable location somewhere in `node_modules`, we cannot do so. We have no guarantees. We could've probably just trusted `immutable.js` authors to never change that location, but based on broken tests for typings and their level of disrespect for users, I'd rather expect `d.ts` to disappear from `node_modules` folder completely on a first year of having an `immutable.js`-based TS project in production.
 Personally, I like the fact that typings are delivered with the project.
What's missing is the "typings" property in the package.json file of immutable.js which will let the TS compiler find the typings (i.e., remove the need to have a /// reference at the top of your TS files).

There's an open PR for that: https://github.com/facebook/immutable-js/pull/779
  For #432.
 Will work on that this weekend.

I think we also have a third option of providing a `.toObjectSafe()`; changing the current `.toObject` is, technically speaking, a breaking change, so another method may as well be preferred if a smooth transition is desired.
  I would like to use `mergeDeep` to merge my deeply nested state object, but not try to merge the Lists whenever it sees them

Simple example. More detailed sample below.

``` js
var originalData = {person: { name: 'John', skills: ['drinking', 'eating']}};
var originalState = Immutable.fromJS(originalData);
var updatedData = {person: {name: 'John Doe', skills: ['sleeping']}};
var updatedState = originalState.mergeDeep(updatedData);
updatedState.toJS().person.skills; // ["sleeping", "eating"]
```

I need the arrays to be ovewritten, not merged. I understand that `mergeDeep` is designed that way. I am just wondering if there's an easier way to achieve what I need. Right now I am doing this:
1. Traverse `updatedData` object, find properties that are `Array.isArray`
2. When found
   - get the path to the current entry
   - use `setIn()`, passing that array
   - delete that array node from `updatedData` to lighten the load for mergeDeep
   
   ``` js
   // mergeDeep that replaces arrays with instead of merging
   function mergeDeepReplaceArrays (state, updatedData) {
     const replaceArrays = (data, basePath) => {
       basePath = basePath || [];
       _.forIn(data, (v, k) => {
         const path = basePath.concat([k]);
         if (Array.isArray(v)) {
           if (state.hasIn(path)) {
             state = state.setIn(path, Immutable.fromJS(v));
             delete data[k];
           }
         } else if (_.isObject(v)) {
           replaceArrays(v, path);
         }
       });
     };
     replaceArrays(updatedData);
     return state.mergeDeep(updatedData);
   }
   ```

This definitely seems hacky and weird. Would be nice, I think, to have a hook into `mergeDeep`, similar to `mergeDeepWith`, except for when the optional `merger` will be called for every node, giving original/target rather than just on the conflicts.

Edit: Updated the code to use `withMutations`, making it a bit faster, but for some weird reasons, my hacky/crappy code is faster than plain `mergeDeep`, according to jsPerf: http://jsperf.com/withmutations-test

More detailed sample

``` js
// Initial entities
var entities = Immutable.fromJS({
  products: {
    '1': {
      name: 'iPhone',
      categories: ['tech', 'phone', 'mobile']
    },
    '2': {
      name: 'Apple',
      categories: ['food', 'fruit']
    },
    '3': {
      name: 'Jacket X',
      categories: ['clothing']
    }
  },

  // list of product ids
  carts: {
    '1': {
      name: 'First Cart',
      items: [1, 2, 3]
    },
    '2': {
      name: 'Second Cart',
      items: [3]
    }
  }
})
```

A change occured to some items:
- `iPhone`
  - Has `tech` category removed
- `First Cart`:
  - Item `2` is removed
  - Name is changed

``` js
var entitiesUpdate = {
  products: {
    '1': {
      name: 'iPhone',
      categories: ['phone', 'mobile']
    }
  }
  carts: {
    '1': {
      name: 'First Cart updated',
      items: [1, 3]
    }
  }
}
```

I need the arrays at  `products['1'].categories` and `carts['1'].items` to be replaced to properly reflect the update, not merged into `['phone', 'mobile', 'mobile']` and `[1, 3, 3]` respectively.
 mergeDeepWith actually only interacts when 2 elements are non-iterable I think. 

I got it to work with `mergeWith` as follow

```
import { List } from 'immutable'
const isList = List.isList
export default function merger(a, b) {
  if (a && a.mergeWith && !isList(a) && !isList(b)) {
    return a.mergeWith(merger, b)
  }
  return b
}
```
  I think my PR is obvious :wink: 
  current behavior

``` js
Immutable.Range(0, -10, 2).toString() // "Range [ 0...-10 ]"
Immutable.Range(0, 1, 0.2).toString() // "Range [ 0...1 ]"
```

fixed behavior

``` js
Immutable.Range(0, -10, 2).toString() // "Range [ 0...-10 by -2 ]"
Immutable.Range(0, 1, 0.2).toString() // "Range [ 0...1 by 0.2 ]"
```
  I was wondering if it would be possible to implement an upgrade to the .get api so that users will be able to do something like props.get('one.two.three') with Immutable.js.

It would potentially be implemented similar to the lines of [lodash's](https://lodash.com/docs#get) api.

What do you guys think? I apologize if this is already a duplicate.
 You can use the getIn syntax to pass a keyPath as an array of key values. Your example would look like `props.getIn(['one','two','three'])`. https://facebook.github.io/immutable-js/docs/#/Iterable/getIn
 I think the support for also dot notation would be a good upgrade to the API. Other libraries are using it, it is nicer to read and feels more intuitive. 

Would you be willing to support both ways?
1. `props.getIn(['one','two','three'])`
2. `props.getIn('one.two.three')`

It would be a backwards compatible API addition.
 Yes. This would be better than doing manually each time : 
`props.getIn('one.two.three'.split('.'))`
 I really don't think it makes sense to support the dot notation API. getIn is more flexible with iterables, as they can be dynamically generated with powerful built in JS APIs. In addition, immutable can use non-strings as keys in most objects. Using dot notation isn't even possible in many of those cases.
 Sorry, but I don't understand what you mean by this:

> getIn is more flexible with iterables, as they can be dynamically generated with powerful built in JS APIs.

Do you have an example? I'm not suggesting to remove anything from the API.

The dot notation is pretty common in many libraries including lodash [_.get method](https://github.com/lodash/lodash/blob/252ea445cab947c6e762b1d99a29ad08806e3b7d/doc/README.md#_getobject-path-defaultvalue), which makes it intuitive to use. How common is it that someone uses non-strings as keys? In my opinion the API could bend a little in this case instead of strictly being consistent with marginal use cases(I'm roughly assuming that it is marginal to have non-string keys, don't have any backing data). 

In any case, supporting this and making a note that the dot notation only works with string keys would be a big improvement for using this the getIn, setIn, etc. methods.
 ``` js
const getFieldByID = (id, field) => _privateThing.getIn([id, field]);
const getNestedEncryptedFields = (...args) => _privateThing.getIn(args.map((key) => decrypt(key));
```

lodash definitely [implements "casting" the dot notation to an array](https://github.com/lodash/lodash/blob/4.7.0/lodash.js#L5738). It just doesn't seem like it provides any real advantage over an iterable. It's more work to create them if you want them to by dynamic and it's always more work for the library to use them.
 Thanks for the responses. +1 for keeping the performance good. A custom function for the job solution sounds the way to go :+1:
 What about using a Proxy query wrapper over a given object, so you could use ES6 Proxy dot access to perform context-origin-specific setter operations + current target getter operations) without even relying on strings at all. That way, you can code using regular dot syntax without relying on get/getIn() or set/setIn() function calls. Not sure about the overhead though...

```
function imProxy(immutable) {
   // ...
   //  actual transformed structure can become something like: 
    {origin: immutable, chain: ["someProperty", "someNestedProperty"], current: currentSelectedNestedImmutable}
   //  upon accessing nested object properties within this Proxy down the dot access chain.
    //  eg. due to dot object accessing such as immutable.someProperty.someNestedProperty  
    // by default
    return new Proxy({current:immutable}, {  ...someStandardJSManagementHooksForQueryingImmutables } );
}
```

// Assuming you're performing a mutation operation on a root state atom....you can manage the return immutable data via withMutations().... and perform plain dot (or bracketed) access operations from within the mutation handler function.

```
newSomeImmutableState = someImmutable.withMutations(  function(someImmutable) {
   var root= imProxy(someImmutable);  // define an origin for the query via a root proxy
    //  ...with the root proxy setting it's target "current' to 'someImmutable'

   // Perform regular JS mutation on root
   root.c= 4;     // actually calls current.set("c", 4) from proxy.
   var nestedQuery = root.someProperty;
   nestedQuery.v= 2;  // after retrieving another Proxy with root.someProperty, forming an origin+query chain, actually calls  origin.setIn(["someProperty, "v"], 2); , where origin is the root of the query. 
nestedQuery.someNestedProperty.b = 3; // after retrieving another Proxy with  nestedQuery.someNestedProperty,. extending the query chain, actually calls  origin.setIn(["someProperty", "someNestedProperty", "b"], 3);
   root.someProperty.someNestedProperty = 2;  // for the sake of example, actually does the same thing above, but re-queries everything from root rather than using the previous nestedQuery dot cache var.
});
```

The purpose of this (in particular with Immutable.withMutations) is that you can write plain mutation handler logic in Pure JS/ Typescript/ Haxe, (whatever language, etc.) first as completely library/platform-agnostic code, without even regarding at all whether the underlying data state parameter should be mutable or immutable. Furthermore, since you are using dot access, you could easily create strictly typed definitions/structures for Typescript/Haxe/etc. to faciliitate full code completion and compile-time checking for the data state access.  If you later wish to use immutable, then you can hook up the Mutation methods that you already have with` newRootState = currentRootState.withMutations( function plainMutationHandlerLogic( currentRootState) { ... });` and use the JS Proxy mediators to translate regular JS operations into app/platform/library-specific calls. I'm not sure if that is a good idea, as  `Proxy` cannot be polyfilled.  There is a project that tried to achieve this, but it's terrible in performance and recommended to not be used in production code.
 If proxying over an unrestricted Map or non-fixed size Array, it would be a problem without an es6 Proxy, since u can't polyfill a es6 proxy exactly. If however the properties of the immutable object structs are known beforehand , ( somewhat like [this](https://github.com/GoogleChrome/proxy-polyfill) proxy polyfill implementation with such a requirement ), it does imply that actually a full es6 Proxy isn't entirely necessary either for such a case, but, simply a wrapper/manager class with automatic prop set-up es5 getters/setters over the known existing immutable struct properties would do likewise. As it stands [now](http://thecodebarbarian.com/thoughts-on-es6-proxies-performance.html), regular Object.defineProperties approach appears to be more performant than dynamic ES6 Proxy approach (albeit the latter will allow for virtualizing array access as well which you can't with defineProperties). In short, , an es5-compatible solution would still have to rely on explicit get/set() on some specific custom-owned collections wrapper class,  ...related link:  https://github.com/facebook/immutable-js/issues/440  More appropriate according to http://languagelog.ldc.upenn.edu/nll/?p=4358.

Alternatively: â€˜â€¦regardless whetherâ€¦â€™ :wink:
  Exposing function for easily identifying if an object is a cursor. This was necessary for me to identify props that were cursors passed down through react elements to determine if I should update based off differences of internal state.
 Signed CLA
  [tfalgout@beyondinto-lm foo]$ cat repl
# !/usr/bin/env node

var repl = require("repl");

var replServer = repl.start({
  prompt: "necs> ",
});
replServer.context.Immutable = require('immutable');
[tfalgout@beyondinto-lm foo]$ ./repl
necs> Immutable.fromJS({1:2});
{ '1': 2 }
necs> .exit
[tfalgout@beyondinto-lm foo]$ node

> var Immutable = require('immutable');
> undefined
> Immutable.fromJS({1:2});
> Map { "1": 2 }
> .exit
> [tfalgout@beyondinto-lm foo]$ node -v
> v5.2.0
> [tfalgout@beyondinto-lm foo]$ npm list
> /private/tmp/foo
> â””â”€â”€ immutable@3.7.6
 This would be more a problem with the `repl` module which doesn't print the type no ?
 Bumping this since I would really like to resolve this issue so I can use ImmutableJS:

I don't believe that it's an issue with the repl module since I see this issue even if I console.log() the output.  I'm unable to get ImmutableJS to return a Map in any runtime environment of Node outside of running the CLI:

Doesn't work:

```
[tfalgout@beyondinto-lm necs]$ cat bin/repl2
#!/usr/bin/env node
"use strict";
var repl = require("repl");
var replServer = repl.start({});
[tfalgout@beyondinto-lm necs]$ bin/repl2
>  var Immutable = require('immutable');
undefined
>  Immutable.fromJS({a:{b:{c:[3,4,5]}}});
{ a: { b: { c: [Object] } } }
> console.log( Immutable.fromJS({a:{b:{c:[3,4,5]}}}));
{ a: { b: { c: [Object] } } }
```

Works:

```
[tfalgout@beyondinto-lm necs]$ node
> var Immutable = require('immutable');
undefined
> console.log( Immutable.fromJS({a:{b:{c:[3,4,5]}}}));
Map { "a": Map { "b": Map { "c": List [ 3, 4, 5 ] } } }
undefined
> .exit
```
 I am experiencing this issue on v.0.10.41 and v4.3.0
  Clicking on the link to download immutable.min.js from the page at https://facebook.github.io/immutable-js/ gives a 404.
 The actual broken link is this:

https://facebook.github.io/immutable-js/dist/immutable.min.js

Thank you!
 That link gives 404 as well.
  What's the best way to reduce to an `Immutable.List`?

 My first attempt is:

```
const newList = list.reduce((newList, val) => {
      /*do stuff*/
      return newList.push(val);
    }, List())
```

Then i started wondering if I needed something like:

```
const newList = list.withMutations(mutList => mutList.reduce((newList, val) => {
      /*do stuff*/
      return newList.push(val);
    }, List()))
```

Does the second approach do anything? Does the first way already have `withMutations` built-in?
  Without this, failing tests would not produce a non-zero exit code.
  I also suggest to add [prettier](https://github.com/prettier/prettier) and [yarn](https://github.com/yarnpkg/yarn) to the list. As I said in https://github.com/facebook/immutable-js/pull/1096#issuecomment-284227352

> And first problem.
> 
> According to the spec - es6 classes can not be called as a functions.
> 
> Few solutions:
> 
> Make a breaking change and disalow var map = Map() syntax in favor of var map = new Map().
> Refactor all es6 classes to Function.prototype style.
> Keep using declassify (but first - need to fix it for latest rollup).

___

Oh, spec changed, now i'll try BublÃ© tonight. @leebyron yep ðŸ‘ for docs need to update react, react-router and jump from gulp to webpack+webpack-dev-server. I guess it's `good first bug` for facebook juniors ðŸ˜œ  One of my favorite things about immutable.js is that most methods like `map`, `filter`, even `concat`, `flatten`, `reduce`, `join`, etc. are present for both `KeyedIterable` and `IndexedIterable`, and the object/array distinctions are almost erased.  Why then does `KeyedIterable` have `findKey`, and `IndexedIterable` have `findIndex`?  Everyone knows that a JS array index is actually just a hash key, and I find myself writing a findKey wrapper method that works on any immutable `Iterable`.

It's fine to keep `findIndex` I suppose, but `IndexedIterable` should also have `findKey`.

Would you accept a PR for this?

For that matter, it seems to me that well-defined semantics for sequential index specific methods like `indexOf`, `zip`, etc. could have well-defined semantics over the numeric keys of `KeyedIterable`s as well and the two could be fully merged once and for all, except perhaps with some ontologic knowledge of whether `toJS` should create an array or object.  The schizophrenia of JS objects and arrays just causes awkwardness, in my opinion; I think they should either be totally interchangeable or totally uninterchangable.
 I guess I could just use `toMap().findKey(...)` everywhere.  Would be nice not to have to create a new object though.
 Hmmm.  I'm just thinking about the behavior of JS arrays and objects.  For instance, given that "numeric" object keys come first in a `for in` loop, even though `typeof` reports they are strings, indicates to me that they might be stored as integer keys internally.  So I was thinking that it would be consistent for a JS object to have an `indexOf` that searched only through values of "numeric" keys.  The same could work for Immutable.js, but does Immutable.js support a mix of numeric and non-numeric keys in `KeyedCollection` and `IndexedCollection`?
 Oh wow, no, thank you!  And I think you're right about `indexOf` et al, the semantics would be a bit too subtle for keyed collections.
  When converting a redux example state:

``` js
const state = {
  issues: [{title:"hello"}, {title:"nothing"}]
}
```

is converted to `List [ [object Object], [object Object] ]` instead of `List [ Map {title: "hello"}, Map {title:"nothing"} ]`

From what I understand, fromJS should convert it to the latter version as they are vanilla objects?
 I can't reproduce this from console on the home page in Chrome.

<img width="536" alt="screen shot 2016-01-02 at 01 11 55" src="https://cloud.githubusercontent.com/assets/52677/12072697/db94c878-b0ed-11e5-9218-968e19c70487.png">
 Ok yeh I can't replicate that in the cmd line.
  help me
 `Immutable.fromJS([[0, 1], [1, 0]])` will give you a List of Lists.
 ```
var a = Immutable.fromJS([[0, 1], [1, 0]]);
console.log(a.toArray());
```

Doesn't give you what it's supposed to! It prints the internals of the Immutable List object instead...
  I got a bug when I use this:

```
const promises = aImmutableMap.map(
      (val, key) => API.get(`something/${val.id}`).then(callback));
 );

await Promise.all(promises);
```

It's failed, at first I think maybe I should use a native JS Array here, but I found: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
It say: 'Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map, while other types (such as Object) are not.'

So I think a Immutable Map will be Ok(like a native JS Map), but in fact it's not, it seems like Promise.all look for a structure like: [promise1, promise2, promise3], but a Immutable Map iterable like this: [[key1: promise1], [key2: promise2], [key3, promise3]], it dosen't work.

I found this: https://github.com/facebook/immutable-js/issues/236
but this only focus on Immutable List in Promise.all, I want to know is either Immutable Map should supported Promise.all, or my understanding is wrong? thx a lot.
  First, you need to return the updated value in the `updateIn`

I'd probably do something like:

``` js
const KEYS = [
  'sneakerName',
  'shoeSize',
  'price',
  'trade',
  'isbm',
  'info',
  'brand',
  'quality',
  'reRelease',
  'colors'
]

export function handleUpdateSneaker(state, sneaker, sneakerDif) {
  var userSneakers = state.getIn(['dashboard', 'userSneakers']);
  var index = userSneakers.indexOf(sneaker);
  return state.updateIn(['dashboard', 'userSneakers', index], sItem => {
    return KEYS.reduce((map, key) => {
      return map.set(key, sneakerDif.get(key /*, fallbackValue[key] */))
    }, sItem)
  })
}
```
  I would expect the below 3 blocks to function the same but both `Map` and `OrderedMap` throw errors when `deleteIn` is used.

``` js
var fromJS = new Immutable.fromJS({ foo: { bar: 'baz' } })
JSON.stringify(fromJS.toJS()) // {"foo":{"bar":"baz"}}
JSON.stringify(fromJS.delete('foo').toJS()) // {}
JSON.stringify(fromJS.deleteIn(['foo', 'bar']).toJS()) // {"0":{}}

var map = new Immutable.Map({ foo: { bar: 'baz' } })
JSON.stringify(map.toJS()) // {"foo":{"bar":"baz"}}
JSON.stringify(map.delete('foo').toJS()) // {}
JSON.stringify(map.deleteIn(['foo', 'bar']).toJS()) // Uncaught Error: invalid keyPath

var orderedMap = new Immutable.OrderedMap({ foo: { bar: 'baz' } })
JSON.stringify(orderedMap.toJS()) // {"foo":{"bar":"baz"}}
JSON.stringify(orderedMap.delete('foo').toJS()) // {}
JSON.stringify(orderedMap.deleteIn(['foo', 'bar']).toJS()) // Uncaught Error: invalid keyPath
```

I see one related issue #489 but it doesn't show the problem quite so clearly IMO.

In my opinion, this problem is serious enough to make use of `Map` and `OrderedMap` very questionable.
 To elaborate a bit on why I think it's a fairly severe issue- it prevents things like the following:

``` js
Immutable.List(myArray).toOrderedMap()
```

And instead requires users to use a more verbose approach like so:

``` js
Immutable.fromJS(
  myArray
    .reduce((map, item, index) => {
      map[index] = item
      return map
    }, {})
)
```
 For what it's worth, I have noticed that the following doesn't exhibit the problem mentioned above:

``` js
Immutable.fromJS(myArray).toOrderedMap()
```

Looks like `Map`, `List`, and others aren't good about converting deep objects?
 After more thought and time spent poking at this issue, I think I'm going to close the bug as invalid. It really boils down to the fact that `fromJS` is the only safe way to instantiate nested structures.

_That being said_ - I think it's too easy to be burned by this. `Map`/`List`/whatever _appear_ to function similarly but will break down the road. Sometimes the "breaks" will manifest as errors (like I initially reported) and sometimes they will just silently fail to return an updated immutable structure. When it happens, it's usually pretty difficult to debug. I've run into similar issues when using `updateIn` or `mergeIn` (accidentally "corrupting" my immutable structure).

I _think_ the objects accept plain JS data-types as constructor parameters so as not to _force_ a tree to be Immutable all the way to the leaves- but (anecdotally) I think it's weird and confusing to have a mix of immutable and non-immutable structures. It makes your operations surprising and hard to reason about. I feel pretty confident about saying that... for what it's worth, if anything... I would prefer immutable structures be immutable from top to bottom, always.
 I just got bit by this too. @leebyron, can you weigh in on this? Why are these two statements not the same:

``` js
fields = Immutable.fromJS({ email: { name: 'email', failProps: { boo: true } } });
fields = Immutable.Map({ email: { name: 'email', failProps: { boo: true } } });
```
 @ffxsam `Immutable.Map()` and `Immutable.List` create shallow immutable structures. They're faster than `fromJS` which creates a deeply immutable structure.

Personally I think `fromJS` behaves more intuitively since it prevents nested data from being mutated. But I think the design decision was an intentional one.

Put another way...

``` js
var data = { foo: { bar: 'baz' } }
var deep = Immutable.fromJS(data)
var shallow = Immutable.Map(data)

deep.get('foo').bar = 123

JSON.stringify(data) // "{"foo":{"bar":"baz"}}"

shallow.get('foo').bar = 123

JSON.stringify(data) // "{"foo":{"bar":123}}"
```
 I still don't get it. What does "shallow" mean in this context?

This is also interesting:

```
shallow.setIn(['foo', 'bar'], 'wow').toJS()
Result:
Uncaught Error: invalid keyPath(â€¦)

deep.setIn(['foo', 'bar'], 'wow').toJS()
Result:
{
  "foo": {
    "bar": "wow"
  }
}
```
 Shallow meaning..

``` js
// If you start with this...
var data = {
  foo: {
    bar: 'baz'
  }
}

// This will create a deeply immutable structure...
const deep = Immutable.fromJS(data)
deep.get('foo') instanceof Immutable.Collection === true

// This will create a shallow immutable structure...
const shallow = Immutable.Map(data)
shallow.get('foo') instanceof Immutable.Collection === false
```

...and all the things that comes with this, meaning that your Immutable calls and methods only go 1 level deep. So you can't use `getIn`, `setIn`, etc. Also means you can mutate the underlying data.
 Ahhhhh! Ok, that makes sense. And also explains why the deep methods don't work. I just wish the documentation better explained these differences. What is even the point of using `Map()` then? I can't think of any scenarios where I'd use it.
 It's faster, so some people prefer it.

I think it makes for a really confusing/bizarre experience- particularly if you have an Immutable store/state and you want to pass pieces of it to React components. If you don't know which piece is Immutable and which isn't- things get hairy. :)
 Faster? So my app will save 20 microseconds? ðŸ˜‰ 
 The perf gains are not worth the added complexity in the applications I use Immutable in- but depending on how big your store tree is, and how frequently it's updated, performance may be a valid concern.
 D'oh. Good point. I tend to use Immutable for making data structures out of POJOs so I overlook use cases like Lists of React components. Thanks for pointing that out. :)
  Removed the reference to `Object.observe` from the readme. This method is set to be removed [1][2] and will not make for a clear reference. 

gh-pages branch should also be updated to reflect the same change to the `index.html` file, however I am unsure how pull requests work for the gh-pages branch. 

[1] https://esdiscuss.org/topic/an-update-on-object-observe
[2] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
  The typescript part of this is a bit suspect, but it compiles!

When constructing a map I'd quite like to create via an API like:

``` js
Immutable.Map.of('key', 'val1', 'key2', 'val2');
```

This is to reduce the visual and allocation overhead introduced when using array-of-arrays - which as far as I can tell is the only way to construct succinctly with non-string keys.
 That could be simpler, I'll make that change now.
 Type signature changed, had a test failing locally - but twas also failing on master so I think it's unrelated to these changes.
  Without this, `jest-cli` is not installed when using `npm@3`, and you can't run the tests.
  It would be nice to have ability of creating extendable immutable classes, so we can make things like:

``` js
function ExtendableMap(d) {
   Object.assign(this, Immutable.Map(d));
}
ExtendableMap.prototype = Object.create(Immutable.Map.prototype, {
   constructor: { value: ExtendableMap, enumerable: false, writable: true, configurable: true }
});

class Form extends ExtendableMap {
   constructor(initialValue = "") {
      super({ value: initialValue });
   }
   setValue(z) {
      return this.set("value", z);
   }
}

class SpecialValidatedForm extends Form {
   setValue(z) {
      return 
         super.setValue(z)
         .set("valid", z != "");
   }
}
```

Performance loss doesn't seem to be considerable.
I can make additional commits, if that makes sense.
  Have you seen this article (http://bendyworks.com/leveling-clojures-hash-maps/)? It might be useful to improve performance.
 @leebyron you mentioned Records in the roadmap. What is the plan for Records in combination with Typescript? I'm refactoring my TypeScript flux implementation to use ImmutableJS but atm I'm losing all the nice type generics in my React Components. I saw some issues here but I wanted to know the 'official' plan?
 Kind of related to API simplicity -- a REPL would go a long way. A big reason I go to the Immutable docs is to open up the Web Inspector and see what different method calls do. Building a REPL is a fairly well-defined task too so getting help from the community could be an option here.
 Nice work on the roadmap! +1 to modularisation (and any other size refinements): 55kB minified is currently too prohibitively large to embrace in many projects/frameworks. I'd like to leverage this internally in my framework, but the rest of the [(full-stack) framework is 6kB](https://github.com/pemrouz/ripple/blob/master/dist/ripple.pure.min.js.gz), so the bloat would make it a burden for some users/cases.

Another option for the size-conscious perhaps could also be to provide a simpler `.lite.js` version/build?
 We're currently working on using immutable.js with flux. A complete and correct type declaration for immutable.js and good support for Records would be highly appreciated, this is the area where we've been running into roadblocks.
 @MSch yes, same problem here. Flux stores with the power of compile-time type checks have a lot of potential. Combined with immutable data structures even more. Sadly Records are not ready for TypeScript.
 Modularity is definitely something I'm looking forward to. I've been watching the status of this at this issue https://github.com/facebook/immutable-js/issues/317
 >  To achieve this, some API changes will be necessary, for example removing `myThing.toMap()` in favor of `Map(myThing)`.

I would just like to point out some issues around getting rid of `toMap()`. Take a look at #600 and #697. Ideally, this sort of behavior would fit better under the `map()` function, but you cannot specify keys via `map()`.
 On the subject of _Interoperability with JavaScript_, Chrome 47+ supports customer formatters.
[I wrote a simple formatter](https://github.com/danielepolencic/immutablejs-devtools) to prettify the output of Immutable.js data structures.

If this is something of interest, I'm happy to do a PR and include it in the REPL for the doc pages.
 @danielepolencic oh man that's amazing! :+1: Definitely going to check this out. :smile: 
 @danielepolencic this is really helpful. Thanks for sharing!
 I am looking forward to Modularity, API Simplicity (which I hope to find some time to contribute to!), and optimizations with React.

It has been requested [before](https://github.com/facebook/immutable-js/issues/88), but a great addition to 2016 would be the [SortedMap](https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html). A helpful [implementation](https://github.com/montagejs/collections/blob/master/sorted-map.js) from [collection.js](http://www.collectionsjs.com/). I could see this being useful in several projects.

@danielepolencic I have been using [immutable-devtools](https://github.com/andrewdavey/immutable-devtools). Perhaps you guys could collaborate. Thanks for the formatter!
 @vinnymac you tagged me, but I'm not sure why - was it intentional? :

EDIT - though I'm glad you did as this is the first time I've seen that roadmap, and it was nice to see that I [implemented something on it](https://github.com/facebook/immutable-js/commit/e437eeb6a337e8346dd008025412027d450badb8) without realising!
 @danielearwicker github's autocomplete ranked you higher up, my mistake ðŸ˜…. Happy to accidentally include you in this thread.
 Be really cool to see the roadmap of Immutable find it's way into the language eventually! The spec by Sebastian Markbage is a great start, https://github.com/sebmarkbage/ecmascript-immutable-data-structures. What are people's thoughts?
 I'd also like to voice my support for pre-sorted maps, sets and lists. Currently I have to add an item to an ordered map and then sort it. Even though the entire list will have already been in the correct order aside from the last item, it still takes the same amount of time to sort the new item into the correct position as it would if all of the items were out of order. The slowdown is noticeable when dealing with lists containing hundreds of thousands of items, and it's even worse with a million or more items. A sort that is applied at insertion time would mitigate this issue almost entirely. #88 
 any news on "Modularity"? maybe it could a good first step to transpile `src/` to `lib/` as is in terms of included files? so we can import Map like `import Map from 'immutable/lib/Map'`.  Not sure if `isSuperset()` is supposed to accept arrays as an argument - it seems like it's supposed to based on the docs. Here's the issue:

``` js
// Works...
Immutable.List.of(1, 2, 3).isSuperset(Immutable.List.of(1, 2));
// true

// Doesn't work...
Immutable.List.of(1, 2, 3).isSuperset([ 1, 2 ]);
// Uncaught TypeError: t.isSubset is not a function(â€¦)
```

Here's a [fiddle](https://jsfiddle.net/adamboduch/ctxjn315/) demonstrating the issue.
 @adamboduch Looks like in that fiddle you're using 3.6.4. I just tried this out with 3.7.6 (the newest release from about 15 days ago) and both expressions appear to be working as expected (returning true). 

Apologies if I'm pointing this out, but you're actually locked into 3.6.\* for a specific reason.

[Fiddle with 3.7.6](https://jsfiddle.net/marcacyr/yecxnsud/)
 @marcacyr Cool. That was my bad for not checking the version. Thanks for looking into it.
  I was trying to debug something like this for a long time:

```
x = x.withMutations(map => {
  map.filter(value => ...).map(value => ...)
})
```

... then I noticed the [footnote](http://facebook.github.io/immutable-js/docs/#/Map/withMutations) that "Only set and merge may be used mutatively."

Why is it possible to call `.filter()`, `.map()` etc if they do nothing? Shouldn't they throw an error?
 Or better yet, why can't these methods be made to do something when inside a withMutations scope?
 +1
 Similarly, `.delete` behaves in unexpected ways. It should throw if the method being called on the mutating state object is not supported:

```
var l1 = Immutable.List(['a', 'b', 'c']);
var l2 = l1.withMutations(newState => {
  newState.delete(1);
  return newState;
}); 

// Expected
['a', 'c']

// Actual
[]
```  Is this considered a problem for Immutable's `is` algrorithm?

``` js
var Immutable = require('immutable');

var map1 = Immutable.Map({
  foo: new Buffer('hi'),
});

var map2 = Immutable.Map({
  foo: new Buffer('hi'),
});

Immutable.is(map1, map2); // true

map1.get('foo').x = 123;

Immutable.is(map1, map2); // true
map1.get('foo').x; // 123
map2.get('foo').x; // undefined
```

([Try above snippet on Tonic](https://tonicdev.com/callumlocke/node-buffers-as-immutable-values))

see [Node Buffer#equals()](https://nodejs.org/api/buffer.html#buffer_buf_equals_otherbuffer)
 It's just a theoretical concern yeah. I can see it might be a happy accident...
  I am not real clear how the documentation is created for Immutable.js, but unless I am looking at a stale copy of the docs, I don't see the new List.insert method documented.

http://facebook.github.io/immutable-js/docs/#/List

Thanks!

The relevant commits:

It was added to typescript here.
https://github.com/facebook/immutable-js/commit/189678f700a1197befa9f74b42169fe4224dc9a1

Here was the original commit for the code
https://github.com/facebook/immutable-js/commit/193ebd572929837156b660eb1d0b6a2304ed3fea
 The docs seem waay off to me. Lots of stuff missing.

for example Map.filter and List.filter?
 See more recent issue #798 for more problems with docs (such as vlinder mentions above (and found under `Iterable` (!) at the moment)).  However, in the meantime your original problem with List.insert() seems to be fixed by now, and can be found [here](https://facebook.github.io/immutable-js/docs/#/List/insert).
  This pull request shows what is required to make `immutable` easily usable with TypeScript >= 1.6.

The key thing is adding the `typings` field to `package.json` and pointing it at the `index.d.ts` file.  This `index.d.ts` file is different from `immutable.d.ts` because it _does not_ have a `module` wrapping it.  The `module` part is apparently implied when using the `typings` field.

A few notes.  First, I'm not necessarily advocating for accepting _this_ pull request.  I just wanted to show what was necessary for me to get it working.  With this simple addition to `immutable`, you can just do this in TypeScript:

```
import immutable = require('immutable')
```

After doing an `npm install immutable`.  There is no need to use `tsd` or `DefinitelyTyped` at all.

Another thing to note is that I've copied and pasted most of `immutable.d.ts` to create `index.d.ts`.  I recognize this is not very DRY.  I just couldn't figure out a quick and simple way to use a `<reference.../>` element to avoid this.  But I'm pretty sure it could be done.
  I am posting this issue to requesting permission that TypeScript definitions of `immutable-js` be allowed to be posted to DefinitelyTyped. (Reference: https://github.com/DefinitelyTyped/DefinitelyTyped/pull/6623)

Namely the following files:
- dist/immutable.d.ts
- contrib/cursor/index.d.ts
- type-definitions/Immutable.d.ts

Currently `immutable-js`'s definition is located in this repo with BSD license. DefinitelyTyped uses MIT license. I am not sure the difficult of re-licensing the `.d.ts` files. 

I have also written definition files for libraries that depends on `immutable-js`, namely `omniscient`, currently in my own project. I would like to contribute it to DefinitelyTyped, so people can use `omniscient` in TypeScript without having to write their own definitions. However, `omniscient` has a hard dependency on `immutable-js`, as such, my definition file would need to reference `immutable-js` or provide a suitable proxy (e.g. I write my own version of `immutable.d.ts` from scratch) 

Thank you very much. 
 See #711 (and perhaps others) if you are using immutable as an NPM module.
 :+1:
 :+1:
Closing this as license hurdle has been resolved. 
  I would like to use a KeyedSeq backed by a database, however the access the the database has some latency and so is accessed using an async method. I was wondering how could I use something like that to back a Seq. Thanks!
 The thing is streams are quite a different beast from keyed associative arrays ie Objects
  If you put a console log into the mapper function i.e. 
`Immutable.Seq.of(1,2,3,4,5,6,7,8).filter(function(x){return x % 2}).map(function(x){console.log('mapper called'); return x * x});`
The mapper only console.logs once.

Similarly, inserting a console.log into the definition of the mappedSequence.get method in the definition of the mapFactory, only shows one invocation.

Docs for Seq should reflect the correct number of calls to map.

Currently it states that filter is called 3 times, and map is called twice.
Filter is called 3 times, but it appears map is only called once, on the single returned value from the .get call.

Screenshot of 3 filter calls and single console.log on map attached.

![screen shot 2015-12-13 at 5 58 52 pm](https://cloud.githubusercontent.com/assets/7946707/11771307/344ea45a-a1c3-11e5-9b79-3eaea658a7e9.png)
  ``` javascript
<script src="./immutable.js"></script>
<script>
var count = 0
Immutable.fromJS({a: {b: [10, 20, 30]}, c: 40}, function (key, value) {
  var isIndexed = Immutable.Iterable.isIndexed(value)
  var result = isIndexed ? value.toList() : value.toOrderedMap()
  // var result = value
  console.log('::' + (count++) , value)
  return result
})
// ::0 Object {size: 3}
// ::1 Object {size: 1}
// ::2 Object {size: 2}
</script>
```

but:

``` javascript
var Immutable = require('./immutable.js')

var count = 0
Immutable.fromJS({a: {b: [10, 20, 30]}, c: 40}, function (key, value) {
  var isIndexed = Immutable.Iterable.isIndexed(value)
  var result = isIndexed ? value.toList() : value.toOrderedMap()
  // var result = value
  console.log('::' + (count++) , value)
  return result
})
// ::0 Seq [ 10, 20, 30 ]
// ::2 Seq [ 10, 20, 30 ]
// ::1 Seq { "b": List [ 10, 20, 30 ] }
// ::4 Seq [ 10, 20, 30 ]
// ::6 Seq [ 10, 20, 30 ]
// ::5 Seq { "b": List [ 10, 20, 30 ] }
// ::3 Seq { "a": OrderedMap { "b": List [ 10, 20, 30 ] }, "c": 40 }
```
  I mean composable curried by default functions. 
  Apparently it's going to be standard for TypeScript to look for definitions in `index.d.ts`. Perhaps `Immutable.d.ts` could be renamed to `index.d.ts`?
 If a type definition is shipped with a package, then yes this is true.

However, it may be that [`typings`](https://github.com/typings/typings) is the best approach given the desire to support type definitions (for a given version of a ImmutableJS) for multiple versions of TypeScript. Related https://github.com/typings/typings/issues/49
 Reading https://github.com/Microsoft/TypeScript/wiki/Typings-for-npm-packages adding the path to `Immutable.d.ts` to the `"typings"` field in the distributed `package.json` would also work and in fact be the preferable path for TS >= 1.6.

My project is using the older https://github.com/DefinitelyTyped/tsd instead of typings. I guess publishing to typings and tsd for backwards compatibility as well as adding to the `typings` field in `package.json` would be the best solution. 
 A data point.  I tried adding `typings` to `package.json` and pointing it to `dist/immutable.d.ts`.  But it failed.  I suspect that the version of `immutable.d.ts` that is present there is not "framed" properly for what `tsc` needs.  As such, I think a separate `.d.ts` file will be required.  I think I've seen this before and I suspect (although I don't know for sure) that all the is really required is to create a new file that uses a `<reference.../>` at the top to the current file and adds some additional details about the module.  I'll play around with it.

But I want to add that, in my opinion, it is **much** better to include an up to date `.d.ts` file in the NPM repository along with the `typings` field in `package.json` vs. adding the declarations file to `DefinitelyTyped`.  It makes use of NPM modules much easier and makes it much easier to avoid version skew.
 Ah, it seems as though #642 perhaps addresses the issue I'm currently seeing with `immutable.d.ts`.
 For reference, I submitted a pull request (#717) that shows what is required to get the `typings` field working.  It is pretty simple.  I don't necessarily expect you to accept that PR since it does have some problems (see PR) and I haven't signed an CLA.  But I at least wanted to show that the fix is simple and **really** simplifies using `immutable` with TS+NPM.
  What if we allowed extensions of Immutable.js with `call`?

```
function sum(collection) {
  return collection.reduce((sum, x) => sum + x, 0)
}

Immutable.List([1, 2, 3]).call(sum) // 6

// Call is really helpful with long method chains.
sum(Immutable.List([1, 2 ,3])
  .filter(x => x % 2 === 0)
  .map(x => x + 1)
)
// vs
Immutable.List([1, 2 ,3])
  .filter(x => x % 2 === 0)
  .map(x => x + 1)
  .call(sum) // Looks native
```

This would keep the core small and lean, yet allow succinct utility method usage.
- Note: I got this idea from [d3](https://github.com/mbostock/d3/wiki/Selections).
 Great idea! But `.call()` looks like [Function.prototype.call()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call) and may be confusing.

As an alternative:

* [let](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/let.md) from `RxJS`
* [thru](https://lodash.com/docs/#thru) from `lodash`  There should be one more Map function overload:

```
Map<V>(obj: {[index: number]: V}): Map<number, V>
```

alongside to

```
Map<V>(obj: {[index: string]: V}): Map<string, V>
```
 @Strate I think objects can only have string keys (for both JS and TS)

If you want a Map with integer keys, this works:

```
Immutable.Map([
  [1, 1],
  [2, 1]
])
```

**EDIT** Oops, I was mistaken. TypeScript supports numeric keys
 This works also:

```
const obj: {[id: number]: any} = {}
Immutable.Map<number, any>(obj as Object)
```

but I should cast `obj` to Object, as you see.
I want to use `{[index: number]: any}` notation to prevent passing string to object keys.
 :+1: 
  Typescript now support:
- tuples: `[int, string]` (usable for `entries(): Iterator<[K, V]>`)
- union types: `A | B` (usable for `concat(...valuesOrIterables: Array<Iterable<K,V> | V>`)
 Also polymorphic this, which helps a ton for things like concat.
 Related to #684 
 ```
filter(
      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
      context?: any
    ): /*this*/Iterable<K, V>;
```

could be changed to

```
filter(
      predicate: (value?: V, key?: K, iter?: this) => boolean,
      context?: any
    ): this
```
 [Related discussion](https://github.com/typings/typings/issues/49)
  Looking into the type definition file I came across this line:

```
export function List<T>(iterable: /*Iterable<T>*/Object): List<T>;
```

The problem with that is that we can actually introduce some bugs into our code. More specifically the above line lets us do things like this:

```
const y = List<string>([10]); 
```

and that's actually right because 

```
 const x: Object = 10;
```

is a valid TS code.
  Not sure why this is broken, but here's a (jest) test case exposing the issue:

```
    let Immutable = require('immutable');
    let list = Immutable.fromJS([1, 2]);
    let value = list.max();
    let valueIndex = list.lastIndexOf(value);
    expect(Immutable.is(list.get(valueIndex), value)).toBe(true);
```

I get `Expected: false toBe: true` using immutablejs version 3.7.5
 :+1: Immutable.js is currently returning the index in the reversed sequence (ie, the index relative to the end), but I think it should return the index in the forward sequence. This would match both the behavior of [lodash](https://lodash.com/docs#lastIndexOf) and [String.prototype.lastIndexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).
  This page, https://facebook.github.io/immutable-js/docs/#/Map, for example, there is no scrollbar to view the consolidated list of apis on the left.Makes it impossible to use without a scrollwheel (ie. laptop). I can fix it but I don't know where the html source is located.
 Same problem here. Tested on both Chrome and Firefox.
  I'm wondering if anything like _.sortedIndex is available. 
 +1
 @leebyron How might you imagine your concern being addressed? One approach is to call out it very loudly in the docs, but that seems less than ideal. There is also the option of creating a new type that guarantees the "is sorted" invariant itself, but that seems nuclear. Is there a middle ground? @leebyron That sounds very reasonable! Seems like a tough trade off. I think that spurred one other question though. I'm not familiar with the implementation details of `List`, but would a binary search in this library be able to take advantage of any implementation details that could make it faster? Or would an externally supplied one essentially look the same as one that was written inside immutable-js proper?  - https://github.com/facebook/immutable-js/blob/7c4483e30e8b9528562f6ef34f66bee6bfb3538d/__tests__/merge.ts#L43
- Above test works on `http://facebook.github.io/immutable-js/` but not on `http://facebook.github.io/immutable-js/docs/#/`
- I suspect docs page is loaded up older version of immutable js
- On `http://facebook.github.io/immutable-js/`
  <img width="1632" alt="screen shot 2015-11-12 at 5 51 34 pm" src="https://cloud.githubusercontent.com/assets/5334108/11136836/1aeb1968-8967-11e5-8987-8e6a7fa34216.png">
- On `http://facebook.github.io/immutable-js/docs/#/`
  <img width="1632" alt="screen shot 2015-11-12 at 6 00 01 pm" src="https://cloud.githubusercontent.com/assets/5334108/11136864/4c58eb42-8967-11e5-86bf-00f63ee6b90c.png">

`key` is always `undefined` in the merger function for the latter case
  Common use case for easily indexing a sequence of data. It would basically work like this:

``` javascript
let data = Immutable.List.of(
    { id:1, value:"value 1" },
    { id:2, value:"value 2" },
    { id:3, value:"value 3" }
);

let mappedObjects = data.toMap((item) => item.id);
let mappedValues = data.toMap((item) => item.id, (item) => item.value);
```

Currently you would probably use reduce:

``` javascript
let data = Immutable.List.of(
    { id:1, value:"value 1" },
    { id:2, value:"value 2" },
    { id:3, value:"value 3" }
);

let mappedObjects = data.reduce((map, item) => map.set(item.id, item), Immutable.Map());
let mappedValues = data.reduce((map, item) => map.set(item.id, item.value), Immutable.Map());
```
 Related: #600
 I started making a pull request, but there appear to be failing tests on master at the moment. This is the code I came up with to replace `toMap()`.

``` javascript
toMap(keySelector, valueSelector) {
  // Use Late Binding here to solve the circular dependency.

  // build a reducer that takes selector functions into account
  var reducer = null;
  if (keySelector && valueSelector)
    reducer = (m, v, k) => m.set(keySelector(v, k), valueSelector(v, k));
  else if (keySelector)
    reducer = (m, v, k) => m.set(keySelector(v, k), v);
  else if (valueSelector)
    reducer = (m, v, k) => m.set(k, valueSelector(v, k));

  // reduce required?
  if (reducer === null)
    return Map(this.toKeyedSeq());

  // apply selector functions via reducer
  return this.reduce(reducer, Map());
}
```
 Does `Map(myThing.map(a => [b, c]))` work currently?

I don't see how `toMap` is confusing, although I can see how it presents a problem for modularity. If all the transform functions (ie `map()`) returned a generic `Seq` or `Iterable` like they used to, this wouldn't be a problem at all. The `Map` module could have easily extended the prototype of `Seq` to include a definition for `toMap()`.

Removing `toMap()` and family hurts chainability, since the constructor must come first. Thus, if you have a longer chain of transformations with a concrete data type in the middle, you have to bounce back and forth as you read the code, leading to reduced readability and comprehension.
 I think there is something wrong with the `map()` function then. This is what I tried before:

``` javascript
var m = Immutable.Map({ "10":100, "20":200 }).map((v, k) => [parseInt(k), v]);
m.toString();
// "Map { "10": 10,100, "20": 20,200 }"
```
 > Luckily, after surveying a large body of code that uses Immutable, conversion between different types is far from the most common of operations, so this should have relatively small impact on code quality and readability.

This issue and issues like it show we think converting between data types should less painful, but it looks like the project is going in the opposite direction.
 Good to know, thanks!

When using JSON to encode maps, int keys always come out as strings, so this kind of `Map` to `Map` conversion happens pretty regularly in the project I am working on.

It seems strange that `map()` would behave differently depending on the source data type. The docs for `map()` don't mention this either. Given that `map()` always provides a key-value pair to the mapper function anyway, the distinction between `Iterable.map` and `KeyedIterable.map` is surprising to me.
  It would be nice if `OrderedSet` had an `update()` function like `OrderedMap`, to support changing value without changing order.

``` javascript
let os = Immutable.OrderedSet.of(1,2,3); // [1, 2, 3]
os = os.update(2, 7); // [1, 7, 3]
```

This can't be achieved currently because `delete()` followed by `set()` changes order.
 Could this be achieved in a performant way by doing a concat and a sort?
  Thanks again for this awesome package!

I'd like to contribute to the docs. I see that I can edit the docs here: https://github.com/facebook/immutable-js/blob/master/dist/immutable.d.ts

I get that the docs are auto-generated. But how can I generate the docs locally so I can preview the docs before submitting a pull request? 

Thanks,
 Thanks!
  Noticed that I was seeing a ton of changes when doing a `mergeDeepIn` and traced it down to the fact that `updateDeepMap` not using `is` and thus ending up with every Date object causing a change. This fixes that, test included.

Also I guess somewhere along the line an old version of `Immutable.d.ts` got checked in, so that's what all the noise is in the change diffs.
 Ping @leebyron - very small change with very big performance implications
 Ah you're right - great solution! Thanks!
  I am trying to update a nested object which consists of both Maps and Lists:

``` javascript
const state = fromJS({
  players: [
    { name: 'Aaron',  forecasts: [ { type: 'winner', val: 1 } ] },
    { name: 'John' }
  ],
  match: { /*...*/ }
});
```

Trying to add a forecast under player, I came up with this:

``` javascript
function addPlayerForecast(state, playerName, forecast) {
  const players = state.get('players');
  const newPlayer = players.find(p => p.get('name') === playerName)
                           .update('forecasts', List(), forecasts => forecasts.push(fromJS(forecast)));
  return state.set(
    'players',
    players.set(players.findIndex(p => p.get('name') === playerName), newPlayer)
  );
}
```

which works fine, but I feel that if, for example, there was a way to use updateIn() with an array of predicates instead of strings would make such a code much more simple. Or is there any other way to simplify this task?
  Sorry if this is already somehow supported or if there's an issue open for it; I couldn't find either.

This is a rather common use case:

``` js
someCollection.filterNot(item => Immutable.is(item, unwantedItem));
```

It would be much easier to write (and later understand) as:

``` js
someCollection.without(unwantedItem);
```

FWIW, lodash has [this same method](https://lodash.com/docs#without).
 An alternative (and/but with broader implications) would be for `filter()` and friends to delegate to `Immutable.is()` when they're called with a value that's not a function.
 Is there a plan to implement a `without` fn? I'm happy to take a stab at it.
 Don't know, didn't get any feedback from the maintainers and then promptly forgot about this myself. :)
 @arjunblj did you ever?
  I want a Map of number to number:

``` js
const x: Im.Map<number, number> = Im.Map([[1, 1]])
```

However, this gives me an error:

```
main.ts(31,7): error TS2322: Type 'Map<{}, {}>' is not assignable to type 'Map<number, number>'.
  Type '{}' is not assignable to type 'number'.
```

Should this be possible?
 Instead write:

``` typescript
const x = Im.Map<number, number>([[1, 1]])
```

The type annotation on the LHS is not required; instead it can be inferred from the RHS.

Also, `Im.Map([[1, 1]])` implies `Im.Map<{}, {}>([[1, 1]])`. Why? Because that's what the [spec says](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#361-type-parameter-lists):

> Omitting a constraint or specifying type any as the constraint corresponds to specifying the empty object type `{}`. 

Hope that helps.
 Your suggestion uses a type assertion to override the type. I was hoping, with the provided type definitions, that TypeScript could infer the type from my usage. Could the type definitions not use generics to allow inference? Still trying to get my head around TypeScript.
 Actually I was just checking that..... The type definition for `Map` could indeed be improved to allow:

``` typescript
const x = Immutable.Map([[1, 1]]); // Immutable.Map<number, number>
```

[This line](https://github.com/facebook/immutable-js/blob/6075107d7bb42414797473b5adf6dd55f6f01062/type-definitions/Immutable.d.ts#L456) from the type definition:

``` typescript
export function Map<K, V>(array: Array</*[K,V]*/Array<any>>): Map<K, V>;
```

could be changed to:

``` typescript
export function Map<K, V>(array: Array<[K,V]>): Map<K, V>;
```
 That's what I was wondering. :+1: Would love to see this change shipped.
 Just come up against this again, completely forgot about this issue. Is immutable js still being maintained? Is there any chance of this being added?
 Thanks @myitcv !!!
 I'm using this helper until the typings are fixed upstream:

``` ts
// Immutable's typings could but don't infer key/value types from entries, so we
// use this helper to convert from Entry[] -> Immutable Map.
// https://github.com/facebook/immutable-js/issues/686
type Entry<K, V> = [ K, V ];
export const entriesToMap = <K, V>(tuples: Entry<K, V>[]): Map<K, V> => (
	Map<K, V>(tuples)
)
```  The example showing how undefined values in a Record are ignored was incorrect, it was actually using a defined value.
 Aaaahh, yeah, I got it now. Sorry for the noise.
  This might be a silly question.

How come when I map over a list it gets converted into an iterable? This means I have to litter my code with `toList` everywhere, like so:

``` js
List([1,2]).map(x => x+1).toList().interpose('foo');
```

Thanks again for the awesome work!
 It doesn't, in your example `toList()` is redundant. The first line of the docs for map states: "Returns a new Iterable of the same type". Remember List extends Iterable, and the return type is given as Iterable to avoid having to write separate map documentation for all the different collection types. However, Map.map returns a Map, List.map returns a List, etc.
 Ah, but I get a compile error when using TypeScript:

``` js
Immutable.List(['foo'])
    .map(x => x)
    .interpose(5)
```

Error:

```
main.ts(27,6): error TS2339: Property 'interpose' does not exist on type 'Iterable<number, string | number>'.
```
 https://github.com/facebook/immutable-js/issues/634 and https://github.com/Microsoft/TypeScript/issues/4967 are related. 

Large parts of the type definition can be improved following the merging of https://github.com/Microsoft/TypeScript/pull/4910 however the issue with `map` remains as far as I can tell (see the comments in https://github.com/Microsoft/TypeScript/issues/4967 in particular)

Whatever the solution here, it raises the question of how we improve the type definition whilst maintaining some degree of backwards compatibility. I can potentially foresee a situation where we end up with multiple typings with suffixes that correspond to TypeScript compiler versions... 

In any case, the immediate solution here is to simply assert the type:

``` typescript
(<List<number>>List([1,2]).map(x => x+1)).interpose('foo')
```

because we know the underlying implementation actually returns a container of the same type, `List<number>` in this situation.
 I am using type assertions to work around this, but how come this doesn't work?

```
(<List<number | string>>List([1,2]).map(x => x+1)).interpose('foo')
```
 Or this:

```
const x = <List<number>>List([1, 2]).map(x => x + 1);
x.map(x => x + 1).interpose('foo')
```
 Breaking apart your first example according to precedence of operators:

``` typescript
List([1,2]) // has type List<number>, inferred from the array of numbers you provide
List([1,2]).map(x => x+1) // therefore has type Iterable<number, number>, per previous comments about map signature
```

The type assertion has the weakest precedence hence these two are equivalent:

``` typescript
<List<number | string>>List([1,2]).map(x => x+1)
<List<number | string>>(List([1,2]).map(x => x+1))
```

which is why you get a compile error in both cases.

Given your map function (which appears to only work on `number`), I'm not entirely sure what you intended here... but hopefully the comments about precedence help steer you in the right direction.

Some other comments:

```
let a = List([1,2]); // a has type List<number>
let b = List<number>([1,2]); // b has type List<number>
let c = List<number | string>([1,2]); // c has type List<number | string>
let d = <List<number | string>>List([1,2]); // d has type List<number | string>
```
 Thanks @myitcv, that helps!
  I'm using immutable.js with TypeScript. I want a typed immutable object, e.g. an object called `Person` with an interface of: `(name: string, age: number)`. 

Ideally I could construct a `Person` and it will be an instance of `Immutable.Map`:

``` js
interface Person {
    name: string;
    age: number
}

var person = Person({ name: 'bob', age: 5 })
person.name // => 'bob'
var newPerson = person.set('name', 'harry');
person.name // => 'bob'
newPerson.name // => 'harry'
```

Is this possible? Sorry if my terminology is not entirely clear!

Thanks :smile: 
 Duplicate of #166 and #341.
 I'm currently following advice from https://github.com/facebook/immutable-js/issues/341#issuecomment-147940378 but this involves overwriting the type definitions. I would also prefer a way to do this without requiring defaults to be setâ€”ideally TypeScript should throw an error if you tried to create an object missing a property.
 To be honest I spent a few days now and a month ago trying to find a solution that would fit all the points including a record inheritance with custom methods, attributes checking and properties accessing using a dot-notation, but I still haven't found it. This feature mixed with a record generic type definitions you mentioned above could solve most of them Microsoft/TypeScript#2225. But there is no progress. @leebyron Could you help us?
 One suggestion is to use Immutableâ€™s Records, but in this case I don't want to allow default values.
 @OliverJAsh if records work for you setting `undefined` defaults should be effectively the same as not setting them at all. Am I wrong?
 Yes, correct, it's just boilerplate really.

On Tue, 28 Jun 2016 at 19:54 Eugene Mirotin notifications@github.com
wrote:

> @OliverJAsh https://github.com/OliverJAsh if records work for you
> setting undefined defaults should be effectively the same as not setting
> them at all. Am I wrong?
> 
> â€”
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/facebook/immutable-js/issues/683#issuecomment-229146829,
> or mute the thread
> https://github.com/notifications/unsubscribe/AA4QCbtrhyPnmGe85DfJFGg4k-nqLyPoks5qQW3IgaJpZM4GYB74
> .
 I found a class to get prop name as string array, then implemented a SetValue Method this has some rough edges.

``` typescript
export class NavigableObject<T>{
    constructor(private obj: T, private path: string[] = []) { }

    To<R>(p: (x: T) => R): NavigableObject<R> {

        let propName = this.getPropName(p)

        if (propName) {
            return new NavigableObject<R>(
                p(this.obj),
                this.path.concat(propName)
            );
        } else {
            return new NavigableObject<R>(
                p(this.obj),
                this.path
            );
        }
    }

    getPath() {
        return this.path;
    }


    private static propertyRegEx = /\.([^\.;]+);?\s*\}$/;

    private getPropName(propertyFunction: Function) {
        let value = NavigableObject.propertyRegEx.exec(propertyFunction.toString())
        if (value)
            return value[1];
    }
}

function NavigatableRecordFactory<X>(defaultValues: X, name?: string) {
    abstract class NavigatableRecord<P extends NavigatableRecord<P>> extends Record(defaultValues, name) {
        SetValue<T>(fn: (x: NavigableObject<P>) => NavigableObject<T>, value: T) {
            return this.setIn(fn(new NavigableObject<any>(this)).getPath(), value)
        }
    }
    return NavigatableRecord;
}

interface IUSER {
    Name: string;
    Age: number;
}

export class USER extends NavigatableRecordFactory<IUSER>({
    Name: "Simy the bothless",
    Age: 27,
})<USER> implements IUSER {
    Name: string;
    Age: number;
}
```

and then use it like 

``` typescript

state.Name // works

state.SetValue(t => t.To(q => q.Name), "test string") // typecheks
state.SetValue(t => t.To(q => q.Name), 123) // error
```

it also works with nested properties 

``` typescript
somenestedImmutable.SetValue(t =>t.To(q => q.Date).To(q => q.Time), 213213123)
```

but cant get it work without needing to implement method in child class ,
little help would be nice if it is possible :)

[Typescript v.2.1.0-dev20160805](https://libraries.io/npm/typescript/2.1.0-dev.20160805)
 Hi Guys,
its 2017, so can we Type a Map now with immutablejs and TypeScript? Specifically enforce the keys.
Posted here: http://stackoverflow.com/questions/41798302/how-do-you-type-an-immutablejs-map-keys
but no one seems to know, odd :/

regards


Sean

Checkout the Ultimate Angular 2 Boorstrap App: @ http://ng2.javascriptninja.io
Source@ https://github.com/born2net/ng2Boilerplate looking fwd to it...
what release will it land on? was this released already? fyi I tried with latest release immutable beta rc and no luck
```

interface ITimelineState {
    zoom: number;
    duration: number;
    channels: Array<IChannels>;
    outputs: Array<IOutputs>;
    items: Array<IItem>;
}

let state: Map<any, ITimelineState> = Map({ // <<<< ERROR
        zoom: 1,
        duration: 500,
        channels: [],
        outputs: [],
        items: []
    });
``` @leebyron Can we see any example of usage? ya same... really need an example please Is this released? An example would be great!
 any news on this? @leebyron can you please post the commits related to fix? Hello from july 6 Hello from July 26th @leebyron any news on this? would love to be able to Type Maps  I'm setting this PR up for this issue: https://github.com/facebook/immutable-js/issues/601

I'm having a problem with the default grunt task though.  There's one test failing for me in master with the following message:

```
Waiting on 1 test.../Users/matt/Documents/Projects/immutable-js/__tests__/zip.ts 97:14 Module 'Immutable' has no exported member 'IndexedIterable'.
 FAIL  __tests__/zip.ts
```

Any idea why that might be the case?

Also I understand that I should add the artifacts to this PR.  Does that include everything from the dist folder?  immutable.d.ts, immutable.js and immutable.min.js?   I just wanted to confirm and I'll update the PR.

Thanks
Matt
 Okay looks like that might have been a problem with the "infinite lists" test in the zip tests file.  I added an additional commit that fixes the build task.
  In a talk, @leebyron explained how immutable data structures work and how any unchanged data is copied while data that is updated is not copied. My question is specifically, "Without comparing old state and new state is there a simple way with immutable js to get the nodes updated or hash input into it?
  Should some methods (`get`, `update`, etc.) accept `notSetValue` as a function that returns a fallback value or it's redundant?

Before:

```
var items = Map<string, Item>();

if (!items.has(key)) {
  items = items.set(key, new Item(...)); // some expensive initialization
}

let item = items.get(key);
```

After:

```
var items = Map<string, Item>(...);

let item = items.get(key, () => new Item(...))
```
 I guess the only issue is that the is a breaking change - if you have a map storing functions, then `items.get(key, defaultFuncValue)` is going to break. Probably not a huge issue, but worth mentioning, since someone somewhere will suddenly have an odd bug.
  ```
var arr1 = immutable.fromJS([
  { age: 25, name: 'john' },
  { age: 32, name: 'sam' },
]);

// simply return the same item
var arr2 = arr1.map( item => item);

console.log(arr2 === arr1) // false
```

Is this behavior designed on purpose? In my opinion, arr2 & arr1 should be equal here.
  Hello friends of immutability!
I just tried to used immutable.js from a typescript project and was wondering why there were static "helper" methods like `Set.of()`, `List.of()` but there seemed to be no `Set.empty()` or `List.empty()`.

After diving into the javascript code it turned out that there actually is an `emptySet()` (this one is sadly not exported), `emptyMap()` and `emptyList()`, but all of them are not exposed via typescript type description. I have not yet checked other collection types but i wished each collection could have an `emptyCOLLTYPE()` or even better `empty()`method as static method (prototype method).

(Even better would be a static class property 'Coll.empty', but as far as I understood, we have to wait for ES7 to get them)
 Good point! I must be blind, sorry for stealing your time :)
  The [documentation for `Iterable.findEntry` and `Iterable.findLastEntry`](https://facebook.github.io/immutable-js/docs/#/Iterable/findEntry) mentions an optional `notSetValue` argument, but this argument does not appear in the [code](https://github.com/facebook/immutable-js/blob/master/src/IterableImpl.js#L176-L189). Instead it just returns `undefined` when the predicate isn't satisfied. I would send a pull request to fix this, but I'm not sure if it's wise to have it return something like `[-1, notSetValue]` because that wouldn't be falsy and could break call sites. It might be better to just update the documentation to not show this argument instead.
 I think they should return `[-1, notSetValue]`. Now destructuring assignment is broken when none of the elements satisfy the predicate:
`const [i, elem] = list.findEntry(predicate);`
 I also stumbled upon this code/doc inconsistency.  I would prefer that the code were implemented to support the docs. I want to use this feature as follows:

```
var entry = list.findEntry(predicate, null, [list.size, new Item()]);
entry[1] = entry[1].set('foo', 'bar');
list = list.set(entry[0], entry[1]);
```

I'm new to this library though, so maybe I'm misusing the paradigm.
  Immutable.is( new Immutable.List([]), new Immutable.List([])); --> true
Immutable.is( new Immutable.List([{}]), new Immutable.List([{}])); --> false

I'm guessing this is due to the object being 2 different instances of a native object. Is this the desired behavior?
 Yes, this is the expected behavior.
 What is the preferred way to check this?
  Hello,

I'm currently using the Immutable library in a project I'm working on. I'm trying to delete an `Map` that is nested inside a `List`, that List itself is nested within a `Map`. Im implementing `.find()` to search for the nested `Map`, and it returns true when it finds it, each time it iterates I increment index and return it from my function. The index that is returned is used within `delete` as the index that `delete` is supposed to delete. The problem is that `.find()` is returning at the wrong place, It is presently returning one index before its supposed to and not sure how predictable that is and how it might respond in different cases. 

``` javascript

//findLead is used within handleRemoveSavedLead, handleRemoveSaveLead returns the new state
function findLead (savedLeads, lead) {
    var index = 0;
     savedLeads.find((l) => {
        index++;
        return l.document_num === lead.document_num;
    }, null, null);

    return index;
}

export function handleRemoveSavedLead (state, selectedLead) {
    var savedLeads = state.get('savedLeads');
        return state.getIn(['savedLeads']).delete(findLead(savedLeads, selectedLead));
}


// Current State That we want to remove an Item from
    var state = Immutable.Map({
                savedLeads: Immutable.List.of(
                    Immutable.Map(
                        {
                            document_id: "L11111111",
                            company_name: "CorpComp",
                            date_filed:"091919",
                            address:"22222 sw 456 Ave",
                            first_name: "jane",
                            last_name: "doe"
                        }
                    ),
                    Immutable.Map(
                        {
                            document_id: "L0928745",
                            company_name: "ShitCorp",
                            date_filed:"987432",
                            address:"02938 sw 754 Ave",
                            first_name: "Misa",
                            last_name: "Crane"
                        }
                    ),
                    Immutable.Map(
                        {
                            document_id: "L4234234234234",
                            company_name: "someComp",
                            date_filed:"083815",
                            address:"11111 sw 123 ave",
                            first_name: "john",
                            last_name: "doe"
                        }
                    )
                )
            });
            // Exact Item we want to delete and is being passed in as parameter
            var leadToRemove = Immutable.Map(
                {
                    document_id: "L0928745",
                    company_name: "ShitCorp",
                    date_filed:"987432",
                    address:"02938 sw 754 Ave",
                    first_name: "Misa",
                    last_name: "Crane"
                }
            );
           // Supposed to return the new state with the item removed.
            var nextState = handleRemoveSavedLead(state, leadToRemove);


```
 I think you are incrementing you index too early in find lead. It will always be 1 more than the desired index.

Consider using `indexOf` here instead of `find`.
 @danielstreit thank you!
  This works:

``` javascript
var x = Immutable.Set().asMutable();
x.add(1);
x.add(2);

console.log(x.toArray());
x.remove(1);
console.log(x.toArray());
```

This fails:

``` javascript
var x = Immutable.Set().asMutable();
x.add(1);
x.add(2);
var y = Immutable.Set([1]);

console.log(x.toArray());
x.subtract(y);
console.log(x.toArray());
```

with:

``` javascript
/Users/dpwrussell/Checkout/immutable_test/node_modules/immutable/dist/immutable.js:1940
        return fn(entry[1], entry[0], this$0);
                       ^

TypeError: Cannot read property '1' of undefined
    at /Users/dpwrussell/Checkout/immutable_test/node_modules/immutable/dist/immutable.js:1940:24
```

The same is true when using `withMutations`.

The documentation for `Set` does mention on `withMutations` that only `add` may be used mutatively, but I am unclear if that is applicable to `asMutable` as well.

This actually does work:

``` javascript
var x = Immutable.Set().asMutable();
x.add(1);
x.add(2);
var y = Immutable.Set([1]);
x = x.asImmutable().asMutable();

console.log(x.toArray());
x.subtract(y);
console.log(x.toArray());
```

As I saId, I'm not sure if this is a documentation issue or an actual bug.
 The docs say that only `Set.add` can be used mutatively for Sets, so your example isn't legal according to the docs: http://facebook.github.io/immutable-js/docs/#/Set/withMutations
 Yes, as I mentioned, it is not clear that this applies to `asMutable` as well as `withMutations`. Looks like it does, but what can/can't be done with `asMutable` and `withMutations` needs to be better documented.
  Hey,

Im new to working with immutable.js and Ive been going through the docs but some of it is very confusing to me, given that I haven't worked with anything like it before so things like this:

``` javascript
update(updater: (value: Map<K, V>) => Map<K, V>): Map<K, V>
update(key: K, updater: (value: V) => V): Map<K, V>
update(key: K, notSetValue: V, updater: (value: V) => V): Map<K, V>
```

literally have me wondering what I am doing with my life. Maybe try to make the docs more friendly to newcomers to the library. The Docs are beautiful to look at, but I've literally looked at snippets and couldn't really understand what the < > things mean and why there are scattered all around the docs. Possibly adding an example of the methods in use would help a lot. Have been defaulting to looking at stackoverflow to see how others implemented the methods but going though stackoverflow looking for something is very time consuming.

Please take this as constructive criticism, I'm not attacking you guys just suggesting. 
 The `Map<K, V>` syntax is says that `Map` accepts keys of type `K` and values of type `V`, where `K` and `V` are arbitrary data types.

I agree that this is very confusing for someone not familiar with the syntax. I like your suggestion of adding concrete examples, but I also think it would be worthwhile to add documentation explaining the syntax used.
 Agreed @brwr 
 I've definitely got to follow up on this. lol. I'd be willing to submit a pull request to explain the syntax but I don't know where to start.

I'm trying to read the docs to figure out how to use and this syntax is tripping me up.

What does this mean?

``` js
findEntry(
predicate: (value?: V, key?: K, iter?: Iterable<K, V>) => boolean,
context?: any,
notSetValue?: V
): Array<any>
```

How do I practically use that?
 Some examples on each function would be awesome, the same way underscore.js ond lodash have them.
 Aha, Just found examples in the tests directory.

https://github.com/facebook/immutable-js/tree/master/__tests__

If I wrote up a bunch of examples to the documentation and submitted a pull request, what's the likelihood it would get merged and my work wouldn't go to waste? :)
 The documentation is still confusing :(
 Adding my 10 cents in here, too. I'm having to learn Immutable.js by trial and error simply because I feel like it's something I really need to understand and use. While there are some basic examples in the docs, it would be great if somebody could give good concrete examples to all elements. Great work though! 
 Agreed, the documentation needs work. It would be great to use a syntax that any JavaScript developer can approach immediately.
  Hi â€“ was prompted to come here by [this tweet](https://twitter.com/niklasbostrom/status/657077775883485184), which reminded me that Immutable uses Esperanto for bundling. Esperanto has been abandoned in favour of [Rollup](http://rollupjs.org/), which does broadly the same thing but with a few added smarts.

The difference this switch makes is fairly negligible...

``` bash
# with Esperanto
Raw: 143,213 bytes
Min:  56,957 bytes
Zip:  15,994 bytes

# with Rollup
Raw: 142,133 bytes
Min:  56,938 bytes
Zip:  15,991 bytes
```

...though the bundled output is slightly nicer to read...

``` diff
-  function src_Iterator__Iterator(next) {
+  function Iterator(next) {
       this.next = next;
     }

-    src_Iterator__Iterator.prototype.toString = function() {
+    Iterator.prototype.toString = function() {
       return '[Iterator]';
     };


-  src_Iterator__Iterator.KEYS = ITERATE_KEYS;
-  src_Iterator__Iterator.VALUES = ITERATE_VALUES;
-  src_Iterator__Iterator.ENTRIES = ITERATE_ENTRIES;
+  Iterator.KEYS = ITERATE_KEYS;
+  Iterator.VALUES = ITERATE_VALUES;
+  Iterator.ENTRIES = ITERATE_ENTRIES;

-  src_Iterator__Iterator.prototype.inspect =
-  src_Iterator__Iterator.prototype.toSource = function () { return this.toString(); }
-  src_Iterator__Iterator.prototype[ITERATOR_SYMBOL] = function () {
+  Iterator.prototype.inspect =
+  Iterator.prototype.toSource = function () { return this.toString(); }
+  Iterator.prototype[ITERATOR_SYMBOL] = function () {
     return this;
   };
```

...really this is just about helping make sure you're not reliant on abandoned tools. Thanks!

PS: One of the tests failed when I ran `grunt`, but that wasn't caused by this change AFAICT â€“ it failed when I ran a freshly checked out master. Just wanted to flag it up anyway
  and so shares the API of Map.  I only discovered this by accident so it seems potentially worth emphasing?
 That's a fair point. That said, the docs don't presently detail how one changes a record (using set, update etc) at all. That should be corrected and guidance given I think.
 Johnny has a point. Right now the docs only show definition, construction and field removal. I wasn't aware of the other methods until I stumbled upon this issue. 
  This mocha test describes my issue:

``` javascript
function closeInstance(processState, name) {
  return processState.deleteIn(['processes', name, 'opened'])
}

it('closeInstance function removes the opened key from the passed process', () => {
  const processState = Map({
    processes: {
      p1: {
        id:     1,
        opened: 'instance_1'
      },
      p2: {
        id:     2,
        opened: 'instance_43'
      }
    }
  })
  const nextState = closeInstance(processState, 'p1')
  const expected = {
    processes: {
      p1: {
        id: 1
      },
      p2: {
        id:     2,
        opened: 'instance_1'
      }
    }
  }
  expect(nextState.toJS()).to.deep.equal(expected)
})
```

Running this test produces the `invalid keypath` error in the `closeInstance` method
 I believe the issue here is that `Map` does not deeply convert the argument.

`processState.get('processes')` returns a vanilla JS object, so the `getIn` call in `closeInstance` returns undefined.

Try using `Immutable.fromJS` to deeply convert the object.
 That fixed my issue, thank you. :+1:
  Changes "regardless of if they WHERE explicitly defined," to "regardless of if they WERE explicitly defined."
  Is getIn more performant then using get? It feels like it should be...But I don't have any good arguments when telling my collegue to use it.

``` javascript
var obj2 = getIn(["key1", "subkey1"])
```

versus

``` javascript
var obj1 = get("key1");
var obj2 = obj1.get("subkey1");
```
 I don't think it makes much difference (an array creation/function call or two, but nothing significant). Either way, I think two O(log32 N) calls are required.
  We have noticed that you don't have to use set withing your withMutations mutator

``` javascript
car.withMutations(t => {
  t.color = "red";
  t.brand = "Volvo";
});
```

The benefit for us is that we get the typing since we use typescript. But Is this safe to use?
 It appears to be a safe, but currently undocumented, feature. Under the hood it just calls 'set'.
  I've been listing through some articles and lots of issues here on Github but I haven't found answer to idea I've got.

If I edit some record in the list somewhere deep in structure tree and pass it on to some store / action creator, in the store I have to somehow find this record again to edit something inside it or maybe delete it. Sure, I can use cursor to simplify this step but I would have to loop through records in the list in order to find that particular record according to ID or something.

Passing on index of this record along with ID (which is needed for API fetch) seems kind a strange to me...

So I got and idea that it would be nice if I had some getPath() method on record, or just record.path because then I could just do in my store something like:

```
updateById(id, record.getPath(), {name: 'john doe'})

updateById(id, path, updateObj) {
   state = state.updateIn(path, prev => prev.merge(updateObj))
}
```

Instead of:

```
updateById(id, {name: 'john doe'})

updateById(id, updateObj) {
  state = state.updateIn(findPathWithLoopById(id), prev => prev.merge(updateObj)))
}
```

Since we have to loop through whole json or some other structure when we do immutable.fromJS() there would be no impact on performance, right?

Or I would appreciate if you point me to some other solution for this which is already out there and I miss it.

Thank you so much for all the great work you have done!
 A single record can be used in many different lists and immutable structures, so which path to return? If you move the record, do you want to change the path in the _immutable_ record?

If you want a simpler lookup, you could maintain a separate map from id to path. Or you could change your data structure so you have an ordered map from id to record rather than a list (you can always get the list back if you need it using toList()).
 @tomwidmer thank you for your reply!
Well yes, yes and yes:)
I think that most of the use cases are that you want to map your immutable state to some react components, get some update action and than find entity to be updated back in the tree using id.
Well maybe I am just looking for some best practices in this area.

And to you note with map with ids as keys: I would love to do it, but we have JSON here, which does not allow to have explicitly indexed arrays nor I can't use object with ids in keys because they don't maintain order :(
  This is a fix for #632 A performance bug with Set#contains

`contains` is initially set to `includes` on the `Iterable.prototype` [here](https://github.com/facebook/immutable-js/blob/master/src/IterableImpl.js#L459). SetIterable.prototype overrides `includes` [here](https://github.com/facebook/immutable-js/blob/master/src/IterableImpl.js#L678). But, `SetIterable` does not implement `contains`, it still points to the super. This pr fixes that.

http://jsperf.com/immutabe-set-vs-normal-object/18

<img width="985" alt="screen shot 2015-10-15 at 10 32 13 pm" src="https://cloud.githubusercontent.com/assets/6923694/10534376/9ddf5712-738c-11e5-9e5e-a892661126e9.png">
  https://github.com/facebook/immutable-js/tree/master/contrib/cursor

Are you using a pattern like redux?
 Seems to me like you can just pass down a cursor to a child component and it will be able to manipulate that cursor as it pleases. All the state pipes all the way down through props. Will all the references change, or will React update optimally?

It seems to be like this could entirely replace redux.
 Yes, it is a simpler alternative to flux, if you want to make your components responsible for data updates. If your app is simple, it may suit you. If your app is complex, I suspect the store+action abstraction might help you.

If you have PureComponents, then the updates should be fairly optimal however you do the update (cursors, or state.setIn, or whatever), since they all boil down the the same Immutable.JS calls ultimately.
 Hmm. Is there an example somewhere I can look at? I havent entirely understood how the whole cursor lifecycle works.
 A few libraries make working with Immutable JS cursors and react a bit easier (I've not tried them):
https://github.com/omniscientjs/immstruct
https://github.com/omniscientjs/omniscient (includes some cursor examples, uses immstruct optionally)
https://github.com/lukasbuenger/immutable-cursors (includes a simple react cursor example - the library itself is minimal)
https://github.com/arch-js/arch

For optimal rendering, you will need to provide a shouldComponentUpdate implementation that is cursor-aware. Just loop over the props and state, detect if the prop is a cursor (using instanceof), and if so check if `next.deref() !== old.deref()` because the cursors themselves will always be !== if they are recreated by a re-render, even if the held immutable data is === (non-cursor props should just be === compared). But that's just optimization, and not required to make it work...
 Thanks for the links! It looks like they are building their own cursors though. not using the immutable.js cursors...
 Hmm. I'm figuring it out a little bit -- is it possible to nest cursors though? for example:

``` js
var data = Immutable.fromJS({ a: { b: { c: 1 } } });
var cursor = Cursor.from(data, 'a', newData => {
  data = newData;
});
var nestedCursor = cursor.get('b')
nestedCursor.set(10)
```
 The links I think all use ImmutableJS cursors under the hood. Your nested cursor example should work, yes.
  Hey, just wondering if there is a possibility to add OT to immutable. The use case can be a common async editing of data. For example, user deletes something and then edit other stuff that mutates the data. The delete ajax call fails and now we need to undo that mutation. Any thoughts?
  What is the reason we introduce immutable.jsï¼Ÿ
Where the immutable's power fromï¼Ÿ
 No magic - just less mutation. 

Research **Persistent data-structures** for a complete picture of what this library offers.

[_From the docs:_](https://facebook.github.io/immutable-js/)

> ## The case for Immutability
> 
> Much of what makes application development difficult is tracking mutation and maintaining state. Developing with immutable data encourages you to think differently about how data flows through your application.
> 
> Subscribing to data events throughout your application, by using Object.observe, or any other mechanism, creates a huge overhead of book-keeping which can hurt performance, sometimes dramatically, and creates opportunities for areas of your application to get out of sync with each other due to easy to make programmer error. Since immutable data never changes, subscribing to changes throughout the model is a dead-end and new data can only ever be passed from above.
> 
> This model of data flow aligns well with the architecture of React and especially well with an application designed using the ideas of Flux.
> 
> When data is passed from above rather than being subscribed to, and you're only interested in doing work when something has changed, you can use equality. Immutable always returns itself when a mutation results in an identical collection, allowing for using === equality to determine if something has changed.
> 
> ``` js
> var map1 = Immutable.Map({a:1, b:2, c:3});
> var map2 = map1.set('b', 2);
> assert(map1 === map2); // no change
> var map3 = map1.set('b', 50);
> assert(map1 !== map3); // change
> ```
> 
> If an object is immutable, it can be "copied" simply by making another reference to it instead of copying the entire object. Because a reference is much smaller than the object itself, this results in memory savings and a potential boost in execution speed for programs which rely on copies (such as an undo-stack).
> 
> ``` js
> var map1 = Immutable.Map({a:1, b:2, c:3});
> var clone = map1;
> ```
 Also, check this out; this provides context in relation with react: http://jlongster.com/Using-Immutable-Data-Structures-in-JavaScript
  Currently I've stumbled upon a somewhat annoying problem in an application using Immutable.js (3.7.5) & React.js (0.14.0).

The following code works as expected:

``` js
import Immutable from 'immutable';
import React from 'react';

export default React.createClass({
  render() {
    const seq = new Immutable.Seq([0, 1, 2, 3, 4]);
    const ids = seq.take(10);

    const divs = seq.map((id) => (
      <span key={id}>{id}</span>
    ));

    return (
      <div>{divs}</div>
    );
  },
});
```

But instead of numbers (`[0, 1, 2, 3, 4,]`) I'm using instances of `Immutable.Record` in my project and the code above raises:

`Uncaught TypeError: Cannot read property '1' of undefined`

This does not happen when the Seq size of the records is > than the n amount I take via `.take(n)`.

[Changing the following lines from](https://github.com/facebook/immutable-js/blob/7c4483e30e8b9528562f6ef34f66bee6bfb3538d/src/Operations.js#L458-L465): 

``` js
var step = iterator.next();
if (useKeys || type === ITERATE_VALUES) {
  return step;
} else if (type === ITERATE_KEYS) {
  return iteratorValue(type, iterations - 1, undefined, step);
} else {
  return iteratorValue(type, iterations - 1, step.value[1], step);
}
```

to:

``` js
var step = iterator.next();
if (useKeys || type === ITERATE_VALUES) {
  return step;
} else if (step.value === undefined || type === ITERATE_KEYS) {
  return iteratorValue(type, iterations - 1, undefined, step);
} else {
  return iteratorValue(type, iterations - 1, step.value[1], step);
}
```

Fixes the issue but it feels like this is being solved at the wrong level.

What is there that I can do to help here?

<img width="1440" alt="screen shot 2015-10-13 at 15 34 08" src="https://cloud.githubusercontent.com/assets/440926/10456137/ee3c4054-71bf-11e5-9f08-c6fc33280496.png">
 Just bumped into this
@ayrton Have your resolved the issue?
 I was not, I was fortunate enough not having to use `.slice()` in that particular case anymore, but this still feels like a weird edge case we should try and solve.
 For me calling `cacheResult` after the `take` (or `slice`) seemed to fix the iterator. Of course you have to take the notes of https://facebook.github.io/immutable-js/docs/#/Seq/cacheResult into account...
  Hello, 

I found an error which appears on Safari <= 5.1. The problem is at the line: https://github.com/facebook/immutable-js/blob/master/src/IterableImpl.js#L471 - Safari has error.stack in version 6 or newer. 

To reproduce this error you just need to require Immutable library and that's it. I guess there are some internal calls for .length in the source code of the library which makes fatal error.

As a temporary solution I've downgraded Immutable to 2.6.2, but it's not a great long term solution. It would be great if you can fix it.
 I have the same problem and needed to downgrade to 2.6.2 version.

Any chance this will by fixed soon?
 Getting exception error due to use of 'Error.prototype.stack' also in Qt browser (4.8).
In my case, it happens on the definition of `Object.defineProperty(IterablePrototype, 'length'`.
  Hi, I'd like to add out-of-the-box support for immutable in Tonic (tonicdev.com). Currently, it is treated like a JS object:

![screen shot 2015-10-05 at 3 34 42 pm](https://cloud.githubusercontent.com/assets/23753/10295621/bb25412e-6b76-11e5-953d-82ca9012a535.png)

Now, ideally I'd do this by identifying that it is an immutable on the server, adding a special flag, and then entirely on the client displaying it the correct way, as opposed to determining it is an immutable on the server and special case serializing it. This way there is no custom serialization, and additionally you can select to view it as a js object as well on the client. However, this would require me to infer the information from the internal structure (iterate through arraymapnodes or whatever). I am happy to do this -- however, I am willing to not do it if the idea is that this will actually change and it is thus unsafe to do it this way.

If that's the case and I should just be appending something like key = map.keys() etc, I'm curious if there is a non-mutative way to do so. That is to say, when we serialize objects on the backend we have a strict policy of not calling any functions that could possibly have side effects (including changing a cache for example). Is I.Map.prototype.keys.apply(theMap) safe (the same way Object.getOwnpropertyDescriptors is?)
  QualifiedName nodes don't have a `text()` method.

This change (or a similar one) is needed to generate the docs after #647. lmk if there's a better way to implement it!
  Re: #592
 @matthewwithanm - what does the resulting documentation look like (not sure how to regenerate)?
 Good question! I hadn't checked /:

The doc generation is in the gh-pages branch and currently chokes on the new fileâ€¦I've opened #648 to teach the visitor about qualified names. After that, these things look pretty much like you might expect (or at least pretty much like I expect):

# Nav

<img width="307" alt="screen shot 2015-10-03 at 9 16 10 am" src="https://cloud.githubusercontent.com/assets/126263/10263811/6e8243da-69af-11e5-9092-9bab6fd47ecf.png">

# Content

<img width="730" alt="screen shot 2015-10-03 at 9 17 20 am" src="https://cloud.githubusercontent.com/assets/126263/10263821/9ac2d84c-69af-11e5-9757-49d35853a214.png">
 I'll defer to @leebyron - just so long as the docs (whatever they look like) match the implementation I'm happy :+1: 
 ðŸ˜Š np 
  Perhaps I'm missing something, but it seems like there is a problem with the `map()` function on records:

``` javascript
R = Immutable.Record({
  foo: undefined,
  bar: undefined
})
r0 = new R({
  foo: 'poo',
  bar: 'BAR'
})
r1 = new R({
  foo: 'FOO'
})
console.log(r1.toJS()) // Object {foo: "FOO", bar: undefined}
r2 = r1.map(function(value, key) {
  return value || r0.get(key)
})
console.log(r2) // undefined
console.log(r1.toJS()) // Object {foo: "FOO", bar: "BAR"}
```
 Definitely looks like a bug (although the documentation is very unclear on what API Record instances actually have access to!).

Should reify be like this:

```
function reify(iter, seq) {
    return isSeq(iter) ? seq : new iter.constructor(seq);
}
```

?? That's just adding the 'new' keyword. It fixes your issue for me locally, but I don't know if it's the correct fix. An alternative might be 

```
function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor.call(null, seq);
}
```

Not sure which fix is the better one!
 > although the documentation is very unclear on what API Record instances actually have access to!

Agreed. The docs are a little unclear on many of the instance methods IMO. I often end up just running them in the console and seeing what happens.
 I believe this is by design. `Record#map` operates on `this` record's values, as opposed to returning a new record.

```
var r = new R();
r.toJS() // { foo: undefined, bar: undefined }
r.map(() => 10);
r.toJS() // { foo: 10, bar: 10 }
```
 Having trouble understanding why any method that _mutated_ an Immutable instance would be intentional.
 That's a terrible behavior if it's intentional. A library called immutableJS should be 100% immutable, it's the sole reason it's useful.

lodash has the same trap: it started as a decent functional lib then added all sort of crap like _.pull, _.pullAt and  _.remove  to directly mutate arrays.

I don't see how this could be intentional.
 It's undefined behaviour (since `Record.map` is not documented anywhere). But if the feature does become official, clearly this would be a straightforward bug, hopefully with a straightforward fix (if my fix above is the correct one, it's just a 4 character insertion). As everyone says, there is no way that `<immutable object>.map()` should modify `<immutable object>` (unless `asMutable` or `withMutable` is used, but map() isn't officially supported on mutable objects in any case).
 Such methods should not be exposed or publicly accessible then.
 Wow, this is an incredibly unexpected behavior. Our project heavily relies on Immutable.js and makes extensive use of Records. This behavior lead to several hours of debugging effort since I didn't think it was possible to mutate the properties of a Record instance once constructed. I offer this feedback not to complain, but to illustrate how seriously this behavior deviates from what I expect as a user of the library.

Hopefully this behavior is not intentional. #505 makes it sound like `.map` will eventually go away on Records, so hopefully that fixes this and any other ways to modify an instance of a record.
  People like to open the console and tinker with the documentation right there.  Might as well give them the latest version.
  With reference to the [current TypeScript type definition](https://github.com/facebook/immutable-js/blob/59028b5e8552339acbdaab0c3f6547bd131f8f54/type-definitions/Immutable.d.ts). 

The following code compiles:

``` typescript
/// <reference path="../jspm_packages/npm/immutable@3.7.5/dist/immutable.d.ts" />

let x = Immutable.Seq([1,2,3]);
console.log(x);
```

but fails at runtime unless you have loaded ImmutableJS elsewhere. For those, like me, who use [SystemJS](https://github.com/systemjs/systemjs) (or other modules loaders) to load modules, we need to declare dependencies via imports, and generally rely on the compiler to tell us when we have missed one (as is the case here).

This PR creates two (linked) versions of the type definition:
- For those people who are going to loaded ImmutableJS elsewhere and want to therefore take advantage of the global definitions, they should reference `Immutable-global.d.ts`
- For those people who use module loaders and want the above code to be a compile error because they haven't imported ImmutableJS, they should use `Immutable.d.ts`

A similar approach is [taken by React](https://github.com/borisyankov/DefinitelyTyped/tree/master/react).

So if instead I reference the `Immutable.d.ts` in this PR, the above code would give a compile error:

```
app/app.ts(3,9): error TS2304: Cannot find name 'Immutable'.
```

This forces me to import:

``` typescript
/// <reference path="../typings/immutable/Immutable.d.ts" />

import * as Immutable from "immutable";

let x = Immutable.Seq([1,2,3]);
console.log(x);
```

The transpiled output then includes the relevant module loading code to ensure ImmutableJS has been loaded before use (in my case I'm using [SystemJS](https://github.com/systemjs/systemjs)):

``` javascript
System.register(["immutable"], function(exports_1) {
    var Immutable;
    var x;
    return {
        setters:[
            function (Immutable_1) {
                Immutable = Immutable_1;
            }],
        execute: function() {
            x = Immutable.Seq([1, 2, 3]);
            console.log(x);
        }
    }
});
```
 Just re-pushed in case anyone got in early...
 @leebyron - any thoughts on this?
 Yes they're unrelated (just so happens that `Seq` is used as an example in both)
 :+1: 
 :+1:
 Related discussion https://github.com/typings/typings/issues/49
 :+1:
 Minor point...I just checked out this PR locally and when I do a `grunt build`, it creates a file called `immutable.d.ts`.  But the `reference` element in `immutable-global.d.ts` says this:

```
/// <reference path="Immutable.d.ts" />
```

Note that the file it is referencing starts with a capital letter.  But the actual file starts with a lower case letter.  I suspect that on an OSX or Windows system, this might somehow can "corrected".  But not on a truly case sensitive file system (unless I'm missing something).  Also, the name `immutable` and `Immutable` appear several places in the `Gruntfile`.  This seems like a recipe for disaster.  This is probably beyond the scope of this ticket, but I just wanted to call attention to it.
  A function `addIn` that is analogous to `setIn`, but for nested `Set`s.

``` js
import { Set } from 'immutable';
const map = Immutable.fromJS({ indices: { ids: Set() } });

map.addIn(['indices', 'ids'], 5);
// Shorthand for:
map.updateIn(['indices', 'ids'], ids => ids.add(5));
```
 Also `removeIn` would be helpful.

Additionally (perhaps this deserves its own issue) this seems inconsistent:

``` js
var set = Immutable.Set([0, 1, 2]);
var map = Immutable.fromJS({ s: set });

set.delete(1).toString();
// "Set { 0, 2 }"

map.deleteIn(['s'], 1).toString();
// "Map {}"

map.deleteIn(['s', 1]).toString();
//Â immutable.min.js:11 Uncaught Error: invalid keyPath(â€¦)
```
 It seems _strange_ to me that this is missing. Working with nested sets is uniquely difficult due to this ommission
 This seems like an easy and obvious improvement.  Why hasn't there been any movement in almost a year?  Would the maintainers like a pull request?
 I guess immutable applies to the API as well...
  Are there plans to offer weak versions of containers, e.g. a `WeakMap` equivalent of [`Map`](https://facebook.github.io/immutable-js/docs/#/Map)?
 Not even using the new experimental [`WeakSet`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet) and [`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) under the covers?
  Consider:

```
var a = Immutable.Iterable([1,2,3])
var b = a.slice(0, 1.5)
console.log(b.size)
// => 1.5
```

From my experience, this later causes functions like `Iterable#map` to never terminate. We probably want to enforce all containers to never ever have a decimal size, as it doesn't make sense. We can make `slice` throw on decimal indexes, or, we can mirror Array#slice behavior and just floor the passed indexes.
   Test passed!
  I'm transitioning my codebase from custom objects + Lodash and so far Immutable has replaced both perfectly. But there's ont thing I can't seem to do easily which is to get the sum of a List/Map. Currently doing this:

``` js
let total = 0;
entries.forEach(entry => total += entry.get('price'));
```

Is there anything similar to Lodash's `sum` like `entries.sum('price')` or `entries.sum(entry => entry.get('price'))` or something that I missed in the documentation? 
 I couldn't find any methods like `sum` but I guess the closest way to accomplish something like `sum` is to use the `reduce` method.

``` js
var entries = Immutable.fromJS([
    {price: 1},
    {price: 2},
    {price: 3},
]);

var sum = entries.map(entry => entry.get('price')).reduce((prev, current) => prev + current);
console.log(sum); // 6
```
 reduce is pretty much the standard way to do these aggregation operations in functional programming
  Using `contains` to search in a set is incredibly slow, the time is spent in the `Iterable.is` comparison method.

This is irritating since `contains` is referenced as alias to `includes` in the documentation.

A benchmark:
https://jsperf.com/immutabe-set-vs-normal-object/14

![screen shot 2015-09-24 at 12 20 41](https://cloud.githubusercontent.com/assets/55547/10071006/b0bd5190-62b6-11e5-90f0-bede5d6654d4.png)
 That is really strange.  Here's the code for it: https://github.com/facebook/immutable-js/blob/9a5897ec0bd623b9e41e0015c75e5f7a46a3494e/src/IterableImpl.js#L459
 The difference is that `contains` uses the `Iterable` mixin: https://github.com/facebook/immutable-js/blob/9a5897ec0bd623b9e41e0015c75e5f7a46a3494e/src/IterableImpl.js#L147

and `includes` uses the `SetIterable`mixin: https://github.com/facebook/immutable-js/blob/9a5897ec0bd623b9e41e0015c75e5f7a46a3494e/src/IterableImpl.js#L678
 I tried adding a Unit-Test, but I don't really understand how the mixins work. How would such a test be written? (that calling `.has` equals calling `.contains` etc.)
 I guess you could 'spy' on .has using a jasmine spy and check that .contains calls it. Something like:

```
var spy = spyOn(mySet, 'has');
expect(mySet.contains('foo')).toBe(true);
expect(mySet.has).toHaveBeenCalled();
```

or something.
  I often find myself in a situation where I would like to update a nested structure where I don't know all the keynames of a sub-structure or a sub-structure is a list. In short i'd need a function like

`obj = obj.updateIn(["key1","key2", /.*/, "key3", function() {})`

The third argument could be a RegExp to match all keys of an object, or a filter-function returning matching indices or keys, if it's a list.

Would such a thing be feasible? 
  The constructor appears to only be invoked once when the first instance is created. When mutating the instance it appears as though I've created another instance but the constructor is not called again, should it?

Example fiddle: https://jsfiddle.net/fuLq02vc/

The use-case is if my instance wants to compute internal values derived from the external properties - it needs a hook to know when those properties have changed.
  Using `Map` collides with ES6 `Map`, and explicit renaming of every `Map` inside import is not ideal. Besides, in JS world `Map` is mutable by default and therefore naming `Immutable.Map` just as a `Map` is a bit tricky.

This of course applies to all types (List, Range...)
 you can:

``` js
import { Map as IMap } from 'immutable';
// or
const IMap = Immutable.Map;
```
 I know that I can, yet neither one solution seems ideal, and taking the vague naming into consideration `ImmutableMap` by default makes biggest sense to me.
  [Here](http://facebook.github.io/immutable-js/#the-case-for-immutability) it says: 

> Immutable always returns itself when a mutation results in an identical collection, allowing for using === equality to determine if something has changed.
> 
> ```
> var map1 = Immutable.Map({a:1, b:2, c:3});
> var map2 = map1.set('b', 2);
> assert(map1 === map2); // no change
> ```

However, on the [documentation for `is`](http://facebook.github.io/immutable-js/docs/#/is) it says:

> ```
> var map1 = Immutable.Map({a:1, b:1, c:1});
> var map2 = Immutable.Map({a:1, b:1, c:1});
> assert(map1 !== map2);
> assert(Object.is(map1, map2) === false);
> assert(Immutable.is(map1, map2) === true);
> ```

Surely both `assert(map1 === map2)` and `assert(map1 !== map2)` cannot both be true?  Very confusing!
 `map1` and `map2` are created in different ways in the two examples.

In the first example, `map2` is created by calling the `set` method on `map1`. As the property 'b' is already 2 there is no change to make, so `set` returns a reference to the same Immutable object that `map1` refers to and so `map1 === map2`

In the second example, `map1` and `map2` are created by separate calls to Immutable.Map, returning two separate Immutable objects, so `map1 !== map2` in the same way that `{a: 1, b: 1} !== {a: 1, b: 1}`
 Thanks @ellbee - I see what you mean.  That makes sense now you've explained it.  

I would say it's a little confusing for a newbie to see these similar yet different things in the docs though.  Generally people will want to check for value equality using `Immutable.is` or `equals` and so I wonder if this example may actually hinder people ie lead to them using `===` where they should be using `Immutable.is`?

By the way, slightly off topic, `equals` doesn't appear to feature in the main documentation - unless I've missed it...
 I think you are right about it being a little confusing. 

Equality is probably the biggest source of confusion I notice around the library and in particular the fact that set/merge returns the same Immutable object if a mutation results in an identical collection but map/filter/reduce **always** returns a new Immutable object (it doesn't matter whether the collection ends up identical or not).
  Given a key that is in an OrderedMap, is there an efficient way (O(1) or O(log n)) to get the next or previous item? 
 It appears that with the current libraries API the best I can do is O(n). 

It would be convenient to implement a [TreeMap](http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html) so we can have an `OrderedMap` that can be navigated via a [NavigableMap](http://docs.oracle.com/javase/7/docs/api/java/util/NavigableMap.html). The `lowerKey()` and `higherKey()` methods return the next and previous keys. This simply keeps track of three nodes (next, current, and previous). Although I know `SortedMap` is also [under consideration](https://github.com/facebook/immutable-js/issues/88) and that would be nice to have alongside this.

If you were to achieve a more performant lookup I imagine it would be similar to what users are doing for SortedMap right now. Which is to maintain an array of the keys. Then you can use the index of the current key in order to get the previous or next keys.

If anyone has any other tips or ways of achieving this I would love to hear about them!
  ES6 Symbols will throw a runtime exception if implicitly coerced into a string.

---

Closes https://github.com/facebook/immutable-js/issues/619

---

Unsure if this is the right patch.
 Yep verified. I probably should've put in a test for it.
 @leebyron I wasn't quite sure how to test this such that:

``` js
Symbol() + ''; // this throws
String(Symbol()); // but this doesn't throw
```

I added a test case that I was working from; but didn't get far. I added a polyfill, core-js, which may be undesirable. 

---

I think an alternative approach to testing would be to mock the String constructor using Jest; but I'm not quite sure how to do this.
 What's the status of this PR? I'm running into the same problem and would like to see this merged.
 This needs more work. I won't be able to look into it for the next few weeks...
 @dashed Can you explain what needs more work? I can lend a hand :+1: 
 @puradox https://github.com/facebook/immutable-js/pull/620#issuecomment-166125273
 Yay! Thanks @leebyron ! ðŸŽ‰ 
 Recover my Gmail account reginaladnier50@gmail.com
  ``` js
const data = Immutable.fromJS({a: 1, b: 2});

const cursor = Cursor.from(data, newData => {
  console.log(newData)
});

cursor.set('a', 2); // Map {"a": 2, "b": 2}
cursor.set('b', 3); // Map {"a": 1, "b": 3}
```

The second `.set()` call disregards the value which the first `.set()` call sets. I require the second `.set()` to return `Map {"a": 2, "b": 3}`
## Context

Two sub cursors (which don't share the same parent cursor), are passed to a React component as two individual `props`. I wish to update the values of both sub cursors in the same function call within that React component.
 In older versions of Immutable you needed to actually redefine the cursor on each change.

Try something like:

``` javascript
const data = Immutable.fromJS({a: 1, b: 2});
const cursor = Cursor.from(data, onTransaction);
function  onTransaction(newData, oldData) {
      cursor = Cursor.from(newData, onTransaction);
}
```
 [From the source it looks like you just use `withMutations` to sequentially operate on the cursor](https://github.com/facebook/immutable-js/blob/cursor/__tests__/Cursor.ts):

``` javascript
  it('can have mutations apply with a single callback', () => {
    var onChange = jest.genMockFunction();
    var data = Immutable.fromJS({'a': 1});

    var c1 = data.cursor(onChange);
    var c2 = c1.withMutations(m => m.set('b', 2).set('c', 3).set('d', 4));

    expect(c1.toObject()).toEqual({'a': 1});
    expect(c2.toObject()).toEqual({'a': 1, 'b': 2, 'c': 3, 'd': 4});
    expect(onChange.mock.calls.length).toBe(1);
  });

```
 I think the problem is more like this, in code:

``` javascript
const data = Immutable.fromJS({x: {a: 1, b: 2}});

const cursor = Cursor.from(data, newData => {
  console.log(newData)
});

const cursor1 = cursor.get('x');
const cursor2 = cursor.get('x');

// pass cursor1 and cursor2 to different places, then

cursor1.set('a', 2); // Map {"x": {"a": 2, "b": 2}}
cursor2.set('b', 3); // Map {"x": {"a": 1, "b": 3}}
```

The cursors are independent, changing one has no effect on the other, which makes them less useful than they could be. You could say they are not "live" - once you derive a cursor from a parent, changes to the parent (because they need to overwrite the parent), don't affect the child any more.

All the cursors do is enable you to apply "local-looking" changes to the global data structure as of the time they were created.

Normally you'd solve this with chaining, but since they are now in different places, you can't do even that. Not sure how to proceed in this case...
 The core of the problem is that each cursor holds it's own reference to the root data, not a shared one. It would IMHO require significant changes to how cursors work to enable this use-case.
 @jameshopkins based on your requirements from _context_ section:

> Two sub cursors (which don't share the same parent cursor), are passed to a React component as two > individual props. I wish to update the values of both sub cursors in the same function call within that React component.

One approach would be to pass an `onChange` handler to the child  component that calls a function on the parent with _both_ new values. Then your parent component can use `withMutations` to make both changes transactionally.
 @jurassix that sort of defeats the point of using cursors in the first place - i.e. getting away from the callback spaghetti :)
  Refs: https://github.com/facebook/immutable-js/issues/569
  Refs: https://github.com/facebook/immutable-js/issues/601 https://github.com/facebook/immutable-js/issues/605 https://github.com/facebook/immutable-js/pull/615/
  @rawls238 In the case that you would do the difference across 2 maps, such as:

``` javascript
const mapOne = new Immutable.Map({a: 1, b: 2});
const mapTwo = new Immutable.Map({a: 1});
console.log(mapOne.subtract(mapTwo));    // {a: 1, b: 2}
console.log(mapOne.subtract({1: 'a'}));  // {b: 2}
```

It seems like the behavior is sort of unexpected because you're using the `includes` function in your implementation, which will use the values of `mapTwo` to perform the "difference."

@derekdreery @leebyron care to shed some light on what the semantics for comparison across 2 maps should be? Seems like the intuitive thing to do is use the keys.

Also, if this is the case, what role should the value play if any? None, as in this example?

``` javascript
// This example assumes that Map comparison is key-based
const mapOne = new Immutable.Map({a: 1, b: 2});
console.log(mapOne.subtract({a: 1}); // {b: 2}
console.log(mapOne.subtract({a: 7}); // {b: 2} as well
```
  When converting an `OrderedSet` to a `Set`, the `equals()` method returns false when comparing to a `Set` that should be considered equal.

``` javascript
// example
var orderedSet = Immutable.OrderedSet([1,2]);
var set = Immutable.Set([1,2]);
orderedSet.toSet().equals(set); // false (expected true)
set.toOrderedSet().equals(orderedSet); // true (expected)
orderedSet.toSeq().toSet().equals(set); // true (expected)
```
 @rawls238 I just double-checked: go to the Immutable.js website, open web inspector and copy my code in it (the last 3 lines you have to copy separately): you will see that what passes locally for you breaks on the current site.
Maybe this is fixed on master and the site uses an old version (as I might do).
 Dupe btw, https://github.com/facebook/immutable-js/issues/508
    Am I missing some sort of API that lets me make a complex object deeply mutable?

For example, given a Map with another Map nested inside, I'd love to grab a reference to that nested Map, alter it and not have to re-assign it to the containing Map. Here is some code that illustrates this behavior:

``` js
  let m = Immutable.fromJS({x: 1, y: Immutable.fromJS({a:5, b:6})});
  console.log("Before:", m.toJS());

  let m2 = m.withMutations((res) => {
    res.set("x", 2);
    res.setIn(["y", "a"], 8);
    let y = res.get("y");
    y.set("b", 9);
  });
  console.log("Final:", m2.toJS()); // {x: 2, y: {a: 8, b: 6}} - "b" doesn't get updated
```

Even if I do `y.asMutable().set("b", 9)` the final `m2` does not show an updated b. Is there any way to turn an object "deeply" mutable so I can pass substructures to helper methods?
 As the other side, I want a asImmutable(deep: true) act recursively.
It's not easily done outside the library and is a common demand.
 (Did not want to create a new ticket, but I was basically looking for the same thing.)

@leebyron So if `withMutations`s scope should not be changed, do you think that a feature like this should be discussed as new functionality? Does this usage even make sense for Immutable, or are the author and myself using the library in some unintended way and hence run into this?

(I am basically asking for a readable, high-performance way to update many nested fields in a record at once.)  I was wondering if it is possible to do something like the following:

``` javascript
let data = {
  "posts": [
    {
      "id": 1,
      "title": "Cool post",
      "content": "This post content!"
    },
    {
      "id": 2,
      "title": "Cool post 2",
      "content": "This is post 2 content!"
    }
  ],
  "someOtherData": [...]
};
let imData = Immutable.fromJS(data);

// Create mask
let mask = Immutable.fromJS({
  "posts": ["id", "title"]
}

// Filter / deep get ?
let result = imData.get(mask).toJS(); 

// Result now being:
{
  "posts":
    [
      {"id": 1, "title": "Cool post"},
      {"id": 2, "title": "Cool post 2"}
    ]
}
```

For arbitrarily deep masks btw.
 Is that a resounding no? or a "yeah, that is obvious" affirmation?  Hi

I've currently have a util function that does something along these lines : 

``` js
 function toggle (set, v) {
  return set.includes(v) ? set.delete(v) : set.add(v)
}
```

What about having it directly on the prototype? Something like : 
`newSet = set.toggle(value)`
 I wished the same today. I agree that simple helpers should not clutter the library, but this seems to be a very common use case of a Set.

While writing a simple helper is not such a big issue, Immutable uses methods in favor of this-less functions so custom helper functions will look very different to builtin methods and it'll create a mixed API. (Adding new methods to the prototype would solve this, but it's almost universally frowned upon.)  There have been fixes to regressions since 3.7.3 that haven't been released as of 3.7.4. Specifically https://github.com/facebook/immutable-js/issues/480. Wondering if we can get a new version out?
 Thanks :+1: 
  When I use `get(false)` or `getIn([false])` on a `List`, the first value from the list is returned. I was expecting `undefined`.

http://jsbin.com/nirahamohu/edit?js,console
 Thanks!
  Currently `fromJS(new Set([1,2,3]))` bails, just returning the original es6 set, not an immutable set as I would expect.
Also, I'd love for `Immutable.Set([1,2,3]).toJS()` to return an es6 Set, but I realize that this would be a breaking API change, and probably unacceptable.

Of course, I could just write my own implementations, which is what I have currently.
  I have an immutable global object which is being changed from multiple components directly. Everytime the object changes I need to re-render the complete page, unfortunately I am not able to figure out if the object has changed. Is there a `subscribe` func thru which I can subscribe for all the changes that are happening on this immutable?

Or could this be a wrong design altogether?
 How are you changing your immutable ? 
Is that object part of the state of your top level component ? 
How do you call .setState({..}) ?
Do you use a "flux pattern" for managing state ? (If not, checkout reflux.js or google for "react flux")

Some code snippets would be helpful. In essence, react will do the rerendering part for you, so you don't have to deal with the DOM, all you do is change the state via react function .setState().
 I only have one immutable global store which contains everything.
1. I am changing the immutable via `setIn()` method.
2. No its not truly a part of the top level component, its a completely different store (Is that the problem?)
3. I don't call setState because I am not setting the root component's state, instead a global immutable obj. (How can I use the immutable obj to persist state in a component?)
4. I am using [redux](http://rackt.github.io/redux/)

## Code

``` javascript
//GlobalStore.js
var store =  Immutable.fromJS({
  a: {aa: 1},
  b: {bb: 2},
  c: {cc: 3}
});

export function updateState(path, val){
  store = store.setIn(path, val);
  render(store);  //re-renders the complete view everytime.
}

function render (data) {
  React.render(React.createElement(Main, {data}), document.body))
}
```

``` jsx
export default class Main extends Component { 
    render() {
                var data = this.props.data;
        return (
                    <Link label='aa' store={data.get('a')} />
        );
    }
}

export default class Link extends Component {
    render() {
        return (
            <a onClick={this.props.store.set('aa', 100)}>       
            </a>
        );
    }
}
```

How do I make sure that the page re-renders when I click on the `Link` ?
 I am not familiar with redux, but skimming docs for a sec I found http://rackt.github.io/redux/docs/api/Store.html#dispatch 

Dispatches an action. **This is the only way to trigger a state change.**

Also the way you create redux store seems strange. Looking at docs,  shouldn't you call a createStore function  and pass it an object ?

I am sorry I can not be more helpful, maybe someone more familiar with redux can help you here, but you will have more luck on stackowerflow. 
  as another guy states in that bug..
https://github.com/facebook/immutable-js/issues/455

i think it would be nice to have this feature.

for example, i am creating a web with ReactJS and i am trying to show a list of items.

i need to quick short cut the rendering if i know that the item doesnt change at all.

Of course i could mergeDeep and then delete the keys that are not anymore there but i think we should have a simple operation as intersection is.

thanks for develop ImmutableJS :).
 +1 for key intersection of Map 
related to #601 
 This would be very useful to me right now. I'm working on a settings modal that uses one immutable map for the current active settings and another one that is the pending settings. If the active settings and the pending settings are the same (via Immutable.is), no changes have been made. When the user goes to save their changes I'd like to do this kind of deepSet between the active settings and the pending settings. The pending settings get priority, any keys that exist in active but are missing in pending get removed from active. For all the other keys it works like a normal merge.
 +1 for this feature. I have exactly the same scenario as frank-weindel.
 I will try to explain my scenario.
supose you have a REST endpoint that returns N items. And this list changes all the time very quickly.
So you have a lot of item that was previously in the map but  some dissapear and some are new.

I wanted to have the intersection of both sets/maps plus the new ones.

So in the end what i wanted it wasn't an intersection.

I wanted something like mergeDeep and delete those items that aren't there anymore.
 This feature would be very useful. I currently have 2 similar structures stored in ordered maps, let's call them Schema and Document. Document is created from Schema then edited as required.

I need to be able to deep merge Document with all its values into Schema but delete any keys (nested or otherwise) that don't exist in Schema.

Currently I use mergeWith and delete keys recursively down the tree but a new member of orderedMap (eg. intersect) would be awesome!

I did consider using orderedSet for this but it doesn't match my needs entirely. By the way, thanks so much for immutable.js - incredible library!
 This would definitely be a nice feature to have. One way this can be done:

```javascript
import { Map, Set } = from 'immutable';

// Shared properties, expected result:
let start = Map({ testing: '123', anotherProp: 'hello!' });

// Make 'superset' objects:
let m2 = start.set('noMatching', '?');
let m3 = start.set('noMatch', 'nope');
// Sets from keys:
let s2 = Set.fromKeys(m2);
let s3 = Set.fromKeys(m3);

// Intersection of keys:
let keySet = s2.intersect(s3);
// Resulting 'intersection' map:
let result = m2.takeWhile((val, key) => keySet.has(key));

result.equals(start);
```

[edit]:

I threw together a solution for deep intersection that should work on most immutable structures:
https://gist.github.com/lukaswelinder/d01c80763de990eb9b0dbb0f722d6659

At the moment, my implementation goes the subtract -> delete approach on the target/original. If you change `USE_VALUE` to true it will also compare value when finding the intersect.

I think the expected behavior of deep intersection needs some consideration:

1. Should the the intersect include values?
1. If not, then what value should be returned?
   a. Value on target/original.
   b. Value on last argument.
   c. List of values starting with the target/original.

Any thoughts on this?  It would be nice if get accepts multiple keys.

So it would be easier to extract data from it, like: `let [id, name] = map.get("id", "name")`
 I think there's a pretty high convenience that comes from being able to destructure a get. Agree that `get`, as it is, is predictable and should stay that way. How about introducing a `getMany`, which would always return an array and always take in a spread of strings representing keys to get values for? 

IMO, get is the inverse of set, so I feel like there would naturally be a `setMany` method, and that could get complicated.

In addition, it's unclear to me whether something like `getMany` would be a method on its own (with logic, etc.) or really just sugar around multiple gets for the same Iterable.

Wanted to add my two cents, as it has crossed my mind when destructuring native structures and then having to resort to either multiple gets or weird `withMutations` code for Immutable Iterables.
 Related discussion:
https://esdiscuss.org/topic/extensible-destructuring-proposal

https://github.com/vacuumlabs/es-proposals/blob/master/extensible-destructuring.md
https://github.com/vacuumlabs/babel-plugin-extensible-destructuring
 I can confirm that destructuring works on Lists because of iteration. In the same way, it can be used for any Immutable Iterable, including Map, if iterators are used.

`let [ id, name ] = OrderedMap({ id: 1, name: "John" }).values();`

Of course you have make sure match the key name to the order it was set.
  The following expression diverges when evaluated:
`Immutable.List().slice(0, NaN).concat(NaN)`.

CC @DivyaPrabhakar
 Thanks!
  It would be nice if `toMap` accepted a mapping function to specify what the values should be:

```
var input = Immutable.List(['a', 's', 'd', 'f']);
var output = input.toMap(x => x.toUpperCase() + '!'); 
// output = Map { 'a': 'A!', 's': 'S!', 'd': 'D!', 'f': 'F!' }
```

You could do `input.toMap().map(x => x.toUpperCase() + '!')` at the moment but it's not as nice :stuck_out_tongue_winking_eye: 

.NET LINQ has similar functionality, except it uses the function to specify the key rather than the value: https://msdn.microsoft.com/en-us/library/bb549277(v=vs.95).aspx
 The current functionality is done by design, per the documentation of `toMap()`: 

`Note: This is equivalent to Map(this.toKeyedSeq()), but provided for convenience and to allow for chained expressions.`

So the chaining that you're doing is exactly how they meant it to work, I think :smile:. 
 Note, the code you have would actually produce:

`"Map { 0: "A!", 1: "S!", 2: "D!", 3: "F!" }"` instead of `Map { 'a': 'A!', 's': 'S!', 'd': 'D!', 'f': 'F!' }`

I'd like a value selector as mentioned above, but I'd actually much prefer a key selector. I find that the lack of a key selector is a much more significant limitation.
 I posted some code for this on #697. Thoughts?
  Adding some tests that ensure that sending a null argument to List.get() will return undefined.

This is the expected behavior on master, but on [3.7.4](https://github.com/facebook/immutable-js/tree/3.7.4) this is currently failing.

I've created [a branch off of 3.7.4](https://github.com/kevinold/immutable-js/tree/v3.7.4_List_get_null) with [a patch](https://github.com/kevinold/immutable-js/commit/f4f123a32a5833e918cf6f5aa60acb1c6384077b) to show these tests failing.

According to a git bisect, this patch was the "good" patch that introduced the fix for this issue - https://github.com/facebook/immutable-js/commit/e4a1e34bc735055819a216764852b03c81cbc301
  is this a bug?

``` javascript
var test = Immutable.fromJS([{'a':[1,2,3, 4, 5]}, undefined, {'c': undefined}]);
test.mergeIn([0, 'a'], [5,6,7]) // [{a: [5,6,7,4,5]} , undefined, {c: undefined}]
test.mergeIn([2, 'c'], 'hello') 
// Uncaught TypeError: Cannot read property 'merge' of undefined
```

I find it a little inconsistent from what i was expecting to happen. 
 Maybe @ddaza is confused about merging [1,2,3,4,5] and [5,6,7] results in [5,6,7,4,5] and not [1,2,3,4,5,6,7]?
 Sorry i didn't specify where the confusion is. 
The first merge makes sense to me the array gets merged on the same indexes of the array so that's not problem.

The last line of the test is what I find inconsistent. 

When I merge 2 objects and keys I assumed that the keys will remain  and values are swapped by the new merged object, since the documentation says that  MergeIn  is "A combination of updateIn and merge".  In my opinion that logic should make `undefined` into  `hello` instead of erroring out.  

If the current functionality is done by design then is my mistake. 

Thanks!  
 thanks
 I disagree that this is expected behavior.

Null is not formally a value, but is typically used as a de facto value in JSON, so that the key is held open for further updates. When I have a data structure that can change shape and value over successive generations of `mergeIn`, I'm gambling that nobody -- at some point -- sent me anything of the form `{ keyToBeFilledInLater: null }`.

So what are the alternatives?

First, I can use `setIn`. On my current project we're doing that, it was the correct behavior for our case.

But going back to the problem of a structure that adds keys. If I use `setIn`, I will first need to check for that key before I can use `setIn`. 

So I throw my hands in the air and use `mergeIn`, since that's what it's for. But now, instead of a guard clause on keys, I need a guard clause on values.

To me, this defeats the purpose of high-level convenience functions, which is to be convenient without surprising corner cases.

If the behavior is not intended to change, perhaps a more helpful error message could be added? Something of the form

```
You tried to merge a new value into a null value. Try using set or ensure that the value is not-null at creation time.
```
 Update for anyone foolish enough to take me seriously, I got the above only partly halfway correct.

`set*` _will_ create new keys and values, including for keys with a value of null.

```
a = { key: null }
aImmutable = Immutable.fromJS(a)
aImmutable.setIn(['key'], 1)
-> Object {key: 1}
```
  Hi, 

I am trying to `import Immutable from 'immutable-js'` with the following webpack settings:

```
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loaders: ["babel-loader"],
      },
```

This results in the following error: 

```
ERROR in ../~/immutable-js/dist/immutable.js
Module parse failed: /Users/alex/myproject/node_modules/immutable-js/dist/immutable.js Line 190: Unexpected token =>
You may need an appropriate loader to handle this file type.
|    */
|   function mixin(ctor, funcs) {
|       var copier = key => { ctor.prototype[key] = funcs[key]; };
|       Object.keys(funcs).forEach(copier);
|       Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(funcs).forEach(copier);
 @ ./components/Quiz.js 21:19-42
```

When I stop excluding `node_modules` in my webpack config: 

```
ERROR in ../~/immutable-js/dist/immutable.js
Module build failed: SyntaxError: /Users/alex/djcode/patient-health-questionnaire/node_modules/immutable-js/dist/immutable.js: Line 350: Derived constructor must call super()
  348 |   var COLLECTION_TYPEDEF = '[Iterable Collection]';
  349 |   class Collection extends Iterable {
> 350 |       constructor() {
      |       ^
  351 |           throw TypeError('Abstract');
  352 |       }
  353 |   }
```

I am currently using the following workaround in my `webpack.config.js`: 

```
  resolve: {
    alias: {
      'immutable-js': 'immutable-js/dist/browser/Immutable.js',
    },
  },
```

although this seems to result in a misbehaving Immutable, eg; `Immutable.fromJS([{someKey: 1, anotherKey: 2}, {someKey: 3, anotherKey: 4}])` is not resulting an `Immutable.List` of `Immutable.Map`'s (admittedly this may  be a separate issue). 

I think the solution is likely to have the `dist` code either be valid ES5 (no more `=>`s, etc) or completely valid ES6 (call super() in constructor's, etc). The former would likely be preferred, probably through a tool like Babel. 
 Looks like you are importing the "wrong" package. You are including [this package from jbiasi](https://www.npmjs.com/package/immutable-js) and not [immutable](https://www.npmjs.com/package/immutable) from Facebook (confusing, I know).

Imports with "immutable" should work fine with the webpack config above, if you are looking for immutable-js you should open an [issue](https://github.com/janbiasi/immutable/issues) there.
 ...Well if that's not embarrassing I don't know what is! Thanks for the gentle correction @madebyherzblut 
  I am testing this:

``` javascript
var test = Immutable.fromJS([1, { 'a':  [1,2,3] }]); 
test.getIn([1, undefined], 'hello') // "hello"
test.getIn([1, 'a', 0], 'hello') // 1
test.getIn([1, 'a' ,undefined], 'hello') // undefined
```

The last statement should return `"hello"` but it returns `undefined`. 
  ``` javascript
var test = Immutable.List([1, {'a':1}]);

test.getIn([0]) //  1
test.getIn([1]) // Object {a: 1}
test.getIn([1, 'a']) // undefined 
```

I was expecting the last stament to be `1`. Am I doing something wrong?
 Thanks!
 I had one other question thought. 

``` javascript
var test = Immutable.fromJS([1, { 'a':  [1,2,3] }]); 
test.getIn([1, undefined], 'hello') // "hello"
test.getIn([1, 'a', 0], 'hello') // 1
test.getIn([1, 'a' ,undefined], 'hello') // undefined
```

The last statement should return `"hello"` but it return `undefined`. 
 sure, thanks!
  Hi,

I found one inconsistency in Immutable.Map class when using numbers as keys.

```
Immutable.Map({ 1: "a" }).get(1) // => undefined
Immutable.fromJS({ 1: "a" }).get(1) // => undefined
Immutable.Map().set(1, "a").get(1) // => "a"
```

When getting JS object from that all ecamples returns `Object { 1: "a" }`
Is there any special behaviour for that or it is just regular bug?
 I think for the plain object, `{ 1: "a" }`, the key `1` is converted to the string `'1'`. All keys for plain objects are interpreted as strings.
 Then last case with `set` is broken or it should works like that?

This really makes me lot of problems with debugging :)
 This works as expected:

``` js
Immutable.Map().set(1, "a").get(1) // => "a"
```

---

See:

``` js
const Immutable = require('immutable');
const foo = Immutable.Map().set(1, "a").set('1', "b");
console.log(foo + ''); // => Map { 1: "a", "1": "b" }
```

---

`Immutable.Map` behaves like a proper map/dictionary. If you're using plain object convention, you'll probably want to marshal your keys with `String()`: 

``` js
const keyify = String;
const foo = Immutable.Map().set(keyify(1), "a");
```
 This also came up in #588 where you can find a response from @leebyron. I have an open PR to document this behavior in #589.
 Thanks for explanation. But it is pretty confusing, damn you javascript!
  `v3.7.4`

The following TypeScript code compiles...

``` typescript
import * as Immutable from "immutable";
...
console.log(Immutable.IndexedSeq<number>([1,2,3]));
```

...but fails at runtime:

```
Uncaught Error: Immutable.IndexedSeq is not a function
```

The following TypeScript code does not compile...

``` typescript
// Property 'Indexed' does not exist on type 'typeof Seq'
console.log(Immutable.Seq.Indexed<number>([1,2,3])); 
```

...but works at runtime:

```
ArraySeq{_array: [1, 2, 3], size: 3}
```

Suggests the `.d.ts` definition is incorrect to me?
 @myitcv Can you give #647 a try?
  $ var results = [Object, Object, Object]

`Immutable.List.of(results).toArray()` will return

```
[Array[3]]
  0: Array[3]
    0: Object
    1: Object
    2: Object
```

why the array of objects nested in an array?
 then you should document this. confusing at https://facebook.github.io/immutable-js/
 Sorry, too busy right now to solve a problem here ...
  In other words, can any combination of collection.set(key, value) result in collection.get(key) !== value (but still I.is value?)
 K, must be something I'm doing (no old bugs in 3.6.2 ;) ?). Separately, didn't see it in the docs and happy to open a new question, but how "fast" is I.is? Namely, if you are recursing down a tree and comparing every node to another tree (so imaging { a: { b: { c: 6, d: 7} } } compared to { a: { b: { c: 6, d: 7} } }, and due to the incidentals of the program first you compare a to a, then b to b, then c to c, etc, do you end up in N^2 since a also internally requried checking b,c,d, and b required c,d, etc? Or is there some sort of has value equality magic going on? 
  Ref #588 
 (I wonder if this confusion is why the ES6 Map doesn't have this kind of constructor.)
 @samwgoldman Can you also put a similar warning for `fromJS()`?
  Hi all,

I'm fairly new to JS so I might be missing something, but it seems like Immutable.Map().get() should treat integers the same way as standard object access. For example:

> Immutable.Map({1:2}).get(1)
> undefined
> 
> var x ={1:2}
> undefined
> x[1]
> 2

You need to convert to a string to use .get() which seems error prone and cumbersome.

> Immutable.Map({1:2}).get('1')
> 2
 Ah, that makes sense. Thank you for the clarification!

On Fri, Aug 14, 2015 at 5:56 PM, Lee Byron notifications@github.com wrote:

> Map, on the other hand, does not coerce to string first. Maps (ES6 Maps
> and Immutable.js Maps) allow you to store any kind of value as keys,
> strings, numbers, other Objects.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/issues/588#issuecomment-131249139
> .
 Just from watching this repo, I feel like this confusion is pretty common. I looked to see if there was anything in the docs calling it out as a common pitfall, but couldn't find anything. I'd be happy to contribute the documentation, but I'm not sure where it should go. The README? The docs for the [Immutable.Map constructor](http://facebook.github.io/immutable-js/docs/#/Map/Map)?
 Sorry to re-open this issue, but I have a question. If we fetch a JSON from an API and create a `Map` from it, all keys will be converted to string, am I right? There is no easy way to automatically parse a JSON to an Immutable structure without having all object keys as strings, really?
 Many thanks for clarifying @leebyron! Yes you're absolutely right that all JSON keys are strings, I put a wrong example because I was mocking data with JavaScript objects and I didn't realised at that moment that the keys I'll receive will be all strings. Thanks for being so helpful! :smiley: 
 So the conclusion is that if I put key in forms of Integer, I should use `toString` method for getting that value ?
  I'm a bit confused about Record objects. Consider this:

``` javascript
var Car = Immutable.Record({});
var Honda = new Car({test: 1});

console.log(Honda.get('test'))
// => null

console.log(Honda.toJS())
// => {}

console.log(Honda._map.get('test'));
// => 1

console.log(Honda._map.toJS());
// => {test: 1}
```

Why are all the properties and methods not working unless I use the '_map' property?
 Ah, that makes sense. The documentation definitely didn't make this clear.

Overall, I'm finding documentation very difficult for this library. It's really great at describing the inner working details of each data type, but what's missing are examples of how and when to use the various methods. I have no idea when to use Maps vs OrderedMaps vs Records vs Lists, etc...
  Consider:

```
Immutable.OrderedMap(...).forEach(function (item, i) {
    // Here I'm expecting 'i' to be 0, 1, 2, 3 etc...
    // However, it's actually the value of whatever the OrderedMap is keyed off
});
```

Why is this? In regular Javascript, when you iterate using forEach, the second param is always the iteration index.
 It makes sense for Maps, and it matches the spec: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach. So in regular Javascript, the second param is the key for iteration over Maps. My question is why do you care about the index?
 Ok that makes sense. I guess I'm still struggling with the different between OrderedMaps and Lists and when to use what. In my head, I way to create a collection (array) of objects (maps). In ImmutableJS it seems the best way to do this is to create an OrderedMap (a map) of Records (another map). At one point, I want to loop over the OrderedMap and render each item (say in a table). For this I need an index.

I suppose I can just use `MyOrderedMap.toArray().forEach` instead.
 Thanks for that @leebyron. The most common use case for us are lists like this:

```
var collection = [{
    id: 1,
    key: 'val'
}, {
    id: 2,
    key: 'val'
}]
```

And our requirements are:
- Good performance for looking up objects via 'id' - as that will be very common (therefore `Immutable.Map` is probably best)
- Order of objects is important, as these objects may be reordered by the user via a UI (therefore `Immutable.OrderedMap` sounds better)
- To allow for custom re-ordering we want ability to get the order index of an item by id, ie. User drags object id 2 into position 1, therefore we want ability to do `collection.indexOf({id: 1})` to get it's index (therefore `Immutable.List` sounds closer to what we need).

Hence the confusion. But it sounds like OrderedMap is still the way to go for this based on what I'm reading. We'll just have to convert it to an array whenever we need index values.
  While premature optimization is the root of all evil, and developers should typically profile their own application and optimize from there, it can be frustrating to go into a project without knowing the basics of the performance profiles of Immutable's `Map` v. `List`, say, or whether `splice` will perform dramatically different performance than `pop`. 

Having a rough, basic understanding of these things can be helpful when a developer is setting out to architect part of an application. It could be even more helpful, perhaps, when optimizing: "okay, so the profiler tells me this operation I'm performing is slow, what could I use instead that would be faster?"
 For example, the `List` docs include this helpful section: 

```
   * Lists are immutable and fully persistent with O(log32 N) gets and sets,
   * and O(1) push and pop.
   *
   * Lists implement Deque, with efficient addition and removal from both the
   * end (`push`, `pop`) and beginning (`unshift`, `shift`).
```

It would be lovely to also have the methods documented like so: 

```
    /**
     * Returns a new List with the provided `values` appended, starting at this
     * List's `size`.
     * O(1).
     */
    push(...values: T[]): List<T>;
```
 +1
 @rattrayalex really good idea +1
 Thanks! I also mentioned this [on hn](https://news.ycombinator.com/item?id=10060770), where user chenglou had these helpful counterpoints: 

> Listing complexity doesn't really help here. There's a huge difference in practical complexity than the theoretical one. Saying that "insert" has log(n) complexity is misleading when you realize the branching factor is 32. Likewise, "compare" has log(n) or mostly constant complexity in most real-life settings where you're comparing against a value that was calculated from the one you're comparing against (so shares lots of subtrees by reference). You're not e.g. sending back a fresh new copy of the data from the server to compare against. Immutable-js _could_ put "it's linear theoretically but most of the time it's really almost constant time", but that doesn't help much either.
> 
> Is it blasphemous to say that looking at runtime complexity is gradually becoming more of a premature optimization (thanks to better hardware)? You can argue all day long that your js object has constant insertion time, but the underlying implementation makes it an order of magnitude slower than array for a limited number of fields. And if you accidentally trigger the hidden class deopt that turns it into a hash map that's another order of magnitude slower. No amount of ordinary complexity analysis will help you here. Vice-versa, when Babel gradually starts supporting constant lifting for collections (somehow), you can look at a piece of code in your editor, reason that a comparison is linear, but then have the transpiler lift it out (`const liftedA = []; function foo() {return liftedA;}` instead of `function foo() {return [];}`) and not realizing yourself that the comparison is actually constant time (reference comparison). And then, if you write some overly clever optimization for that piece of code yourself, you might ironically get worse perf because the transpiler can't lift the collection anymore.

I'd leave it to the maintainers to say whether this is a good idea or not after all. 
 You know what'd be great? If lazy seq cached so that get would be amortized O(1) instead of O(n).

Just trolling =) I'll put a rephrased version in the wiki later.
 Cool. I'd be happy to help if there's any grunt work that could be offloaded to someone who doesn't know the codebase (let alone the perf characteristics). 
  To create an immutable it needs an object. e.g: var map1 = Immutable.Map({a:1, b:2, c:3});

With ES6 comes classes that when transpiled becomes function closures. Is there current or upcoming support to create a way to pass in a class and make its properties immutable? e.g: 

let rm = new RoleManager; //where RoleManager is an ES6 class
var immutableRoleM = Immutable.makeImmutable(rm); //sample method

A use of this that I can think of is similar to what clojure immutable global app state. From this [blog](http://blog.circleci.com/local-state-global-concerns/): "all components store their state in a global data structure." 
  I'd like to take advantage of Maps not requiring strings as key. Is it currently possible to declaratively get a value in a Map by key of type tuple? IE, something like `map.get(['something', 1]) // => my value`
  A Github issue is probably not the right place for this, but I've had such a great experience using Immutable over the last few weeks that I'm compelled to say thank you somehow. 

I've been moving an existing React app to Immutable, and I've seen significant performance gains and much simpler, cleaner, easier to understand code as a result. Immutable has just been a pleasure to use in so many ways, and I think I'm a better (certainly happier) developer for having used it. 

So to @leebyron and all the other contributors, **thank you** for your hard work on a wonderful project! I really appreciate what you've done with Immutable and hope to contribute myself someday, even if just documentation patches (step 1: move past feeling like I have nothing to contribute). 
 Not sure if this is the right place, either, but... I fully agree. :smile: 
  ..._eventually_! It seems that for a while, a `Symbol` works ok, but after what seems to be a pretty precise count of 8 entries, no `Symbol` can be used.

Here's a pen to illustrate: http://codepen.io/lettertwo/pen/ZGwwqL?editors=001

_note:_ You'll want to open the console when viewing that pen to see the result.

Is it possible this is a quirk of an optimization? Or maybe Symbols working _at all_ is the optimization quirk? (Or maybe i'm just doing something batty?)
 Some additional notes and stack traces:

From the app I came across this behavior in (using Immutable@3.6.4):

```
Uncaught Error: Non-extensible objects are not allowed as keys.
  hashJSObj @ immutable.js:829
  hash @ immutable.js:781
  createNodes @ immutable.js:2368
  ArrayMapNode.update @ immutable.js:1939
  updateNode @ immutable.js:2341
  updateMap @ immutable.js:2316
  src_Map__Map.set @ immutable.js:1751
  (anonymous function) @ immutable.js:1732
  (anonymous function) @ immutable.js:1048
  ArraySeq.__iterate @ immutable.js:362
  FromEntriesSequence.__iterate @ immutable.js:1043
  mixin.forEach @ immutable.js:4258
  (anonymous function) @ immutable.js:1732
  src_Map__Map.withMutations @ immutable.js:1840
  src_Map__Map @ immutable.js:1729
```

From the pen i created for the issue (Immutable@3.7.4):

```
Uncaught TypeError: Invalid value used as weak map key
  hashJSObj @ immutable.js:853
  hash @ immutable.js:789
  BitmapIndexedNode.update @ immutable.js:2035
  updateNode @ immutable.js:2392
  updateMap @ immutable.js:2367
  src_Map__Map.set @ immutable.js:1790
  src_Set__Set.add @ immutable.js:3561
  (anonymous function) @ immutable.js:3536
  (anonymous function) @ immutable.js:1042
  ArraySeq.__iterate @ immutable.js:362
  ToSetSequence.__iterate @ immutable.js:1042
  mixin.forEach @ immutable.js:4327
  (anonymous function) @ immutable.js:3536
  src_Map__Map.withMutations @ immutable.js:1891
  src_Set__Set @ immutable.js:3533
```
  Here is a reproducible example:

``` js
Immutable.List.of(1, 2, 3).take(2.5).toArray()
// RangeError: Array size is not a small enough positive integer.
```
  I've got like 100 messages in my inbox saying:

"Thank you for reporting this issue and appreciate your patience. We've notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed."

Are these repeated messages really necessary or helpful?  Especially since this project is so actively maintained.

I can certainly filter them out, but why force thousands of people to filter them when you could just not send them.

Thanks.
 Thanks.  Just FYI, I got another batch of 20 or so of these all received at 11:03am today (Pacific Time).
  This test fails:

```
        var Range = Immutable.Record({
            from: null,
            to: null,
        })
        var range = new Range({from: 0, to: 1})
        assert.strictEqual(range.from, 0)
        assert.strictEqual(range.to, 1)
        var returnValue = range.mapEntries(() => {})
        assert.strictEqual(range.from, 0) //fails here
        assert.strictEqual(range.to, 1)
```

using immutable version 3.7.4. Based on the docs, I expect that `range` will be unchanged and `returnValue` will be created based on the map function. What actually happens is that range is modified based on the map function.
 :+1: 
 +1

This applies to the filter function as well
 Bump. This behaviour was really unexpected when I encountered it today. Here is a quick patch that solves this (in pseudocode - I haven't looked at this project's sources):
```js
mapEntries(mapper) {
  return new this.constructor(this.toMap().mapEntries(mapper))
}
```  FindIndex should return something besides `-1` specially since the `get(-1)` gets the last value of the list. It just makes it confusing and not intuitive.
 I agree with this, once the tests are fixed. It is strange that I can't use the int returned from findIndex to get a provided default value from a list.

```
const fridge = new List(['bacon', 'eggs', 'cheese']);
const index = fridge.findIndex((food) => {
  return food === 'vegetables';
});
fridge.get(index, 'Food not in fridge.')
```

outputs: `cheese`
 Completely forgot about this! Thanks for taking the time to respond.

After giving it some thought, I agree with the `findIndex()` response being the same as the JS response.  I think the confusion came when using it with the `get`, we need to be careful combining the 2 functions.   dear all,

Can i use immutable.js with react-native?

thanks.
 thank you very much. @leebyron 
  With reference to: https://facebook.github.io/immutable-js/docs/#/List/includes

Consider:

``` javascript
var Immutable = require("immutable");

var o1 = Immutable.fromJS({x: 5})
var o2 = Immutable.fromJS({x: 5})

console.log("o1 === o2", o1 === o2);

var l = new Immutable.List([o1]);

console.log("l.includes(o1)", l.includes(o1));
console.log("l.includes(o2)", l.includes(o2));
```

which gives the output:

```
o1 === o2 false
l.includes(o1) true
l.includes(o2) true
```

The last line surprised me because my assumption was that every function in the API would, by default, use reference equality tests as opposed to value equality (with the obvious exception of [`is(...)`](https://facebook.github.io/immutable-js/docs/#/is)). 

`.includes` is in effect returning `true` iff `Immutable.is(e, o2)` for any `e` in `l`. 

Have I missed an important part of the docs here?
  What do you think about supporting extensible destructuring described here:
https://github.com/vacuumlabs/es-proposals/blob/master/extensible-destructuring.md

There is currently babel plugin for that:
https://www.npmjs.com/package/babel-plugin-extensible-destructuring
 Or at least, it would be nice to mention that in docs:)
  This is helpful in cases where immutable.js was imported via a script tag, as "immutable" will not
be available in that environment (but Immutable is).
 @leebyron I've updated the comment and squashed the commits. Cheers.
 @leebyron thanks, will do!
  :+1: - will this also cater for primitive values too? e.g. 

```
Immutable.isImmutable(Immutable.fromJS({x: 5})); // true
Immutable.isImmutable(5); // true
```
 Sorry, re-reading the title for this issue I'm guessing the capitalisation is significant. i.e. this issue is capturing an API function that returns true iff an object passed as an argument is an instance of any `Immutable.*` class. Let's call this `Immutable.isImmutableInstance(x)`

My previous comment is related but would deal with the wider question of whether the argument is immutable (lower case 'i')
 :+1: 
For now, I've been shimming with something like this

```
function isImmutable(thing){
    return Boolean(isList(thing) || isMap(thing) || isSet(thing) || isOrderedSet(thing) || isOrderedMap(thing));
}

function isList(thing){
    return Boolean(thing instanceof Object && thing['@@__IMMUTABLE_LIST__@@']);
}

function isMap(thing){
    return Boolean(thing instanceof Object && thing['@@__IMMUTABLE_MAP__@@']);
}

function isSet(thing){
    return Boolean(thing instanceof Object && thing['@@__IMMUTABLE_SET__@@']);
}

function isOrderedSet(thing){
    return Boolean(thing instanceof Object && thing['@@__IMMUTABLE_ORDERED__@@'] && thing.hasOwnProperty('__hash'));
}

function isOrderedMap(thing){
    return Boolean(thing instanceof Object && thing['@@__IMMUTABLE_ORDERED__@@'] && !thing.hasOwnProperty('__hash'));
}

module.exports = {
    isImmutable: isImmutable,
    isList: isList,
    isMap: isMap,
    isSet: isSet,
    isOrderedSet: isOrderedSet,
    isOrderedMap: isOrderedMap
};
```
 @NickStefan you should better use the built-in [Immutable.List.isList](http://facebook.github.io/immutable-js/docs/#/List/isList), [Immutable.Set.isSet](http://facebook.github.io/immutable-js/docs/#/Set/isSet) and so on. Checking for `@@__IMMUTABLE_ORDERED__@@` is an internal detail which may change in future versions.

`isImmutable()` can be replaced with `Immutable.Iterable.isIterable()` since all classes inherit from `Immutable.Iterable`.
 @madebyherzblut thank you! I must have missed those methods in the docs. 
 +1
 +1
 +1
 My motivation here is mostly that my call .get of undefined poops itself really hard, and initializing properly all over the place helps, but doesn't catch all edge cases. I just want the data or undefined without any breakage. Specific type checking causes me to do more work later if I want it to make changes. 

``` javascript

export const isArray = (maybeArray) => maybeArray && typeof maybeArray === "object" && maybeArray.constructor === Array;

/**
 * Iterable Type Checking usecase:
 * .get() of undefined (or .get() is not a function of 'other type') explodes with fatal error. All Immutables extend Iterable and have .get().
 * All data is eventually gotten. All data is eventually/accidentally undefined or mutated incorrectly(not immutable).
 */

/* base class Iterable check @returns boolean */
export const isIterable = (maybeIterable) => Iterable.isIterable(maybeIterable);

/* base class Iterable check and @returns maybeIterable || undefined  || Default */
export const validate = (maybeIterable, Default) => (isIterable(maybeIterable) && maybeIterable) || Default;

/**
 * @getValid: Checks for valid base class ImmutableJS type of Iterable
 * @params getValid(maybeIterable: any, keyPath: key || array of keys, Default: (if undefined return this) )
 *
 * @returns: valid Iterable || child data of valid iterable || undefined || Default
 *
 * Verbose: Iterable.isIterable(maybeIterable) && maybeIterable.getIn(['data', key], Map())
 * Terse  : getValid(maybeIterable, ['data', key], Map())
 *
 * @Examples:
 * getValid(maybeIterable)             :    returns the maybeIterable or undefined
 * getValid(maybeIterable, null, Map()):    returns the maybeIterable or Map()
 */
export const getValid = (maybeIterable, keyPath, Default) =>
  isIterable(maybeIterable) && keyPath
    ? ((isArray(keyPath) && maybeIterable.getIn(keyPath, Default)) || maybeIterable.get(keyPath, Default))
    : validate(maybeIterable) || Default;


//Here is an untested version that a friend requested. It is slightly easier to grok.

export const getValid = (maybeIterable, keyPath, getInstead) => {
  if(valid(maybeIterable)) {                 // Check if it is valid
    if(path) {                                        // Check if it has a key
      if(typeof path === 'object' && maybeArray.constructor === Array) {  //check for array
        return maybeIterable.getIn(path, getInstead) // Get your stuff
      } else {
        maybeIterable.get(path, getInstead) // Get your stuff
      }
    } else {
      return maybeIterable || getInstead; // No key? just return the valid Iterable
    }
  } else {
    return undefined;   // Not valid, return undefined, perhaps should return false here
  }
}
```

Just give me what I am asking for or tell me no. Don't explode. I believe underscore does something similar also.
 what if I need to check it in 3rd party lib? I need some "signature" to be sure if the value I've got follows some protocol of immutableJS, like `equals`.  var myRecord = new ABRecord(b:3) should be var myRecord = new ABRecord({b:3}) in the "Record()" API doc.
  I have started using immutable.js within a TypeScript (1.5.3) project and it is working great save for one small annoyance.

Please excuse me if this has already been asked before or if there is something obvious that I am missing.

``` typescript
import { List } from 'immutable';

function printNiceList(listOfStrings: List<string>): void {
  console.log(listOfStrings.pop().join(', ') + ', and ' + listOfStrings.last());
}

var countries = List(['USA', 'UK', 'Ukraine', 'Uzbekistan']);

// This works nicely:
printNiceList(countries);

// This does not pass the type check:
printNiceList(countries.rest());
// TSC errors with:
// error TS2345 Argument of type 'Iterable<number, string>' is not assignable to parameter of type 'List<string>'.
// > TS2324 Property 'set' is missing in type 'Iterable<number, string>'.

// The type needs to be explicit to get it to work:
printNiceList(<List<string>>countries.rest());

// Same issue with all inherited methods like: slice, splice, skip, concat, e.t.c
```

Since I work with `List<Blah>` a lot I end up having to insert `<List<Blah>>` all over the code which is a little annoying.

Would it be possible to redefine the inherited method types in the `.d.ts` file so that these methods' return type is `List<Blah>` vs `Iterable<number, string>` ?
 Hi @leebyron ,

Thank you for the reply.

You can not change the type signature of `printNiceList` because it calls `pop`. You would get an error of `error TS2339 Property 'pop' does not exist on type 'IndexedIterable<string>'.`

I am not sure what you mean when you say that `rest()` does not return a list as the return type of it certainly behaves like a list by having the `pop` method and satisfying `List.isList` (as one would expect).

``` javascript
var countries = List(['USA', 'UK', 'Ukraine', 'Uzbekistan']);
console.log(List.isList(countries.rest())); // => true
```

As far as I can see Immutable's logic is solid, it is only the TS type definition that is lacking as it is indication a more generic return type (and that too is only a small cast inconvenience). 
  Is there a way to preserve shallow copy when performing Immutable.fromJS()?

For example,

``` js
a = [1, 2, 3]
b = { copy1: a, copy2: a}
console.log(b.copy1 === b.copy2);  // true

immB = Immutable.fromJS(b);
console.log(immB.get('copy1') === immB.get('copy2'));  // false
```

I'd like to convert `b` to an Immutable Map so that `immB.get('copy1') === immB.get('copy2')`. Is it possible to do that?

Thanks!
  This is really odd, I've made really simple example: http://codepen.io/FredyC/pen/vOVmwK?editors=001

In console you can see "Maximum call stack size exceeded" which is rather weird. Does that mean that it's impossible to use ES6 inheritance with ImmutableJS?

I think it would be very helpful if source code would be part of NPM. That way we could transpile the code with Babel too.
 Is `Immutable.Record` an exception here? This code seems to work:

```
const R = Immutable.Record({a: 1})
class TGRow extends R {
}
```
 Yeah, I believe this is exception. Looking at the [source code](https://github.com/facebook/immutable-js/blob/master/src/Record.js#L42-L45) it just returns standard constructor function.
 @leebyron Did you make any progress in supporting inheritance?

It would be very valuable for us to create `List` subclasses with domain specific methods, for instance
- `MyList.byAuthorId(id)` (to support lookup via a cache in O(1))
- `MyList.getTotal()`
- `MyList.updateSomething(x)`

Using rich models enables us to encapsulate domain behavior into the model layer (or stores/reducers etc), easing the complexity on the view. This way we could combine the best things from OOP and functional programming.
 Sorry, for commenting on such an old issue, but this was being discussed in #301. I've written a library that makes extending Immutable.js possible, but it doesn't look like this will be a goal for Immutable itself.

> For anyone who's still interested in this, I wrote an extendable-immutable package, similar to @jdfreder's one, but with complete expected behavior: it can be extended multiple layers deep, it doesn't break the prototype chain at all (f.e. Map.isMap and x instanceof Map would pass), it doesn't break mutable operations etc.

https://github.com/philpl/extendable-immutable
  Just a small docs fix. The `isIterable` function is on `Iterable` (not `Immutable`).
    This code generates an infinite recursion in sliceFactory, on the `splice` call with a negative index. 

``` javascript
    var dog = Immutable.Seq(['d', 'o', 'g']);
    var dg  = dog.filter(c => c !== 'o');
    var dig = dg.splice(-1, 0, 'i');
```

The filter step is required to see the problem. And an index >= 0 in splice works just fine.

Results:

```
 RangeError: Maximum call stack size exceeded
        at wholeSlice (/immutable-js/dist/immutable.js)
        at sliceFactory (/immutable-js/dist/immutable.js:1292:9)
        at sliceFactory (/immutable-js/dist/immutable.js:1303:14)
        at sliceFactory (/immutable-js/dist/immutable.js:1303:14)
        ...
```

(Aside: TypeScript doesn't seem to believe the result of the filter allows splice, which also seems wrong. But even adding an explicit toIndexedSeq to keep TypeScript happy doesn't solve the issue.)

Maybe related to #459?

[Immutable 3.7.4; seems to still be true in master]
  The docs (IIRC) state that `Record` is implemented with a `Map`, yet:

```
> m1 = new Immutable.Map({ foo: 0 });
> m2 = m1.set('foo', 0);
> Immutable.is(m1, m2)
true
> m1 === m2
true

> MyRecord = Immutable.Record({ foo: 0 });
> r1 = new MyRecord();
> r2 = r1.set('foo', 0);
> Immutable.is(r1, r2)
true
> r1 === r2
false
```

What am I missing..?
 This is a duplicate of #536, what was I thinking...
  Hello,

Documentation for [`Map.toList()`](http://facebook.github.io/immutable-js/docs/#/Map/toList) method says:

> Note: This is equivalent to List(this), but provided to allow for chained expressions.

However these approaches give different results (example [here](https://jsfiddle.net/jzysqg41/)):

``` js
var map = Immutable.Map({a: 1, b: 2});
Immutable.List(map); // List [ a,1, b,2 ]
map.toList(); // List [ 1, 2 ]
```

Is it documentation incorrectness, wrong behavior or my misunderstanding?
 I'm a newbie, but I think you're misunderstanding.

Looks like the behavior is to construct a list out of the values in your dictionary, which would make sense.

Recommend closing this issue.
 @tphyahoo Behaviour is clear. I'm just saying that these operations don't look equivalent as documentation states.
 I see what you mean now.

I think documentation should read

This is equivalent to List(this.values())
 (untested)
 @leebyron 
      Hello, I was a novice, I looked Immutable.js period of time, did not know specifically what to do? Just the data processing? What are its benefits? Can you give me explain?
    First of all, sorry for the wall of text. I'm trying to cover the argumentation, why this is needed and how this can open for more powerful patterns, so we can have a discussion around it. A lot of times there is a need to group operations on cursors, much like withMutations, but not with passed values but the actual cursors. Like so:

``` js
var data = Immutable.fromJS({'a': 1});
var c1 = Cursor.from(data, ['a'], onChange);
var c2 = c1.groupedOperations(cursor => cursor.set(2));
```

In contrast to 

``` js
var data = Immutable.fromJS({'a': 1});
var c1 = Cursor.from(data, ['a'], onChange);
var c2 = c1.withMutations(cursor => cursor.set(2)); // Would fail
// This would also fail as c1 points to a scalar
c2 = c1.withMutations(value => 2); // Would fail

// Would instead have to go "one level up" to point to a immutable structure:
c1 = Cursor.from(data, onChange);
c2 = c1.withMutations(value => value.set('a', 2)); // Would work
```

By having `groupedOperations` (or with another name?) you could have seperate operations/functions and group/compose them to one, and behave as if it was one with only one triggered `onChange`.

Problem is, if you have the following:

``` jsx
var square = cursor => cursor.update(input => input * input);
var timesTwo = cursor => cursor.update(input => input * 2);
```

you could do:

``` jsx
var c2 = square(c1);
```

and that would work as expected. You could also do:

``` js
var c2 = square(timesTwo(c1));
```

but that would trigger `onChange` twice, which is in many cases less than optimal. How ever, with `groupedOperations`, you can pass in composed functions and only trigger one update:

``` js
var c2 = c1.groupedOperations(compose(square, timesTwo));
```

As mentioned, you could do something seemingly similar with `withMutations`, but as `withMutations` pass on the cursors underlaying data and not the cursor it self, this would be "semantically different", and our functions would have to be different with composed and non-composed editions (one handling cursors, and one handling the values the cursors are pointing at).

Alternative to `groupedOperations` name can be `bulk` or `grouped`.
 I get the confusion, and what you propose is kind of a viable alternative. But the problem with this is that you have to invoke the update function through cursor updates, and that would potentially allow `cursor.updates` to "leak through your system". I think it's a question of principal/separation here.

Let's say I have a React component:

``` js
var Comp = React.createClass({
  render: function () {
     // Partially apply action to get cursor as input (or any other props.
     // Component doesn't care about what type of input it is.
     let onClick = partial(compose(clickAction, logAction), this.props.data);
     return <button onClick={click}>Click me</button>
  }
});
```

``` js
// Some other place/file, a collection of functions that just
// manipulate state cursors point at. Separate from the
// Component, and holds the "whole truth" of state
// manipulation.
function clickAction (cursor) {
  return cursor.update(....)
}

function logAction () { /* ... */ }
```

Alternativly, my component would have to be implemented as

``` js
var Comp = React.createClass({
  render: function () {
     // Component has to care about whether it's a cursor or not
     let onClick = partial(this.props.data.update, compose(clickAction, logAction));
     return <button onClick={click}>Click me</button>
  }
});

// and clickAction

function clickAction (someSortOfInput) {
  return someSortOfOutput;
}
function logAction () { /* ... */ }
```

Both examples will work, and having more generic/versatile functions as the latter example is smart in many cases, but I'd argue that sometimes you'd want to have the entire truth of your state update in these sort of actions, and have them specific to state-update.

Summarised, I think this

``` js
var newCursor = manipulate(oldCursor);
```

is in many cases (in regards to component "actions") better separated with more clear intent for the `manipulate` function, rather than

``` js
var newCursor = oldCursor.update(manipulate);
```

Another potential drawback of the second example how to handle async operations on cursors isolated in an "action". Or how to do multiple input. So if a "action" (state update function) requires multiple data as arguments (depends on some sort of data in a immutable tree), you'd have to have the cursors as input anyways, as a mere `cursor.update` wouldn't do.

With something like `groupedOperations` you could potentially group operations across cursors as well, by finding the common parent cursor, updating that by manipulating the parent cursor inside the `groupedOperations` body. If that made any sense.
 I realise that it's hard to understand my point, and I'm having a hard time formulating why I think this is a very nice to have, but bear with me. Also, this discussion has kind of derailed to be about "actions" and whether or not they should have cursors or data as input, but I think that's kind of the integral part of if `groupedOperations` is needed or not. I think, if it's sensible to have actions which takes cursors as input, this feature is needed.

> Hmm, I'm sorry but I'm still a bit confused - I don't see where "groupedUpdates" fits into your examples.

Thinking of it, it's not really `groupedUpdates` or `groupedOperations`, but it's essentially just an `update` where you're passed the `cursor` you want to update instead of the underlying immutable object (or scalar value).

> Because of the nature of cursor updates, an "onclick" does need to know about cursors, since calling cursor.update and ignoring the result (all React event handlers) implies the top-level mutation and side-effects that we use cursors for.

It wouldn't ignore the result, but return the resulting cursor(s). Actions should be pure, or at least abstract side-effects to lifted functions (returning accessors to async data/promises/observables or what ever).

> To me, the 2nd example you illustrate there looks like a cleaner implementation. The component on-click is explicit about calling the cursor's side-effecting update method while the library functions are more generic since they operate on values rather than operating on cursors.

My examples are fairly contrived and the distinction between the two isn't too clear, but in more real-world examples the actions would probably be larger and probably some use `set`, `remove`, `push` etc, and/or a combination thereof. I think having the ability to pass in the cursors it self (or the immutable objects for that sake) as arguments is more flexible in the sense that you can more dictate the signature of your actions, instead of immutable.js cursors doing it. You can design your internal API with more flexibility and "intent". You could work around that with partial applications and binding of your actions to pass inn additional data, but I'd say that would be semantically weird and the API would be way harder to use/not clean.

> With the intention of being reusable or compostable, then I would recommend isolating the cursor.update calls outside of these functions. It's the inner someSortOfInput => someSortOfOutput functions within cursor.update which are reusable and composable

In the current examples, I'd agree with you. But I didn't necessarily intend to make them reusable across immutable structures, native structures and scalar values in a sense. But reusable across components getting passed cursors as props, if that makes sense. What I tried to argue, was that it held a more complete picture what is happening/shows better intent.

> Regardless, I think we may be able to solve this using update without you needing to change how your methods work today.

Yeah, you're right, and that's what I've done previously, and recommended others to do. However, this doesn't work if cursors point to scalar values. If I have a cursor that points to an integer, I'd get passed an integer as argument to the update functions. This is part of the "problem". By having a update function that is passed a cursor, you can compose without having to know if the cursor points to a scalar or not.

I get your scepticism and would be vary of feature creep myself, but I think the ability of passing cursors to your actions can allow you to have a better internal API. Therefor a method like this could help to make actions much more composable.
 I agree with Mikael! The uniformity of cursors is much preferable to have to deal with either immutables or scalars, depending on the input.
  I believe this issue fits best here (although it's also related to React and fluxible).

React Components lose context when used within a seq.map. Possibly due to lazy evaluation.

```
{Immutable.fromJS([1,2]).toSeq().map(_ => 
    <NavLink routeName="foo">bar</NavLink>)}
```

This fails with `Failed Context Types: Required context getStore was not specified in RouteHandlerStoreConnector.`

```
{Immutable.fromJS([1,2]).toSeq().map(_ => 
    <NavLink routeName="foo">bar</NavLink>)
 .toArray()}
```

When resolving the sequence explicitly, like above, it works. 

Is this expected behavior? My understanding is that converting Immutables to sequences is the recommended procedure before passing them to React.
  I think this helps in certain situations where Immutable was imported via a <script/> tag, as the module is imported as Immutable and not "immutable".
  Test case - http://jsfiddle.net/1ccutco5/1/
I think take should throw exception with info about usage, or return 1 element(i issued this with takeLast() and, for me, this name sounds like function already should return last element without any arguments).
 Error: agree.
Last element: don't agree.
 @asan: I think the name is modeled after take from haskell, and that's why it should give an erorr. (Copies the behavior from haskell.)

If we REALLY wanted to copy the behavior, there's the question of what to do if take arg exceeds the size of the collection.  In haskell, the behavior is to just return the whole collection. 

Not sure what we do in immutable.js but maybe it should be in the docu.
 The root if error is https://github.com/facebook/immutable-js/blob/master/src/IterableImpl.js#L412:
`Math.max(0, undefined)` returns `NaN`
If its ok to return empty list, it easy to fix using pattern from splice `Math.max(amount | 0, 0)`
Is it ok?
If ok I can make PR to fix take and skip(have same issue)
  A lot of people including myself need a way to generate a key path between a root and node of a deeply nested data structure. This method does that. See the tests for examples.

I also see you are moving toward pulling Cursor out of Immutable. That's awesome. Maybe it would be best to move keyPath to be a static method on Immutable since getIn() and friends need a keyPath, or I'll just put it into a separate module.
 +1
  Completed as per https://github.com/cognitect-labs/transducers-js/issues/20. cc: https://github.com/facebook/immutable-js/issues/538.

I ran some tests locally (see https://gist.github.com/donabrams/3f42e7017170b52593f5), but I was using an implementation (https://github.com/transduce/transduce) to test this rather than some standalone code. I'm not sure what tests would be appropriate to commit here. 
 It looks like the double at strings were used at the time, since symbols weren't ready yet. Only Gonzala used symbols:
[`Symbol.for("transducer/step")`](https://github.com/search?utf8=%E2%9C%93&q=%22Symbol.for%28%5C%22transducer%2Fstep%5C%22%29%22&type=Code&ref=searchresults) vs. [`"@@transducer/step"`](https://github.com/search?utf8=%E2%9C%93&q=%22%5C%22%40%40transducer%2Fstep%5C%22%22&type=Code&ref=searchresults)
 Yeah, I originally drew a blank when deciding what tests I'd write for this. Since these interfaces are declarative but imply that these data structures hold certain properties, I'd think the right test would be around the property invariants. Really, there should be a generative/invariant test for anyone implementing transducer protocol but I couldn't find one :( I'll update this w/in the next few days.
 Would love to see this merged.. anything an outsider could do to help move it along?
  Not sure what is the best wording for this, I'll be happy to change it to your liking.
 Well, I didn't think I would need to sign the CLA since I added a link to the README, but if a bot gets involved... VoilÃ , I signed it :-)
 Anyone? @leebyron? :-)
I know it's a shameless plug, but I actually think it might help...
 Yay, awesome, thanks @leebyron! Congrats on the new version!
  I want to update John's mobile number to be `{mobile: '444'}`? Is there a way to figure out the keyPath needed for that?

``` js
var obj = [
    {name: 'john', phones: [
        {home: '111' },
        {office: '222'},
        {mobile: '333'}
    ]}
    {name: 'mary', phones: [
        {home: 'a111' },
        {office: 'a222'},
        {mobile: 'a333'}
    ]}
]
```
 Thanks for the quick reply!

The thing is, I thought the example I provided is a very common use case in everyday project (array of objects with nested array of objects inside, this is the most likely return value from a REST api).

In a typical CRUD app the manager might need to update John's info every now and then, hence I was trying to figure out an efficient way to make that happen, which is, given an object (John), and the collection, find the keyPath as fast as possible. 

I was wondering Is it possible for Immutablejs to provide an API like `myMap.keyPathOf( john:Object ): Array` through reflection/introspection in ES6? or have it store the path info internally?

A 2nd thought, am I using immutablejs wrong and it's not suitable for this kind of use case?
 Right, makes sense to me, guess this is the necessary trade-offs to make while enjoying immutability, thanks for clearing up the thing a bit!
 Ended up I wrote this [tiny util](https://jsfiddle.net/coodoo/5w20s7th/2/) to help finding keyPath. 
 The problem is this does fine for short paths. But as [your second line](https://github.com/facebook/immutable-js/issues/548#issuecomment-121129523) demonstrates this gets worse the deeper nested your collection is.

Could `getIn`, `updateIn`, and friends support function as keys that would return the index instead? It'd be a little closer to how `update` works without needing to repeat the whole path for every dynamic key.

``` js
obj.setIn(['a', 'b', list => list.indexOf(item), 'd'], '444')
```

``` js
const matcher = item => list => list.indexOf(item)
m.getIn(['a', 'b', matcher(item)]);

const indexOfJon = obj.findIndex(person => person.get('name') === 'john')
const findMobile = phones => phones.findIndex(phone => phone.has('mobile'))
const updated = obj.setIn([indexOfJohn, "phones", findMobile, "mobile"], "444")
```

Of course, this would break functions-as-keys, but a) I would assume that's fairly rare, and b) we could allow only Lists to work with indexer functions.
  Bundle each class into it's own file so consumers can use only the parts that they need. Minified versions are included as well.

I've left the tests running against the full-build, and havn't split up the type file.
 @leebyron What do you think is the best way to split the typedefs up? I started looking at importing `typescript-services` and some of the other stuff that the gh-pages branch has but it feels like overkill. How do you feel about manually splitting `Immutable.d.ts` into parts and then recombining it during the build step?
 @leebyron, @ryan953, its worth looking at [`rollup`](https://github.com/rollup/rollup) and specifically whats discussed [here](https://github.com/rollup/rollup#a-better-approach) not as a tool for building Immutable.js but rather as an approach for packaging in general... Using ES2015 modules like is [done here](https://github.com/lodash/lodash/tree/3.10.0-es) makes it easy for modern tooling like `rollup` to pull only what is needed to reduce distribution footprint of web apps.

Another thing, providing an ES6+ package like `lodash` have done enables the module user to build their distribution based on their target environment which for cases when using recent `iojs` distributions eliminates a lot of unnecessary cruft from ES5 polyfilling. ;)
 This PR would enable something like this:

``` js
const Map = require('immutable/map')
// or
import Map from 'immutable/map'
```

Basically the way `lodash` does it?! That would be pretty sweet :)
I was surprised by the size of my bundled app after including immutable ;)
 It's been a year now. Is there any reason why individual modules do not exist yet...?
 Would love an update if anyone has time, where this is at >>?  At the moment it is quite easy to push mutable objects into immutable structures, e.g.

```
var record1 = {items: [1, 2]};
var list = Immutable.fromJS([record1]);

// but it doesn't complain if I push a mutable record by mistake
var record2 = {items: [3]}
list = list.push(record2)

// now we have a mix of mutable and immutable things
record2.items.push(4);
console.log(list.toJS())
```

http://jsbin.com/wiyeju/7/edit?html,js,console

I would expect something like this to either: throw an error or make the pushed object immutable automatically. It would be great if Immutable.js could provide stronger immutable guarantees.
 This feature would be great, i've seen quite a few people struggle with this. Once people get the idea of immutable js they expect everything you get out of a immutable data structure to be immutable.

```
var aMap = Immutable.Map({aList: [1, 2]});
var newList = aMap.get("aList").push(3);

// User expects newList to be contain [1, 2, 3]
console.log(newList); // 3
```

I'm not sure adding a whole load more types is the best way to do this.
- List
- Stack
- Map
- OrderedMap
- Set
- OrderedSet
- StrictList
- StrictStack
- StrictMap
- StrictOrderedMap
- StrictSet
- StrictOrderedSet

How about

```
Map<K, V>(iterable: Object, options: Object): Map<K, V>

Map({}, {strict: true});
Map({items: [1, 2]}, {strict: true, deep: true});
```

Strict throws an exception if you attempt to add a non immutable object and deep does what fromJS does.
 #473 seems related, btw.
 With as useful as it is to `.map()` over something to produce potentially mutable objects, I don't think it's a good idea to have strict structures that enforce immutability. When rendering Immutable structures into React Components you'll end up having to convert your strict collection to a non-strict collection just so you can `.map()` over it normally. I'm using this function I built: `assertImmutable`. 

`prefix` is to give you something to identify the root object. `assertImmutable(userMap, 'User Store')` might tell me that `User Store. Array or Object found at: aayers.permissions.3`

`oldObj` is an optional optimization. If your object has a small number of shallow changes it's significantly faster to include `oldObj`. However, if your tree is very large and contains significant changes it can actually be slower than not passing it at all.

```
function visit(obj, prefix = '', oldObj = undefined, path=[]) {
    for (let key of obj.keys()) { // eslint-disable-line prefer-const
        const value = obj.get(key)

        const oldValue = (oldObj == null || oldObj.get == null) ? null : oldObj.get(key)

        // There's no need to check branches that haven't changed.
        if (!Immutable.is(oldValue, value)) {

            if (value instanceof Collection) {
                const currentPath = path.concat([key])
                visit(value, prefix, oldValue, currentPath)
            } else if (value instanceof Error) { //eslint-disable-line no-empty
                // Errors don't really change. I guess they're ok
            } else if (value instanceof Array || value instanceof Object) {
                const currentPath = path.concat([key])

                throw new Error(prefix + 'Array or Object found at: ' + currentPath.join('.'))
            }
        }
    }
}

function assertImmutable(obj, prefix, oldObj = undefined) {
    if (prefix) {
        prefix = prefix.trim() + '. '
    }

    visit(obj, prefix, oldObj)
}
```
 @AsaAyers I'll be happy to explicitly convert strict collections to non strict or mutable collections when I need to. For me strong immutable guarantees are more important than speed. Anyway, it would be great to have this choice.
  As discussed in #486, using keys which can't be coerced to numbers in Lists ignored notSetValue. This pull request should hopefully solve that problem.
  ES6 destructuring is handy, but I don't want to override built-in ES6 Map and Set types. This adds an alias to allow destructuring.

Bad:
`var {Map, Set} = require('immutable'); // overrides ES6 Map and Set`

Good:
`var {ImmMap, ImmSet} = require('immutable');`

This parallels Hack immutable type naming conventions.
  Repro case in a Gist: https://gist.github.com/mkscrg/62d624a118e2722313fe

Immutable produces some odd warnings when loaded in PhantomJS with es5-shim:

``` html
<!doctype html>
<html>
  <head>
    <script src="node_modules/es5-shim/es5-shim.js"></script>
    <script src="node_modules/immutable/dist/immutable.js"></script>
  </head>
  <body></body>
</html>
```

``` txt
> phantomjs test.js

iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. Error:
    at file:///Users/mike/Development/sandbox/phantom-es5shim-immutable-warnings/node_modules/immutable/dist/immutable.js:4602
iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. Error:
    at file:///Users/mike/Development/sandbox/phantom-es5shim-immutable-warnings/node_modules/immutable/dist/immutable.js:4602
iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. Error:
    at file:///Users/mike/Development/sandbox/phantom-es5shim-immutable-warnings/node_modules/immutable/dist/immutable.js:4602
iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. Error:
    at file:///Users/mike/Development/sandbox/phantom-es5shim-immutable-warnings/node_modules/immutable/dist/immutable.js:4602
iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. Error:
    at file:///Users/mike/Development/sandbox/phantom-es5shim-immutable-warnings/node_modules/immutable/dist/immutable.js:4602
iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. Error:
    at file:///Users/mike/Development/sandbox/phantom-es5shim-immutable-warnings/node_modules/immutable/dist/immutable.js:4602
```

(I'm not sure this is actually a problem with immutable!)
 > We use console.warn to alert to misuse ...
> 
> Phantom.js emulates a browser ...

Understood!

I'm confused by the warnings because `immutable.js` is the last script to be loaded in that page. It's triggering its own warnings?
 I got the same error (with PhantomJS 1.9.7 and es5-shim) and it's not from a test case verifying the error.

The warnings are generated by the following lines in immutable.js as it loads:

```
mixin(KeyedSeq, KeyedIterable.prototype);
mixin(IndexedSeq, IndexedIterable.prototype);
mixin(SetSeq, SetIterable.prototype);
mixin(KeyedCollection, KeyedIterable.prototype);
mixin(IndexedCollection, IndexedIterable.prototype);
mixin(SetCollection, SetIterable.prototype);
```

and more specifically, the `Object.keys(methods)` call inside the `mixin` function.

I'm guessing either es5-shim or PhantomJS uses `.length` in its `Object.keys` implementation.

Adding `methods.length` to the `mixin` function doubles the errors.
 may be just add to immutablejs flag like `process.env.DISABLE_IMMUTABLE_WARNING_ABOUT_LENGTH`? it is so annoying =(
 @mjomble Yes. es5-shim's Object.keys calls isArguments which looks like this.

``` js
var isArguments = function isArguments(value) {
    var str = toStr(value);
    var isArgs = str === '[object Arguments]';
    if (!isArgs) {
        isArgs = !isArray(value) &&
          value !== null &&
          typeof value === 'object' &&
          typeof value.length === 'number' &&
          value.length >= 0 &&
          isCallable(value.callee);
    }
    return isArgs;
};
```

Which it does so it knows if it should `array_slice.call` on the value before calling `$Object.keys`.
  â€¦ncated values.

These tests currently fail until someone fixes the issue.
  Hi,

If I understand correcly, ImmutableJS use a list that looks like Scala/Clojure vector with internal nodes of size 32.
I think exposing this internal structure may leverage better performances when rendering big immutable list. For example it an item has changed in an immutable list of 100000 elements, one does not have to iterate the 100000 elements and call `shouldComponentUpdate` 100000 times, but rather traverse the ImmutableJs List tree and call `shouldComponentUpdate` for the nodes, permitting to short-circuit the rendering faster and not have to call `shouldComponentUpdate` on all the 100000 items.

I mean if an item is modified in a big array of 100000 elements, the internal node holds an array of 32 references and the item "depth" in the tree is 3, instead of calling `shouldComponentUpdate` 100000 times, you can just call `shouldComponentUpdate` something like 4*32 times with PureRenderMixin.

I don't know how to achieve this in ImmutableJS nor if it's a good idea to use its internal structure if it's not part of the public API, but this could definitively boost performances.

See also related SO question: http://stackoverflow.com/questions/30976722/react-performance-rendering-big-list-with-purerendermixin
 This React feature seems required also to avoid creating intermediate dom elements when we simply want to optimize the rendering of a flat list: https://github.com/facebook/react/issues/2127
 hi @leebyron 

Here's an exemple implementation of what I want to achieve. As you can see, the number of shouldComponentUpdate calls becomes linear to the depth of the immutable structure, instead of being linear to the number of items of the list.

I simplified the implementation of an immutable list to be composed of nodes and leaves, where nodes are simple JS arrays.

It would be possible to create a facade to the ImmutableListRenderer component, so that it takes directly an ImmutableJS type.

``` javascript

/////////////////////////////////////////////////////////////////////
// Here is the "lib" code

var ImmutableListRenderer = React.createClass({
    // Simple implementation, but should use something like PureRenderMixin instead
    shouldComponentUpdate: function(nextProps) {
      return (nextProps.list !== this.props.list || nextProps.leafRenderer !== this.props.leafRenderer || nextProps.itemProps !== this.props.itemProps );
    },

    propTypes: {
        // The immutable structure intermediate node (or maybe a leaf)
        // Used the name "list" to make it more user-friendly from the outside only
        list: React.PropTypes.any.isRequired,
        // The way a leaf (ie an item of the list) should be rendered
        itemClass: React.PropTypes.func.isRequired,
        // A set of props that are passed to each item
        itemProps: React.PropTypes.object
    },

    render: function() {
        // Internal node case
        if ( this.props.list instanceof Array ) {
            // This should not be required to create an intermediate span element, but this feature is not available in React yet
            return (
                <span>
                    {this.props.list.map(function(subnode,index) { 
                        return <ImmutableListRenderer key={index} list={subnode} itemClass={this.props.itemClass} itemProps={this.props.itemProps}/>
                    }.bind(this))}
                </span>
            );
        } 
        // Leaf node case
        else {
            return React.createElement(
                this.props.itemClass,
                this.props.itemProps,
                this.props.list
            );
        }
    }
})


/////////////////////////////////////////////////////////////////////
// Here is the "client" code to demonstrate usage

// This is the supposedly simplified structure of an immutable list (I guess) of 1 to 18
var BigImmutableList = [
    [[1,2],[3,4],[5,6]],
    [[7,8],[9,10],[11,12]],
    [[13,14],[15,16],[17,18]]
]

// Hold the current list to render (like a global variable)
// The naming just comes from Clojure's Atom
var Atom = BigImmutableList;

// We only update the 1st item on the list and we increment it by 1
// and use structural sharing the most we can
// Obviously this should not be done this way but rather use ImmutableJS methods
function updateList() {
    Atom = [
        [[Atom[0][0][0]+1,Atom[0][0][1]],Atom[0][1],Atom[0][2]],
        Atom[1],
        Atom[2]
    ]
}


// Customize the way an item of the list is rendered
var ListItem = React.createClass({
    render: function() {
        return <span>{this.props.itemPrefix + this.props.children}</span>
    }
})

// These are "shared props" that will be passed down to all the list items
// If any of these props change, the whole list would have to re-render
var ItemProps = { itemPrefix: " -> " };

function render() {
    React.render(<ImmutableListRenderer list={Atom} itemClass={ListItem} itemProps={ItemProps}/>, document.getElementById('container'));
}

render();

setInterval(function() {
    console.debug("-------------------------------------");
    updateList();
    render();
}.bind(this),1000);
```

Here is a JsFiddle where you can see the shouldComponentUpdate calls in the log: https://jsfiddle.net/txfhzuey/2/
 @leebyron I've made a quick POC of the same principles but using ImmutableJs internals (I mean the "Gn" object and _root/_tail properties)

You can see the core idea here:

``` javascript
var ImmutableListRenderer = React.createClass({
  render: function() {
    // Should not require to use wrapper <span> here but impossible for now
    return (<span>
        {this.props.list._root ? <GnRenderer gn={this.props.list._root}/> : undefined}
        {this.props.list._tail ? <GnRenderer gn={this.props.list._tail}/> : undefined}
</span>);
  }   
})


var GnRenderer = React.createClass({
    shouldComponentUpdate: function(nextProps) {
      console.debug("should update?",(nextProps.gn !== this.props.gn));
      return (nextProps.gn !== this.props.gn);
    },
    propTypes: {
        gn: React.PropTypes.object.isRequired,
    },
    render: function() {
        // Should not require to use wrapper <span> here but impossible for now
        return (
            <span>
                {this.props.gn.array.map(function(gnItem,index) { 
                    // TODO should check for Gn instead, because list items can be objects too...
                    var isGn = typeof gnItem === "object"
                    if ( isGn ) {
                        return <GnRenderer gn={gnItem}/>
                    } else {
                        // TODO should be able to customize the item rendering from outside
                        return <span>{" -> " + gnItem}</span>
                    }
                }.bind(this))}
            </span>
        );
    }
})
```

Here's a JsFiddle that show shouldComponentUpdate count: http://jsfiddle.net/txfhzuey/13/

As you can see, for a list of 10000 elements, it only requires ~77 calls to shouldComponentUpdate, while by normally iterating through the item list, it would have required 10000 calls
 Seems like you should investigate cursors: https://github.com/facebook/immutable-js/tree/master/contrib/cursor

You can have `ListItem` re-render whenever there's an update on the data it uses. In addition, your top-down rendering path (from root to leaf) is shortened to just the leaf itself.
 @Dashed I know cursor and I actually implemented them in our startup framework: https://github.com/stample/atom-react

Most cursor implementations out there are "listenable" (ie we can register a callback). This permits to get better performances, but I think this is absolutly not necessary. If you look at Om's implementation, cursors are not listenable (https://github.com/omcljs/om/wiki/Cursors). I think the listener thing can improve the performances and works probably well but it's just not the path we are following.

In our framework, we ALWAYS render from the VERY TOP. We have something very akin to Flux stores, but they are not listenable either. This sure has some performance drawbacks but I'd like to keep the model very simple: `f(M) = V`. The only listenable structure we have is the Atom, which holds the global app state. For now it works fine in a complex SPA production app (check this video https://www.youtube.com/watch?v=zxN8FYYBcrI) and we'd like to push this architecture to its limits before introducing new abstractions like listenable stores and cursors.

See also this discussion: https://github.com/gaearon/redux/issues/155

**Edit** Oups Om have observable cursors as well (https://github.com/omcljs/om/wiki/Advanced-Tutorial#reference-cursors)

---

Also, using cursors, if instead of modifying one value of the list I push a new value at the end of the list, how would you do so that you don't have to iterate on the 10000 elements of the list and call `shouldComponentUpdate` on all the 10000 iterated items? Cursors seems to work fine to shortcircuit some React component renderings, but as far as I know it's a bit harder when the list size / cursor paths are dynamic.
 > In our framework, we ALWAYS render from the VERY TOP.

Is this something you absolutely need to do? You can still re-render substructures without cursors; so long as you use the right API to modify your data (e.g. immutable API).

One approach is this: https://medium.com/@gilbox/an-elegant-functional-architecture-for-react-faa3fb42b75b where the global app state is in the root component.

I've since modified the demo in the article to be able to re-render the sub-components, instead of top-down approach: http://codepen.io/anon/pen/oXeyxR

The refactor is based on my experiments with higher-order component with cursors: https://github.com/Dashed/orwell

---

> Cursors seems to work fine to shortcircuit some React component renderings, but as far as I know it's a bit harder when the list size / cursor paths are dynamic.

With 'orwell', I'm able to observe cursors (custom implementation) directly, and the wrapped component will eagerly re-render whenever the cursor emits a change. If need be, I'm able to add some validation step to cancel/continue the re-render.

---

> Also, using cursors, if instead of modifying one value of the list I push a new value at the end of the list, how would you do so that you don't have to iterate on the 10000 elements of the list and call `shouldComponentUpdate` on all the 10000 iterated items?

This would need a specialized solution. Doing `array.map(mapper)` isn't sufficient b/c you're still iterating N element.

Something like would be a better approach:
1. cache the list/tree of components on initial render (probably on Immutable list)
2. observe changes and construct splice steps and apply to cached component list/tree to update the necessary components
3. return list/tree as children (no need for `toJS()`, since it's an iterable)

Observation in step 2 may depend whether your primary API of your global app state supports this.
 @Dashed while interesting I think this discussion is out of the scope of this issue.

You propose a "specialized solution" to solve my problem, using cursors, caching and "splice steps", but did not provide any concrete implementation. Using cursors ties the implementation to a specific cursor framework and here we are on ImmutableJS so please provide an implementation of your idea with ImmutableJS cursors :)

I propose a solution that solves the same problem efficiently without introducing anything new, just using React and a render function optimized to render persistent data structures.

I'll take this quote from @travisbrown that I really like:

> It's just a solid development practice to use the least powerful abstraction that will get the job done. In principle this may allow optimizations that wouldn't otherwise be possible, but more importantly it makes the code we write more reusable.

http://stackoverflow.com/questions/12307965/method-parameters-validation-in-scala-with-for-comprehension-and-monads/12309023#12309023
 The 'specialized solution' I proposed is independent of cursors. And the reason it's specialized is because ImmutableJS doesn't provide any API to access the previous versions (e.g. **no API for it to be partially persistent**); nor are there any API to know exactly which parts of the new immutable version that was modified. 

This implies the need to wrap ImmutableJS objects in some fashion with 3rd-party libraries, unless it's somehow baked into ImmutableJS.

Hence, the need to create splice steps. Assuming you're using a flux-model, you can create splice steps at the same store that is creating/modifying the immutable data structure (b/c only at this point you know where in the data to modify).

This has to be adapted for every type of immutable collection. 

---

You're overall goal is to minimize data traversals, and only have it at the area where a change occurred.

IMO, reliance on internal implementation (e.g. `list._root`) of the persistent data structure is not the solution.
 Sorry @Dashed please provide code example of what you are talking about because I can't understand. I don't know what you mean by "splice steps" nor why would you need an API to be able to know which "parts" of the immutable list has changed nor why you would need to wrap ImmutableJs.

Please tell me what's your problem with my initial idea because you seem to propose another solution to the same problem (that I don't understand) without giving any implementation and without really explaining why my solution does not satisfy you.

> IMO, reliance on internal implementation (e.g. list._root) of the persistent data structure is not the solution.

I totally agree and this is the whole point of this issue: ImmutableJS could offer a stable/public API to support my usecase, instead of me having to rely on internal and unsafe implementation details.
The problem is already solved on my side, it is just I don't get any guarantee from ImmutableJs that the "unsafe contract" will not be broken in next release.
 @leebyron did you have time to take a look at my jsfiddle?
 Happy to see you think my idea is interesting @leebyron 

Unfortunatly I don't really know what can ImmutableJs expose safely for this performance enhancement, nor how it can be generalised to other libraries (like Mori?). 
 Hi @leebyron 

In response to this SO question: http://stackoverflow.com/a/34788570/82609

I've discovered surprising facts while hacking on the answer.

You can check this JsFiddle: http://jsfiddle.net/slorber/txfhzuey/28/

It seems for example that doing list1.concat(list2) where list1 is huge and list2 is small (like 10 items) seems less performant than doing multiple list1.push(). The internal structure seems like completly updates when using concat.

Also noticed that adding/removing items at a random list index makes the whole internal structure updates too. I understand that having a performant slice on a very large list can be quite hard to implement, but wouldn't it be possible to support efficient single inserts/deletes at a random index without changing all the internal nodes of the list structure? Couldn't we provide some parameters to the list, to say that insertions inside the list could happen, by reserving some "empty space" or something?
 +1

I'm doing exactly the same thing with Immutable and React â€” I need to maintain a growing, and potentially very long, List. I've tried to isolate the code that deals with the VNode internals as much as possible because, as you say, those details may very well change; but the performance win is too dramatic not to do it â€” 50-100x when the List grows to thousands of elements. Of course I understand that exposing the internals is "unnecessary" to the List API per se, but it would be awesome to get at this structure in a dependable future-proof way.

Thanks for any input! And thanks for this awesome library.
 @slorber You can't insert or remove from a List without rebalancing the entire tree after that point. The constant time access guarantee is based on the fact that all buckets and sub-buckets are constant size.
 @polgfred it was really an experiment I did not dig much in ImmutableJS internals yet :) I don't use this trick in production as I don't render such huge lists. But happy to see it used by other people :)

Anyway @polgfred maybe you can build a separate NPM project to do that. And for example you say in that project that it should be used with the exact same immutablejs version or something, to avoid incompatibilities
 @slorber Well, the way I'm using the List, I can guarantee that it hasn't been modified from the front, so the traversal logic is trivial. But that means I can't really package up what I'm doing as a general solution. In a pinch I could easily replace my List with an explicit tree structure that doesn't need to worry about insertion and alteration. But ths is the easiest approach for now.
  ``` js
Immutable
    .fromJS([1,2,3,4,5])
    .slice(0,2)
    .setSize(5)
    .forEach(function(val){console.log(val)});
```

Outputs:

```
1
2
3
4
undefined
```

One would not think that you get the values removed by slice back again by setting size. Somehow the last value is the only one which actually gets removed.

From the documentation of setSize()

> If size is greater than this List's size, the new List will have undefined values for the newly available indices.

Same output when using using .setSize() twice instead of slice().

``` js
Immutable
    .fromJS([1,2,3,4,5])
    .setSize(2)
    .setSize(5)
    .forEach(function(val){console.log(val)});
```

Might be browser specific?
### Tested with
- Chrome Version 43.0.2357.130 (64-bit) on OS X 10.10.
- Firefox 38.0.5 on OS X 10.10
- Firefox 39.0 on OS X 10.10
- Chromium 43.0.2357.132 on Arch Linux
  The first time I read the signature for `merge` in the docs I thought previous/next referred to the items at indices before/after the item to merge. Old/new would make this clear.
  Would you accept a PR to update ~~Map and~~ List (and any other types that make sense) to support the transducer protocol? Like this: https://github.com/jlongster/transducers.js#the-transducer-protocol It should be a minimal addition.

Sorry if this has been asked and answered already. I did a search and only found this comment https://github.com/facebook/immutable-js/issues/23#issuecomment-60796072
 :100: 
 @leebyron Great! I'll add it to List, Set, and Stack. Keyed collections like Map don't make sense, unless I am mistaken.
 @acdlite Any Immutable collection that is iterable should work (this includes Map).

For Map, the merge operation would probably be suitable for the `@@transducer/step` protocol.
 @acdlite What are the advantages in using transducer.js over using immutable.Seq?
If transducer.js is better than Seq should it be replaced? Or do they do different things?
 Stumbled on this and wondered why it stagnated? The PR looks superficially solid besides needing feedback for tests.
 Seems like the PR got closed due to lack of tests. If `transducers.js`or `transducers-js` was added as a `devDependency`, it wouldn't be hard to test it using `transduce`, `into` and so on. Could definitely look into it.  Per [documentation](https://facebook.github.io/immutable-js/docs/#/Record):

> Values provided to the constructor not found in the Record type will be ignored

This behavior makes it very easy to change the constructor and forgetting to change the type itself. The leads to unnecessary and long debug cycle, in which one tries to understand why the value on the object is "undefined", even though it was set.

Is there a reason to this behavior? What are the disadvantages of throwing an exception right away?
 Throwing an error as default behavior could be _very_ risky as default behavior - take the case where data is pulled from an API and sent into a record. Adding a new property to an API response would become a breaking change to a production site, when normally, the extra property would just be ignored.

However, I've also been burned by the silent ignores, especially when writing tests which do comparisons against records, so it would be great as an opt-in feature. I'm currently wrapping records to check for extra properties and log a warning when extra attributes are sent in, but it's be much cleaner to add warn/error as an optional third argument to the Record constructor itself. Something like:

`Record({}, null, { strict: 'warn' })`
`Record({}, null, { strict: 'error' })`
(note, there's a second argument marked "name", although I'm not sure exactly what it does)

I can work on a pull request, but it'd be nice to know if there's enough interest before putting in the work.
  I'm testing this out in the console and `Record` does not seem to behave the same way as `Map` when merged with unchanged attributes:

``` js
Reclass = Immutable.Record({a: '1', b: '2'})
> function Cr/r()
r1 = new Reclass()
> Object { _map: Object }
r2 = new Reclass()
> Object { _map: Object }
r3 = r1.merge(r2)
> Object { _map: Object, __ownerID: undefined }
r3 === r1
> false
```

Whereas with a `Map`:

``` js
m1 = Immutable.Map({a: '1', b: '2'})
> Object { size: 2, _root: Object, __ownerID: undefined, __hash: undefined, __altered: false }
m2 = Immutable.Map({a: '1', b: '2'})
> Object { size: 2, _root: Object, __ownerID: undefined, __hash: undefined, __altered: false }
m3 = m1.merge(m2)
> Object { size: 2, _root: Object, __ownerID: undefined, __hash: undefined, __altered: false }
m3 === m1
> true
```
 It's unclear to me how to tell the type of the object being created, but as near as I can tell, calling `merge` on a `Record` actually returns a `Map`.
 Hmm, this is actually two issues:
1. The identity of the return value should be `===` to the original
2. The type of the return value should match the original

The first simply seems as not the case.

The second, I'm not sure. Based on some quick tests it seems to actually work as expected:

``` js
var R = Immutable.Record({ foo: 123 });
(new R()) instanceof R
> true
(new R().merge({})) instanceof R
> true
(new R().merge(new Immutable.Map())) instanceof R
> true
(new Immutable.Map()) instanceof R
> false
```

...but I could have sworn I've also seen `Record.Merge()` return a `Map`.
 Should I open a separate issue for the 2nd point in my above comment..?
  I have suggestion to add default empty immutable object when reading value from any ImmutableJS object, so user don't have to think that return value could be undefined and write null check every time or add default value as second parameter. I use `get` or `getIn` a lot in my project and it's annoying to add default parameter in each `get` call. You could name it `read`, `readIn` or something
 It's useful when reading some list from immutable structure and you want to apply method like `map` or `reduce`

```
// this could throw an exception
state.getIn(['path', 'to', 'the', 'list']).map((x) => x + 1)
```
 ```
var obj = immutable.Map({
  prop1: {
    prop11: 11,
    prop12: [0, 1, 2, 3, 4, 5, 6]
  }
});

var mapped = obj.getIn(['prop1', 'props12']).map(function(n) { return n +1; });
var screwed = obj.getIn(['prop1', 'props13']).map(function(n) { return n +1; });
```

Last line will throw an error, since `undefined.map is not a function`. I want some another method, e.g. `read`, `readIn`, so I can do this

```
var empty = obj.readIn(['prop1', 'props13']).map(function(n) { return n +1; });
```

Which is equivalent of

```
var empty = obj.getIn(['prop1', 'props13'], immutable.Map()).map(function(n) { return n +1; });
```

It's useful only for collection when chaining few methods like `filter`, `map`, `reduce` in one line. And it becomes tedious to specify default collection in each method.

The only problem I think, that we do not store only collections in properties, so sometimes it could be number and string and `undefined` or `null` is OK. In this case it's better to use `getIn` instead of `readIn`.
 I share similar sentiments. But I feel like this shouldn't go into core. If extendable Immutable types is possible, then we can have a custom operation that would partially apply `getIn`/`get`: https://github.com/facebook/immutable-js/issues/301
 I think this is a bigger issue than most people give it credit for. It's not uncommon for an undefined collection and an empty collection to be treated logically the same. Not just coercing undefined into an empty collection, but being able to test if a collection is either undefined or empty. Combine this with the fact that javascript eagerly evaluates function parameters, and passing in a new default collection is a poor solution too because you are continually creating new collections whether you use them or not.
 I will just point out certain problems I have, but I'm not saying these are issues of Immutable, just pointing them out. As a frontend developer I can't always influence what should response from API look like. For instance, Sequalize (Node framework) by default sets empty object properties to _null_ which causes problems to Immutable's get function. For example, let's take this object as an example:

    const profile = {
      bio: null,
      confirmed: true,
      createdAt: '2016-11-24T15:32:51.695Z',
      email: 'test@email.com',
      firstname: null,
      id: 1,
      lastname: null,
      resourceId: null,
      updatedAt: '2016-11-24T15:32:51.695Z',
    }

I'm also using React to render my views. So, everytime I have to do this ternary operator inside my JSX to know if this property exist before I render it or I should render empty string:

    profile.get('bio') ? profile.get('bio') : ''

I can't use _.has_ function because key really does exist and it will return true and I also can't use this:

    profile.get('bio', '')

Because it will return null back, which does sound like correct behavior, although it's not going in my favor. The key shouldn't exist or it should be set to undefined for _get_ function to work correctly in my case. Unfortunately, with these responses (when I can't influence API responses) I'm either forced to remove every null key on every response before storing object in state or write ternary operators everywhere in JSX.

Lastly, even in cases where I influence API and key really doesn't exist it can be tiresome to write second parameter on _get_ function to always be empty string which is what creator of this issue already reported.

**EDIT:** There's shorter notation than ternary ```profile.get('bio') || ''``` which I can use in most cases, but again it is a bit tiresome to write it all the time.  I've expected map behaviour like for other Iterable object instead it returns undefined.
  Scenario: Introduce immutable js into an existing application. Data from the server is received, should be rendered immutable and then be used throughout the app. Using fromJS() on the received data is conceptually fine, however the application contains a lot of code accessing the received data via '.' for objects and [] for arrays. Thus a large refactoring would be required, introducing .get() calls everywhere.

Is there a simple way that would not require to refactor all the read accesses?
 My personal suggestion would be to have a local variable representing the data at the top of a function. There you can use the .toObject, .toArray, .toJS methods to maintain the '.' access pattern but guarantee that your code in the function can't mutate the variable outside of the local instance.

Example:

``` js
function processData() {
   var result = restData.toObject();

   console.log(result.ID);
}
```

This does not prevent your code within the function mutating the local result variable but at least the mutation is contained and won't pollute the external reference.
  This also applies to `values` and `valueSeq`, `entries` and `entrySeq`.
 Why should I ever use `keys` if I can use `keySeq`? Every code that works with `keys` should also work with `keySeq`, right?

Is there any reason why `keys` just don't return lazy sequence?
  It would be more consistent with `get` then.
  It would be nice if could just use

```
map.set(key1, val1, key2, val2, key3, val3, ...)
```

Instead of

```
map.set(key1, val1).set(key2, val2).set(key3, val3)
```

The former is bit more readable. Also, it is backward compatible.
  This would be nice

```
update(key, notSetValue, updater, ...args)
```

where `args` are additional arguments for `updater`.

It would basically be implemented like:

```
update(key, notSetValue, (v) => updater(v, ...args))
```

Nice thing is it enables composition of operations nicely. See how they use it in Clojure.
Also, it is backward compatible.
 Yes, let's say I have bought some new item and I am gonna update max cost I paid per item.
I could do it this way

```
coll.update('maxCost', undefined, Math.max, itemCost)
```

Instead of

```
coll.update('maxCost', undefined, (cost) => Math.max(cost, itemCost))
```

I find the former more readable.
 I could create a pull request, if you like:)
  I don't see a benefit of

```
update(updater: (value: Map<K, V>) => Map<K, V>): Map<K, V>
```

If I am right

```
map.update(f)
```

and

```
f(map)
```

Do the very same thing and the latter makes more sense.
  Similarly to Python or Clojure way.
https://docs.python.org/3.5/library/functions.html#map
https://clojuredocs.org/clojure.core/map

```
collA.map(f, collB, collC)
// [f(collA[0], collB[0], collC[0]), f(collA[1], collB[1], collC[1]), ...]
```

It is backward compatible change, it is nice convenient and we don't need `zipWith` anymore.
 I see.
  So it is consistent with other collections.
 Well, instead of 

```
Map([["a", 3], ["b", 4], ["c", 5]])
```

you would be able to write

```
Map.of(["a", 3], ["b", 4], ["c", 5])
```

Just for convenience, it would be nice if every collection has `of` and it behaved like this:

```
Coll.of(...val) => Coll(val);
```
 Of course, I would not type `Coll.of(...val)`. That was just implementation code:)

The same way I would prefer to type `List.of(1, 2, 3)` instead of `List([1, 2, 3])`, I would also prefer typing `Map.of(['a', 1], ['b', 2], ['c', 3])` instead of `Map([['a', 1], ['b', 2], ['c', 3]])`. I don't see much difference between those two cases and I just want them to be consistent.
  Documentation doesn't mention them for `List` nor any other structure. Also, I don't see much value in having these `all` functions with ES6.
  ``` javascript
var a = Immutable.Seq([1,2,3,4]).filter(function(val) {
  return val < 3;
}).take(10).toArray();
```

take(10) in the preceding code will create a sliceSeq with size 10, which then causes toArray() to construct an array of 10 elements instead of the expected 2. I think that in this case the sliceFactory called by take() should not set the size for the sliceSeq, because the filterSeq it is slicing does not have a defined size.

My attempted fix is to reinstate a line of code that was changed in commit bcd51c0 which checks if the sequence to be sliced has a valid size before setting sliceSeq.size.
  Added an extra check to the Set constructor so that it does not short circuit and return argument if that argument is an Ordered Set. Test added.
  I'd like to use immutable.Set with a complex object. Can I pass a custom equality operator to the Set somehow?
 Thanks for the info. It doesn't seem to be documented here: https://facebook.github.io/immutable-js/docs/#/is
 @leebyron  It would be nice that this feature is documented.
 It sounds like @robz's use case is covered, but I have an alternative use-case for this feature that isn't handled yet, as far as I know.

I'd like to create an `Immutable.Map` that treats `'7'` and `7` as equal keys. This avoids all the nuisance and traps described at https://github.com/facebook/immutable-js/issues/282. Currently, `Map`s always use `Immutable.is` to determine key equality, so what I want is impossible. It seems like it might be possible in principle to allow me to pass in a custom definition of equality when constructing a `Map` or `Set` to handle this use case.
 I'm interested in this feature. I posted a related [question](http://stackoverflow.com/q/39557342/312785) on Stack Overflow.
    See jsfiddle here:
https://jsfiddle.net/coodoo/ghkgq2oL/1/

Just trying to get a hold of how immutable.js works, thanks for any tips!
  Closes #249. Uses code from @confiks in https://github.com/facebook/immutable-js/pull/250 comment..
 @geirsagberg This can be refactored to use standard API:

EDIT: ignore this suggestion below

``` js
IndexedCursorPrototype.set =
KeyedCursorPrototype.set = function(key, value) {
    return arguments.length === 1 ? this.setIn([], key) : this.setIn([key], value);
}
```
 @Dashed tried your version, test fails with: 

```
Cursor â€º it can set value of a cursor directly
  - TypeError: Object 1 has no method 'updateIn'
        at /Users/geirsagberg/Projects/immutable-js/contrib/cursor/index.js:148:14
        at updateInDeepMap (/Users/geirsagberg/Projects/immutable-js/dist/immutable.js:2500:22)
        at updateInDeepMap (/Users/geirsagberg/Projects/immutable-js/dist/immutable.js:2509:23)
        at src_Map__Map.updateIn (/Users/geirsagberg/Projects/immutable-js/dist/immutable.js:1816:26)
        at updateCursor (/Users/geirsagberg/Projects/immutable-js/contrib/cursor/index.js:307:38)
        at KeyedCursor.IndexedCursorPrototype.updateIn.KeyedCursorPrototype.updateIn (/Users/geirsagberg/Projects/immutable-js/contrib/cursor/index.js:147:10)
        at KeyedCursor.src_Map__Map.setIn (/Users/geirsagberg/Projects/immutable-js/dist/immutable.js:1794:19)
        at KeyedCursor.IndexedCursorPrototype.set.KeyedCursorPrototype.set (/Users/geirsagberg/Projects/immutable-js/contrib/cursor/index.js:89:40)
        at Spec.<anonymous> (/Users/geirsagberg/Projects/immutable-js/contrib/cursor/__tests__/Cursor.ts:247:20)
        at jasmine.Block.execute (/Users/geirsagberg/Projects/immutable-js/node_modules/jest-cli/vendor/jasmine/jasmine-1.3.0.js:1065:17)
        at jasmine.Queue.next_ (/Users/geirsagberg/Projects/immutable-js/node_modules/jest-cli/vendor/jasmine/jasmine-1.3.0.js:2098:31)
        at jasmine.Queue.start (/Users/geirsagberg/Projects/immutable-js/node_modules/jest-cli/vendor/jasmine/jasmine-1.3.0.js:2051:8)
        at Spec.jasmine.Spec.execute (/Users/geirsagberg/Projects/immutable-js/node_modules/jest-cli/vendor/jasmine/jasmine-1.3.0.js:2378:14)
        at jasmine.Queue.next_ (/Users/geirsagberg/Projects/immutable-js/node_modules/jest-cli/vendor/jasmine/jasmine-1.3.0.js:2098:31)
        at onComplete (/Users/geirsagberg/Projects/immutable-js/node_modules/jest-cli/vendor/jasmine/jasmine-1.3.0.js:2094:18)
        at Spec.jasmine.Spec.finish (/Users/geirsagberg/Projects/immutable-js/node_modules/jest-cli/vendor/jasmine/jasmine-1.3.0.js:2352:5)
        at null.onComplete (/Users/geirsagberg/Projects/immutable-js/node_modules/jest-cli/vendor/jasmine/jasmine-1.3.0.js:2379:10)
        at jasmine.Queue.next_ (/Users/geirsagberg/Projects/immutable-js/node_modules/jest-cli/vendor/jasmine/jasmine-1.3.0.js:2108:14)
        at null._onTimeout (/Users/geirsagberg/Projects/immutable-js/node_modules/jest-cli/vendor/jasmine/jasmine-1.3.0.js:2088:18)
        at Timer.listOnTimeout [as ontimeout] (timers.js:121:15)
```

Here is the test:

``` js
it('can set value of a cursor directly', () => {
    var onChange = jest.genMockFunction();
    var data = Immutable.fromJS({a:1});
    var c = Cursor.from(data, ['a'], onChange);
    var c1 = c.set(2);
    expect(c1.deref()).toBe(2);
    expect(onChange).lastCalledWith(
      Immutable.fromJS({a:2}),
      data,
      ['a']
    );
  });
```
 Ah I see. Nevermind then; I didn't actually test my suggestion.

Your PR works much better. :+1: 
 I've used cursors a little bit more extensively ever since I've suggested https://github.com/facebook/immutable-js/issues/249.

I think `Cursor.set(value: any): Cursor` doesn't seem to be consistent with the the rest of the API of the immutable library; especially since `Cursor` is to be a transparent type. 

I think `Cursor.update(updater)` is a much better approach. 
 All I know is that it feels really unnecessary to do `cursor.update(function() { return newValue; })` if `cursor.set(newValue)` would do the same thing. `cursor.setIn([], newValue)` is slightly better, but is not more intuitive nor easier to read, IMHO.

Can't we add `.set(value)` just for the sugar?
 Or at least point out a scenario where `.set(value)` would cause undesirable effects, because I can't think of any off the top of my head.
 @geirsagberg I totally understand the need; and there isn't anything wrong with the implementation of `Cursor.set(value)` as it is done through this PR.

I'm merely respecting the author's intent of `Cursors` as he has stated here: https://github.com/facebook/immutable-js/issues/242#issuecomment-67198651
Which to me, means the Cursor API should be consistent with the other Immutable collections. 
  ``` javascript
> Immutable.Set([1]).union(Immutable.OrderedSet([1]))
Set { 1 }
> Immutable.Set().union(Immutable.List([1]))
Set { 1 }
> Immutable.Set().union([1])
Set { 1 }
> Immutable.Set().union(Immutable.OrderedSet([1]))
OrderedSet { 1 }
```

Expected `union` to always return a Set, as written in the docs.
  We're dealing with a huge JSON object which gets delivered by an ajax request - around 4mb with nested objects and arrays (one has a length of 10,000+). Upon receiving, we're running it through `Immutable.fromJS` which takes about 7.8 seconds. This 7 seconds is obviously a huge bottleneck for the browser.

A feature for preprocessing the data on the server before it hits the client's `fromJS` would be nice. Something like a curry which preps the object for immutability. Or is there another recommended strategy for handling this sort of thing?

**Update:**

I've isolated the issue into a jsfiddle and get much better performance without any other javascript executing. Though, it does still take about 1.5 seconds of grinding.

http://jsfiddle.net/jL596cny/1/
 That did work! Thanks for the speedy reply as well. There is definitely a noticeable difference in performance. It's worth noting that I had to change the example given in that article slightly to use `List` instead of `Vector`. 

``` javascript
import { List, Map } from 'immutable';
import transit from 'transit-js';

let rdr = transit.reader("json", {
  arrayBuilder: {
    init: function(node) { return List().asMutable(); },
    add: function(ret, val, node) { return ret.push(val); },
    finalize: function(ret, node) { return ret.asImmutable(); },
    fromArray: function(arr, node) { return List(arr); }
  },
  mapBuilder: {
    init: function(node) { return Map().asMutable(); },
    add: function(ret, key, val, node) { return ret.set(key, val);  },
    finalize: function(ret, node) { return ret.asImmutable(); }
  }
});
```

Having done this, I actually decided to take another approach and not immediately transform all the data upon receiving it (especially that huge array). It just wasn't necessary. Feel free to close!
  Since contributing guide mentions [code style rules](https://github.com/facebook/immutable-js/blob/master/CONTRIBUTING.md#coding-style), it worth to add JSCS style checking:

```
{
    "esnext": true,
    "validateIndentation": 2,
    "maximumLineLength": 80,
    "validateQuoteMarks": "'",
    "requireSemicolons": true,
    "requireCommaBeforeLineBreak": true
}
```
  See commit for five locations. These are bad, especially in IE8 etc.
 Thanks for fixing this. I'd love to see this merged, so closure compiler doesn't give any warnings.
  Can you please explain a bit more what is wrong with `PropTypes.instanceof` validation? 

I use it my project as simple is:

``` js
var Product = Immutable.Record({name: undefined});
var product = new Product();
product instanceof Product // true
product instanceof Immutable.Record // true
product instanceof Object // true
```

Hence, it work the same in React:

``` js
class Cargo extends Component {
    static propTypes = {
        product: PropTypes.instanceOf(Product)
    }
}
```
 @leebyron Have you tried https://github.com/HurricaneJames/react-immutable-proptypes?
 +1
  `Immutable.is()` returns `false` when comparing an `OrderedSet` and a `Set` with the same elements. I had expected this to be `true`:

``` node
> Immutable.Set('a').equals(Immutable.Set('a'))
true
> Immutable.OrderedSet('a').equals(Immutable.OrderedSet('a'))
true
> Immutable.OrderedSet('a').equals(Immutable.Set('a'))
false
```

Even if my expectations were wrong, it seems like we can't convert an OrderedSet to a Set

``` node
> Immutable.Set(Immutable.OrderedSet('a'))
OrderedSet { "a" }
```

Unless we do something like:

``` node
> Immutable.Set(Immutable.OrderedSet('a').toSeq())
Set { "a" }
```

and then use `is()`. Maybe there should be an easier way to test if an OrderedSet and a Set contain the same elements?
 Ran into this the other day as well with Map / OrderedMap. It seems like this is a bug, at least when comparing with the analogous clojure behavior.

``` js
(def a {2 :two 1 :one})
(def b (into (sorted-map) a)) // {1 :one 2 :two}
(= a b) // true
```
 Ah... well it turns out that I had references to two Sets to begin with, but one reference turned into an OrderedSet.

Here's the culprit:

``` node
> Immutable.Set([1]).union(Immutable.OrderedSet([1]))
Set { 1 }
> Immutable.Set().union(Immutable.OrderedSet([1]))
OrderedSet { 1 }
```

An empty Set union'd with a non empty OrderedSet returns an OrderedSet. 

I hope this is a bug?
 I did a bit of searching and couldn't find anything too concrete about the reasoning, though the best explanation I could find came from this [stack overflow post](http://stackoverflow.com/a/11006759/525714)

I think maybe the simplest way to think of it would be in terms of EDN's definition of [equality](https://github.com/edn-format/edn#equality) - there is no concept of sort order maintained in reading/writing of a data structure to EDN, it's purely a runtime construct.

> sequences (lists and vectors) are equal to other sequences whose count of elements is the same, and for which each corresponding pair of elements (by ordinal) is equal.
> 
> sets are equal if they have the same count of elements and, for every element in one set, an equal element is in the other.
> 
> maps are equal if they have the same number of entries, and for every key/value entry in one map an equal key is present and mapped to an equal value in the other.

So yep, in Clojure it seems as though if both objects are a Set or both are a Map, the sort order is ignored in equality.

Possibly relevant, commit I came across in cljs to [change the hashing algorithm](https://github.com/clojure/clojurescript/commit/6fd16df50bca7a6118693712e6918c70a64de255) 

> "so that the various map types hash to the same value when equal, independent of insertion ordering and the like and without sorting of keys."
 @leebyron any thoughts on whether you'd want a change in behavior on this? 

It's a simple patch, but was waiting to hear what you thought since it'd be a breaking change.
 Having come across this need in my own project, I'm finding that what I really want is a separate set equality operator - I've implemented this as `a.isSubset(b) && b.isSubset(a)`, but it might be nice to have in the standard API. I agree that there are some conceptual problems with OrderedSets and unordered Sets with the same members being equal, but set equality comparison is a very common use case.
  I just ran into this issue and spent a while trying to debug it. Is there any way we can add this to the docs so that future developers don't spend a while debugging this issue? I'd be more than happy to make that change
 :+1: 
 I found all methods that called `record.constroctor()` has problem, includes `merge` (actully `mergeIntoCollectionWith`).

``` js
var R = Immutable.Record({});
var r = new R();
r.merge({});   // no problem, return "r" itself
r.merge({a: 1});  // return undefined
```
 Why remove them altogether though ? Record.map seems very useful for instance.
  List#indexOf returns unexpected result if List consists of custom type elements.

Consider following example:

``` javascript
var one = new Immutable.Record();
var two = new Immutable.Record();
var list = Immutable.List([one, two]);

console.log(one === two); // false
console.log(list.indexOf(one)); // 0
console.log(list.indexOf(two)); // 1
```

This works well. Both `one` and `two` are similar empty Records, but they are not equal. `one` is first element of `list`, `two` is second element.

Something goes wrong if custom types are used:

``` javascript
var Type = Immutable.Record({});
var one = new Type();
var two = new Type();
var list = Immutable.List([one, two]);

console.log(one === two); // false
console.log(list.indexOf(one)); // 0
console.log(list.indexOf(two)); // 0, but should be 1
```

For some reason, `one` and `two` appears to be on the same place in the list. What is going on? Is that expected behaviour?
 Thank you for explanation!

I was confused by example of `===` equality for Maps from documentation. It show following example:

``` js
var one = Immutable.Map({a: 1});
var two = one.set('a', 1)
console.log(one === two); // true
```

It looks like `one` and `two` compares by values resulting they're equal. Previously didn't notice text about `Immutable` always returns itself on trivial mutation. I thought if `one.set('a', 1)` is equal to `one`, so `one.set('a', 2).set('a', 1)` must be equal. Obviously, it must not.
 Can you please explain me one more thing. Is it possible to use `indexOf` to search for reference?

For example, in my project I need to maintain list of editable objects. On certain event, like clicking on item on page, I copy selected object to another variable and mutate object's fields on that variable. By that, when edition completes and updates are not discarded, I still have fresh new object and reference to original. Now I want to replace original object to the new in the list. Is it possible to know index of object in the list without storing index separately? Is it possible to have something like:

``` js
var i = list.indexOfRef(object);
list = list.set(i, newObject):
```
  Hi!
In the Issue #459 was described problem with infinite loop after calling `slice`.
I found, that this problem not only with List, but with all types, which call function `wholeSlice` from the file TrieUtils.js. Infinite loop starts every time when `slice` parameters begin or end is not integer

``` javascript
var vec = Immutable.List([7,4,5,8]);
result = vec.slice(0,"A");
console.log(result); //infinite loop
//Same thing in console.log(vec.slice(NaN,NaN));
//or console.log(vec.slice("A","B"));
//or result.toJS()
```

I fixed this and now, every time when slice gets non integers parmeters, it returns valid value

``` javascript
var vec = Immutable.List([7,4,5,8]);
console.log(vec.slice(0,"A")); //List [7,4,5,8]
```
 Hm, it looks that node v0.10.38 is not supported `Number.isInteger()`. In the 0.12.4 it forked fine. Of course, it can be replaced with `Math.round(num) === num` or something like this, but it will be not ES6 harmony style :)
 Unfortunately, it looks, what test case probably is not complete in the place. in the `slice.ts`, checks only case with NaN, but not checks another types(float, string). Detect only NaN is not enough. Also, this problem occurs after toJS method and this case also missed in the `slice.ts`.
I think, i will provide this test cases and test case with `__capacity`
 
[![Coverage Status](https://coveralls.io/builds/10359451/badge)](https://coveralls.io/builds/10359451)

Changes Unknown when pulling **4f3aba11e4cc7b9f76f7543dd74bf8fa329acebe on saromanov:fix-bug-#459** into ** on facebook:master**.
  The tsd type definitional manager for typescript supports a link functionality to automatically pull in d.ts files from included npm and bower dependencies if they have a "typescript" entry. https://github.com/Definitelytyped/tsd#link-to-bundled-definitions. Branch "typescript-package-link" adds these entries to both json files.
  I want to read it's doc compontent, but I didn't find it
 tks
  According to docs `includes` method should be available on `Iterable` and other classes extending it.
http://facebook.github.io/immutable-js/docs/#/Iterable/includes
However, its alias `contains` is working.
 Could you please update the library included inside the doc website?
(it's useful to easily test there but the version is 3.6.4)
  Could someone help me understand why the following assertions work:

``` javascript
var name = "Tim Cook";

var list1 = Immutable.fromJS([{name: "Name: Tim Cook"}]);
var list2 = Immutable.fromJS([{name: "Name: " + name}]);

var map1 = Immutable.fromJS({name: "Name: Tim Cook"});
var map2 = Immutable.fromJS({name: "Name: " + name});

expect(Immutable.is(list1, list2)).toBe(true);
expect(Immutable.is(map1, map2)).toBe(true);
```

But in the following example, the list assertion fails because it returns false. For the maps comparison it returns true as expected though.

``` javascript
var name = "Tim Cook";

var list1 = Immutable.List([{name: "Name: Tim Cook"}]);
var list2 = Immutable.List([{name: "Name: " + name}]);

var map1 = Immutable.Map({name: "Name: Tim Cook"});
var map2 = Immutable.Map({name: "Name: " + name});

expect(Immutable.is(list1, list2)).toBe(true);
expect(Immutable.is(map1, map2)).toBe(true);
```

Am I using the API incorrectly?
 Thanks @leebyron that explains it just fine!
 @leebyron, been lurking around here for quite a while now, first post so let me say :+1: for your work here and :100: for your outstanding communication!

This issue comes up again and again in one form or another. Two of three most recently closed issues are related to it: #493 and this one. I don't see anything at a quick glance at the README that shows this behaviour. Maybe in the https://github.com/facebook/immutable-js#nested-structures section, you could add some language and an example for list and map that shows what happens (and maybe even move the section up)? I think basically what you've written here is a great explanation.

Thanks again for all your hard work
  According to [the docs](https://github.com/facebook/immutable-js/blob/013d52b58d6c7497a6c791cd5950acc32a7340b8/type-definitions/Immutable.d.ts#L2070), `isSuperset` should accept an Array. This adds a check similar to the one in `isSubset` to make sure that's true (:

I wasn't sure where to add the test so I put it in `Set.ts`. Let me know if there's a better place!
 np (:
  I am heavily using Records for most of my Data that is passed around in my app.

I came across some weird behaviour with ES6 Javascript Getters. 
Let's say I have a Product Record:

``` javascript
var Product = new Record({
    'id': 0,
    'name': null,
    'moneyPrice': null,
     getMoneyPrice() {
        console.log(this);
        if (this.moneyPrice) {
            return (`${this.moneyPrice}`).replace('.', ',');
        }
    },
    get needsPayment() {
        console.log(this.moneyPrice);
        return (this.moneyPrice && this.moneyPrice > 0);
    }
});

var shoe = new Product({id: 1, name:'Super Sneaker', moneyPrice: 59.00})
shoe.getMoneyProce();
shoe.needsPayment;
```

In my real function (getMoneyPrice), this.moneyPrice is correctly set to 59.00, but using the getter this.moneyPrice is null. Actually in needsPayment this is an empty product and not populated with my shoe data.

I have read in #21 that @leebyron is using getters with Immutable.Record.
 What I ended up doing is splitting it in 2 classes. It supports a constructor and having get functions on my Records. Which will compile into something very similar to what you wrote.

``` javascript
var RecordClass = new Record({
    'id': 0,
    'team1': null,
    'team2': null,
    'scoreT1': null,
    'scoreT2': null,
    'date': null,
    'gamegroup': null,
    'myBet': new GameBet()
});

export default class Game extends RecordClass {
    constructor(game) {
        if (game.gamebets) {
            var myBet = game.gamebets[0];
            game.myBet = new GameBet(myBet).set('game', game.id);
            delete game.gamebets;
        }
        super(game);
    }

    get result() {
        return this.scoreT1 + ':' + this.scoreT2;
    }

    getDate() {
        return new Moment(this.date, 'YYYY-MM-DD HH:mm Z');
    }

}
```
 @leebyron is there a way to override existing values? I want to do something like this:

``` js
var Task = new ImmutableRecord({
  title: null,
  estimate_seconds: null
});

Object.defineProperty(Task.prototype, 'estimate_seconds', {
  get: function () {
    return this.get('estimate_seconds') || 1800;
  }
});
```

But what is odd is that other properties no longer turn up:

``` js
t = new Task({ title: 'foo' })
> Record {_map: Object}
t.title
> undefined
t.estimate_seconds
> 1800
```

It seems to work fine if I just give the property another name.
 Yeah, that's what I ended up doing.
 There's a tiny type in @leebyron's example, `Property.prototype` should be `Product.prototype` :)

Btw, any update on when v4 will hit the shelf?
  I want to update one of my components to use Immutable.js and was curious the best way to update nested Maps.  I have a relatively simple data structure with nested objects and children and it could potentially go very deep.  It is a json structure used for a Tree component.  The data looks like this:

<pre><code>
[
  {id:'A', label: 'A', checked: true},
  {id:'B',label: 'B'},
  {id:'C',label: 'C',
    children: [
        {id:'C-A',label: 'C-A'},
        {id:'C-B',label: 'C-B', checked: true},
        {id:'C-C',label: 'C-C',
          children: [
              {id:'C-C-A',label: 'C-C-A'},
              {id:'C-C-B',label: 'C-C-B'},
              {id:'C-C-C',label: 'C-C-C', checked: true}
          ]
        }
    ]
  },
  {id:'D',label: 'D'}
]
</code></pre>


This is a controlled component and so when the user interacts with the tree, I update the appropriate checked value in the data with the corresponding id.  So for example, I may change the checked attribute from true to false for the node with id 'C-C-C'.  I am attaching a link of a JSFiddle that I used and it works but I am not sure if the same can be achieved in a better way using setIn or something.

JSFiddle link: http://jsfiddle.net/yk2y2hhu/1/
 Ah ok.  Yes the id's will be unique so I will go ahead and try to model them as an OrderedMap and see how it works.  The order does not necessarily matter in this particular example but there are cases where people using the component may want it in a specific order or to have the ability to reorder it.

Thanks.
 Hey sorry to bother you again.  I seem to be having some trouble getting this set up correctly and am hoping you could point me in the right direction.  How would I take something like the above data structure and model the children as an OrderedMap.  I was thinking something like this:

<pre><code>
var data = new Immutable.OrderedMap({
  'A': { label: 'A', checked: true },
  'B': { label: 'B', checked: false },
  'C': { label: 'C', children: Immutable.OrderedMap({
    'C-A': {label: 'C-A', checked: true, children: Immutable.OrderedMap({
      'C-A-A': {label: 'C-A', checked: true}
    })}
  })}
});
</code></pre>

but when I try to retrieve deep values with this, I get undefined:
<code>
data.getIn(['C','children','C-A'])
</code>

Im sure Im missing something obvious or setting this up wrong but I was hoping you could point me in the right direction.  I put this in an updated fiddle as well in case it's easier to look at it there.

http://jsfiddle.net/yk2y2hhu/3/
 The value of 'C' is a plain object, not another immutable structure, i.e. `data.getIn(['C', 'children']) === undefined`

If you have a nested object that you want to convert to a Map use `Immutable.fromJS`, https://github.com/facebook/immutable-js#nested-structures
 Ah awesome thanks.  I got it figured out now.  I appreciate the help.
 I need to use the solution with deeply nested maps and lists. The problem with the Solution of @Robert-W http://jsfiddle.net/yk2y2hhu/1/ is that it always returns a new structure event if nothing changed!. I guess this is because `.map` always produces a new collection. 
Is there another good way to [update, set , merge] deeply nested maps and lists?
 Thanks. I could easily use `setIn` or `mergeIn` or `updateIn` if my data structure is maps all the way down. But is it possible to use `setIn` in a structure like the following? for example to set `active = true` on the deepest item with id 356 . If it's possible, please show me how to do that.

```
[
            {id:123, active:false, children:[]},
            {id:134, active:false, children:[
                {id:212, active:false, children:[
                    {id:245, active:false, children:[]},
                    {id:256, active:false, children:[]}
                ]},
                {id:145, active:false, children:[]},
                {id:156, active:false, children:[]},
                {id:213, active:false, children:[
                    {id:313, active:false, children:[]},
                    {id:314, active:false, children:[
                        {id:345, active:false, children:[]},
                        {id:356, active:false, children:[]}
                    ]}
                ]}
            ]}
        ]
```

As I said, I tried to use @Robert-W 's old solution (before he changed his lists into orderedMaps) http://jsfiddle.net/yk2y2hhu/1/ . It works but it always creates a new copy of the whole data structure even if nothing changed!!
 Got it. Thanks :)
  `[ [ 'a', 'b' ], [ [ 'c', 'd', 'f' ] ] ]`

What I need to get is `[ [ 'a', 'b' ], [ 'c', 'd', 'f' ] ]` regardless of deepness of the input.

Maybe I'm loosing something and I can easily archive this with existing functionality.. Atm I think that `list.flatten(-1)` would be natural way to do such thing.
 Also I think about `list.flatten(untilPredicate)`
 What about `list.map((inner) => inner.flatten())`?
 @samwgoldman your point is valid, but

![screen shot 2015-06-05 at 9 08 25 pm](https://cloud.githubusercontent.com/assets/547167/8012097/42d21350-0bc7-11e5-841f-013cc72df00c.png)
 @leebyron I want to flatten list to List< String > and not Array< NestedValue > . I think it's obvious from my examples.

Why I need it, I want to distinguish my nested Lists, but deepness of these Lists can vary and I cant predict it.
 For my concrete case I want
[ [ 'a', [ 'b' ] ], 'c' ] => [ [ 'a', [ 'b' ] ], 'c' ]
[ [ [ 'a' ] ], 'b' ] => [ [ [ 'a' ] ], 'b' ]
[ [ [ 'a' ] ], 'b' ] => [ [ [ 'a' ] ], 'b' ]
[ 'a', [ [ 'b' ] ], 'c' ] => [ 'a', [ [ 'b' ] ], 'c' ]
[ 'a', [ 'b', [ 'c', [ 'd' ], 'e' ], 'f' ], 'g' ] => [ 'a', [ 'b', [ 'c', [ 'd' ], 'e' ], 'f' ], 'g' ]

But I just propose, I think it would be useful if it could be controlled by list.flatten(untilPredicate). 
If there is any other solution for my case, I will appreciate a lot.. 
 list.flatten((v) => "List that contains not Lists") . The predicate could signal on which point it should stop flatten.
 My real-life case is

``` javascript
static getMapPaths(map) {
        map = fromJS(map);
        getPaths = (map, result = new List([])) => (
            (!Map.isMap(map) || map.isEmpty()) && result.toArray() ||
            map.flip().toList().reduce(
                (res, k) => res.push(getPaths((map.get(k)), result.push(k))),
                new List()));
        return fromJS(getPaths(map).flatten().toArray());
    }
```

Maybe there is a better way to implement that kind of function, but in this particular implementation I got nested Lists and I need to flatten it somehow, but I don't want to loose separate paths, which are represented as Lists. Which is why I was required to separate actual "paths" by JS Arrays from nested Lists and than convert it to Immutable data structures back.

Original idea was:

``` javascript
static getMapPaths(map) {
        map = fromJS(map);
        getPaths = (map, result = new List([])) => (
            (!Map.isMap(map) || map.isEmpty()) && result ||
            map.flip().toList().reduce(
                (res, k) => res.push(getPaths((map.get(k)), result.push(k))),
                new List()));
        return getPaths(map).flatten(-1); // or .flatten((v) => "List that contains not Lists")
    }
```
 @leebyron Great! ) It recalled me on SICP courses ). Also I recognized that I need different algorithm and different output data structure for my problem.. Your explanation and examples did great job for me to understand it. ATM believe that my concrete request was provoked by wrong approach which was leaded to ~maybe~ wrong need (I'm about negative flatten param and/or predicate). If someday I catch myself on it I'll think twice until I'll be dead sure that we need it.

Thank you and your colleagues for what you're doing for open source, it's huge )
  I took the sample from the WIKI page and pasted it into a JSBin.  I added script tags with CDN links to React, and Immutable.js.  So the only changes I made to this code removes Common JS and prefixes Map and List with Immutable.

[Link to sample on Bin](http://jsbin.com/hipazukede/2/edit?js,output)

The issue is when I run the sample the count does not update.  Is this sample supposed to work this way?  The count always being 0?
### Sample Output

Count: 0
Saved counts:
- Saved: 0
- Saved: 0
- Saved: 0
- Save count

``` javascript
var Component = React.createClass({

  getInitialState() {
    return {
      data: Immutable.Map({ count: 0, items: Immutable.List() })
    }
  },

  handleCountClick() {
    this.setState(prev => ({
      data: prev.data.update('count', v => v + 1)
    }));
  },

  handleAddItemClick() {
    this.setState(prev => ({
      data: prev.data.update('items', list => list.push(prev.data.get('count')))
    }));
  },

  render() {
    var data = this.state.data;
    return (
      <div>
        <div onClick={this.handleCountClick}>
          Count: {data.get('count')}
        </div>
        Saved counts:
        <ul>
          {data.get('items').map(item => 
            <li>Saved: {item}</li>
          )}
          <li onClick={this.handleAddItemClick}>Save count</li>
        </ul>
      </div>
    );
  }

});

React.render(<Component />, document.body);
```
 Clicking on "Count: ##" will increment the count. Clicking "Save Count" will add the current count to a `List`.

The example is supposed to work in this way. It may be better to have "Count: ##" and "Save Count" be hyperlinks or buttons to make it more clear if this functionality wasn't apparent from the code.
  Are there any plans to allow objects to define their own hashing algorithms a la Python's [`__hash__`](https://docs.python.org/2/reference/datamodel.html#object.__hash__)? It seems like it would just require making `UID_HASH_KEY` public (though I can also see an argument for not wanting to introduce new equality semantics into JS).
 Perfect! I had looked in the source but somehow missed that line!
 > Two equivalent MUST return the same hash code, but the same hashCode doesn't need to guarantee equality. @leebyron 

That single phrase just saved my day! I encountered weird case with hash collision of two different objects. It turns out {x: 10, y: 20} and {x:20, y:10} give the same hashCode. I discovered that the hashCode is not safe but that summary you gave cleared it out for me. It should be documented.  I'm pleased to see immutable-js has a bunch of methods that use keypaths (so I don't need to write messy verbose code to update one property deep in a nested structure.

But has anyone considered also supporting the same syntax as the [update](https://facebook.github.io/react/docs/update.html) addon to React? Which itself is based on the MongoDB query language.

It's fairly simple yet flexible. And I have a feeling that without it Immutable is going to be stuck either endlessly adding even more keypath methods or shunning users who want to simplify a simple but unsupported mutation.

For example. I see #406 asking for concatDeep or concatAll because mergeDeep clobbers lists. And #331 asking for a similar pushIn.
 It's great idea, I believe. MongoDB-style queries are simple, convenient and quite usual, since they are used both in Mongo and React.

I suggest those queries should be supported not separate methods, but by *In-functions signatures. For example, for data like:

``` js
var data = Immutable.fromJS({cat: {isDead: false}})
```

`Map#setIn` method could be called by two equivalent methods:

``` js
data.setIn(['cat', 'isDead'], true)
```

``` js
data.setIn({cat: {isDead: {$set: true }}})
```

What do you think about it?
 +1
 +1
 +1
 @leebyron I can prepare a prototype PR for this feature, if you don't mind.
    ``` js
const {List} = require('immutable');

const foo = List();

const NOT_SET = {};
console.log(foo.get('bar', NOT_SET) !== NOT_SET); // => true (expected false)
console.log(foo.getIn(['bar'], NOT_SET) !== NOT_SET); // => true (expected false)

// this regression breaks .hasIn()
console.log(foo.has('bar')); // => false
console.log(foo.hasIn(['bar'])); // => true (expected false)
```
 Using `immutable@3.7.3`.
 I tried other types of keys:

``` js
const {List} = require('immutable');

const foo = List();

[
    'bar',
    true,
    false,
    null,
    void 0,
    {},
    42,
    42.5
].forEach(function(key) {

    const NOT_SET = {};

    let ret = false;

    ret = (foo.get(key, NOT_SET) !== NOT_SET) || ret;
    ret = (foo.getIn([key], NOT_SET) !== NOT_SET) || ret;

    ret = foo.has(key) || ret;
    ret = foo.hasIn([key]) || ret;

    if(ret) {
        console.log('broken for key', key);
    }
});
// broken for key bar
// broken for key undefined
// broken for key {}
```
 +1
 ``` js
Immutable.List([7]).getIn(0) // throws error whereas 7 was expected
Immutable.List([7]).getIn('0') // returns 7 as expected
```
 Thanks @leebyron, I realized that I was calling `getIn` incorrectly. I created a new issue at https://github.com/facebook/immutable-js/issues/940 for strings in getIn.
  Hi, I'm trying to perform `remove()` and `sort()` inside a `withMutations()`. Now the documentation says that only `set()` and `merge()` can be used with a mutable collection. However, [this post](https://github.com/facebook/immutable-js/issues/228) suggests that `remove` is safe to use with a mutable Map.

Can someone please let me know whether I can use `remove()` and `sort()` for an OrderedMap in `withMutations`? Thank you.
 Thanks for your very quick reply. So if `remove()` is not safe on OrderedMap, would you recommend me to use `filterNot()` instead, or another approach?
 Thanks. Really appreciate your time in answering my questions.

So what would be the best practice when removing a bunch of entries from an OrderedMap? I'm guessing that `filter()` or `filterNot()` will be more efficient than multiple calls of `remove()`. Also, I'm assuming the filter methods, like the `remove()`, will return a new collection, is that correct? Does that reuse the existing map entries or does it clone the existing entries?
  First of all, let me prefix this by saying that I haven't looked into Immutable.JS implementation so I might be doing something wrong/expecting the wrong thing. First the results:

Using reduce and concat to perform what is called flatten in Immutable. Immutable.JS version:

``` javascript
xs = Immutable.Range(0, 700).toList();
item = Immutable.Range(0, 50).toList();
bigList = xs.map(x => item);
t = +new Date();
bigList.reduce(((x, v) => x.concat(v)), Immutable.List([]));
new Date() - t
```

Runs in over 3 seconds (tested in FF).

Vanilla JS version:

``` javascript
xs = Array.apply(null, Array(700)).map(function (_, i) {return i;});
item = Array.apply(null, Array(50)).map(function (_, i) {return i;});
bigList = xs.map(x => item);
t = +new Date();
bigList.reduce(((x, v) => x.concat(v)), []);
new Date() - t
```

Takes about 250ms.

Now of course I wouldn't write this code by hand, I'd use flatten. I am just using this as a benchmark. I would like to know why Immutable is so much slower and whether it's to be expected. I would also like to know in general how Immutable's List compares in performance to native Array. Thanks.
 Thanks for the answer. I imagine that concat would be a good candidate for structural sharing?

I also wonder whether it would make sense to use native data structures for backing small collections and only switch to tries when the collections hit a certain size. I would also love to know how @swannodette's mori is doing in comparison (again, in general). 

Perhaps the answer for my use case is to switch to laziness, which unfortunately became more difficult with Immutable 3...
 For future reference, I was obviously using `flatten` completely wrong, since what I wanted was Haskell's `concat`, so the fast way to do this is:

``` javascript
bigList.first().concat.apply(bigList.first(), bigList.rest().toArray());
```

provided the outer collection isn't empty (which is incidentally 10 times faster than flatten).
  It would be nice if you could set multiple properties, or even deep setting properties in a map.

What happens now:

``` js
> var m = Immutable.Map({a:1,b:2,c:3})
undefined
> m.toJS()
Object {a: 1, b: 2, c: 3}
> m = m.set({a:5,b:6})
> m.toJS()
Object {a: 1, b: 2, c: 3, [object Object]: undefined}
```

It would make more sense for `m = m.set({a:5,b:6})` to result in `{a:5,b:6,c:3}` ...

As an extension it would make sense for nested objects to become maps themselves, and set the nested properties.
 @lebyron thanks... I was mainly just playing with what I saw for the first time, and thought the behavior was a bit odd.
  Right now:
`Immutable.Set.of(10, null).min()` returns null
`Immutable.Set.of(10, null).max()` returns 10
`Immutable.Set.of(10, NaN).min()` returns NaN
`Immutable.Set.of(10, NaN).max()` returns NaN

I know we're using js for comparison, but the result seems somehow unexpected. Just wanted to bring this to attention, because it seems that the strategy to ignore nulls and NaNs for min e max seems legit for all cases, right? I mean that, if, most user code would tend to .filter null/NaN before calling min/max, isn't better to put the extra check inside min/max? 

I know it's ok to continue letting NaN poison all operations, and let the user ensure correct values or filter null, etc. Just a comment, because data structure libraries can avoid bugs with decisions like these.

[]'s
 ```
> Math.min(10, null)
< 0
```

Even if the idea is to mimic `Math.max` and `Math.min`, it seems like there's a bug in your first example. It would appear that the candidate values should be converted to a number before comparison.
 The idea would _not_ be to mimic default Math.max e Math.min. I consider currrent Immutable behaviour to be better (i.e. I like that it returns the actual value, not the coerced one used in the comparison). The question is if is it even better to filter only numbers for max/min (outcome being 10 in all the examples I wrote before)
  Consider this demo code:

``` javascript
var items = Immutable.List([{a:1, b:[{c:1}]}, {a:2, b:[{c:2}]}]);

var index = 1;
var newItems = items.update(index, function (item) {
   item.b = [{c: 22}];
   return item;
});

console.log(items === newItems);
// true..

console.log(items.get(index), newItems.get(index));
// both objects are updated..
```

This behavior looks strange to me. I'm expecting list to be immutable actually..
# 

Few words on my practical case - I have some "items" as array of data in Flux store and on user's action some object from it can be updated with new data received from REST API.
 @leebyron thanks a lot for such descriptive response. However I've change my example code to `Immutable.fromJS` instead of `List` and result was the same.

``` javascript
var items = Immutable.fromJS([{a:1, b:[{c:1}]}, {a:2, b:[{c:2}]}]);

var index = 1;
var newItems = items.update(index, function (item) {
   item.b = [{a: 456789}];
   return item;
});

console.log(items === newItems);
// true..

console.log(items.get(index), newItems.get(index));
```
 @leebyron thanks a lot! Great examples! 
 @leebyron what if I want to update several properties inside object from list? `setIn` is not capable with that?
 Man, can you girls/guys please please please update the immutable.js documentation with these examples? I'm sure one of your 100 front end engineers has the time - please - thanks.
  There seems to be a regression in v3.7.3 that causes `take(n)` to fill the resulting array with up to `n` `undefined`s.

```
$ npm install --save immutable@3.7.2
immutable@3.7.2 node_modules/immutable
$ node
> var Immutable = require('immutable')
undefined
> Immutable.Map({a: 1, b: 2}).valueSeq().filter(function (n) {return n > 1}).take(10).toJS()
[ 2 ]
$ npm install --save immutable@3.7.3
immutable@3.7.3 node_modules/immutable
$ node
> var Immutable = require('immutable')
undefined
> Immutable.Map({a: 1, b: 2}).valueSeq().filter(function (n) {return n > 1}).take(10).toJS()
[ 2, , , , , , , , ,  ]
```

Strangely enough, it doesn't seem to happen without filtering beforehand.

Thanks in advance,
Tim
  I am trying to manipulate an Immutable(3.6.4) cursor by adding and inserting an entry to a list:

```
var data = Immutable.fromJS({a: {b: [0, 1, 2]}});
var cursor = Cursor.from(data, ['a', 'b'], function(newData){
    data = newData;
});

cursor = cursor.push(3);
var newList = cursor.splice(1,0,11);
cursor.update(function(x){return newList;});

console.log(data.toJS().a.b); //Result [0, 11, 1, 2, 3]
```

Why is it that the cursor.splice is not updating the 'data'?

Now, using withMutation, splice does not seem to work. I have added the results next to the log statements.

```
var data = Immutable.fromJS({a: {b: [0, 1, 2]}});
var cursor = Cursor.from(data, ['a', 'b'], function(newData){
    console.log("Setting Data");
    data = newData;
});

cursor.withMutations(function(c){
    console.log(c.toJS()); //[0, 1, 2]
    c.push(3).toJS();
    console.log(c.toJS()); //[0, 1, 2, 3]
    var newList =  c.splice(1,0,11);
    console.log(newList.toJS()); //[11]
    console.log(c.toJS());//[]
    c.update(function(x){return newList;});     
});
```

What is the right way to achive this?
 See #196 for a discussion of this.  I don't follow why `splice()` is considered non-mutative though.  It operates on the array in-place, whereas `slice()` makes a copy. 
 What is the right way to insert into an array using Cursors? Set overwrites the existing elements.
  This is helpful for newer version of `tsd` which can support inspect npm packages for type definitions.
 Thanks!
 awesome :rose: 
 Would be great to get this on NPM :)
 Agreed!

On Mon, Jun 15, 2015 at 1:41 AM Basarat Ali Syed notifications@github.com
wrote:

> Would be great to get this on NPM :)
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/pull/478#issuecomment-111979874
> .
  The following code will not sort the list:

```
var items = items.withMutations(list => { list.sortBy(...).sortBy(...).reverse() });
```

But this works as expected:

```
var items = items.sortBy(...).sortBy(...).reverse();
```

Does it not makes sense to use `withMutations` for these types of changes?
  what do you think implements Option(scala) or Maybe(haskell).

just code image.

```
class Option<A> extends Iterable<A>
  constructor: (value) ->
    if value is null or undefined
      None
    else
      Some(value)

class Some<A> extends Option<A>

class None extends Option<Nothing>
```

action image.

```
Option(1).map((i) -> i + 1)
# Some(2)
Option(null).map((i) -> i + 1)
# None
Option(1).map((i) -> i + 1).filter((i) -> i == 9)
# None
```

and more

```
Seq([1,2,3]).find((i) -> i == 2)
# Some(1)
Seq([1,2,3]).find((i) -> i == 9)
# None

Option(1).getOrElse(0)
#1
Option(null).getOrElse(0)
#0
```
 +1
It would be a great feature , but violates api , possibly worth giving the ability to disable this functionality.
  Similar to [`clojure.set/rename-keys`](https://clojuredocs.org/clojure.set/rename-keys), it returns a `Map` with the keys in `keyMap` renamed to the values in `keyMap`.

I find this function really handy when putting a `Map` through a series of transformations and can only imagine its a common use case.

``` js
Map({ a: 1, b: 2, left: 'alone' }).renameKeys({ a: 'y', b: 'z' });
// => Map { "y": 1, "z": 2, "left": "alone" }
```
 You're right, that's a much nicer implementation.

I can see your point that it's trivial to write if needed with `mapKeys`. I guess it's your call; I'm sure it would be a useful API, but you're the one that will be maintaining it :)
  OrderedSet has a guaranteed iteration order, and therefore methods like zip(), interleave(), interpose() and other combination methods make perfect sense for it. But they are only available for IndexedIterable which OrderedSet does not inherit.
 Not sure if `.indexOf` makes sense to include on OrderedMap, but I noticed recently that was missing there as well
 > @leebyron I don't think so... as it's not indexed, it just has a fixed and specified iteration order vs non-ordered Map's unspecified iteration order.

Is that why there is no `OrderedSet::get(index)`?
 @leebyron `indexOf` would be useful to be able to take advantage of `slice` (since slice deals with indexes). While OrderedMap has the ability to sort, it lacks the ability to insert somewhere in the middle. Typically I wan't to say "Insert key `foo` before key `bar`". Right now, the best I can come up with is something like:

```
omap.takeUntil((val, key) =>key === 'foo').concat(OrderedMap({ bar: 'barValue' }).concat(omap.skipUntil((val, key) => key === 'foo'))
```
  Is there any mechanism to enforce that everything is recursively immutable? I can pass everything through `Immutable.fromJS(...)` and then pass that through, but it gets inconvenient to have to remember to do that everywhere.

``` javascript
tmp = Immutable.List.of({name: 'foo'})
tmp2 = tmp
tmp2.first().name // "foo"
tmp2.first().name = 'bar'
tmp.first().name // "bar"

// It seems like the right way to do this is:
tmp = Immutable.List.of(Immutable.fromJS({name: 'foo'}))
```
 I don't know if this belongs in the same issue or not, but I'm also wondering if it's possible to convert to particular types. If not, do you have any advice on how this can be done? (Or reason I don't know why this may be a bad idea?)

```
NameRecord = Immutable.Record({name: null});
tmp = Immutable.List(/* of NameRecord objects */)
tmp = tmp.push({name: 'foo'}) // implicit conversion here?
tmp.first() instanceof NameRecord // currently false, but would be nice if it were true
```
 You should use an array of objects to create "immutable all the way down".

``` javascript
tmp = Immutable.fromJS([{name: 'foo'}]);
```

As for record type conversion, Immutable.List doesn't require all object types to be identical, so it can't automatically type this for you. You should do this yourself.

``` javascript
tmp = Immutable.fromJS([new NameRecord({name: 'foo'})]);
```

Alternatively

``` javascript
// create a list of immutable maps
tmp = Immutable.fromJS([{name: 'foo'}]);

// cast all of the maps to NameRecord
tmp = tmp.map(function(obj) {
    return new NameRecord(obj);
});

// add a new NameRecord
tmp = tmp.push(new NameRecord({name: 'bar'}));
```
 Now that I've given this a bit more thought, I guess what I'm really trying to figure out is, can I extend the Immutable types so that I can do something on every... mutation is the wrong word, but mutation.

```
tmp = new CustomList()
tmp.push({name: 'push'})
tmp.set(1, { name: 'set'})

parent = Immutable.Map()
parent.mergeDeep({ myList: [ {name: 'mergeDeep' } ]})

// ideally parent.get('myList') should be a CustomList() that
// has transformed each row into a `NameRecord`
```

I looked through the code, but I'm just not seeing a central function I could override that looks like it would catch all the different ways of adding values to immutables.
 Sounds what you're really after is a RecordSet class (extending List) that takes a Record as object type. You would prob need to override all of the change methods and cast the object before sending it to your parent method.

You might run into issues with some of the merge methods however, if object depth is unexpected.

Using `mergeIn` might be good enough for your purposes of "mutating" a record instance.

``` javascript
var tmp = Immutable.List();
tmp = tmp.push(new NameRecord({name: 'push'}));
tmp = tmp.mergeIn([0], {name: 'set'});
```
 Just saw this [interesting conversation](https://github.com/facebook/immutable-js/issues/407) with a result of a new library being developed.

https://github.com/Gozala/typed-immutable
 > it's pretty common to actually want to refer to a plain JS object within an immutable collection

This is true, but this also carries the potential for very difficult-to-debug Heisenbugs; you assume your entire tree of references is immutable because the root is, but somewhere along the line someone sneaked in a mutable reference, and many of the nice guarantees immutable data structures give you no longer hold.

As to typing only `{key: "value"}`, there's many API's which could still work this way, even if the setters enforced immutability. Merging `{key: "value"}` into a Map would still be safe, but merging `{key: {nested: "value"}}` wouldn't.

I would be **very** happy being able to enforce this "deep purity" somehow. Not really sure what the API would look like, though... Should there be e.g. `Map` which works as it does now, and a `PureMap` or something which would enforce immutability for values?
 I found a solution that seems to be working for me. I'm using an `Immutable.Map()` to store data and there's only one place it can get updated. In development mode I call `verifyImmutable()` to produce an exception if it finds any mutable objects or arrays.

``` js
import Immutable, { Map, Collection } from 'immutable'

function verifyImmutable(oldObj, newObj, path=[]) {
    for (let key of newObj.keys()) { // eslint-disable-line prefer-const
        const value = newObj.get(key)
        const oldValue = (oldObj === undefined) ? undefined : oldObj.get(key)

        // There's no need to check branches that haven't changed.
        if (!Immutable.is(oldValue, value)) {

            if (value instanceof Collection) {
                const currentPath = path.concat([key])
                verifyImmutable(oldValue, value, currentPath)
            } else if (value instanceof Array || value instanceof Object) {
                const currentPath = path.concat([key])

                throw new Error('The store must contain only immutable objects.'
                    + 'Mutable Array or Object found at: '
                    + currentPath.join('.'))
            }
        }
    }
}

export function replace(newStore) {
    if (newStore instanceof Map) {
        if (newStore !== store) {
            if (process.env.NODE_ENV !== 'production') {
                verifyImmutable(store, newStore)
            }

            store = newStore
            ee.emit('CHANGE')
        }
    } else {
        throw new Error("InvalidArgument: newStore must be an update to the existing store")
    }
}
```

Maybe it would be better to just have a utility function like this to verify deep immutability instead of trying to enforce it. This allows me to safely map over any of my structures to produce whatever I need to, I just can't push mutable data to my central store.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 As a new user of Immutable, I expected it to be strict and deeply convert JS objects when I insert them. I got bitten very quickly:

``` js
var map = Immutable.fromJS({ a: [0, 1, 2] });
map.getIn(['a', 1]); // â†’ 1
map = m.set('a', [1, 2, 3]);
map.getIn(['a', 1]); // â†’ undefined
```

`m.merge({ a: [1, 2, 3] })` would've worked â€” it _does_ deeply convert â€” and I don't grok why they behave differently. I also didn't expect `getIn()` to fail silently when I tried to descend into a JS array.

Maybe it would make sense to have a pointer or box type that would let regular objects be stored (explicitly) in an Immutable collection, but I think that otherwise they should be Immutable all the way down.
 So i just stumbled across this issue of not enforced immutability. and the thread is pretty old!
are there any plans to to avoid this pitfall?   Used ES6 Spreads instead of `.apply` where ever possible.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  I'm doing the following in my component where ProjectStore.projects() returns an Immutable.List (React 13.3).

```
  getInitialState() {
    return {
      projects: ProjectStore.projects()
    }
  }
```

However, I get the following `iterable.length has been deprecated` warning.  If I comment out that function, the warning disappears.

```
iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. Error
    at List.Object.defineProperty.get (eval at <anonymous> (http://192.168.1.106:8080/app.js:2542:2), <anonymous>:4584:21)
    at eval (eval at <anonymous> (http://192.168.1.106:8080/app.js:3436:2), <anonymous>:10:47)
    at isArrayLike (eval at <anonymous> (http://192.168.1.106:8080/app.js:3064:2), <anonymous>:12:36)
    at baseMergeDeep (eval at <anonymous> (http://192.168.1.106:8080/app.js:3052:2), <anonymous>:40:9)
    at eval (eval at <anonymous> (http://192.168.1.106:8080/app.js:2812:2), <anonymous>:46:42)
    at arrayEach (eval at <anonymous> (http://192.168.1.106:8080/app.js:3046:2), <anonymous>:15:9)
    at baseMerge (eval at <anonymous> (http://192.168.1.106:8080/app.js:2812:2), <anonymous>:38:22)
    at eval (eval at <anonymous> (http://192.168.1.106:8080/app.js:2818:2), <anonymous>:37:9)
    at eval (eval at <anonymous> (http://192.168.1.106:8080/app.js:2914:2), <anonymous>:45:27)
    at newConfig.getInitialState (eval at <anonymous> (http://192.168.1.106:8080/app.js:2176:2), <anonymous>:13:14)
```

What's the current correct method of using Immutable.js with component state?
  It would be nice to have a queue, or similar data structure the same functionality can be achieved with a list, but it would be nicer and probably more performant to have a true queue implementation.
 We talking about Silicon Valley? That show is awesome.

I am not an expert on how Immutable is written so I am not sure what overhead comes with a list. Unfortunately I am a bit pressed for time (and rusty on my c#) so I can dissect that article too much :( I will read it more closely tonight. 

As for my suggestion on a data structure, I would think a doubly linked list which keeps track of the head and tail would be the most efficient (memory and performance wise), enqueues and dequeues  would be O(1)(*<s>not including the immutable list copy</s>), a simple integer could be maintained for size on enqueue and dequeue, to avoid any overhead like a count() function. 

If list is already implemented this way, then a wrapper which hides the body may be enough. Here is the class I am writing for my own use, essentially to hide the mid section.

``` js
import Immutable from 'Immutable'
// This is untested and freshly written, please ignore stupid typos etc.
class Queue {
  constructor(defaultList = Immutable.List()){
    if(defaultList instanceof Array){
      defaultList = Immutable.List(defaultList)
    }
    this._list = defaultList
    this.length = defaultList.size
  }
  enqueue(value){
    return new Queue(this._list.unshift(value))
  }
  dequeue(){
    return new Queue(this._list.pop())
  }
  last() {
    return this._list.last()
  }
}

export default Queue
```
- now that I have thought about it, the new queue would only need to copy the head and tail pointer, as the list items would keep track of siblings.
 I think I need to whiteboard this, but my first instinct is that a doubly linked list wouldn't be able to be made immutable, except in the case where all middle sections (Like this queue) are hidden and the end -1 and tail +1 are the only things that would need to be copied. 

I am going to have to give this some more thought when I have more time, I am at work currently, but my interest is peaked.
 I white boarded it, and you are right (sometimes I just need to see it). You can't make a doubly linked list immutable. And I like the idea of the finger trie, though I need to learn more about it.

Thanks for the input!
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 This is an alternative way of implementing a queue based on two lists: https://github.com/sunesimonsen/changeless/blob/master/src/main/java/com/jayway/changeless/queues/FirstInFirstOutQueue.java
 Correct me if I'm wrong but doesn't a [Stack](https://facebook.github.io/immutable-js/docs/#/Stack) cover this?
 @dhenson02 a stack is a first in last out data structure.
 It sure is.

Dunno what I was thinking, disregard.
 you could check how Erlang implements its queue data structure:

https://github.com/erlang/otp/blob/maint/lib/stdlib/src/queue.erl

%% Efficient implementation of double ended fifo queues
%%
%% Queue representation
%%
%% {RearList,FrontList}
%%
%% The first element in the queue is at the head of the FrontList
%% The last element in the queue is at the head of the RearList,
%% that is; the RearList is reversed.
  I'm looking for a TreeSet/SortedSet type persistent data structure so I can create a heap. 
  Hi,

In all the browers at my disposal on my Arch Linux machine, the code snippets in the `http://facebook.github.io/immutable-js/` site is not visible. I don't have any user-defined style sheets installed. For example, on latest Firefox:

![Screenshot](http://dawidloubser.name/tmp/screenshots/immutable-docs-blank.png)
 No, never encountered with any other site. Being a web developer myself, I have curiously not been able to explain why the code is invisible - it's there in the DOM, and no CSS analysis seems to show an obvious reason for them to be invisible.
 +1
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 +1 this seems to happen on Linux (Arch Linux). It will be great if this can be fixed. At least use a different font if one is not working? 
 Maybe there is something wrong with "Fira Mono" and "Fira Sans" font families in some linux distros (Arch Linux for sure), because I have the same problem with http://blog.keithcirkel.co.uk/, which also uses those.
 Same here. ArchLinux user. I installed `ttf-fira-mono` and `ttf-fire-sans` which triggered removal of `google-fonts-git` package. Closed browser and re-opened and the problem is gone. Thanks for the tip on which fonts to pick, seems this did the trick.
 yeah, seems `ttf-google-fonts-git` has broken Fira fonts:
https://github.com/google/fonts/issues/10
https://code.google.com/p/googlefontdirectory/issues/detail?id=368
https://aur.archlinux.org/packages/ttf-google-fonts-git/
 @leebyron Working perfectly fine for me over the past couple of months - sorry for not closing this earlier, I'll close it now. Running latest `firefox`, and latest `ttf-google-fonts` on Arch linux.
  The sibebar in documentation cannot be scrolled on Laptop. This causes a terrible experience.
 My Browser is Chrome  43.0.2357.52 beta-m (64-bit) on WIndows 8.1
 I am also on Chrome 43 on Win 8.1, but I believe the same thing happens in Chrome 43 on Linux Ubuntu. There is no scrollbar for the left nav panel. If I put my cursor over it, I can wheel scroll or arrow scroll but it's not good. Also, it gets totally "lost" when it expands to a sub item.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  browserify does a [quick](https://github.com/substack/node-detective/blob/75946ee23cb7abb974a2053235ecb2663b879c07/index.js#L4) regexp match for `\brequire\b` before deciding on whether to build an AST to get the require calls. By rewording this comment so that the word "require" is nowhere in the source, you'd be improving everyones build times. Though Browserify has `noparse` option, this is an easy win.

I'm not sure why uglify decided to remove some line breaks for me but not for whoever ran the build last - but I'm not going to question it.
  The old one was just the same as the `zip` example.
  **Hypothetical Scenario**
I have a list of items - people for example. A person looks like this:

``` javascript
{
  firstName: 'John',
  lastName: 'Smith',
  phoneNumber: 123456789
}
```

I have a generic React "list" component that wants a list of items to display where each item looks like this:

``` javascript
{
   text: 'John Smith',
   hoverText: '123456789'
}
```

So... we need to map people into list items like so:

``` javascript
render() {
  return (
    <MyList items={people.map((person) => {
      text: person.get('name'),
      hoverText: person.get('number')     
     })} />
  );
}
```

**Problem**
Assuming `MyList` to be a pure component, React is still going to re-render it every time the parent component is rendered whether or not the Immutable `people` list has changed. 

Since `map()` returns a new object every time it's called, equality will not be preserved across calls to `.render()`.

**Proposed Solution**
A `pureMap` method that maintains referential equality:

```
people.pureMap('a-hard-coded-key', (person) => {
  text: person.get('name'),
  hoverText: person.get('number')     
});
```

ImmutableJS then will keep a cache of the last value returned for `'a-hard-coded-key'` and (if `people` hasn't changed), return the cached data structure.

The main downside with this approach is that `'a-hard-coded-key'` MUST be globally unique. It would be pretty trivial, however, to add a build step that would inject random, unique keys.

Thoughts?
 Note that this same approach could be used to provide optimized "pure" variants of other transformations such as `sort`, `slice`, etc.
 Thanks for the quick and detailed response!

> I would suggest that rather than passing in a result of map, that you instead pass in the original list, and allow the component's render function to perform the map - that way you can rely on the equality of that original list.

Yep. This is what I've done in the past. It's not ideal mainly because it's easy to forget to do. Also passing around mapping functions a lot is a bit inelegant. Still, this does work.

> Otherwise, what you're describing is a memoization function, which should be independent of what operation you're doing.

Good point. Baking the common-cases into the library, however, would make this more convenient and help to clarify the need to memoize where performance is critical.

> It also can lead to memory leaks

Yes, I was about to post a follow-up comment mentioning this. Obviously cleanup methods can be provided, but it does add to the conceptual overhead.

>  The reason Immutable.js doesn't contain memoization like this is that it makes referential vs value equality even more observable than it already is.

Not sure I follow. Are saying you'd like library consumers to just call `.equals()` without thinking too hard about whether referential equality is being used vs. a deep compare?

---

Whether or not adding memoization to ImmutableJS is a good idea, it's a very fair point that I can easily write my own generic `memoize` function.
 @leebyron - Makes perfect sense. Thanks again for your thoughtful and detailed reply. Please feel free to close.
  This pull request changes the value of the license property in `package.json` to a standard, machine-readable SPDX license identifier.

I'll be honest: This is a semi-automated pull request. I started by using [dat](http://dat-data.com/) and [dat-npm](https://www.npmjs.com/package/dat-npm) to review metadata for all packages on [npm](http://npmjs.com), looking for packages that don't use a valid [SPDX license identifier](https://spdx.org/licenses/) in `package.json`. I used my own npm module, [spdx-correct](https://github.com/kemitchell/spdx-correct.js) to guess what license you were after: [`"BSD-3-Clause"`](https://spdx.org/licenses/BSD-3-Clause). A quick manual check and a few shell scripts later, and this pull request was born.

npm doesn't require that you use a valid SPDX identifier, but it's strongly recommended. (Try `npm help 7 package.json` and search for â€œLicenseâ€.) Other source code package managers, like Maven for Java and RubyGems for Ruby, recommend the same. 

Why care about SPDX? A machine-readable standard makes it possible for programs, rather than just people, to review a module or even an entire codebase to make sure that licenses are compatible. Whatever the reasonâ€”strong personal conviction, company policy, terms of a business dealâ€”SPDX makes it easier to collaborate with others when licenses can be a problem, and helps take open-source software to more places. Given that [npm has a ton of modules](http://www.modulecounts.com/) but also handles dependencies in a novel way, I think a little license hygiene could help npm build amazing new relationships between communities that lawyers have long kept apart.

Though this PR was semi-automated, my responses to any questions you have won't be. I can't give legal advice via GitHub, but I'm happy to answer questions about SPDX or point you to good resources.

Thanks for your contribution to open-source software!

K
 @leebyron thanks for the package! I've used it quite a bit.
  Especially when using Browserify - if I'm pulling in this script and the build chain has (for various reasons) a minifier that MUST support oldIE (IE8 and lower) then the trailing commas produce errors.

I know that _technically_ this is valid (or rather, acceptable) in newer browsers... but is there any way to not do this for compatibility reasons (toolchain compatibility not the browsers specifically).

Right now this basically means it's impossible to use ImmutableJS in an IE<9 compatible toolchain.
 Sure! Specifically in the `KeyedIterable`, `IndexedIterable`, and `SetIterable` mixins. Also at the end of the Immutable var declaration (line ~4900, the `fromJS: fromJS,` property.

I think that's all of them, but can't be 100% sure.
 oh - found another - at the end of the `hashCode` function declaration.

A short cut to finding them is running through the Google Closure Compiler - it complains by default.

(note - I think that's all of them, if I remove those it works, but I don't know the TypeScript build chain and I suspect it is a problem with that output rather than something you want to manually edit. Else I'd fork it...)
 Yeah, it's mostly a problem for browserify builds tbh (that's how I ran into it) as those pull in the NPM module.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 I believe this is fixed in #510 and 3565850
  Is there a way to update a value that contains an array in it's structure?

I have this data structure: 

``` js
_messages = {
  '02a2ce90-1432-11e1-8558-0b488e4fc115': {
    channels: [
      { name: ''
      , scheduled_at: ''
      , scheduled_by: ''
      }
    ]
  },
}
```

I would really like to be able to do this: 

``` js
_messages = _messages.updateIn([uuid, 'channels', 0, 'scheduled_at'], newDatetime)
```

[Lodash's set](https://lodash.com/docs#set) does this. You can do:

``` js
_.set(messages[uuid], 'channels[0].scheduled_at', newDatetime)
```

or:

``` js
_.set(messages, [uuid, 'channels', 0, 'scheduled_at'], newDatetime)
```
 Aha, thank you. 
  Example:

``` javascript
var list = Immutable.List([1, 2, 3, 4, 5]);
var newList = list.slice(0, NaN) // newList._capacity = NaN and newList.size = NaN
list.toJS() // causes infinite loop
```

I'm not sure whether the issue lies with the newList object being incorrectly formatted or toJS() not being able to parse that kind of object. It is probably the former as I believe I've gotten an infinite loop calling some method on that kind of object other than toJS(). 
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Immutable currently will only zip iterables up to the shortest length of the set. So for something like this:

```
var a = Seq.of(1, 2, 3);
var b = Seq.of(4, 5;
var c = a.zip(b)
```

`c` will be `Seq [ [ 1, 4 ], [ 2, 5 ] ]`. Is this intended? This seems like the least useful case. Lodash for example will fill in, "missing" values with `undefined`.
 I believe this is intended, consider a pathological case where `a` in your example is a stream and you know that `b` is a finite sequence. The `Seq` returned should close over the finite sequence.

Other language examples include:

The documentation for Scala's `List.zip` says it will return: `a new list containing pairs consisting of corresponding elements of this list and that. The length of the returned collection is the minimum of the lengths of this list and that.`

In both Scala and Haskell this is true:

``` scala
scala> val a = List(1,2,3)
a: List[Int] = List(1, 2, 3)

scala> val b = List(1,2)
b: List[Int] = List(1, 2)

scala> a zip b
res0: List[(Int, Int)] = List((1,1), (2,2))
```

``` haskell
Prelude> let a = [1,2,3]
Prelude> let b = [1,2]
Prelude> zip a b
[(1,1),(2,2)]
```
 Fair enough. Wasn't thinking about the case of infinite sequences. Might be nice to have a function like Scala's `zipAll` which takes up to the longest list, filling in with a default as it goes. Not sure how well that would play with the existing interface in Immutable. 

Another option would be to pass in a length parameter and take up to that length, filling in with a default. This would avoid the infinite sequence issue.
 @leebyron Ah interesting, did not know that!
 @leebyron @dkingman I gave it a swing over in https://github.com/facebook/immutable-js/pull/460, would love feedback!
 Great work @mduvall! Thanks for taking this on. Scala and [Python](https://docs.python.org/2/library/itertools.html#itertools.izip_longest) both provide the option to fill with a default value. I know doing it that way would involve diving into the iterator so I'm not sure if it's worth it. Ruby and others don't allow specified defaults and just fill with nil/null/etc. I can see how allowing a specified default would be useful though. What do you all think?
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  The current mergeDeepWith passes the two values and the key that they share - would it make more sense to provide the entire keyPath? With just the key, it's pretty difficult to understand where the object exists within the structure.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 :+1: 
 :+1: 
  Let us say that I have two objects:

``` javascript
var js1 = {
    name: 'John',
    age: 30
};

var js2 = {
    name: 'John'
};

var map1 = Immutable.fromJS(js1);
var map2 = map1.mergeDeep(js2);

console.log(map1.toString()); // Map { "name": "John", "age": 30 }
console.log(map2.toString()); // Map { "name": "John", "age": 30 }
console.log(map1 === map2); // true
```

Is there any way to _remove_ fields that does not exist on the returned map? E.g:

``` javascript
console.log(map1.toString()); // Map { "name": "John", "age": 30 }
console.log(map2.toString()); // Map { "name": "John" }
console.log(map1 === map2); // false
```

**EDIT**

Arrays exhibits the same behavior, and is quite unexpected to me (or simply that I do not understand Immutable data properly :smile:):

``` javascript
var js1 = {
    name: 'John',
    age: [1, 2]
};

var js2 = {
    name: 'John',
    age: [1]
};

var map1 = Immutable.fromJS(js1);
var map2 = map1.mergeDeep(js2);

console.log(map1.toString()); // Map { \"name\": \"John\", \"age\": List [ 1, 2 ] }
console.log(map2.toString()); // Map { \"name\": \"John\", \"age\": List [ 1, 2 ] }
console.log(map1 === map2); // true
```

Shouldn't the new map be: `Map { \"name\": \"John\", \"age\": List [ 1 ] }` here?
  Is there any solution to convert non-plain object in to Immutable?

``` js
class B {
    constructor() {
        this.c = "d";
    }
}

var a = { b: new B };

Immutable.fromJS(a);
```
  We can't create immutable object with Immutable.fromJS if source object has been created in different context (e.g. we want to create immutable object in chrome extension's popup, but source for immutable object is received from background page).

We have plain JS object in the background page:

```
var data = {
    item1: {
        name: 'Name 1'
    },

    item2: {
        name: 'Name 2'
    }
};
```

In the popup.js script we want to get this object and create immutable version of it:

```
chrome.runtime.getBackgroundPage(function(page) {
    var data = page.data;
    var immutableData = Immutable.fromJS(data);
});
```

but we can't because 'data' has been created in different context (in the background page). 

```
immutableData === data; //true
```

If we serialize and deserialize data we can have immutable version:

```
var dataAfterSerialization = JSON.parse(JSON.stringify(data));
var newImmutableData = Immutable.fromJS(dataAfterSerialization);

newImmutableData.toString() === 'Map { "item1": Map { "name": "Name 1" }, "item2": Map { "name": "Name 2" } }'; //true
```

Full example is here - https://github.com/Elergy/Immutable-extension-test
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 @leebyron what about using `Object.prototype.toString` instead of `=== Object`?

``` javascript
function isPlainObj(value) {
  return value && (Object.prototype.toString.call(value) === '[object Object]' || value.constructor === undefined);
}
```

If this test is robust enough and don't hurt performance it could be a nice fit.

By the way, I encountered the same issue using a JS SDK that was returning a plain JS Object created from another frame.
  As for me it would be convenient  to pass not only array in 'getIn, updateIn, setIn' methods.
https://monosnap.com/image/3fIhtzRKIFP3um0vCF0eSmrzqBPc05
 Ok, thanks for answer :)
 Actually in 4.0 could calling a deep method without a valid key be changed to throw?
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Does immutablejs have method isImmutable? If no how to check if data is immutable?
Thanks
 Thanks) 
 Well, I tested on Node this comparison:

``` javascript
var Immutable = require('Immutable');
var myMap = new Immutable.Map({});

console.log( myMap instanceof Immutable.Map ); // true
```
 Yeah, that's true. But there aren't that many kinds of collections :) But yeah, a 'isImmutable' method would be just fine :)
 Just ran into this issue would put a +1 as there are so many uses where you'd want to check this.
 I do not recommend to use `instanceof` because when you (or another library you use) require different copies of Immutable.js (by not having a shared node_module directory) it returns `false`.

module-a.js

``` js
var Immutable = require('immutable');
module.exports = Immutable.Map({foo: "bar});
```

module-b.js

``` js
var Immutable = require('immutable');
var moduleA = require('moduleA');
moduleA instanceof Immutable.Map // will return false
```

@leebyron Should this behavior be documented? (related to #421)
 Are there propTypes for immutable.js?  Every example I see online uses `React.PropTypes.instanceOf(Immutable.Iterable)`, but I just read above that it's not recommended to use instanceOf.
 @fingermark There is [react-immutable-types](https://github.com/HurricaneJames/react-immutable-proptypes#react-immutable-proptypes) which does not [suffer from the instanceof problem](https://github.com/HurricaneJames/react-immutable-proptypes/blob/master/src/ImmutablePropTypes.js#L22).
  hasIn(searchKeyPath) {
    return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
},
  Main idea:
We have pagination therefore I need "slice" on items. From beginning items is OrderedMap where key is id of item, and value is object or undefined(data of item). Data is loaded later on demand.
It is worked as expected when I use toArray on "slice" result. But I want to pass OrderedMap into itemView function, to have key and value(which can be undefined). And there is a bug...
It draws additional "span" elements , but (according to log) itemView method is called only for my "li" items  in OrderedMap - therefore I can't to filter those unexpected elements.
Can anybody sugest or explain what is going on? I hope it is possible to use OrderedMap directly instead of toArray.
Thanks for help!

This is what I receive - extra "span" items, but there should be only "li" items...

``` html
<ul id="se-pl-projects" data-reactid=".0.2.0.2.0.2">
    <span data-reactid=".0.2.0.2.0.2.$size:0"></span>
    <span data-reactid=".0.2.0.2.0.2.$_map:0:$size:0"></span>
    <span data-reactid=".0.2.0.2.0.2.$_map:0:$_root:0:$entries:0:0:0"></span>
...
    <span data-reactid=".0.2.0.2.0.2.$_map:0:$_root:0:$entries:0:3:1"></span>
    <span data-reactid=".0.2.0.2.0.2.$_list:0:$size:0"></span>
    <span data-reactid=".0.2.0.2.0.2.$_list:0:$_origin:0"></span>
    <span data-reactid=".0.2.0.2.0.2.$_list:0:$_capacity:0"></span>
    <span data-reactid=".0.2.0.2.0.2.$_list:0:$_level:0"></span>
    <span data-reactid=".0.2.0.2.0.2.$_list:0:$_tail:0:$array:0:0:0"></span>
    <li data-reactid=".0.2.0.2.0.2.$_list:0:$_tail:0:$array:0:0:1"></li>
    <span data-reactid=".0.2.0.2.0.2.$_list:0:$_tail:0:$array:0:1:0"></span>
    <li data-reactid=".0.2.0.2.0.2.$_list:0:$_tail:0:$array:0:1:1"></li>
    <span data-reactid=".0.2.0.2.0.2.$_list:0:$_tail:0:$array:0:2:0"></span>
    <li data-reactid=".0.2.0.2.0.2.$_list:0:$_tail:0:$array:0:2:1"></li>
    <span data-reactid=".0.2.0.2.0.2.$_list:0:$_tail:0:$array:0:3:0"></span>
    <li data-reactid=".0.2.0.2.0.2.$_list:0:$_tail:0:$array:0:3:1"></li>
</ul>
```

This is not production code :). Just to show main idea.
On project we are using Flux architecture.

``` javascript
var _items = Immutable.OrderedMap();
var getState = function () {
    _items = Immutable.OrderedMap().withMutations(map=> [5, 1, 4, 6].forEach(id=>map.set(id, _items.get(id))))

    return {
            pageItems: _items.slice(1, 3)
    };
};

React.createClass({
    getInitialState() {
        return getState();
    },
    render(){
        var itemView = function (value, key) {
            logger.info(' Mapping item ', value, key);
            return (
                <li onClick={this._openProject.bind(this, key)}>
                    <MyItemView id={key} info={value} key={key}/>
                </li>
            )
        };
        var view =
            <div>
                <ul id="se-pl-projects">
                {this.state.pageItems.map(itemView, this)}
                </ul>
            </div>;

        return (view);
    }
});
```
 Thank you,
Updating from 0.12 to 0.13 helped!
  Hi, i have deep structure such as 
{
   ...
   items: [{
       ...
    },{
       ...
       items: [...]
    }]
}

And I want to splice item into 'items' array at any level of hierarchy. Is there any solution to do that?
Thanks
 Thanks Lee)
  Just simple example of using `fromJS`:

```
var data = Immutable.fromJS({ data: { n: 13 } });

data.toString(); // "Map { "data": Map { "n": 13 } }"
```

But, if I use converter (no matter how), I'm getting another result:

```
var data = Immutable.fromJS({ data: { n: 13 } }, (k, v) => v);

data.toString(); // "Seq { "data": Seq { "n": 13 } }"
```

It's break my code and I need to write additional conversion `toMap`.

If you agree with importance of this PR I can add unit tests for this case.

Thanks,
Alexey Raspopov
 My case is OrderedMap of Records.

``` javascript
var data = {
  todos: {
    'bc72a': { id: 'bc72a', text: 'rule the world' },
    'f45g9': { id: 'f45g9', text: 'do something' }
  }
}
```

``` javascript
var Todo = Immutable.Record({ id: '', text: '', completed: false });

var immData = Immutable.fromJS(data, function(k, v){
  // that's why I opened this PR: I'll get Seq instead of Map
  if(k === ''){
    return v.toMap();
  }

  if(k === 'todos'){
    return v.toOrderedMap().map(function(t){
      return Todo(t.toObject());
    });
  }

  return v;
});
```
 Just to clarify my point

> This is actually counter to the purpose of the converter function. If you omit it, a default converter is used which converts Arrays to Lists and Objects to Maps, however the converter function is there to allow for overriding this behavior.

I agree with this behavior, but in case of complex structures, if I want to change only one or two of children I expect the default behavior for other structures (especially for root).
 Any updates? @leebyron 
 @leebyron I just want you to remember that this PR was created 3 month ago :) Can we decide what to do next?
 I haven't been using Immutable for all this time, but still feel guilty because of not finishing this. @leebyron feel free to close this to have less noise in PR list.
  I made a guess as to where this test should go, I'm not confident I got it right.

Without this change, I'm seeing an exception on a (re)generator-fed Seq if I skip(1), as it does not create the parent iterator.
  I haven't been able to construct a simple example, since I don't really understand in what cases __iteratorUncached is used, and how React iterates over lists of elements. However, it seems clear to me that if `sliceSize = 0`, iterator will be zero, and the line which calls `iterator.next()` will cause an exception to be thrown whenever skipped is not zero.

```
sliceSeq.__iteratorUncached = function(type, reverse) {
  if (sliceSize && reverse) {
    return this.cacheResult().__iterator(type, reverse);
  }
  // Don't bother instantiating parent iterator if taking 0.
  var iterator = sliceSize && iterable.__iterator(type, reverse);
  var skipped = 0;
  var iterations = 0;
  return new src_Iterator__Iterator(function()  {
    while (skipped++ < resolvedBegin) {
      iterator.next();
    }
    if (++iterations > sliceSize) {
      return iteratorDone();
    }
    var step = iterator.next();
    if (useKeys || type === ITERATE_VALUES) {
      return step;
    } else if (type === ITERATE_KEYS) {
      return iteratorValue(type, iterations - 1, undefined, step);
    } else {
      return iteratorValue(type, iterations - 1, step.value[1], step);
    }
  });
}
```

(From immutable.js line 1344.)
  I'm using a `Map` to point number ID properties to config objects, and I'm creating the `Map` from an object with the same structure, like so:

``` javascript
const options = Map({
    13000: { /* ... */ },
    13004: { /* ... */ }
});
```

Later on I'm checking for the existence of IDs in the `Map` by calling, for example, `options.has(13000)`, which returns `false` because the keys are being coerced to strings upon creation.

As a faster example, simply trying `Immutable.Map({ 1: true }).has(1)` will return `false` as well.

My question is simply whether this is the intended behavior, and if so can it be documented more clearly?

Thanks!
 Objects coerce to string keys. So these objects you are using actually have string keys not number keys. Hence why you can't get the values our when you use `has` or `get`.
 Stated another way, immutable-js does support non-string keys, but in this case, the misunderstanding about JavaScript object keys is leading you astray.

```
Map().set(1, "s").has(1); //true
```
  Okay, that makes sense - I can see that `Object.keys({ 1: true })` returns `["1"]`. Thanks for clarifying, I'll close this. Thanks!
 > the misunderstanding about JavaScript object keys is leading you astray

It's a misunderstanding of the internal implementation of object keys though, not the interface.  This works just fine:

```
var map = {1: true};
map[1]; // true
```
  Hello. 
Lately in a project we stumbled upon the following issue: what is the best practice for extracting data out of an immutable object to be rendered in a React.js component.
In the following TodoMVC the creator uses the toJS() method, which feels kind of unnatural : https://github.com/hoppula/react-immutable-todomvc

In another example, however, a get() method is used directly on the immutable object: https://github.com/facebook/immutable-js/wiki/Immutable-as-React-state

What way would you suggest? 
Thanks in advance.
 There has been a discussion about this on https://reactiflux.slack.com/messages/immutablejs/ on the 6th of April. I'm not sure how to link to the discussing directly.

From the discussion, it's not clean cut about what's the best way either, but it using Immutable objects all the way down has advantages.
Maybe it would be good to list both advantages and disadvantages of both approaches?
 We use immutable objects all the way down and it is working great. `.get()` is used every time we want to render a value, like in the given example.

Note: `toJS()` is no longer necessary since Rect 0.13 (see https://github.com/facebook/react/pull/2376)
  If I set an `Object` to a key in a map, I can manipulate that object freely. Should this be allowed?

``` node
> var i = require('immutable')
undefined
> var a = i.Map()
undefined
> a = a.set('key', {foo: 1, bar: 2})
Map { "key": [object Object] }
> a.get('key')
{ foo: 1, bar: 2 }
> a.get('key').bar = 3
3
```
 @leebyron oh ok, so for now some operations can produce false positive or false negative (like `===` or `.set`) when mutable object is involved?
  `list.get(index)` syntax works fine some of the time but it adds up a learning curve + migration cost when you wish swap out arrays in the existing code with lists. I think it would be very nice to put the Proxy like following at the bottom of the prototype chain to allow optional access by index:

``` js
let accesor = new Proxy(Object.prototype, {
  get(target, property, receiver) {
    return receiver.get(property)
  }
});

// Workaround to monkey patch loaded immutable.js library, although it should be:
// Iterable.prototype = Object.create(accessor, {....})
Object.setPrototypeOf(Immutable.Iterable.prototype, accesor)

Immutable.List.of(1, 2, 3)[0] // => 1
Immutable.List.of(1, 2, 3)[1] // => 2
Immutable.List.of(1, 2, 3)[5] // => undefined
Immutable.List.of(1, 2, 3)[-2] // => 2
```
 **P.S:** That code actually works in firefox (at least in nightly)
 > Very cool. I'll probably hold off on adding something like this into the library itself until the support is broader, as people are concerned about library byte weight, but this monkey patch is a pretty great way to start experimenting with this.

It's just 4 lines :)

> I imagine Record would want the same sort of support from Proxy.

Records already do have getters so I'm not sure proxies are necessary there. This hack also makes keyed access on maps work as well (only for string keys though):

``` js
Immutable.Map({x: 20, "hello-world": "!!"})["hello-world"] // => "!!"
Immutable.Map({x: 20, "hello-world": "!!"}).x // => 20
```

> I'm curious - what kind of performance constraints does Proxy have in the FF nightly? Does this code perform with some overhead compared to using .get() directly?

Yeah proxies do come with an overhead but I have not performed performance measurements to compare raw `.get` vs proxied access vs getter access. I doubt it will be a bottleneck in non hot code paths though. Either way `.get` is still there so users could use `.get` when that impacts performance enough to matter. 
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 +1
 Want this!
 Browser support for `Proxy` is now pretty good, only Safari is missing (But the Technical Preview already has it): http://caniuse.com/#search=proxy
 @coreh is right, would love to see this in the lib and use it in all side projects to get familiar with immutable.js, till Proxy (and so immutable) is ready for production projects.
 +1 (How about using the Proxy polyfill in case it's not supported?)
 @ahmedghoneim92 seems that Proxy can't be polyfilled. The one and only way to do that is to transpile all or your property access calls into function calls (see https://www.npmjs.com/package/babel-plugin-proxy)
 @Strate actually it already has been :)
https://github.com/GoogleChrome/proxy-polyfill
The only caveat is it seals the Object it proxies (which won't be much of an issue in our case).
 Someone is building this idea in a different module: 

https://github.com/Legitcode/immutable-proxy

Seems a good place to contribute & check how proxies behave. 
 I'm not sure if the issue's example could be used anywhere?
For instance, if I set that in a separate module and import it in the beginning of my (React) application, there will be a `Maximum call stack size exceeded` error from something trying to access the `size` attribute.
From my (quite light) knowledge on deep and modern JS, I could not find a way to return a property from inside that getter without creating a recursivity with itself.

``` js
const accessor = new Proxy(Object.prototype, {
  get(target, name, receiver) {
    if (name in receiver || name == 'size') {
      //will call this proxied get() again, and generate a call stack overflow
      return receiver[name]
    } else {
      return receiver.get(name)
    }
  }
})
```

The referred module in the last comment has a serious flaw: as it's not overloading own Immutable objects but creating new ones on top of them; thus, it would need to override all mutation and iteration methods to return the proxied versions, like `push()`, `filter()`, and so on :(

It seems the only way to get this type of feature into Immutable is, indeed, by having it implemented in the source.
 @igorsantos07 In the `get` function, you should use `Reflect.get(obj, key)` instead of `obj[key]`.  `Reflect` will not call the `get` recursively.

See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect 
 I have been working on https://github.com/mschipperheyn/normalizr-immutable using proxies. One of the challenges is deep merging. It may be undesirable to try to merge proxies and in the case of normalizr-immutable, it leads to lots of issues. 

I had to add a proxy marker to be able to identify this so I could use this merger function

```
export function proxyMerger(a, b) {
  if (a && a.mergeWith && !a._isProxy) {
    return a.mergeWith(merger, b)
  }
  return b
}
```
 +1

I think this one simple change will get Immutable.js so much more adoption  Hi, 

I have been using Cursor and I am really enjoying it. Thanks for putting it as _contrib_. 

I never had problems using Cursors on `Map` or `List`. However, using them on `Set` does not seem to work. `Cursor.from` returns a `KeyedCursor`. Not sure if it should return a `KeyedCursor` or a `IndexedCursor`, however it should implement the `Set` interface. 

Thanks
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  In the spirit of shaving a few bytes [lodash](https://lodash.com/) has per-method exports, i.e. one can:

```
  var _map  = require('lodash/collection/map');
```

instead of:

```
  var _  = require('lodash');
```

Would it be possible to achieve the same with Immutable, i.e.

```
  var ImmutableList = require('immutable/src/List');
```

instead of: 

```
  var Immutable = require('immutable');
```

Would it provide some benefits or is everything too interlinked?
I realize the `src/` dir is mostly ES6 code, but I use babel/webpack which lets you import ES6 code (though Babel 5.0 does complain about the lack of `super()` calls when I tested earlier).
 +1
 @leebyron Thanks Lee, I suspected as much. Do you prefer I close this issue, or leave it for 5.0?
 > could save about 1.5KB from the 15KB total

Every little bit counts. I've been going through my webpack project, cleaning up my imports, and have shaved ~100kb off my minified builds. I think this would be worthwhile to consider.
  _Disclaimer: I am using JavaScript only, so I don't know the potential specifics of TypeScript for this topic_

Scala defines `Tuple` structures, from [`Tuple1`](http://www.scala-lang.org/api/current/index.html#scala.Tuple1) to... [`Tuple22`](http://www.scala-lang.org/api/current/index.html#scala.Tuple22)!

Along the way, [`Tuple2`](http://www.scala-lang.org/api/current/#scala.Tuple2) and [`Tuple3`](http://www.scala-lang.org/api/current/#scala.Tuple3) are pretty nice, they come with extra methods (like `swap` for `Tuple2`. These two are so common that they respectively are aliased to [`Pair`](https://github.com/scala/scala/blob/2.10.x/src/library/scala/Predef.scala#L256) and [`Triple`](https://github.com/scala/scala/blob/2.10.x/src/library/scala/Predef.scala#L262) (were actually, since they got deprecated in favor of a syntax we unfortunately cannot use here).

Right now, if I want to make a pair, I can either use an `Array` (and therefore be mutable) or a `List` (and therefore abuse the types):

``` js
var a = ['foo', 42];
var l = List.of('foo', 42);
```

Isn't the second one a violation of the types?

I think it'd be nicer to have specific data structures like:

``` js
var p = new Pair('foo', 42);
var t = new Tuple2('foo', 42);
```

Among other things, a nice consequence of this, for those who are using JavaScript and [JSDoc](http://usejsdoc.org/) is that the former version has to be documented with `{List.<*>}`, while the latter one can be documented with `{Pair.<string, number>}`, which is much more precise and useful documentation!

Am I completely missing the point here?
 Both TypeScript and Flow have support for tuple types, which are based on array values, but the type checker verifies the number and type of elements.

Overall, I agree that tuple structures are handy. Materialized (`new Tuple(a, b)`) and functional (`type Tuple<A,B,C> = (a: A, b: B) => C`) representations are useful. The later is already useful in `zipWith`.

What kind of code are you writing that you want a tuple structure?
 > Both TypeScript and Flow have support for tuple types, which are based on array values, but the type checker verifies the number and type of elements.

Well, I didn't know that, and it makes sense. Points to them then. I see why it's not implemented in this library because of that, but any chance to consider it for those using the library in plain JavaScript?

> Materialized (`new Tuple(a, b)`) and functional (`type Tuple<A,B,C> = (a: A, b: B) => C`) representations are useful.

I was merely talking about the former one. Can the latter one still be considered a tuple, if it's essentially a function?

> What kind of code are you writing that you want a tuple structure?

I opened this issue after faking a tuple structure [here](https://github.com/w3c/echidna/blob/a8936b7c044dbc7acc592c0a01f554ab2da177de/lib/orchestrator.js#L86) and [there](https://github.com/w3c/echidna/blob/a8936b7c044dbc7acc592c0a01f554ab2da177de/lib/orchestrator.js#L326), but this code is going to evolve soon to actually use a `List` for what it's purposed.

However, I am using an `Array`-based tuple [here](https://github.com/w3c/echidna/blob/f63e8c384defb95d4ec3446d07b1040bb253ebc7/lib/document-downloader.js#L43). I'd happily switch to a nicer `Pair`/`Tuple2` structure. And oftentimes I feel like using such thing, increasingly since starting to use `Promise` objects.
 Sure, the functional variant is a kind of "final encoding," where if you know how you will use the tuple, you can structure your code a bit differently. Say I know I am going to use the second half of a tuple and ignore the first, I can pass `(a, b) => b` as my "tuple."

Of course, you could also name the fields of your tuple and use an object/record with two properties.
 I'm also after a `Tuple`, but a special instance of one, one that represents an "entry" in a `*Map`. Let's call this type a `MapTuple` for the sake of what follows.

A `MapTuple` would be a tuple (two values), `(K,V)`. In addition to the regular `Tuple` interface, a `MapTuple` would also expose the interface `.key()` and `.value()` that allows you to extract the key (type `K`) and value (type `V`)

In this way you could (as I need to do) convert a `*Map` into a `List/Seq` of `MapTuple` entries.

For now we are working around this by converting to a `List/Seq` of `Seq` which has two entries, `0/1` indexed. But having a `.key()` and `.value()` interface would be more explicit.

I note it's not currently possible/desirable to extend Immutable types https://github.com/facebook/immutable-js/pull/368
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 i'm also abusing `List`s for this functionality
  Had to fix a test for Map on my system, but Travis thinks otherwise it seems.
 I have a Record, and would like the ability to express a default value that is not static, but the result of an expression evaluated when default values are computed (during the record initialization).

Typical example: default value with a string representing the current time:

``` javascript
class MyRecord extends Immutable.Record({
    reference: null,
    status: Status.AWESOME,
    availableSince: function() { return moment().toISOString(); }
});
```

Of course, when a MyRecord instance is reified, if a value is given for 'availableSince', the expression should not be evaluated; also, the value may be overridden a later time (later than the initialization) on the same record.

Is there another, already implemented way to do this I'm not aware of ?
 Well OK, I guess this might work yes.

Thanks. I still think that it might be a nice featurette, mainly for the greater expressiveness it conveys.
  It was probably just a typo.
  Hi, In my application I use d3.js for some visualizations... 
Now D3 works with **mutable** native js data structures. 
Some data marshaling would be necessary for this to work with immutableJs. 

I also use Reflux with React, so in my Store I manage an Immutable Map. Since this Map becomes a new thing on every change I cannot just pass it to D3 Force Layout because it works with mutable data so each time it recalculates everything from scratch. 

I end up with managing both Immutable and mutable data structures but this feels very wrong. 

I found this article: [Practical Time Series Visualization using D3 + OM](http://blog.getliquidlandscape.com/2015/01/08/practical-time-series-visualization-using-d3-om/) 
which seems to touch on the subject, and suggest to use _Cursors_. Thing is it uses Clojure(Script) when Im using just JavaScript.

I understand its very Abstract without code examples but any suggestion on the subject of working/syncing both immutables and mutables will be appreciated  !
 :+1: 
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
   Thats odd, that test passes for me.
 All good points. However the fact that it's come up several times should add a little weight to perhaps looking at it again. But I get it. 

I don't expect a change in this policy but in my defense I was aware of all of these issues for the most-part. Complex keys into lists (as opposed to js arrays) was a new one on me. The array of strings interface is a klunky interface to work with which is why the issue is being brought up. The string notation in that sense is a nice-to-have not a be all end all for every use case. It's intended as an option. For complex keys you can always fall back to the array notation. As for debugging you have access to the parsed keyPath. "Passing a string where a keyPath is expected is actually a pretty easy mistake to make" yes I ran into this frequently and it seems it should not be a mistake, an array of a single string vs just a single string, interface wise it makes sense to me but then again i liked jQuery's interface some people think its an crime to have polymorphic interfaces, I think its nice. In my mind why even bother with get vs getIn just have one function that does both. But thats a matter of taste. 

I'll use a helper and be done with it then. 
 Any reasons for not using json pointer syntax? It already defines how to escape the seperator char
 I was just curious if there will be the support for getting into `{a:{"b.c": 1}}`? I was thinking about JSON Pointer, which uses `a/b/c` and in this case, would encode the analogous path into `a/b~1c/`. 

For example: even with this string support, I'll continue translating to arrays using a custom function, given a string and underlying schema - because you would have getIn accepting strings but updateIn would have have to assume too much in order to solve ambiguity. Even getIn can be ambiguious and probably not deterministic, if you have both number and strings in a Map for instance.

Just an idea: Is it possible to add new methods to Immutable objects prototype? IsnÂ´t this kind of stuff better as optional plugins, defining new methods? Perhaps immutable-js would benefit a lot from having ways of having contrib libs, adding new helper functionality.
 Hello.

I am using Immutable.js and also found lack of this feature. @leebyron points are fair enough but there are a lot of projects which don't have `.` in key names and also use numbers only as array indexes. So, that corner case is not an issue for them and they deserve to have prettier API.

Helper function can be solution, but not enough because then you have to import this function into every file in your project, rather than just accessing values with built-in method.

As for me, adding extra methods like `getPath`/`setPath`/`updatePath` seems a good solution. It doesn't change anything in existing features, but gives a better experience for popular use cases.

I considered to create an external wrapper around Immutable, but then figured out, that it is not possible because Immutable itself know and uses only built in data-structures, and I can't create extended version of them. So it is possible only with changes in core.
  This does something weird:
`Map().set("__proto__", null).toJS()`
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  I just forked the project, ran npm install and grunt build, then grunt test and all but two tests failed. When I look at the tests folder those two tests are in .js, the rest are in .ts. I think this commit has something to do with it https://github.com/facebook/immutable-js/commit/952cfc4bd152fd029f9367b59afdcdf6bd798ec6
 I can confirm all tests passing when using the prior [tag 3.6.4](https://github.com/facebook/immutable-js/tree/3.6.4)
 Sorry thats, all but two tests failed.
MultiRequire.js and RecordJS.js were the only ones that worked.
 I'm running node v0.10.35 if it matters
 hmm it pulled in "version": "1.5.0-alpha",
 works great thanks!
  If a user runs:

```
store().withMutations(store => {
  // multiple mutations
});
```

And you have an onChange listener in your cursor, it just returns an empty array:

``` js
    Cursor.from(data, function (newData, oldData, keyPath) {
        state = cursor(newData);
        debugger; // keyPath === []
        action(state, keyPath);
      });
```
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Wondering thoughts on this. I know we have await coming in es7, it seems to me to read better:

``` js
store.await(store => {
 store.push([1]).push([2]);
});
```
 On other hand could be _more_ confusing, not sure.
  Hi!

Firstly, @leebyron , thank you for creating this awesome library. 

I am a total noob here, so bare with me. 

I have the following collection:

``` javascript
var array = [ {id: 1, approved: false}, {id: 2, approved: true}, {id: 3, approved: false}..];
var my_list = Immutable.fromJS(array);
```

So this should create the following structure (List (Map), (Map), (Map)..)

Now let's say I have another array with list of ids: 

``` javascript
var ids = [1, 2, 3...]
```

Now I want to get a new version of my_list where approved value is changed(to true or false) only for Map's with ids in ids array. This is how I am doing it now, but I am wondering if there is a better way to do this.

``` javascript
var new_list = my_list.map(function(obj) {
  if (_.includes(ids, obj.get('id'))) {
    return obj.set('approved', approved_bool);
  } else {
   return obj;
}});
```
 From one noob to another: looks good to me. :)

Depending on `my_list.size`, you could consider using batch mutations<sup>1</sup>. You'd loop `ids` instead of mapping `my_list`.

<sup>1</sup> http://facebook.github.io/immutable-js/#batching-mutations
 I don't think that using `fromJS` is as good as constructing your own data structure for this.

``` javascript
var array = [ {id: 1, approved: false}, {id: 2, approved: true}, {id: 3, approved: false}..];

// A record to represent your objects
var MyRecord = Record({id: null, approved: false});

// ideally you can avoid this function altogether and instead create the better representation in the first place
function convertArray(arr) {
  return Map().withMutations(map => {
    arr.forEach(item => map.set(item.id, new MyRecord(item)));
  });
}

// If you can't have the appropriate data structure created in the first place, then convert what you have
var map = convertArray(array);

var approved_bool = true; // the following code should be abstracted out

// Use withMutations to avoid the many intermediate maps that this process may create
map = map.withMutations(map => {
  ids.forEach(id => {
    if (map.has(id)) { // this is more efficient that looping over a list
      map.update(id, record => record.set('approved', approved_bool));
    } else {
      // depending on how you want this to function, you could throw an exception here
      // (as an id that isn't recognized has been provided), or alternatively you can add a new record
      map.set(id, new MyRecord({id: id, approved: approved_bool});
    }
  });
});
```
  I find name `Immutable.List` to be confusing. I was able to find this announcement that kind of explains reasoning behind the rename https://github.com/facebook/immutable-js/wiki/Upgrading-to-Immutable-v3#list-from-vector

Lists are usually name used for Linked Lists that Immutable.List are not really related to, there for I question if such a name is actually an appropriate. I could argue that `Immutable.Array` maybe even a better choice here since as both API and characteristics seem to match Array more than List.
 I think List is fine, both C# and Java call their data structure a list.
 > I think List is fine, both C# and Java call their data structure a list.

To be fare only thing that List here has in common with List from those languages is a name :smiley: 

My main concern is that immutable data structures that this library implements originate from functional languages where name `List` refers to a very specific data structure with a very different characteristics.
  Hi! First of all Awesome library!
Is it possible to convert a nested Map of Records (or Maps) to Array of Objects? 
Currently if I do `someMap.toArray()` the outcome is `[Record, Record]`, id like it to be: `[{},{}]`.
Thanks!
 Yea I've tried toJS(). Thing is the output is not exactly what I need. I'll explain.

I'm using a data structure which is a Map of Records so I can get and set to it by the key which is an ID in my case, example:

``` javascript
var _nodes = Immutable.Map();

var nodesRecord = Immutable.Record({
  id : null,
  text : 'some text'
});

function add(node) {
 _nodes = _nodes.set(node.id, new nodesRecord({id : node.id, text: node.text }));
}

function update(id, updates) {
_nodes = _nodes.set(id, _nodes.get(id).merge(updates));
}

function delete(id) {
_nodes = _nodes.delete(id);
}
```

Now I need to convert this to an Array of Objects (Not Object of Objects) for some external decoupled d3 module, so the way I figured to do this is:

``` javascript
var _nodesJS = _nodes.toArray().map(function(item) {
       return item.toObject();
});
```

Is this a correct approach when using immutable.js ?
  I used something like this, using `size` as a field.

``` js
var Grid = Record({size: 10});
var grid = new Grid().set("size", 4);
```

But I think since https://github.com/facebook/immutable-js/commit/347d2efb this broke.

Executing the code results in this error:

```
Error: Cannot set on an immutable record.
    at invariant (/home/arian/www/test/node_modules/immutable/dist/immutable.js:932:27)
    at Record.Object.defineProperty.set (/home/arian/www/test/node_modules/immutable/dist/immutable.js:3892:9)
    at new Record (/home/arian/www/test/node_modules/immutable/dist/immutable.js:3758:36)
    at Object.<anonymous> (/home/arian/www/test/test.js:10:12)
```

I made a new issue, but just close it if it's already covered by #377 or #362.
 Can confirm this was a change between v3.6.4 and v3.7.0. If it was intentional it definitely should be in the release description as it is a breaking change. Also, it happens when just creating the record, no need to call `.set`. The following code throws this error:

``` js
var R = Record({ size: 1 })
new R();
```

@leebyron is this a supported use case or should we change the code to use something other than `size`?
 I still get this on `3.7.6` & `3.8.1`. What happened?
 Still an issue: 

```
var Foo = new Immutable.Record({id:'', size:0})
var Bar = new Foo({id:'wut'}) // <-- Error: Cannot set on an immutable record.
```
 Still trouble with `size`
 @vojtatranta: per @leebyron, `size` is never going to be supported in Records and using it will raise an exception in v4
 It's because Record supports getting by dot notation..
  Maps created from Immutable.fromJS() and Immutable.Map are inconsistent with their mergeDeep behavior. The Immutable.fromJS one seems to be the correct of the two.

```
var a1 = Immutable.fromJS({ a: 1, b: 2, c: { c1: 3, c2: 4 } })
var b1 = Immutable.fromJS({ a: 10, b: 20, c: { c3: 30 } })
a1.toJS().c // Object {c1: 3, c2: 4}
b1.toJS().c // Object {c3: 30}
a1.mergeDeep(b1).toJS().c // Object {c1: 3, c2: 4, c3: 30}

var a2 = Immutable.Map({ a: 1, b: 2, c: { c1: 3, c2: 4 } })
var b2 = Immutable.Map({ a: 10, b: 20, c: { c3: 30 } })
a2.toJS().c // Object {c1: 3, c2: 4}
b2.toJS().c // Object {c3: 30}
a2.mergeDeep(b2).toJS().c // Object {c3: 30}
```
 Thanks for the clear and detailed explanation!

The (simplistic) map I used coupled with `toJS()` is what made it tricky to see the issue. Had I used *.get('c') instead of *.toJS().c, it would have been easy to spot the difference in behavior.

Thanks again!
 I don't think this is in the documentation, and definitely think it should be. I have been struggling with this for a good twenty minutes trying to figure out why the following initialization would be overwritten.

```
const initialState = Map({
  user: {info: null, error: null, loading: false}
})
state.mergeDeep({user: {loading: true}}) // state = Map{user: {loading: true}}
```
 Whats the solution to get the intended result ?
  Hi there,
how can I detect whether the instance is immutable data structure created with Immutable.js?
 Right now I am checking that [`obj instanceof Collection`](https://github.com/astorije/chai-immutable/blob/8d720415290983d6df6ab9caaf55b8de26b5f9b5/chai-immutable.js#L31) for https://github.com/astorije/chai-immutable (see #378 for details about this project).

Probably not the best way to do it, but I didn't investigate much. I'll keep an eye on this thread and will add a Chai matcher to my plugin when a better answer comes in.
 But I need to avoid having any direct references to Immutable.js.
It's for external library.
 @leebyron hope so, thanks!
 Albeeert
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  This addresses issue #419.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Running this in node

```
Immutable.Set(['a', 'd']).withMutations(function(set) {
      set.add('b');
      set.union(['c']);
      set.intersect(['b', 'c', 'd']);
})
```

will fail with a `TypeError: Cannot read property '1' of undefined`. It seems that `intersect()` does not play well when `add()` or `union()` calls before it that share similar elements.
 I thought I'd check up on this - could I get feedback / acknowledgement that this has been seen?
 I see. Thanks!
 Suggestion, inside src_Set__Set.prototype.intersect, the values to be removed could be locally accumulated and then removed. For example:

```
src_Set__Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
    if (iters.length === 0) {
        return this;
    }
    iters = iters.map(function(iter ) {return SetIterable(iter)});
    var originalSet = this;
    return this.withMutations(function(set ) {
        var acc = [];
        originalSet.forEach(function(value ) {
            if (!iters.every(function(iter ) {return iter.includes(value)})) {
                acc.push(value)
            }
        });
        acc.forEach(function (value) {
            set.remove(value);
        })
    });
};
```
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  All links are pointing to http://facebook.github.io/ . For example fromJS() is tageting http://facebook.github.io/fromJS which doesn't exist resulting a redirection to code.facebook.com
 +1, same issue 
 Good for me thanks :)
 Thanks! 
 Having the same problem now. ðŸ˜® 
  Fixes issue #394. An iterator created from a sliceSeq would get into an infinite loop on the second call to next() because it would run the code that skips to the first item each time next() was called. Test added.
  Speed up the test suite by updating to the current version
of the TypeScript compiler which is ~5x faster than the 1.0
version that was being used previously and caching compiled
TypeScript files.
- Update type definitions and flatten.ts for compatibility
  with TS 1.4
- Remove ts-compiler dependency and use the now-public TypeScript
  compiler API directly.

Fixes #399

With these changes a full run of the test suite on my laptop goes from ~100s to ~20s on first run and ~10s for subsequent runs where the test files have not changed.

_There is currently a test failure in slice.ts which I'm looking into_
 > I guess TypeScript changed their rules around trailing comma removal in 1.4?

Looks to me like it was simply a bug that got fixed.

Thanks for the quick review!
 I'm having trouble getting started with contribution to the project. My first time trying to run tests failed. I tried with the tag prior to this change and all was fine. I just filed an issue for it https://github.com/facebook/immutable-js/issues/431
  This commit adds a `Set.intersection()` function for getting the intersection of an unknown number of sets. This isn't a problem with `union`, since the identity element for that is an empty set (which is easy to create):

``` javascript
Immutable.Set().union(...allTheThings);
```

However, with intersection, it's the universal set and Immutable doesn't have a representation of that.
 > If there is truly an unknown number of sets, would it be better to provide an array/list of Sets instead of using var-args?

Yeah, maybe that would be betterâ€¦I wasn't sure if it would be confusing to deviate from `Set#intersect()`'s signature.

> I'm curious when you would use this API over set1.intersection(set2)

Sorry for the bad explanation. The purpose of this API is to handle cases where you have an unknown number of sets _that's potentially zero._
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 I guess it's still relevant? Honestly, I haven't been using Immutable lately so I'm not sure!  Version on site is `3.3.0` while NPM version is `3.6.4`  which means the website is missing some APIs like `Immutable.Map#deleteIn`.

To reproduce:
Go to http://facebook.github.io/immutable-js
Open console and enter the following

```
m = Immutable.Map()
m.deleteIn
// undefined
```
  This is a fix for #407. Please note that this change is based on #411 so it will appear to contain somewhat unrelated changes actual changes related to only this feature are:
https://github.com/Gozala/immutable-js/compare/sub-records...Gozala:list-record
 For now I just did some manual testing as I'm having issues with running tests locally (see #412 for details) and I need to crash. Will submit actual test for this feature tomorrow.
 > Considering that Record.List's constructor returns a List. I'm not convinced this warrants being a new type of collection. Instead what it looks like you want to do is build a smarter kind of fromJS which is aware of a schema of Records, Lists (and Maps, Sets).

That is not entirely correct, `RecordType.List()` returns a subclass of the `List`, which is indeed a List but it's `.push()` `.pop()` etc have different behavior in that they do add instances of `RecordType`. This does enables you to define polymorphic operations over lists that don't need to be `RecordType` specific that this list consists of. In other words parsing JS at the construction is a part of it indeed, but there is more to this than just that.

I do agree though that other types (but Maps) should probably have it as well.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  All `*.ts` tests fail on node 0.12.0 (at least on my machine) with a pretty similar stack traces:

``` sh
> immutable@3.6.4 test /Users/gozala/Projects/immutable-js
> ./resources/node_test.sh

Using Jest CLI v0.4.0
 FAIL  __tests__/ArraySeq.ts
TypeError: /Users/gozala/Projects/immutable-js/resources/jestPreprocessor.js: undefined is not a function
  at BitMatrixImpl.release (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:815:32)
  at PullInstantiatedTypeReferenceSymbol.PullTypeSymbol.wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:31567:26)
  at PullInstantiatedTypeReferenceSymbol.getGenerativeTypeClassification (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:46402:30)
  at PullTypeEnclosingTypeWalker.getGenerativeClassification (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:32236:36)
  at PullTypeResolutionContext.oneOfClassificationsIsInfinitelyExpanding (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:32867:71)
  at PullTypeResolver.typesAreIdenticalInEnclosingTypes (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:39263:29)
  at PullTypeResolver.signatureTypeParametersParametersAndReturnTypesAreIdentical (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:39504:52)
  at PullTypeResolver.signaturesAreIdenticalWorker (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:39492:75)
  at PullTypeResolver.signaturesAreIdentical (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:39470:40)
  at PullTypeResolver.signatureIsRelatableToTargetWorker (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:40140:22)
  at PullTypeResolver.signatureIsRelatableToTarget (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:40120:36)
  at PullTypeResolver.signatureGroupIsRelatableToTarget (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:40095:61)
  at PullTypeResolver.sourceCallSignaturesAreRelatableToTargetCallSignatures (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:39961:27)
  at PullTypeResolver.sourceIsRelatableToTargetWorker (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:39748:23)
  at PullTypeResolver.sourceIsRelatableToTarget (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:39729:36)
  at PullTypeResolver.sourceIsRelatableToTargetInEnclosingTypes (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:39611:25)
  at PullTypeResolver.sourcePropertyIsRelatableToTargetProperty (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:39935:66)
  at PullTypeResolver.sourcePropertyIsAssignableToTargetProperty (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:39554:69)
  at PullTypeResolver.typeCheckIfTypeExtendsType (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:41369:45)
  at /Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:41507:34
  at Function.PullTypeResolver.typeCheck (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:40589:21)
  at TypeScriptCompiler.getSemanticDiagnostics (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:45510:41)
  at CompilerIterator.moveNextSemanticsPhase (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:46021:45)
  at CompilerIterator.moveNextInternal (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:45981:33)
  at CompilerIterator.moveNext (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/node_modules/typescript/bin/tsc-unlocked.js:45961:25)
  at BatchCompiler._compile (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/tsc.js:125:16)
  at BatchCompiler._batchCompile (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/tsc.js:103:18)
  at /Users/gozala/Projects/immutable-js/node_modules/ts-compiler/tsc.js:59:19
  at setupArguments (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/tsc.js:82:13)
  at BatchCompiler.compile (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/tsc.js:57:9)
  at Object.compile (/Users/gozala/Projects/immutable-js/node_modules/ts-compiler/tsc.js:12:32)
  at Object.module.exports.process (/Users/gozala/Projects/immutable-js/resources/jestPreprocessor.js:9:10)
  at Object.readAndPreprocessFileContent (/Users/gozala/Projects/immutable-js/node_modules/jest-cli/src/lib/utils.js:332:53)
  at Loader._execModule (/Users/gozala/Projects/immutable-js/node_modules/jest-cli/src/HasteModuleLoader/HasteModuleLoader.js:214:11)
  at Loader.requireModule (/Users/gozala/Projects/immutable-js/node_modules/jest-cli/src/HasteModuleLoader/HasteModuleLoader.js:916:12)
  at jasmineTestRunner (/Users/gozala/Projects/immutable-js/node_modules/jest-cli/src/jasmineTestRunner/jasmineTestRunner.js:242:16)
  at /Users/gozala/Projects/immutable-js/node_modules/jest-cli/src/TestRunner.js:371:12
  at _fulfilled (/Users/gozala/Projects/immutable-js/node_modules/jest-cli/node_modules/q/q.js:798:54)
  at self.promiseDispatch.done (/Users/gozala/Projects/immutable-js/node_modules/jest-cli/node_modules/q/q.js:827:30)
  at Promise.promise.promiseDispatch (/Users/gozala/Projects/immutable-js/node_modules/jest-cli/node_modules/q/q.js:760:13)
  at /Users/gozala/Projects/immutable-js/node_modules/jest-cli/node_modules/q/q.js:574:44
  at flush (/Users/gozala/Projects/immutable-js/node_modules/jest-cli/node_modules/q/q.js:108:17)
  at /Users/gozala/Projects/immutable-js/node_modules/jest-cli/src/lib/FakeTimers.js:325:7
  at process._tickCallback (node.js:355:11)
```
 This is strange `npm update` did not resolved it although just deleting `node_moudles` and then `npm install` worked. Although I do see one test failing:

``` sh
 FAIL  __tests__/Map.ts (8.453s)
â— Map â€º it does not accept strings (iterable, but scalar)
  - Expected function to throw Expected Array or iterable object of [k, v] entries, or keyed object: abc , but it threw Expected [K, V] tuple: a
        at Spec.<anonymous> (/Users/gozala/Projects/immutable-js/__tests__/Map.ts:63:12)
```
  This is a fix for #408 
 Please note I am unable to pass tests on my machine neither with nor without my changes it maybe related to version of node (0.12.0) as I noticed travis is running on older version of it. Or it could be something to do with typescript as only passing tests on my machine are written in js.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  I'm a bit unclear about the expected behavior with `Map/List.merge` when the values are ReactElements (or nested non-function Objects in general).

``` javascript
var div = React.createElement('div', null);
var span = React.createElement('span', null);
var map = Immutable.Map({ reactElement: div });

map = map.set("reactElement", span);

React.render(map.get("reactElement"), document.body);
```

The above works fine...but if we use `merge`:

``` javascript
var div = React.createElement('div', null);
var span = React.createElement('span', null);
var map = Immutable.Map({ reactElement: div });

map = map.merge({ reactElement: span });

React.render(map.get("reactElement"), document.body);
//(Throws an error...this isn't a proper reactElement anymore);
```

So it seems like the `Map.constructor` assigns the key 'reactElement' to the object reference, and `set` update the existing reference a new one, but merge is (I assume) recursively serializing the updated key-values with `fromJS`?  Is this expected, or is there no way to say merge shallow object references?  
 Nevermind I see that the problem is because I should be doing:

``` javascript
map = map.merge(Immutable.Map({ reactElement: span }));
```
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  I've being using Records for modelling application state and soon enough run into a case where I'd like to specify a record field that must be a collection of other Records. Something along these lines:

``` js
const Suggestion = Record({ url: '', title: '' })

const Completer = Record({
  selected: -1
  entries: List()
})
```

Here I'm unable to specify that `Completer` entries should be a `Suggestion` records. I would love if there was a way to declare that somewhat along these lines:

``` js
const Suggestion = Record({ url: '', title: '' })

const Completer = Record({
  selected: -1
  entries: Suggestion.List()
})
```
 > I now understand from your pull-requests that you're interested not just in type validation but parsing an arbitrary JS body into a tree of Immutable collections. That's also super interesting and something I would love to see, but probably should not be specific to Record, but apply to all Immutable collections.

Indeed! I'm not actually interested in adding a type checking to the records, what I'm interested in is to allow polymorphic record transformation functions that don't need to be a record type specific.

> Something like that would probably have a different sort of API from the Immutable collection constructors. For example, as you discuss here, you can't simply write: List(MyRecord) and expect it to operate as a type checker, for the same reason you can't write Record({number:Number}) and expect that to operate as a type checker. Both cases expect runtime values. We will need something else for schema-based object inflation.

I'm not sure I am following what you're trying to say here. Could you maybe explain it little differently ? Also would you mind proposing what the API for that could look like ?
 To put it from a different perspective I want to get following:
1. To be able to serialise records into JSON and then construct them back from the JSON producing equal values:
   
   ``` js
   let Point = Immutable.Record({ x: 0, y: 0 })
   
   let point = Point({x: 10})
   point.equals(Point(point.toJSON())) // => true
   
   let Line = Immutable.Record({start: Point(), end: Point() })
   let line = Line({start: Point({x: 10})})
   
   line.equals(Line(line.toJSON())) // => false
   ```
   
   As you can see from the example right now it only works if you have flat records.
2. Ability to define polymorphic functions that can set / push entries into record without needing to instantiate concrete record instances as that would imply function per record type or method definition per record type with a possible name collisions.
 As of runtime costs I agree this is not free lunch, but I don't think in practice it is going to be different from a normal records use as is. Let me elaborate on this:
1. If you do not use sub-records only added runtime cost is `instanceof` check for set operations.
2. If user does use sub-records most likely user already does the same sub-Record construction by hand:
   
   ``` js
   line.set('start', Point({x: 1})
   ```
   
   Or something slower when executed from a polymorphic function:
   
   ``` js
   line.remove('start').setIn(['start', 'x'], 1)
   ```
   
   **P.S:** polymorphic function that do `.set` is actually not that bad, but it's a lot more difficult with an `.update` that we tend to use a lot more.
3. If user does set / update with in the record like `line.setIn(['start', 'x', 10)` or `line.updateIn(['start', 'x'], inc)` there is no added runtime cost.

So unless I'm missing something only added runtime cost is `instanceof` check per modification operation (which I suspect js engines are well optimised for) and if it is still too much it could probably be optimised further by generating specialised setters per key during `RecordType` construction.
 I will understand if you'll say this is out of scope for this library and maybe defining whole new library would be a better way to go about it. Although I would still appreciate feedback from you on some of the points I tried to make above, as I could be missing some details.
 > For example, as you discuss here, you can't simply write: List(MyRecord) and expect it to operate as a type checker, for the same reason you can't write Record({number:Number}) and expect that to operate as a type checker. Both cases expect runtime values. We will need something else for schema-based object inflation.

Putting a typecheker part of this aside, with this change `ListRecord(RecordType)()` kind of does exactly with `RecordType.List` as a syntax sugar. In fact I did also wanted to propose another addition in a following iteration:

``` js
const Point = Record({x: Record.Number(0),
                      y: Record.Number(0)})
```

That would add optional schema validation when desired. In fact I wanted to propose React like props validation as well:

``` js
const Email = Record.Field(value =>
  emailRegExp.test(value) ? value : TypeError('Invalid email address')

const Login = Record({
  user: Email('user@gmail.com'),
  ...
})
```
 BTW implementing this as third party library is not quite visible right now because:
1. `List` implementation is not sub-classing friendly as part of implementation presumes that instances produced can be created using  `Object.create(List.prototype)` and that there can be only single empty list. I had to make following changes to `List.js` to be able to subclass it:
   https://github.com/facebook/immutable-js/pull/413/files#diff-be56562c9370c7fbf67b5bfca397aac5
2. As you noticed in the pull request the way I construct list subclasses is far from ideal due to the fact that `List` constructor does a lot and isn't really extendable. It would be great if that could also be changed to make subclassing a List easier.

If you'll be more in favour of having a separate library (which I'll understand)  maybe we could at least make Immutable Types more subclassing friendly so one would not need to maintain a fork of `List.js` and possibly other types to achieve this. 
 @Gozala check out #368 for a proposed approach of subclassing Immutable types across the board - I've been using it quite a bit it's been working great so far.
 @tgriesser thanks for pointing that out, indeed that would greatly simplify this pull request or allow defining this as a separate library. Any ideas when is it going to land ?
 @leebyron mentioned there's a better benchmarking system in the works internally so once that's available we can have more certainty there aren't any regressions in terms of performance across the board, though with the current `npm run perf` [these are the results](https://gist.github.com/tgriesser/d25be4eca84cffa9b0fa) (pretty impressive performance gains):

There's one (minor) caveat, if you try to add something like a metadata API to an object, or any other case where empty state is signaled by more than just value equality of the Map, List, etc., calling something like `clear` on the type will cause it to go back to a full empty state for now.

I believe I have a good fix for this but it modifies even more of the internals and didn't want to go any further in the PR until there's more discussion.
 > This is not possible in all cases because converting to JSON is lossy. In some simplified common cases it's possible though.

Could you please elaborate, example of where it's not going to work ? I understand that conversion to JSON is lossy, but (with proposed changes) `RecordType` does hold enough information to be able to reconstruct it back by parsing generated JSON. But it could be that I'm missing something.

> However, I'm not sure that I'm convinced a subclass of List is necessary in order to properly parse JSON to Records and Lists.

Parsing from serialised JSON is just one part of it. The other that I think you missed is ability to have a polymorphic functions that operate on the different RecordTypes.

To give you more insight here is how I got to where I am now with this.
1. We are working on an application that uses react form via omniscient.js and all our state is implemented with immutable.js data structures (basically maps & list). All of the application state is in central immutable map. And we used cursors to allow separation of concerns between components (although we're moving away from them).
2. As application got large enough it became little cumbersome to deal with a huge mostly unstructured data. In addition use of .get instead of destructuring was little annoying. So we considered using Records instead.
3. Once we started using records we've quickly run into several issues:
   1. Restoring from persisting app state in DB became more difficult (it still restores but we essentially loose all the properties that made us consider records instead.
   2. Many functions that were used on different subsections of the state were no longer applicable Record types the dealt there were different (even though sub-shapes that functions operate are same).
4. Te resolve first issue we end up writing additional functions that would basically destruct inputs and map parts of it before passing to the TypeRecord that it would return. This end up generating huge amounts of code and any structure change would require this guardian function change as well.
5. Later we created a RecordType decorator function that was basically doing more or less what you see in the pull. Figuring out field types extracting their constructors so that it could map over data before it would pass it to the RecordType itself & restoring from app state as well.
6. We still were running into issues though that sometimes some of the lists would contain data that was not of he Record type that List was supposed to contain. Mostly it was going down to the issue of transformation functions that would update record with some logic but return would be a JS object not the record type it took.
7. Some cases were resolved by making function per Record type in other cases functions would actually sniff for the other records and create a new one with it's constructor. This allowed for some kind of polymorphic functions but had another issue that RecordType again if had nested structures creating data with it's constructor was not enough it needed to use our decorator instead etc...

At the end of the day yes you can use `Records` as is but it requires a lot extra code and decorators and discipline in writing functions that operate on them. With a changes in this pull request we were able to fix most issues and get rid of all the glue code that made whole experience a lot nicer.

>  I understand you want this to be able to override the set/merge/etc methods, but I'm not sure this is strictly necessary.

I hope lengthy story above explained why I feel this is necessary.
 > In this case, the Point refers to the Point constructor. We can then infer that the fromJS should parse these fields using this constructor, and the default value will be the default values of the Point, e.g. Point().

Inference in the pull was pretty much doing that, it was looking at the `._defaultValues` and if they were instances of `Records` it would infer via their constructors.
 > For the first part of this: nested Records, I have a diff pushed to the 4.0 branch here: 5001072. This is based on your pull request, I actually borrowed the tests directly.

Great thanks a lot!
 @leebyron I have few more questions:
1. Did I managed to make a compelling case for `RecordLists` that are the key to having polymorphic functions without workarounds described earlier ? Asking because all your responses seem to be related to JSON parsing.
2. How do I help to move this forward ? I do understand you do not want to rush this and rightfully so. I  just don't know if you'd like to have more discussion or some more code or maybe just time to think through this.
3. I do need to move the project I'm working on forward & given the issues I described earlier I do believe I have only following options:
   1. Use a patched up version & hope that it would at some point in one form or other make it into upstream.
   2. Make a separate library built on top of immutable.js (I think this has a benefit of providing some prior art that you could consider in making a call on this), but this seems difficult without #368 because some of the assumptions in the List implementation. In best case scenario I might get away but copying most of `List.prototype` methods onto custom one and overriding some of them, but then I'd be touching too many intimate parts of immutable.js to be comfortable with.
   
   Which option would you recommend ? Maybe there is yet another option that I even fail to see.

Thanks!
 > I think I need more time to stew on possible ways to implement this that have the properties:
> 
> Very small overhead on existing library

As long as you keep typed fields optional you can have 0 overhead in case of untyped records by using different `.set` implementation. And nearly 0 overhead for partially typed records where overhead can be just a property lookup in the js object to see if the factory for the field exist. And very small overhead of instanceof check for typed fields when field assigned is already typed. Of course you'll have an overhead of constructing fields when untyped data is passed, but that's not really an overhead as user would need to construct that anyhow.

> Highly performant

Assuming current implementation is considered highly performant, I'd say this requirement is same as one above it, isn't it ?

> Works for all Immutable collections, current, future, and 3rd party.

I'm not sure this a valid requirement. Each data structure comes with it's own pros and cons and if some data structures are not meant to be used with typed records I don't think there is anything wrong with that. 

> If you have thoughts on how to accomplish this, I'm happy to keep spit-balling.

I have being meaning to take a stab at prototyping extensible records after elm's implementation that is based of this paper http://research.microsoft.com/pubs/65409/scopedlabels.pdf I wonder it could provide relevant input in this context, I'll need to re-read it.

Without digging to much into library my guess would be that if you want to allow optional typing for all structures likely you'd need a parse function for the type construction that will be involved in leaf node creations for that structure. I'd also presume that you can have typed & untyped version of leaf node creations so that untyped versions won't get any performance overhead. 
 Lately I have being thinking maybe it's best not to try changing a `Record` API but instead create a whole new data structure like `TypedRecord` and do the exploratory work there. That way other data types can gradually be added like `TypedList` etc... That way there will be neither breaking changes nor performance overhead for current data structures. Later Typed and untyped version could be merged if that would make more sense.
 @leebyron I want to bring up a problem I've run into while making / using typed list that I can't see a solution for. The use case example is something along these lines:

``` js
const Point = Record({ x: Number(0), y: Number(0) }, 'Point')
const PointList = List(Point, 'Points')

const graph = PointList(data)
const xs = graph.map(({x}) => x)
```

This code is doomed to have one of the following problems:
1. mapping a typed list returns untyped list. That sounds ok at first but then if you just wish to maybe move points in a graph by some factor you'll end up with an untyped list and you can also wind up with invalid items in the list. Also if you end up doing it like `state.update('graph', graph => graph.map(moveBy(2, 5)))` (assuming `state` is a record) you'll wind up creating one untyped list and then parsing it to a typed list.
2. mapping a typed list returns typed list. That would be great, but as we don't know what type of records resulting list should be of we can only go with a same type or any type. Later is basically a case described above while former is makes it impossible to map points to numbers in first place. Only other options I see is to provide optional type argument to map to say what type of list it should construct & assume it's a same / any type if omitted.
3. mapping a typed list returns a typed list where type of the resulting list is a union type of types that it winded up with. I find this most reasonable as in common case where mapping function is `a -> b` it will be able to do `[a] -> [b]` although in cases where mapping function returns arbitrary types it may lead to surprising result and suboptimal performance with when used within the records.

I've being thinking that it may in fact be better to not do the typed list or records as I originally was proposing. Maybe indeed it would be the best to only do a type parsing during construction and leave it up to user to push / unshift / set right types during updates. Although I still think it would be nice to provide some feedback if a wrong data structures are inserted during update.
 > However typed records still seems valuable, perhaps there's a way to leverage "list" being part of a record type.

That is how I got to typed lists actually as you do need to have this special lists that are part of the record but can be operated just as same if passed to you without owner record.

That being said I think I end up with pretty reasonable solution see next post.
 More updates on this front:
1. Maintaining a fork turned out to be a pain so I end up pulling related code out into separate project / repo which currently lives here: https://github.com/Gozala/typed-immutable
2. Current implementation avoids any changes to the stable version of immutable.js and does more or less what Record implementation in immutable.js does, meaning TypedList wraps an actual Immutable.List and most methods basically delegate to internal list and then wrap it with new TypedList. Not ideal but avoids forking library.
3. Earlier @leebyron mentioned that `Record({ x: Record.Number, y: Record.Number })` was not ideal as users may confuse and do `Record({x:Number, y:Number})` which I end up using to my advantage and basically both produce equivalent record types. As a matter of fact all JS built-in constructors can be used now and even `Record({x:Number(0), y:Number(0)})` will do right thing and define record with `x` and `y` fields of number type with a default value `0`.
4. I have added `Maybe(Type)` to allow nullable types.
5. I have added union types like `Union(Username, Email)`.
6. Typed lists can be mapped to lists of different type and the way it works is that type inference is used during mapping to detect type of mapped items. If resulting item is of the same type then resulting list will be of the same class as an original if say you mapped list of points to a list of `.x` then result will be typed list of numbers. Basically type is open during mapping but then it's locked. Now obviously mapping function can return values of different types, in that case resulting list is of union type of all types involved. Although in some cases if mapping function just returned js object list will be of `Any` type which is unwrapped `Immutable.List`. I think in practice this matches `map` behavior in typed languages where resulting list is of type of return value although there type is inferred at compile type :)

I do intend to add few more data structures `Tuple` and `Map`. I also will be more than happy to merge this work back to immutable.js if there will be an interest in doing so.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  `merge` appears to operate by key, which means merging two Lists together clobbers values (rather than appending them):

``` javascript
Immutable.List([1, 2, 3]).merge(Immutable.List([4, 5])).toJSON()
// [4, 5, 3]
```

`concat` doesn't have this problem; however, there's no `concatDeep`.

@leebyron, how do you feel about adding `concatAll`?  It would be a nondestructive union of any Immutable iterables, like so:

``` javascript
Immutable.fromJS(
  {
    "a":  [
            1
          ],
    "b":  {
            "fruits": [
                        "banana",
                      ],

            "place": "ireland",
          }
  }
).concatDeep(
  Immutable.fromJS(
    {
      "a":  [
              3
            ],
      "b":  {
              "fruits": [
                          "apple",
                        ],

              "author": "seuss",
            }
    }
  )
).toJSON()

// {
//   "a":  [
//           1,
//           3
//         ],
//   "b":  {
//           "fruits": [
//                      "banana",
//                      "apple",
//                     ],
// 
//           "place":  "ireland",
//           "author": "seuss",
//         }
// }
```
 This can currently be accomplished with a custom `mergeWith`:

``` js
var isList = Immutable.List.isList
var fromJS = Immutable.fromJS

function merger(a, b) {
  if (isList(a) && isList(b)) {
    return a.concat(b)
  }
  if (a && a.mergeWith) {
    return a.mergeWith(merger, b)
  }
  return b
}

fromJS({
  "a": [1],
  "b": {
    "fruits": ["banana"],
    "place": "ireland"
  }
}).mergeWith(merger, fromJS({
  "a": [3],
  "b": {
    "fruits": ["apple"],
    "author": "seuss"
  }
})).toJSON()
```

produces:

``` js
// {
//   "a": [
//     1,
//     3
//   ],
//   "b": {
//     "fruits": [
//       "banana",
//       "apple"
//     ],
//     "place": "ireland",
//     "author": "seuss"
//   }
// }
```
 I think you've got it, @leebyron!
 Yeah, same thing here. When merging two Maps that have a List on a nested property, the second List overwrites the first one completely instead of the values being merged as well. 

So, the following:

```
{todos: {list: [1, 2, 3]}} 
{todos: {list: [3, 4, 5]}}
// gives
{todos: {list: [3, 4, 5]}}
```
 I also definitely would love to see something to perform a deep concat!
 Ping for `4.0` milestone! I'm using this pattern to merge WebPack configs.

For posterity I'm checking `isIndexed()` instead of `isList()` and testing `isIterable()` before merging:

``` js
const mergeDeepConcat = (mapLike, ...iters) =>
  mapLike.mergeWith(concatDeepMerger, ...iters)

const concatDeepMerger = (l, r) =>
  l && l.mergeWith && isIterable(r) ? l.mergeWith(concatDeepMerger, r)
    : isIndexed(l) && isIndexed(r) ? l.concat(r)
    : is(l, r) ? l : r
```
 Rather than add `concatDeep`, I think the functional expectation is that `concat` should be called deeply by default (monoids of monoids and all that).

One typical example is [the Validation type](https://github.com/folktale/data.validation):

``` js
Failure(
  Immutable.Map({
    username: Immutable.List.of("required")
  })
).concat(Failure(
  Immutable.Map({
    password: Immutable.List.of("is too short")
  })
)).concat(Failure(
  Immutable.Map({
    password: Immutable.List.of("must contain a special character")
  })
))

// expected:
Failure(
  Immutable.Map({
    username: Immutable.List(["required"]),
    password: Immutable.List(["is too short", "must contain a special character"])
  })
)

// actual:
Failure(
  Immutable.Map({
    username: Immutable.List(["required"]),
    password: Immutable.List(["must contain a special character"])
  })
)
```

``` diff
-    password: Immutable.List(["is too short", "must contain a special character"])
+    password: Immutable.List(["must contain a special character"])
```  you can check this in a console

```
> Immutable.Set().withMutations(function(set) {
    set.union([ 'a' ]);
    set.add('b');
}).toString()
"Set { "b" }"
```

it works outside of a `withMutations` though.

```
> Immutable.Set().union(['a']).toString()
"Set { "a" }"
```
  It'd be really convenient, esp for interactive console work, if the toJS() and/or toArray() methods were implemented on iterators. Its much easier to chain commands from the console (i.e. append to previous text) than nest functions (balance parens, etc), and also avoids having to have a reference to Immutable from the console in order to explore immutable data structures.

```
// This is a lot easier to type on the console....
someMap.keys().toJS();

// than this...
require('Immutable');
Immutable.List(someMap.keys()).toJS();
```
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 I think this is the right decision, but I think there should be a change in the docs to add the `Iterator` so that it's possible to see what that interface looks like.

It's easy to see something like `keys(): Iterator<K>` and then click on `Iterable` in the docs (which supports toArray/toJS) and then be confused as to why it isn't working. Obviously it's because `Iterator` and `Iterable` are not the same thing, but the abscence of `Iterator` in the docs makes it make this mistake.

Cheers
 :+1: on the docs change. I ran into this issue exactly as @dpwrussell described!
 Having Iterator documented would be VERY helpful
  ```
a = Immutable.List.of("w", "x", "y", "z");
b = [];
b[1] = "i";
b[3] = "j";
console.log(a.merge(b).toArray());
> [ undefined, "i", undefined, "j" ]
```

CC @mcilroyc
 @iwehrman what do you expect as behavior?
 Call me crazy, but:

``` javascript
[ "w", "i", "y", "j" ]
```

Or is there some other, preferred way to sparsely update a list?
 Probably just using `.set`

``` js
console.log(Immutable.List.of("w", "x", "y", "z").set(1, "i").set(3, "j").toArray())
// [ "w", "i", "y", "j" ]
```

Or you could define custom merge behavior using `mergeWith`
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 For what it's worth I just ran into the same thing and expected the behavior that @iwehrman did (except with a deep array). Should a list really be treated as an opaque value if Immutable is supposed to be all about handling collections?
 +1 Any news on this?
  For convenience: `insert()` would be nice. Basically just a convenience wrapped around `slice()`, similar to `remove()`.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Example:

``` javascript
Immutable.List().withMutations(l => l.push(3).push(2).push(1).sort());
// Expected: [1, 2, 3]
// Actual  : [3, 2, 1]
```
 I think throwing a exception would help
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 I agree with @joewalnes. I think an Error would be helpful.
  Hi, I really like Immutable.js.

I am used to use RxJS, and it's nice that many of its operators have counterparts in Immutable.js. But I feel one of them is missing, and that would be an operator that aggregates consecutive values for you. In Rx, that would be [buffer](http://reactivex.io/documentation/operators/buffer.html) or "pairwise" in RxJS, or even the good old `scan`, which is like `reduce` but used for producing an Iterable, instead of one single "reduced" value.

Practically, what I would like to do is:

``` javascript
> let a = Immutable.List([1,2,3,4,5]);
List [ 1, 2, 3, 4, 5 ]

> let b = a.pairwise();
List [ List[1,2], List[2,3], List[3,4], List[4,5] ]
```

Naive groupBy doesn't work for that because it doesn't overlap the children lists. 
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  The test suite runs rather slow, and I was wondering whether it is possible to speed it up.

Iâ€™ve tested different variants on MBPs from 2010 and 2008 (sorry, donâ€™t have more recent hardware available atm):

| CPU | current state | [no typescript](https://github.com/davidaurelio/immutable-js/tree/no-typescript-in-tests) | [jasmine instead of jest, no typescript](https://github.com/davidaurelio/immutable-js/tree/no-jest-no-typescript) |
| --- | --- | --- | --- |
| Core2Duo | 4m20.332s | 0m51.636s | 0m27.554s |
| i7 (2010) | 2m1.904s | 0m24.786s | 0m23.579s |
- The biggest offender is TypeScript, so the first question is: Do the tests really need to use typescript?
- The QuickCheck-style tests (with jasmine-check) take their time. I think it might be worth considering moving those to a separate suite. That way, thereâ€™d be a really fast running test suite that gives quick feedback (< 5 seconds) during development, and the jasmine-check-suite that can be run on occasion and by CI. 
- I donâ€™t know why jest is slow on old hardware, but I guess that matters only to me when working on my ancient machine.
 I had a look at this. I don't think the problem is TypeScript inherently but the way it is being used. The current version of the compiler can compile all the .ts files in the test suite in ~2.3s on my i5 system, whereas the whole test suite takes about >100s to run.

There is a general issue on Jest's issue tracker at https://github.com/facebook/jest/issues/116 about performance. I haven't looked into that closer so I can't say how much of that is relevant.
  Since the output of each of these methods for a given immutable will always be the same, I would assume that a result will be cached internally after being calculated for the first time, right?
   I noticed this

```
function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
```

I'm trying to understand the reasoning behind this.
I'm currently having issues where I'm storing meta data on Immutables.
Eg: 

```
var item = new Immutable.Map();
...

if (item.state !== 'LOADING') {
    // metadata 
    item.state = 'LOADING';
}
```

Now, every time `new Immutable.Map()` is run it returns the the same object reference. So, all subsequent runs will have `state === 'LOADING'` because they point to the same object.
To get around this, I'm having to do the following to force a new object:

```
var item = new Immutable.Map({__new: true});
item = item.delete('__new');
```

This was obviously intentional since there is code explicitly for it and not a bug. But why?
 Note that if `item` is an `Immutable.Map`, `item.state = 'LOADING'` would not mutate `item`, it would have to be something like: `item = item.set('state', 'LOADING')`

After this, `item !== new Immutable.Map()`

Clarification: Although `item.state = 'LOADING'` is legal, it bypasses the Immutable.js api
 @danielstreit Right. Which is what I'm expecting. I don't want it to mutate, its just some metadata that I need to store on the object until i figure out a better way to store the metadata associated with those items.
 @leebyron I see. Well, I was under the impression that they were classes. I'll fix that.
What's confusing is I expected Immutable.Map() to always return a new object. I'm unable to articulate why it feels wrong, but thanks anyway. I'll figure out a different way of doing this.
 @leebyron Wouldn't it be both more idiomatic and more efficient to expose base objects as properties instead of through factory calls? Ie `Immutable.map` or `Immutable.emptyMap` instead of `Immutable.Map()` (which has some linting issues) or `new Immutable.Map()` (which creates an unused object).
  When using toJS() to convert Immutables back to plain JS objects their internal references are lost even it the object did not in fact change.
From what I understand they are reused internally but toJS() works differently (by creating new objects every time).

```
a = Immutable.fromJS({x:{y:1}});
a.toJS().x === a.toJS().x;
false
a.get('x') === a.get('x');
true
```

I have an 3 party lib that can only use plain JS objects as arguments and checks shallowly (by ref) if the passed in objects/arrays have changed. I was hoping to use Immutable to construct such arguments and having it do the work of keeping the references intact if the values did't change. 
Something like this:

```
//in consutructor
this.propsMap = Immutable.map();

//in render
props = {
  latLng: [a[1], b[0]],
  other: 'props' 
  //...
}
this.propsMap = this.propsMap.deepMerge(props);

extrenalLib(this.propsMap.toJS());

//and having inside external lib 
props.latLng === this.oldLatLng; //true
//if 'a' didn't change
```

But toJS fails in this case. Is there some other way to go about it? Or or do I have to rely on Immutable only informing me if the object did mutate but I have to do the references book keeping myself. 
Like this:

```
oldPropsMap = this.propsMap;
this.propsMap = this.propsMap.deepMerge(props);
if(this.propsMap !== this.oldPropsMap) {
  this.prevProps = this.propsMap.toJS();
}
props = this.prevProps;

extrenalLib(props);
```

Which seems a little tedious and maybe overkill for Immutable since I can use something like loDash.isEqual. 
 I think you need to do the book keeping yourself. Expecting Immutable to return the same plain JS object through `.toJS()` implies that it should keep a reference to every Object returned, which would cause an important memory leak.
 Thanks for the reply. I can now clearly see the reasoning here. 

I'm  just staring out my React and Immutable coding and was probably hoping to kind of ease into the immutable part. I thought I could only use it where I can rally see the performance benefits as a helper 'thingy' to maybe avoid some problems mentioned here: [http://noredinktech.tumblr.com/post/107617838018/switching-from-immutable-js-to-seamless-immutable](like having to use get/set and being very disciplined in naming things to not mix up vanilla vs immutable vars).
I was thinking this would be a premature optimisation to really use it everywhere and wrap the whole way of writing around it.

But now I think it's the whole point: either you go all in or it doesn't really do you any good. Unfortunately it's not a win / win. Fox example I was really hoping to be able to escape from getters and setters for example after moving to react :) . I'm giving it a go regardless and I'll see where it gets me. Maybe it will get too tedious and annoying or maybe I will never be able to go back to the mutable way.
 @leebyron
I think we should be able to do it via setters and getters without worrying about memory leaks see as follows â€”

``` javascript
var Immutable = require('immutable')
var fromJS = Immutable.fromJS

var i = fromJS({a: {b: {c: 1}}})

function wrap (immutable) {
  if (immutable instanceof Immutable.Map === false) {
    return immutable
  }
  var obj = {}
  for (var i of immutable.keys()) {
  Object.defineProperty(obj, i, {
    enumerable: true,
    set: function (value) {
      immutable.set(i, value)
    },
    get: function () {
      return wrap(immutable.get(i))
    }
  })
  }
  return obj
}

var js = wrap(i)


console.log(js.a.b.c) // access them easily like any other JS object

```

This code might not cover all the cases, but it sure does give us a good starting point to consider opening up an api where the immutable objects are accessible as pure js objects.
 @leebyron Ping!
  Wasn't sure if I should file this here or at the react project.

Very bizarre, this code crashes in latest Chrome and Firefox for me:

``` javascript
var data = Immutable.List([1])
  .toSeq()
  .filter(_ => true)
  .take(1)

React.createElement('div', null, data);
```

Using react 0.13 and immutable-js 3.6.4

JSBin: http://jsbin.com/qoyimuneqo/2/edit?html,js,output (might crash tab, firefox handles it better for me)

Taking out the line with `filter` or the `take` will work as usual.

edit: removed 6to5/jsx dependency
 From my debugging, it gets stuck in the while loop in `validateChildKeys`

``` javascript
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    } else if (typeof node === 'object') {
```

digging in deeper, this line in immutable is an infinite loop:

``` javascript
      return new src_Iterator__Iterator(function()  {
        while (skipped++ !== resolvedBegin) {
          iterator.next();
        }
```

`skipped` is `1` and `resolvedBegin` is `0`
  Dear all, 

``` javascript

var m = Immutable.fromJS({
   form: {
    username: 'test',
    email: 'test@test.com',
    address: {
      country: 'xx',
      city: '**'
    }
   }
});

how to reset m as:

var m = Immutable.fromJS({
   form: {
    username: '',
    email: '',
    address: {
      country: '',
      city: ''
    }
   }
});

```

//a little boring
m.set('username', '')
m.set('email', '')
....
 Keep the empty map around and reassign variables to that empty map when you want to "reset".
 @kentor  3ks
 @leebyron thank you very much.  Immutable is really awesome.
  If you have an object that has integer keys, and you use setIn, with a keypath that includes an integer, it will clobber values:

``` js
var Immutable = require('immutable');
var obj = Immutable.fromJS({ 5: { foo: 'bar' } });

var correct = obj.setIn(['5', 'baz'], 'qux');
console.log(correct.toJS());
// { '5': { foo: 'bar', baz: 'qux' } }

var incorrect = obj.setIn([5, 'baz'], 'qux');
console.log(incorrect.toJS());
// { '5': { baz: 'qux' } }
```

Is this expected behavior? I couldn't find any information about how keypath is defined, I just tried deducing it from the examples.
 I see, it's the .toJS() call that is actually destroying data, makes sense, thanks.
  This way, it's obvious when numeric keys are being mixed with string
keys, like when importing from JSON and inserting by key.
  The `.first()` method returns the first _value_ in an OrderedMap. How do I get the first _key_?
 ``` javascript

var Immutable = require('immutable');

var m = Immutable.OrderredMap({a:1, b:1});

//get first key
m.keySeq().first(); //a

```
 still not changed?  I am using custom reviver with `fromJS`, which detects arrays with object having `id` property which I turn into `OrderedMap` instead of default `List`, which is very useful for traversing large JSON structures. Now I need to make the conversion other way round (OrderedMap -> array), but `toJS` does not support `reviver`. 

Could be this considered as feature request? Or is there trick I can use?

Thanks! 
 you could perhaps override `.toJS()`?
 ```
myMap.toJS(function (key, value) {
  // I assume that first() would return converted JS type ?
  if (Immutable.OrderedMap.isOrderedMap(value) && value.size && value.first().id) { 
    return value.toArray()
  }
  // trying to mimic the default behaviour
  else if (Immutable.Iterable.isIndexed(value)) {
   return value.toObject()
  }
  else {
    return value.toArray() 
  }
})
```

Does it make sense? 

For reference - [here](https://github.com/facebook/immutable-js/issues/57#issuecomment-77529149) is the reviver I use with fromJS. It also took some elaborating to make it work as dealing with seq coming from reviver was kind of magic - some api seq calls end up with undefined errors, but getting value via `getIn` worked eventually. I think it has something to do with seq lazy behavior..
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 @jardakotesovec have you had any luck with this?
 @leebyron I agree that adding ```toJS``` to  ```Immutable.toJS()``` would be a good direction to go with this request. Would we want to remove the existing ```Collection.toJS()```, or share the new functionality in ```Immutable.toJS()```.  Addresses issue #338. Adds the ability to create a Map and OrderedMap from a List of Lists (if this is something that should actually be supported). Ran the perf tests and all seems to be good.
 Re the perf tests, I was just trying to make sure that I hadn't caused a performance regression for existing cases as I had the same worries about creating a Seq each time vs straight up array access. I'll get perf coverage added, I guess it should follow the 2, 8, 32, 1024 pattern?
 Ah sorry @leebyron, I misread the Map perf test and as you hinted it turns out I wasn't doing a regression test at all! I have added construction with arrays and Lists to the test and not surprisingly Seq did indeed turn out to be expensive. Here's the perf test (only the 1024 case shown, Old is current branch of master):

```
Map builds from an array of 1024
  Old:     1,678     1,692     1,706 ops/sec
  New:       833       841       849 ops/sec
  compare: 1 1
  diff: -50.27%
  rme: 0.9%

Map builds from a List of 1024
  New:       260       262       265 ops/sec
```

Whoops. So I think this is the most correct, if not fastest, thing to do:

``` javascript
  __iterate(fn, reverse) {
      return this._iter.__iterate(function(entry ) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var iterable = !Array.isArray(entry) && isIterable(entry);
          var k = iterable ? entry.get(0) : entry[0];
          var v = iterable ? entry.get(1) : entry[1];
          return fn(v, k, this);
        }
      }, reverse);
  }
```

The isArray check prevents a larger drop off when using plain arrays.

```
Map builds from an array of 1024
  Old:     1,639     1,656     1,674 ops/sec
  New:     1,570     1,596     1,622 ops/sec
  compare: 1 1
  diff: -3.67%
  rme: 1.35%

Map builds from a List of 1024
  New:     1,135     1,146     1,158 ops/sec
```

The following might also be an option, although I suspect it has edge cases e.g. entry is not an Iterable and happens to have a get function with different semantics. It is significantly faster for constructing from List:

``` javascript
  __iterate(fn, reverse) {
      return this._iter.__iterate(function(entry ) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var iterable = typeof entry.get === 'function';
          var k = iterable ? entry.get(0) : entry[0];
          var v = iterable ? entry.get(1) : entry[1];
          return fn(v, k, this);
        }
      }, reverse);
  }
```

```
Map builds from an array of 1024
  Old:     1,635     1,653     1,671 ops/sec
  New:     1,652     1,667     1,682 ops/sec
  compare: 1 1
  diff: 0.86%
  rme: 0.98%

Map builds from a List of 1024
  New:     1,521     1,534     1,547 ops/sec
```
  Repeating the tests instead of having to recurse and handling a recursion guard

See https://github.com/facebook/immutable-js/issues/300#issuecomment-78452758 for a problem description
 @leebyron done. The tests I added pass on this PR and throw on current master

Note that the tests were actually not testing, see the expectIs\* helpers :grinning:. I had to fix the 0, -0 equality
 @leebyron anything else needed to get this merged?
  I tried Records nesting and results are really embarrassing. It seems. Record structures are now limited to be flat (or contain Map/List/etc), no Record nesting is allowed in any way. Record nesting is very desired. For example

```
var Location = Record({code: ..., timezone:..., name:...});
var Flight = Record({origin: Location, destination: Location, ...})
```

This is in fact related to https://github.com/facebook/immutable-js/issues/334, extending records. Extending is simple case, the composition of complex types is more complex.

We can do following, If a record's key is another Record, then instantiate that Record and put it there. Now we put it's constructor function instead:

```
var Rec = Immutable.Record({id:123, subrecord:Immutable.Record({name:'John', lastname:'Smith'})})
var rec = new Rec()

rec.id
123

rec.subrecord
function (t){return this instanceof r?void(this._map=Mn(t)):new r(t)} 
```

That's nonsense! It seems, nesting Records should be easy enough.

PS Sorry for spamming lots of issues about Record feature, I just want them to be really useful. Maybe, I have a chance to try improve them?
 Well, I have found a way to nest Records

```
var Rec = Immutable.Record({id:123, subrecord:new (Immutable.Record({name:'John', lastname:'Smith'}))})
var rec = new Rec()

rec.subrecord.toString()
" { name: "John", lastname: "Smith" }"
```

even setIn works ok.  As record is immutable, instantiating records with single subrecord is legal.

I would suggest syntax sugar to allow put record constructor instead of record instance.
 Another experiment

```
var Rec = Immutable.Record({id:123, subrecord:new (Immutable.Record({name:'John', lastname:'Smith'}))})
var rec = new Rec({subrecord: {name:'James', lastname:'Bond'}})

rec.subrecord
Object {name: "James", lastname: "Bond"}
```

The problem is constructor replaced record with plain object. The proper behavior was to instantiate another Record and put it to subrecord. 

Default record can be asked for constructor, then the constructor is to be called with proper init data.
 I know this issue is closed, but I was hoping to get your opinion on a solution like this

``` es6
// Untested psudo code
import Immutable from 'immutable'

let NestedRecord = Immutable.Record({
  foo: 'bar'
})

class MetaData extends Immutable.Record({
  meta: 'data',
}){
  constructor(){
    super()
    this.map = {
      NestedRecord: NestedRecord
    }
  }
}

class LiveEvent extends Immutable.Record({
  id: null
}) {
  constructor(){
    super()
    this.map = {
      MetaData: MetaData
    }
  }
}


function using(type){
  var t = new type();
  return (key, value) => {
    if(type.map[key])
      t.set(key, using(type.map[key])(value))
    else
      t.set(key, value)
  }
}


Immutable.fromJS({
  id: 1,
  MetaData: {
    meta: 'some other data',
    NestedRecord: {
      foo: 'baz'
    }
  }
}, using(LiveEvent))
```

I am trying to find a good way to do this on a large scale project, and was hoping you could tell me if you see any obvious flaws with this approach.
 @leebyron That 4.0 branch looks very neat. Excited to try it out when ever it releases. In your mind what would be "best practice" to achieve a similar result with the current version of Immutable? 

Right now I have the following, but am not sure if it is the best way to go about it: 

``` javascript
const LiveEventData = Immutable.Record({
  title: '',
  description: null
})

const RandomizerEventData = Immutable.Record({
  query: '',
  display: null,
  categories: Immutable.List()
})

const VideoEventData = Immutable.Record({
  title: '',
  description: null,
  assetId: null,
  previewURL: null,
  thumbnailURL: null,
  display: null,
  categories: Immutable.Seq()
  status: null
})

const EventRecord = Immutable.Record({
  eventId: null,
  scheduleId: null,
  type: null,
  duration: 0,
  start: (new Date()).toISOString(),
  metadata: null
})

function EventRecordFactory (type, scheduleId, start, duration, metadata) {
  const typeMap = {
    "VIDEO": VideoEventData,
    "LIVE": LiveEventData,
    "RANDOM": RandomizerEventData
  }
  const MetaType = typeMap[type]
  let createdEvent = new EventRecord({
    scheduleId, type, start, duration
    metadata: new MetaType(metadata)
  })

  return createdEvent
}

let liveEvent = EventRecordFactory('LIVE', 1, 'TIMESTAMP', 200, {title: 'foo'})
```

Thank you for you time! 
 Super late to the party here, but I also wanted to have Record nesting like @AlgoTrade. The problem, as he said, is 

> 'The problem is constructor replaced record with plain object. The proper behavior was to instantiate another Record and put it to subrecord' 

I'm not sure if this is the optimal way to do it, but the following is my solution:

I wanted to parse the following nested JS object to nested Records:

```
let data = {
  name: 'Andrew',
  email: 'andrew@gmail.com',
  car: {
    type: 'Ford',
    cost: 10,
    usageDetails: {
      distanceTravelled: 0,
      averageMileage: 0
    }
  }
}
```

Step 1 is to define the structure of your nested records as follows. Note how UsageDetails is at the top (most deeply nested) and User at the bottom. If this is not done, the console will tell you that the Record does not exist.

```
var UsageDetails = Record({
  distanceTravelled: 0,
  averageMileage: 0
});

var Car = Record({
  type: '',
  cost: 10,
  usageDetails: new UsageDetails()
});

var User = Record({
  name: '',
  email: '',
  car: new Car()
});
```

It works fully when you haven't passed through data:

```
let user = new User();
user.get('car').get('cost'); //10 the default value
```

However if you pass through the data you get the following:

```
let user = new User(data);
user.get('car').get('cost'); //user.get(...).get is not a function
user.get('car').cost; //40, the nested Records are now normal objects, This passed value of 40 is accessed through dot notation.
```

So then following the advice of @leebyron:   

> Instead, you should use Immutable.fromJS() with a custom reviver function

I found this solution:

```
Record.constructor.prototype.fromJS = function(values) {
  var nested = fromJS(values, function(key, value){
    //See https://facebook.github.io/immutable-js/docs/#/fromJS for docs on custom reviver functions
    if(this.prototype[key] && this.prototype[key].constructor.prototype instanceof Record){
      return this.prototype[key].constructor.fromJS(value.toJS()); //use toJS() here if nest more than once
    }
    else {
      return value;
    }
  }.bind(this));
  return this(nested);
};
```

You can then call:

```
let user = new User();
user.get('car').get('cost'); //The default value of 10 works as normal

//This now works
User.fromJS(raw).get('car').get('cost'); //40. Note our new function: {Model}.fromJS()
```
 Just wanted to share what I'm doing using TypeScript:
1. Create a single .ts file per Immutable Class
2. Only export the TypeScript class. Keep the Immutable Record secret
3. Every class is responsible for creating / mapping it's values
4. (Nested objects will get created by their own class)

```
import { Record } from 'immutable';
import { Address } from './address';

let InternalRecord = Record({
    name: "",
    address: null
});

export class Contact extends InternalRecord {
    name:string;
    address:Address;

    constructor(args:any = {}) {
        super(Object.assign({}, args, {
            address: args.address && new Address(args.address)
        }));
    }
}
```

The same works for `List`:

```
export class ContactList extends InternalRecord {
    content:List<Contact>;

    constructor(args:any = {}) {
        super(Object.assign({}, args, {
            content: List(args.content && args.content.map(val => new Contact(val)))
        }));
    }
}
```

Hope this might help someone ðŸ˜ƒ 
 Yet another alternative, 

```
class SubModel extends Immutable.Record({}) {}

class Model extends Immutable.Record({name: null, subModels: new SubModel()}) {
  constructor(values) {
    const record = super(values);
    return record.set('subModels', record
      .subModels
      .map(subModel => new SubModel(subModel)
      )
    );
  }
  
}
```  It seems, Records are of great interest and it is one of killer features of Immutable.js. I start to use it, but unfortunately ES6 is not yet there for extending Records with methods and ES5 inheritance is pain.

For now, I "embed" methods into Records like this:

```
var Complex = Immutable.Record({real:0, image:0, magnitude:function() { return Math.sqrt(this.real*this.real+this.image*this.image);}});

var num = new Complex({real:1, image:2})

num.magnitude()
2.23606797749979
```

In reality, there is for example isNull method that shows the record has no real value. It would be useful to allow prototype extending in Record constructor, not sure it is acceptable for functional programming purists though.

I also heavily support the idea of making Records efficient (https://github.com/facebook/immutable-js/issues/286). Records can be lightweight structures, they are often used for small "value" types and they never change keys
 I do this for adding methods to record instances:

``` javascript
var Person = Immutable.Record({ name: '' });
Person.prototype.sayHi = function() {
  return this.name;
});
```
 For now, you can also get an efficient structure and methods by defining your own objects with `equals` and `hashCode` like so:

``` javascript
function Complex(p)
{
    this.real = p.real;
    this.image = p.image;
}

Complex.prototype.equals = function(other)
{
    return this.real === other.real && this.image === other.image;
};

Complex.prototype.hashCode = function()
{
    return util.hash_int32array([
        this.real,
        this.image,
    ]);
};

Complex.prototype.magnitude = function()
{
    return Math.sqrt(this.real*this.real + this.image*this.image);
};
```
 So, we can add hashCode and equals like @copy describes using the way @kentor describes? This would basically work using an immutable Set to guarantee unique Record based object in the Set?
 Can we return altered versions of records from Record methods? I have the following:

    class MyRecord extends Record({...}) {
        updateIssues = (issues) => this.mergeDeepIn(["items"], Map(issues.map(issue => [issue.id, issue])));
    }

as a method of a Record class, and when I call it, I get back something that the debugger claims is an instance of MyRecord, but there is no `updateIssues()` method on it anymore.  ```
record.toString()
" { a: 1, b: 2 }"
```

There is a first space character. toString is useful only for inspection, it is not a valid JSON as it has no quotes for keys and strange spaces

I certailnly want record.toJS(), I want to switch to the old JS world when I need
 Got it. When name is empty, the output is space prefixed.
Looks strange though.
 Hi @AlgoTrader, I am not able to get record.toString() to fail in the way you are seeing. When name is empty I get Record, and I also get quotes around the keys. 

``` javascript
> var Test = Immutable.Record({a: 1, b: 2});
> Test().toString();
'Record { "a": 1, "b": 2 }'

> var Test2 = Immutable.Record({a: 1, b: 2}, 'Test2');
> Test2().toString();
'Test2 { "a": 1, "b": 2 }'

> var Test3 = Immutable.Record({a: 1, b: 2}, '');
> Test3().toString();
'Record { "a": 1, "b": 2 }'
```

Am I missing any steps to reproduce this?
  Now I use 

```
Immutable.Map(record).toJS()
Object {a: 1, b: 2}
```

or

```
JSON.parse(JSON.stringify(record))
Object {a: 1, b: 2}
```

Switching to plain JS world is often needed.
Can you please add toJS/toJSON for records?
 Works for me.

``` javascript
> var Person = Immutable.Record({ name: 'hi' });
undefined
> (new Person()).toJS()
{ name: 'hi' }
```
  Due to defect in the code, calling cursor() on cursor can return improper type

``` javascript
var data = Immutable.fromJS({ a: [1, 2, 3] });
var cursor = Cursor.from(data);
var deepCursor = cursor.cursor('a');
deepCursor instanceof IndexedCursor; // fails since is KeyedCursor
```

Originally reported here https://github.com/facebook/immutable-js/pull/297 I decided that it might be a safer fix to continue using argument.length rather than checking undefined since I think it might be valid to use undefined in some circumstances.

So this fix goes back to using argument.length in the makeCursor check, but properly calls it with only 3 arguments from subCursor if subCursor is not called with value.
 This issue is also mentioned in #318 
 :+1: this fixes #398 as well.
 Great! Thanks.
  Phil's (may he rest in peace) contribution is massive by comparison. His name ought to come first (at least.. I think so)
  Hi all,

Following up on #242, [we're using Cursors to browse tree-like data structures](https://github.com/facebook/immutable-js/issues/242#issuecomment-77404067).

This PR implements `parent`, `sibling`, `nextSibling` and `prevSibling` on `Cursor` to work with tree-like data structures.

Would that be a desirable feature for `Cursor` or should it live in a more specific implementation?

Thanks :)
DarÃ­o
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Good stuff! Thanks for the heads up :) So, would that data structure be
accepted in, say, contrib? Or should I do my own package for it?
Is it ok to base it off Cursors and have it use its internals? I guess that
my biggest concern with it is that internals like _rootData and _keyPath
can change. Perhaps these could be public? Or am I missing something? Thanks

On Fri, Mar 27, 2015 at 4:49 AM Lee Byron notifications@github.com wrote:

> This should live in a separate sort of thing. Cursor is meant to be a very
> transparent view over a Map or a List, not to represent a new kind of data
> structure. What you're describing sounds more like Zippers which we do not
> have any tools for at the moment. Feel free to start to flesh that out!
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/pull/379#issuecomment-86818595.
 That's fine :) Thanks for your answer on this!
  [I mentioned some time ago](https://github.com/facebook/immutable-js/issues/225#issuecomment-69242344) that I wanted to centralize some Chai assertions for Immutable, to make test writing more natural.

As opposed to what I was mentioning, I didn't end up writing code here directly, but [came up with a separate Chai plugin](https://github.com/astorije/chai-immutable), because I think it makes more sense. Although I do my best to keep it clean and fully tested/covered, It is highly unstable for now, but [I just sent a PR on the Chai doc repo](https://github.com/chaijs/chai-docs/pull/79) so that it appears on the [plugin page](http://chaijs.com/plugins).

I have 3 questions here:
1. Right now I only provide 3 assertions. Do you have any preference over the semantics and wording of the current ones? I am completely willing to change them to match your expectations.
2. I have plans for a few others assertions, but I will quickly run out of ideas as I am myself using only a small subset of the Immutable data structures you provide. Do you have any requirements/requests you'd like me to implement?
3. Do you think there could be a link to this plugin (either the GitHub page or the Chai plugin page) to guide people willing to test their code involving Immutable? If you allow me to, I'd love to send a PR to add a section in the README, maybe after "Documentation", or wherever you see it fit.
 Hi @leebyron, thanks for your support, that's appreciated! I'll try to keep it in shape to match your library's quality :-)

Good advice regarding `contains`/`includes` (`has` is just a noop keyword though) and I am planning to add [support for value retrieval](https://github.com/astorije/chai-immutable/issues/9) too. That'd be great if you can give your 2 cents on the latter thread by the way.

If you tell me the API (aka, the wording/grammar for the assertions, always better to have this approved by a native speaker!) is what you'd expect, then I'dd like to go to version 1.0.0 whenever I add a new feature.

Finally, what do you think about a link in the README (item 3)?

Thanks!
 @leebyron, do you mind taking a look at my previous comment? I'd be happy to release my plugin in version 1.0.0 if you agree with the current API.

Thanks a lot in advance!!
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 Oops, forgot to link back here: related PR is #549
 This was added to README some time ago, closing.
  Your approach of not assigning property descriptors when the key is in the prototype chain does seem better than an invariant. I guess people will still be able to add things directly to the prototype chain or introduce a clashing method name when subclassing Record but that is also true of my invariant approach. Your point that people may deliberately want to clobber the prototype was a good one, I have to admit that hadn't occurred to me. Maybe public properties that are also used internally like size could be a getter pointing to an internal property like _size that the internals use? That way it doesn't really matter if it gets clobbered (obvious drawback is that it won't work for IE8).

In the meantime, how worried are we about size, Record types and Immutable.is()? As it stands Immutable.is() will likely give the wrong answer when size is clobbered. Unless the value of size matches the actual size of the collection it will return false.

```
const Shirt = Immutable.Record({
  size: 'XL',
  style: 'stripes',
});

var a = new Shirt({});
var b = new Shirt({size: 'XL', style: 'stripes'});

Immutable.is(a, b); // returns false
```

Maybe it is an edge case not to be overly worried about until the next major release? I've spent a bit of time messing around with Records with weird size keys and not found any other problems.
 > Either way, this will be a breaking change that will need to go into the next major version bump of immutable.js, and we may also need to include some way to opt out of this behavior in the case that you want to clobber the prototype.

That was my exact first thought as well. After some background thinking I've got into confusion (that may be resolved by someone who knows internals):

If it's impossible to use `Record` with `size` (or any other attribute that is used for internal purposes) - then if someone used it - they already have had their code broken. You literally just cannot run it.

So, why this change is a "breaking" one then?
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 I lost an hour or two try to use `size` as a Record attribute today, which results in the error  `Cannot set on an immutable record.` when constructing an instance.  Its not possibly to successfully use an attribute size.  While it seems stupid/obvious now, its seems like a pretty common attribute name.

How about throwing a warning if someone passes a reserved prop in when invoking/extending Record rather than waiting until an instance is constructed?

I suppose I'll change my backend schema to a different attribute name because thats still an option now, but not always possible.  Is there a clean way to do attribute aliasing/translation with Records, as in `Backbone.Model.parse/toJSON`?
 I have the exact same problem. Wanted to use size as an attribute name on a Record but got the error `Cannot set on an immutable record.`. Would love to see a solution without having to rename attributes at the source.
 Couldn't ES6 Symbols be used to name the properties that are specific to immutable (like the size property).
I know it would probably require a lot of work but it would guaranty that there is no collision.
  the `dist` folder is missing, which renders the release unusable
 Yep - broken for `3.6.3`, working correctly on `3.6.2`
 :+1:
  Immutable.Stack#last() returns undefined #353:

Stack.last() calls Stack.get(-1), but Stack.get() did not contain the wrapIndex call to handle negative indexes.

Stack.map throws a TypeError #332:

Stack.map was throwing an error due to the following line of the Stack.__iterate method in Stack.js:

return this.toSeq().cacheResult.__iterate(fn, reverse);

Note the missing parens after cacheResult. However, reinstating them led to an infinite loop where Stack.__iterate was calling Stack.__iterate recursively which is why I changed this line to use this.reverse().__iterate(fn). I also made a similar change to the Stack.__iterator method.

Tests have been added. 

The transpiler seems to have made some extra changes to dist/immutable.js, renaming some of the classes (Map and Iterator). I don't know if this is a problem. Maybe I missed something in the build step?
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  How do I return unenumerable from Map#toObject and Map#toJSON

``` js
var foo = new Map({
  bar: true,
  qux: true
});

var obj = foo.toObject();

console.log(obj);
```

It would output:

```
{ bar: true, qux: true }
```

When I want the `bar` property not to be enumerable, I want the output to be:

```
{ qux: true }
```

But the `obj.bar` still exist. Like when I implement:

``` js
var obj = new Object;

Object.defineProperty(obj, 'bar', {
  value: true,
  enumerable: false
});

Object.defineProperty(obj, 'qux', {
  value: true,
  enumerable: true
});

console.log(obj);
```

So, How can I implement this?
  Useful if you want to have different behavior depending on the key being compared / merged.

Test and docs updated.
  You can find more details about the issues here: https://github.com/omniscientjs/omniscient/issues/89

Here is a little illustrative summary:

``` js
let root = Cursor.from(Immutable.fromJS({items: [{x: 3}, {x: 2}, {x: 1}]}))
let x1 = root.cursor('items').cursor(0);

let root2 = root.updateIn(['items'], items => items.reverse());
let x2 = root2.cursor('items').cursor(2);

x1.equals(x2) // => true
x1._keyPath === x2._keyPath // => false
```

Now consider react components like this:

``` js
class Item extends React.Component {
  shouldComponentUpdate(props)  {
     return !this.props.cursor.equals(props.cursor);
  }
  render() {
    const {cursor} = this.props;
    return React.DOM.div({
      onClick() {
         cursor.update(...)
      }
    }, generateContent(cursor))
  }
});

class App Extends React.Component {
   render() {
     const children = this.props.cursor.cursor('items').map(item =>
        Item({ key: item.get('x'), cursor: item }));
      return React.DOM.div({}, children);
   }
}
```

If `App` is rendered with with `root` and then `root2` Item for `{x: 3}` will not re-render as equality check returns `true` even though it refers to different location in the structure. Also clicking it will end up sending changes to out of date `_keyPath`.

With react API this is actually not a big deal if one would not capture cursor in render, but in omniscient it is because cursor will be passed in into `render` itself.

Maybe `.equals` behavior is correct, but what would be a way to handle such case properly ? 
 To be honest I can get behind over either point of views on this matter. Although I am afraid there are issues with ether option. Here are my further thoughts on this:
1. If `.equals` takes key path  into account it should probably also take `root` data structure into account as well (or do they ?). If so this will lead to another issue where observer of the `root` cursor will initiate another render that would force all of the subcomponent to re-render as the sub-cursors will be pointing to a diff `root`.
2. If `.equals` continues to behave as is there is no public API right now to see if key path is different and tweak `shouldComponentUpdate` accordingly.

I'm personally leaning towards keeping `.equals` as it is now as structures themselves are equal. To make an analogy structures can be equal regardless of where they came from:

``` js
const m = Immutable.map({ x: x, y: {x: x} });
m.get('x').equals(m.getIn(['y', 'x']) // => true
```

As a matter of fact in terms of react / omniscient re-rendering a component when a key path has changed is not ideal, ideal solution would be to update previous equal cursor to point to a new path (not sure if that still could lead to errors with a deep structures like when parent components cursor will be re-rooted while it's children will end up having old root because render short circuited).

Maybe just exposing key path in the public API is enough ?

I was also wondering if you have considered alternative cursor API, like the one used by Om. My understanding of it is that cursors get synchronised on updates there for same component structure won't lead to any errors as render will short circuit while cursors will still get updated (similar to how `this.props` get updated regardless of what `shouldComponentUpdate` returned).
 @Gozala am I understanding correctly that your onClick() handler changes the cursor directly? That breaks top-down flow.
The way I use cursors is by providing an onChange handler that gives the new root object value to the store and returns undefined so the cursor keeps pointing to the previous version of the root object.
Then the store-triggered redraw handles everything as it should, since the cursor content will differ in the new props.
 > @Gozala am I understanding correctly that your onClick() handler changes the cursor directly? That breaks top-down flow.

Hi @wmertens thanks for your input. I am afraid I do not agree that changing cursors directly from the event handlers breaks top down flow. Although depends what do you mean by changing directly. The purpose of cursors is pretty much what the purpose of stores is (at least in our use of them). Root component is passed cursor for the whole app state which is observed for changes (note that changes to cursors don't actually mutate anything just trigger observer with a whole new data structure with changes applied) once observer is invoked root component is re-rendered with a new cursor created from the updated state. So it is the same top down flow and same idea as stores.

> The way I use cursors is by providing an onChange handler that gives the new root object value to the store and returns undefined so the cursor keeps pointing to the previous version of the root object.

It sounds pretty much what happens here as well, cursor indeed will still point to the old root object.

> Then the store-triggered redraw handles everything as it should, since the cursor content will differ in the new props.

This is where I think you are misunderstanding a problem. In our case simplified `shouldComponentUpdate` looks like this:

``` js
{
  shouldComponentUpdate(newProps) {
     return !this.props.cursor.equals(newProps.cursor)
  }
}
```

Now if some user interaction just caused to reverse `items` on a next render each `item` from the list will still point to the same data structure and cursor will be equal although their `._keyPath` will be different. Which would lead to an issue that is that `shouldComponentUpdate` on each item will return `false` there for `render` will not execute and there for when `onClick` is invoked enclosed `cursor` on each item will point to old root and old `._keyPath`. Note: That this would not be an issue if `onClick` handler referred to `this.props.cursor` instead of enclosed `cursor` as `props` would have updated even though `render` was not triggered.

My guess reason you do not run into this issues is either because your `shouldComponentUpdate` does not return `false` even if state has not changed (maybe because you pass new store instance or something else) or because your `onClick` invokes something on the mutable object, like store who's target cursor was updated or `this.props` that are mutated for you by react.

I hope this explains it.
 @Gozala The way it works for me is because the list itself is also rendered with a cursor, and that will point to a different object even though the `item`s themselves do not change.

Also, I only interface with the store in "container" elements that create cursors and render "pure" elements.

Here's my flow (I use Fluxy):
`onclick() -> cursor.update() -> _onChange(newRoot) -> store saves newRoot -> notifies watchers -> redraws`

`_onChange` returns undefined so the cursors remain stale. The store watchers are only set on container elements that wrap the pure elements. They simply call `this.forceUpdate()` which causes new cursors to be created from the store key they're watching.

So in fact it's `click -> new root data -> create new cursors` and then the wrapped pure elements do conditional rendering. I do check with Perf to see if there were wasted updates so I know it works as it should.
 > @Gozala The way it works for me is because the list itself is also rendered with a cursor, and that will point to a different object even though the items themselves do not change.

In our case everything is cursor from top to bottom as well (as you can see in the description `App` component is using `this.props.cursor.cursor('items')` to get a cursor to the list. But since each `item` is handler with a `Item` component each of them will run `shouldComponentUpdate` and cursor equality checks will return `true` even though they belong to different structure and in a different path. Do you see what I mean ?

> Also, I only interface with the store in "container" elements that create cursors and render "pure" elements.
> 
> Here's my flow (I use Fluxy):
> onclick() -> cursor.update() -> _onChange(newRoot) -> store saves newRoot -> notifies watchers -> redraws

Are you doing `cursor.update()` in `onClick` or call method on the store ? If later that would absolutely explain why you don't have this issue, because your store will update to track a new cursor so it's method will end up operating on up to date cursor regardless if render was called or not. If you do `cursor.update()` from a `onClick` handler & indeed don't trigger render on each item after reorder then I'm really curios to see the actual code as I don't see how that could be a case. If that a case maybe you could modify this example to illustrate your approach http://jsbin.com/yunomateha/1/edit?js,output otherwise it's hard to follow what's going on. (P.S. that example uses cursors wrapper from omniscient library as I wrote it for https://github.com/omniscientjs/omniscient/issues/89 but same happens on plain Immutable.js Cursors and plain react).

> _onChange returns undefined so the cursors remain stale. The store watchers are only set on container elements that wrap the pure elements. They simply call this.forceUpdate() which causes new cursors to be created from the store key they're watching.
> 
> So in fact it's click -> new root data -> create new cursors and then the wrapped pure elements do conditional rendering. I do check with Perf to see if there were wasted updates so I know it works as it should.

I'm sorry at this point it's really hard for me to understand how things work without seeing actual code. Wait does not `.forceUpdate()` is going to call the `render` though ? Also this issue has nothing to do with weather new cursors are created or not, the issue is that two absolutely different cursors with different roots (that may not even have much in common) pointing to the same data structure (in totally different places) are considered equal & there for `shouldComponentUpdate` will return `false`.
 I'll take a look at the jsbin later, but I think your problem is due to
this:

> Also this issue has nothing to do with weather new cursors are created or
> not, the issue is that two absolutely different cursors with different
> roots (that may not even have much in common) pointing to the same data
> structure (in totally different places) are considered equal & there for
> shouldComponentUpdate will return false.

When a pure component gets the same props, it should render the same way.
In this case, it gets a cursor which doesn't expose the path, so the props
are the same and the element should render the same. I think what's going
on is that your list of items doesn't re-render when it should. If it did
re-render, it would have created the elements in a different order with the
same keys and React would have moved the DOM elements.

On Mon, Mar 16, 2015 at 12:09 AM Irakli Gozalishvili <
notifications@github.com> wrote:

> @Gozala https://github.com/Gozala The way it works for me is because
> the list itself is also rendered with a cursor, and that will point to a
> different object even though the items themselves do not change.
> 
> In our case everything is cursor from top to bottom as well (as you can
> see in the description App component is using
> this.props.cursor.cursor('items') to get a cursor to the list. But since
> each item is handler with a Item component each of them will run
> shouldComponentUpdate and cursor equality checks will return true even
> though they belong to different structure and in a different path. Do you
> see what I mean ?
> 
> Also, I only interface with the store in "container" elements that create
> cursors and render "pure" elements.
> 
> Here's my flow (I use Fluxy):
> onclick() -> cursor.update() -> _onChange(newRoot) -> store saves newRoot
> -> notifies watchers -> redraws
> 
> Are you doing cursor.update() in onClick or call method on the store ? If
> later that would absolutely explain why you don't have this issue, because
> your store will update to track a new cursor so it's method will end up
> operating on up to date cursor regardless if render was called or not. If
> you do cursor.update() from a onClick handler & indeed don't trigger
> render on each item after reorder then I'm really curios to see the actual
> code as I don't see how that could be a case. If that a case maybe you
> could modify this example to illustrate your approach
> http://jsbin.com/yunomateha/1/edit?js,output otherwise it's hard to
> follow what's going on. (P.S. that example uses cursors wrapper from
> omniscient library as I wrote it for omniscientjs/omniscient#89
> https://github.com/omniscientjs/omniscient/issues/89 but same happens
> on plain Immutable.js Cursors and plain react).
> 
> _onChange returns undefined so the cursors remain stale. The store
> watchers are only set on container elements that wrap the pure elements.
> They simply call this.forceUpdate() which causes new cursors to be created
> from the store key they're watching.
> 
> So in fact it's click -> new root data -> create new cursors and then the
> wrapped pure elements do conditional rendering. I do check with Perf to see
> if there were wasted updates so I know it works as it should.
> 
> I'm sorry at this point it's really hard for me to understand how things
> work without seeing actual code. Wait does not .forceUpdate() is going to
> call the render though ? Also this issue has nothing to do with weather
> new cursors are created or not, the issue is that two absolutely different
> cursors with different roots (that may not even have much in common)
> pointing to the same data structure (in totally different places) are
> considered equal & there for shouldComponentUpdate will return false.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/issues/370#issuecomment-81282853
> .
 > When a pure component gets the same props, it should render the same way.
> In this case, it gets a cursor which doesn't expose the path, so the props
> are the same and the element should render the same. I think what's going
> on is that your list of items doesn't re-render when it should. If it did
> re-render, it would have created the elements in a different order with the
> same keys and React would have moved the DOM elements.

List itself does get  reordered, but react does not executes render methods of an Item components and reason is exactly what this bug say if `a1` was moved to a different index and become `a5` `a1.equal(a5)`  will be `true` so react will not run `render` and just use previously generated VDOM.
 I don't see how that is a bug - I think that's exactly how it should work?

Oh - are you using the array index as the Item key? You should use a
per-item unique key so that React knows what goes where. Otherwise React
will just see "item with key 1 - still the same, great, nothing to do; item
with key 5 - still the same, great, nothing to do".

On Wed, Mar 18, 2015 at 6:28 PM Irakli Gozalishvili <
notifications@github.com> wrote:

> When a pure component gets the same props, it should render the same way.
> In this case, it gets a cursor which doesn't expose the path, so the props
> are the same and the element should render the same. I think what's going
> on is that your list of items doesn't re-render when it should. If it did
> re-render, it would have created the elements in a different order with the
> same keys and React would have moved the DOM elements.
> 
> List itself does get reordered, but react does not executes render methods
> of an Item components and reason is exactly what this bug say if a1 was
> moved to a different index and become a5 a1.equal(a5) will be true so
> react will not run render and just use previously generated VDOM.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/issues/370#issuecomment-83069714
> .
 > I don't see how that is a bug - I think that's exactly how it should work?

This is not a bug indeed, but it has an unfortunate side effect, which is since render will not run event listeners from previous run will hold on to a previous cursor that has a different ._keyPath so if the will fire they will end up updating wrong state.

> Oh - are you using the array index as the Item key? You should use a
> per-item unique key so that React knows what goes where. Otherwise React
> will just see "item with key 1 - still the same, great, nothing to do; item
> with key 5 - still the same, great, nothing to do".

Please read the code I provided with the bug, I feel I keep explaining what is already illustrated in the code snippet provided.
 So the way I do it is that cursor.update tells the store to update but **does not** change the cursor root data value. Then the store triggers a re-render where needed (I register store listeners on wrapper elements that talk to the store).

Your List would be a different cursor and it would cause DOM element moves.

`````` es6
class Item extends React.Component {
  shouldComponentUpdate(props)  {
     return !this.props.cursor.equals(props.cursor);
  }
  render() {
    const {cursor} = this.props;
    return React.DOM.div({
      onClick() {
         cursor.update(...)
      }
    }, generateContent(cursor))
  }
});

class App Extends React.Component {
   render() {
     const children = this.props.cursor.cursor('items').map(item =>
        Item({ key: item.get('x'), cursor: item }));
      return React.DOM.div({}, children);
   }
}

class AppStoreWrapper Extends React.Component {
  // Somehow listen to store changes induced by cursor updates
  // Cursor onChange callback calls store directly or launches action and returns undefined
  // When the store is done updating, it should notify its listeners (maybe just render the whole app)
  // and they will get new cursors that will be different from the originals when the data needs updating.
 render() {
  cursor = store.getCursor()
  props = extend({cursor: cursor},this.props)
  return React.createElement(props, App);
 }
}```
``````
 @Gozala I just found an annoying issue with my approach, I'm not sure if it's what you're seeing: Since cursors only compare their referenced value, they can nicely avoid repainting whole blocks, but when you make use of cursor.update() the way I describe, it will use stale data to make the change on itself.

In other words, you have an app that paints `{a: {b: [c, d]}}` into a section using `a.b.0` and another using `a.b.1`, and then the user operates on `c`, resulting in `{a2: {b2: [c2, d]}}` for the app state, but since `d` didn't change, it will still refer to the original data structure. When the user then changes `d`, the `onChange()` handler gets the old `a` with a change to `d`, and the change to `c` is lost.

To fix this, the `onChange()` handler should get the partial data...

Is this related to your issue? I think not right?
 > @Gozala I just found an annoying issue with my approach, I'm not sure if it's what you're seeing: Since cursors only compare their referenced value, they can nicely avoid repainting whole blocks, but when you make use of cursor.update() the way I describe, it will use stale data to make the change on itself.

Yes this is another example of this issue, although this one is less problematic scenario than the one I described.

> To fix this, the onChange() handler should get the partial data...

There are different workaround in different scenarios and neither issues nor solutions are obvious. Actual code base I run in those issues is complex enough that workarounding this solution was not a viable option as we would run into different variations of it over and over.

That is why I originally proposed to modify cursor equality check so it would also compare `.keyPaths` that way render will be triggered even if data structure has not changed but only it's location did. Never the less that isn't ideal options either as that would cause unnecessary render calls just to update cursors so event handlers will have up to date reference.

At this point I think most viable solution going with cursors is to do what https://github.com/omcljs/om does which always keeps cursors in sync with changes, although I'm not in a favour of that approach either as at that point cursors don't seem any better than mutable state.

In the end I'm planning on moving from cursors to an approach inspired by http://elm-lang.org and illustrated in this example http://jsbin.com/hogulenuhu/5/edit?js,console,output
 I still like cursors as an immutable proxy for a store object, so I changed them so they never change and only pass the changed sub-object and path to the store. The store can then decide what to do with it.

In other words, cursors are immutable too.

This fixes my issues.

I agree that the Om approach doesn't make sense in a React context.
 > I agree that the Om approach doesn't make sense in a React context.

@wmertens I think it might be my imperfect English but I feel like we talk past each other as you misunderstand comments I'm making.

I did not implied Om approach does no make sense in React context. In fact I think only reasonable option of going with cursors is to follow Om's approach.

What I tried to say was that **I personally** came to realise that cursors that get synced automatically is **not much better** than a mutable API exposed by react & I would much rather use an alternative approach similar on one used by Elm.

> I still like cursors as an immutable proxy for a store object, so I changed them so they never change and only pass the changed sub-object and path to the store. The store can then decide what to do with it.
> 
> In other words, cursors are immutable too.
> 
> This fixes my issues.

I am afraid I don't fully understand your solution or how it solves this problem without causing unnecessary re-render. In fact it seems odd to me that you are using both cursors and stores as they are tools that take different approach to solve the same problem - provide a single source of truth.

Don't get me wrong I'm not implying there is anything wrong with your use, it's just does not seems to be a good fit for my use. And even if such a combination of tools avoids described issue I still think issue is present and is worth thinking about a fix that would not require additional abstractions. Again I tend to lean towards the Om like cursors as that seems to work and be free of this problem.
 The way I understand it from you, Om cursors are updated immediately all over the application. If that is correct, that means that when you are comparing cursors to see if an element needs updating by React, they are actually the same.
So actually that probably can't work, unless you deep copy the cursor state at render() time.

I use cursors as the replacement for a (Store, object, path) triplet and I keep them immutable. When you call one of the change methods, the store gets notified about the change and then propagates the change to the elements that watch the store. This propagation generates new cursors which can compare against the old ones and thus prevent unnecessary redraws. 

I do not have an issue with elements moving in a list, that simply means the list gets re-rendered and DOM elements moved to their correct place.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  > Designed to inter-operate with your existing JavaScript, immutable accepts plain JavaScript Arrays and Objects anywhere a method expects an Iterable with no performance penalty.
> This is possible because immutable can treat any JavaScript Array or Object as an Iterable.

I wonder what this exactly mean. I though that Immutable.js structures are always represented via tries structures. So I would expect that converting from JS Array/Object to Immutable would require some processing and creating these tries structures.  But quoted docs sounds like its using array/object directly.

So may I ask for brief explanation? Thanks!
 Thanks @leebyron . Really appreciated. As I have use cases when I don't need to update data much, but the additional Immutable.js interface is handy. So basically trying to understand if Immutable.js is good fit and does not come with significant overhead.

To make sure I understand. Lets say I have simple array `[1,2,3,4,5]` and I call `var list = Immutable.fromJS([1,2,3,4,5])`. At this point `list` is not represented via _trie_ structure, but by original (wrapped) array, is that correct?  If so, when the conversion to tries is triggered - when some setter like `set()` is used?

Thanks!
 Thanks!
  In case anyone wants to kick the tires on this a bit, here's another pass at custom classes, actually with really great performance... this is the syntax:

``` js

// Note this is Immutable.Classes.Map not Immutable.Map
// This class is not meant to be called directly, but via the factory created below:
class UserClass extends Immutable.Classes.Map {
  fullName() {
    return this.get('first_name') + ' ' + this.get('last_name')
  }
}

// Make the Immutable factory
var User = Immutable.createFactory(UserClass)

// For better debugging, you can also create it with a named function:
// var User = Immutable.createFactory(function Immutable_User() {
//    UserClass.apply(this, arguments)
// }, UserClass)
```

Now you've got a nice new Immutable "User" type:

``` js
var u = User({first_name: 'Joe', last_name: 'User'})
var u2 = u.set('first_name', 'Jane')
u.fullName() // Joe User
u2.fullName() // Jane User
var u3 = u.set('first_name', 'Joe')
u3 === u // true
```

With the following guarantees:

``` js
u instanceof User // true
Immutable.Map.isMap(u) // true
u instanceof Immutable.Classes.Map // true

// false... though Immutable.Map() instanceof Immutable.Map is still true
u instanceof Immutable.Map 
```

Still a WIP, any feedback is appreciated!

@leebyron sent more details via email

/cc @janmarek, @vkurchatkin, @dandelany
 Cool @tgriesser thanks for the update! I will play with this branch when I have time.
 @tgriesser I has started to use this patch and it's awesome!
How do I change `constructor` here? I want:

``` js
var u = User({first_name: 'Joe', last_name: 'Green'})
// constructor changes arguments, and
// {first_name: 'cool Joe', last_name: 'Mr. Green'}
// will being received by Map
```

Can I do it? Thanks!
 I suppose you could provide a custom `__factory` implementation to handle that, but I don't see that as necessarily a good idea.
 This looks neat. Hopefully this lands.
 I like this too :+1: 
 Updated this against 4.0, even though apparently GH doesn't let you change the target branch in a pull request.

As fun as it's been to use in my own projects, I'm a bit wary this will open pandora's box a bit, people might start trying to do things with this that they really shouldn't be doing in general.

Wouldn't mind just keeping this as an upstream fork for awhile to see if anyone has other opinions or ideas.
 > In previous conversations you compelled me to include a metadata API which I think handles a lot of the cases that subclassing was desired for - and that's still on the docket.

Awesome to hear
 In my project on React.js I want to wrap certain data in type classes to perform strict datatype checking using `propTypes`. For example, to check if property `cargo` if array of `Cargo` I want to use:

```
propTypes: {
    cargos: PropTypes.arrayOf(PropTypes.instanceOf(Cargo))
}
```

But since all props came from store they must be considered as immutables. So, to typify raw data I intend to use this fork of ImmutableJS:

```
class Cargo extends Immutable.Classes.Map { }
```

Can you, please, comment on this pattern. Is it appropriate use of proposed feature or there exist simpler solution?
 Yes, you're right about propType custom validation functions. I can use it in my project, but how to handle situations with passing certain props deep into children components? For example, consider following structure:

``` jsx
class CargoList extends React.Component {
    render() {
        return <div>{this.props.cargos.map(cargo => <CargoItem cargo={cargo} />}</div>
    }
}

class CargoItem extends React.Component {
    render() {
        return <div>{this.props.cargo.getName()}</div>
    }
}
```

Note, that in `CargoList` component I have property holding array of `Cargo`-type objects, and in `CargoItem` component I expect the single `Cargo`-type property. As far as I understand React approach, first array should be treated as immutable array of immutable object. How to handle props validation on each components?

First method is to have a custom validation function. I can have some kind of `AppPropTypes.cargo` validator and use it in a way:

``` jsx
CargoList.propTypes = { cargos: React.PropTypes.arrayOf(AppPropTypes.cargo) }
CargoItem.propTypes = { cargo: AppPropTypes.cargo }
```

But this may be quite verbose. I need to maintain type structure both in creator and validator. 

Much plainer might be to validate props by their types using `React.PropTypes.instanceOf`:

``` jsx
CargoList.propTypes = { cargos: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Cargo)) }
CargoItem.propTypes = { cargo: React.PropTypes.instanceOf(Cargo) }

// somewhere in store
_cargos = update(_cargos, { $push: new Cargo(data) })
```

Where `Cargo` extends Immutable Record.

Am I correct in my conclusions or I'm going totally misconcept?
   Removing parentheses around URLs.
  The Record documentation in the API docs is rather incomplete. I had to look at the source to find out that Record has a "merge", which is very handy if you are extending record with other immutable methods -- I had implemented a "clone" method to do that before I realized merge was actually available.
 +1
 +1

Records are of great use, but the doc is incomplete. The records are convertible to maps using Immutable.Map(record) and then I have a rich world of full-featured interface.
 Yes, Record has some advantages over Map, but then appears to have barely any methods.
 Same here. I went digging around in the source and discovered that it inherited a lot from `Map`.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 Any update on this? The Record docs still seem to be a bit lacking
 Hi @leebyron 

I found what was the problem with the doc generator and fixed it here #1229
  I tried to add some methods to the Cursor API because they are missing. This solves #346.

I'm not sure if this is the right way to do it, because all other methods extend both KeyedCursorPrototype and IndexedCursorPrototype and this only extends IndexedCursorPrototype. So all feedback is more then welcome!
 This is big for me, really hinders ability to use of cursors until this is fixed! :+1: :+1: 
 @natew If there are other methods that are missing, let me know, I'm happy to implement them too.
 wow, this is so great, exactly the things I need. Can't wait for it
 I'm not sure how to push regular JS items onto an immutable cursor List, this doesn't work:

``` js
immutableStore.push.apply(null, jsarray);
```

I've tried a few variations I keep getting:

``` js
Possibly unhandled TypeError: Cannot read property 'updateIn' of undefined
    at updateCursor (webpack:///./~/immutable/contrib/cursor/index.js?:279:37)
```
 @natew can you give a full testcase? Somewhere as a gist or something?
  Immutable.js advertises that it has cursor support in its changelog, and I've seen references to it elsewhere like in Omniscient, but documentation for the cursor implementation is difficult to find. Basically it seems to live in a README file only reachable through github and is very minimal:

https://github.com/facebook/immutable-js/tree/master/contrib/cursor

The API documentation doesn't seem to get published anywhere.

I took it from another issue that Cursor support is still experimental (maybe; the issue is a few months old..), though I don't see the documentation saying even that. 

Finally a note about contrib you are free to ignore. I myself am critical about making something live in the limbo of "contrib":

http://blog.startifact.com/posts/against-contrib.html

In this case, if cursor support is indeed still experimental, instead of trying to signal that obscurely by placing the code in "contrib", publish documentation about it in the normal place for Immutable.js and then say it's still experimental there.
 The API/code seems pretty easy to read once you grokked the Immutable library (hint: every type pretty much have the same methods): https://github.com/facebook/immutable-js/blob/master/contrib/cursor/index.d.ts

I agree that it's considered "experimental". To elaborate, it's not battle tested. There's consideration for a custom cursor implementation or something that extends Immutable cursors to add usable features: https://github.com/omniscientjs/immstruct/issues/41
 My point is that its documentation should be part of the public documentation, with an 'experimental' marker on top if it's experimental. That's a lot more clear than putting code in a contrib directory of unclear status and telling people to read the code.

According to the immstruct issue @leebryon isn't interested in maintaining this code. If indeed nobody is willing to maintain it, I'd argue it shouldn't be in Immutable.js in the first place, but in some other package, where someone else can take over maintenance. It being in contrib sounds like the worst place for it to be in; nobody external can take over its maintenance, and it's just going to sit there in limbo status.

I'm only starting to explore immutable.js, and it took me a while to _find_ the code; I expected this to be part of the documentation. I looked left and right for documentation on cursors in the Immutable.js docs, but found nothing, even though the changelog makes mention of it.
 > According to the immstruct issue @leebryon isn't interested in maintaining this code.

Is that really the case? It would be nice if @leebyron could confirm this.
If it is really the case, I agree with @faassen and believe that a different package with a different maintainer would be a nice thing to do.

I'm in the middle of exploring cursors for some of my applications and it would be nice to know what's the official status is.
 From the changelog of [v3](https://github.com/facebook/immutable-js/wiki/Upgrading-to-Immutable-v3#cursors-in-contrib):

> Cursors are no longer part of the core Immutable library, however the existing implementation lives on as the first addition to the contrib/ directory. (...) The included Cursor implementation does not deserve first-class treatment. I hope to see this open up development of other state-management APIs. The included implementation of Cursor has no internal dependencies, illustrating how you can extend Immutable in your own libraries.

So @leebyron hasn't said that he won't maintain Cursors anymore (as he has maintained them until now), but rather that the community could take more initiative to shape the future for it, as the library is really only a 250-line wrapper.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  To reproduce just run:

```
const C = Immutable.Record({
    size: undefined
});

var a = new C({});
var b = new C({});

Immutable.is(a, b);
```

Expected: it must run well

Actual: it fails with `Uncaught TypeError: undefined is not a function` which points to this line: https://github.com/facebook/immutable-js/blob/master/dist/immutable.js#L3885

```
if (a.size === undefined) {
  if (b.size === undefined) {
    a.cacheResult(); // <--- this line
  } else {
    flipped = true;
    var _ = a;
    a = b;
    b = _;
  }
}
```
 I've taken a quick look at this. The problem is that the supplied size key is clobbering the size key that immutable-js is adding to the prototype. This throws if set to undefined, but if it was set to a valid size (that is not the actual size of the collection) it could cause a bunch of more subtle errors. I don't have any good ideas here. Maybe the best thing is disallowing the use of size as a key name for Record Types?
  Currently you can create cursor to a primitive which is quite awkward as it implements same API as cursors to immutable structures but then does not quite works & in general tends to be confusing since actual underlying type interface and resulting cursor interface do not match.

I would suggest to either throw if cursor points to a primitive or just return primitive and dump a warning suggesting to use .get instead to get primitives.
 Agree, meeting the same problem.

If cursor points to a primitive, there's no way to update it directly right now, even with `withMutations`. Exceptions would be thrown because the primitive types like strings, don't have the same API with cursor or immutable collection, definitely a bug here.

Also considered with the API suggested in #249, I would suggest add a new cursor type like `PrimitiveCursor` to deal with primitive types and put the `set(value)` API there, and it doesn't need the same API with KeyedCursor or IndexedCursor.
  Omniscient (http://omniscientjs.github.io) that is react interface that embraces immutable.js and cursors provides custom implementation of `shouldComponentUpdate` to avoid re-renders unless where not necessary. Although it's implementation instead of differing comparison to `.equals` seems to prefer reference checks (you can ifnd relevant discussion https://github.com/omniscientjs/omniscient/issues/76).

I do believe there is an assumption that letting .equals run comparison on non-equal data structures may end up costing more than just re-triggering re renders.

I was assuming hashes were calculated during `.equals` but I was wrong, which got me thinking if there is a way to reuse comparison done on the root components for components down the pipe. What I mean if update has happened 10 level deep in the data structure, it will likely end up traversing same structure several time to do same comparison over, would be nice if somehow first traversal could be reused to optimise subsequent comparisons.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 +1 I would expect hashes to be calculated in stead of all attributes being processed each and every time. Should make a huge difference.
  Hey,

This is more of a question than an actual issue, I might be getting things backwards.

If I have a snippet like this:

```
var items = Immutable.List([1,2,3]);

var filtered = items.filter(() => true); // filter matches all items, list is unmodified

// this doesn't work
filtered === items // should be true? But it is false

// while this works
Immutable.is(filtered, items) // this is true
```

So - is this a bug or am I missing something very obvious?
 It's not necessarily a bug. It's just a bit confusing. Unless changing this behaviour would improve performance, I don't think it'll be changed.

See #305 for another discussion about this. Also #335 and #216.
 I think the documentation is confusing this issue by showing reference equality after certain transformations. While reference equality is much faster than value equality calculation by other means, consumers shouldn't depend on it.

In the filter example, providing reference equality after a no-op filter would involve a trade-off that (I suspect) is worse most of the time. Filters are performed lazily, so when you compare `filtered === items`, the filter hasn't actually been "applied."

To figure out if the filter is a noop, the library would need to run the filter eagerly on each element, which would break the laziness/stream-like performance characteristics we currently enjoy.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Good day!

Can I set a listener to observe object's updates?

Thanks.
 They has no updates but they are (re)`set`ed :smile:

@leebyron I want something like https://github.com/Raynos/observ-struct
 Maybe. But is it for parts? Why?

Maybe https://github.com/omniscientjs/immstruct. Don't know.
 @kuraga `immstruct` is your way to go as an initial implementation to observing by paths/cursor has been implemented: https://github.com/omniscientjs/immstruct/pull/30

Observing by `Cursor.from` is limited in some capacity where you won't be able to detect changes of a `keyPath` if an ancestor has changed its subtree. 

This is also handicapped in `immstruct`, as there are event capturing semantics to consider (cursor event capture/bubbling). See: https://github.com/omniscientjs/immstruct/issues/37

I'm experimenting this externally, and will eventually working towards a PR to revamp observation on cursor references.
 @Dashed thanks!
 @kuraga Maybe you are looking for this: https://github.com/steida/este-todomvc/blob/23601e1f9460327bd05b0b90643029900e8fdcf3/src/lib/state.js
 Yeah, nice idea! Just wrap it up!
 Take a look at whole Este.js TodoMVC demo. It's full of ideas ;-)
 @steida I want (just for fun as an academic aim) make something like https://github.com/Raynos/mercury but with more mainstream libraries (as such as `immutable-js`) :smile: 
 Este.js TodoMVC consists of only mainstream libraries. steida/este will be deprecated soon (today I hope).
 P.S. The answer was to use `Cursor`s. Thanks to everybody!
  Hello!

Thanks for a great lib! We've just started using it.

Could you please add links to each heading of the docs? E.g. say I wanted to link to the `set(at, val)` in `List()`; with github READMEs I can just find the link next to the heading -- could you do something similar?

It would help me share docs with my team! =)

Thanks again for the library!
Henrik
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 Hi @leebyron I am new to immutable code base. I am giving this a try. hopefully i read the problem correctly. please let me know if this pr needs any update. Thank you!    The typo I picked up was on List#min():

Returns the **max**imum value in this collection. If any values are comparatively equivalent, the first one found will be returned.
min(comparator?: (valueA: V, valueB: V) => number): V

The secondary concern I noticeed was that I tried briefly to navigate to the master copy, fork, change it, and issue a pull request. But I couldn't immediately find where 
 Sorry, dumb me hit the wrong button.

I couldn't immediately find where to navigate to the file in question; perhaps facebook / immutable-js / docs could be created with a stub saying "If you want to change the docs, they're over at _______."
 Thanks!

On Mon, Mar 2, 2015 at 2:44 PM, Lee Byron notifications@github.com wrote:

> Hey @JonathanHayward https://github.com/JonathanHayward thanks for the
> report.
> 
> For future reference, if you scroll to the bottom of any of the pages in
> the docs, there's a red box explaining that they are autogenned with links
> to the relevant files.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/issues/354#issuecomment-76816073
> .

## 

[image: Christos Jonathan Seth Hayward] http://jonathanscorner.com/
Jonathan S. Hayward, a full stack web developer with Python/Django and
AngularJS/jQuery.

Articles on Technology http://jonathanscorner.com/technology/ â€¢ Book: _Django
JavaScript Integration_
http://www.packtpub.com/django-javascript-integration-ajax-and-jquery/book
 â€¢ _Email jsh@jsh.name_ â€¢ Github http://github.com/JonathanHayward â€¢
LinkedIn http://www.linkedin.com/in/jonathanhayward â€¢ Main Website
http://jonathanscorner.com/ â€¢ _Professional Site http://jsh.name/_

I invite you to visit my professional site! http://jsh.name/
  **Version:**
3.6.2

**Bug:**
Stack should return the last value when `last()` is called.

**Example:**

``` javascript
var l = Immutable.List([1, 2, 3, 4]);
var s = Immutable.Stack(l);
s.first(); // 1
s.last(); // undefined
s.size; // 4
s.get(3); // 4
```
 I checked the docs, and it mentions both `first()` and `last()` functions for Stack. However, there are no special notes that state that `last()` should behave differently for the Stack object. Can you clarify if it is intended that Stack should not return a `last()` value?
  Hi!

Just started to play with Immutable, and I'm wondering why this line is returning me `undefined`:
`I.Repeat('I love').interleave(I.Repeat('doge')).get(3)`

And not `'doge'` instead?

Cheers
 No worries :)
It seems that `interleave` is not part of the documentation anymore though. Is it going to be added back? 
  Hello!
In JS we often have some entity models. For example, User.
We have User constructor and some helper methods in it prototype. So, creating myUser instance, we get object with data and methods.
Is it possible to do something like that with Immutable? Record looks suitable, but I have feeling something wrong here: is it right to have functions in it as methods?
 I got you.
Now I think, do we need inheritance as in example? 

```
class ABRecord extends Immutable.Record({ a:1, b:2 }) {
  getAB() { return this.a + this.b; }
}
```

Perhaps enough to extend prototype of created record class (prototype is created together with the creation of class)?  Less intermediate objects in property resolution.

```
var ABRecordClass = Immutable.Record({ a:1, b:2 });
ABRecordClass.prototype.getAB  = () => { return this.a + this.b;  }
var ABRecord = new ABRecordClass();
```
 Perhaps related: https://github.com/facebook/immutable-js/issues/334
 And this: https://github.com/facebook/immutable-js/issues/124
 @klimashkin, check #384 
  This does not work

``` javascript
var a,b,
a = new Immutable.Map();
b = a.withMutations(function(_a){

// below code does not return this 
 _a.merge({x: 1});
});

console.log(b.get('x')); // undefined
```

below code works fine

``` javascript
var a,b,
a = new Immutable.Map({x:1});
b = a.withMutations(function(_a){   
 _a.merge({y: 1});
});

console.log(b.toJSON()); // {x:1, y:1}
```
 +1
 Yes,  cursor has the same problem.

``` javascript

var Immutable = require('immutable');
var Cursor = require('immutable/contrib/cursor');


var a = Immutable.Map();
var c = Cursor.from(a, function onChange(next) {console.log(next)});
var b = c.withMutations(function(_c) {return _c.merge({x: 1})});
console.log(b);


var a1 = Immutable.Map({});
var c1 = Cursor.from(a1, function onChange(next) {console.log(next)});
var b1 = c1.withMutations(function(_c1) { return _c1.merge({x:1})});
console.log(b1);

var a2 = Immutable.Map({x: 1});
var c2 = Cursor.from(a2, function onChange(next) {console.log(next)});
var b2 = c2.withMutations(function(_c2) { return _c2.merge({y:1})});
console.log(b2);


//output
Map {}
Cursor {}

Map {}
Cursor {}

Map { x: 1, y: 1 }
Cursor { x: 1, y: 1 }
```
  How to convert to plain object only some keys from Map?
 Thanks, Lee!
  Suppose I have a map `m` defined like this:

``` js
var m = Immutable.Map({x:1});
```

then the following code snippet returns `true` as expected:

``` js
m === m.set('x', 1);
```

But, for some reason, this doesn't work:

``` js
m === m.set('x', 10).set('x', 1); // unexpected failure #1
```

and even weirder, nor does this:

``` js
m.set('y', 5) === m.set('y', 5); // unexpected failure #2
```

I have no experience with Clojure, and perhaps this stuff would be obvious to me if I did, but as a JavaScripter I think it would be great for the documentation to explicitly mention that this is what happens, and to provide an explanation of the rationale for this behaviour.

At present, I can only guess that failure case number 1 is too hard to do for more complex use cases, so it's avoided for all cases. As for failure case number 2, I'm baffled, and it almost makes me start doubt that there is any data structure sharing going on at all!
 Hi @leebyron,

Thanks for the very detailed response. I guess I just had some incorrect assumptions about what the structural sharing of immutable data using a trie actually looked like. I had supposed it involved a tree of information starting with a common shared root, where each addition involved the creation of a new branch, and where each modification involved the creation of a new branch from a different part of that common tree.

Were it modelled like this, then `m.set('y', 5) === m.set('y', 5)` would evaluate to `true`, as would `Immutable.Map({x:1}) === Immutable.Map({x:1})` since it would just involve the same modification to the same common root for all map data of `{}`.

I've tried Googling for a good explanation of the Clojure map trie data structure, but have struggled to find anything really comprehensive. Are you able to recommend a good resource, or would I need to read the source code?
 Hi @leebyron, I've just watched [a video of your excellent conference talk](https://www.youtube.com/watch?v=I7IdS-PbEgI) that perfectly explains the underlying data structures involved, and now I finally understand why it works the way it does :+1:. The trie isn't split based on the contents of the list or map, but is a densely packed data structure used to reduce the cost of structural data sharing mutations to O(log(N)).

It may make sense to link to this resource from the site where you discuss how it works and the emergent behaviour of this design.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 @leebyron Love this project. One thing related to the `===` is, is there no way to make strict equal work? Since all data structures are created via the `immutable` namespace, would it be possible at creation time, check a global cache (perhaps a weak map?), and see if the object already exists, if so, return a reference to the pre-existing object, rather than creating a whole new object?
  Automatically include all grunt dependencies `grunt-*` using **load-grunt-tasks**  instead of call `loadNpmTasks` for each one :)
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Currently the example in the `README.md` shows `assert(map1 === map2)`. This is confusing for readers since these two are not equal, but we `assert` that they are. This change adjusts the example to `assert` the reality.
 In this case the two are actually equal though, `map1.set('b', 2)` is a no-op because the value of `'b'` is already `2`, so it's just smart enough to return the same value.
 Of course my mistake thank you. I wonder if an inline comment wouldn't help to clarify that fact.
  I'm using the _babel/6to5_ transpiler and would like to be able to import each class separately instead of the Immutable namespace, like this:

``` javascript
import { List, Map, Record } from 'immutable'
```

This PR adds named exports in addition to the default export in `src/Immutable.js` (I also took the liberty of using of object shorthand notation for building the export objects).

Please note that #314 also needs to be solved before transpiling with babel is going to work again.
 I use the [ES6 Module Loader polyfill](https://github.com/ModuleLoader/es6-module-loader) to load modules that are transpiled to `System.register` format using babel (`babel --modules system`).

Using the current export today, trying to `import { Map } from 'immutable'` results in Map being undefined. The module loader polyfill handles circular bindings, but default exports can only be imported as `import x from 'module'`.

Using this PR and making sure classes are instantiated with `new`, I have no problems, however (except for the performance implications cf. #314 ).
 Esperanto will build a module exporting the Immutable namespace on `exports.default` and each class on `exports.Map` etc. I see how this might be a problem with interoperability.

As an alternative, I've pushed ba07e4c2394300838436186372c63a951e01ea08 which adds `interop.js` as the entry point for building the distribution, leaving `Immutable.js` to be imported if you use the source directly. `interop.js` exposes the Immutable namespace the same way the current distribution does it.

From babel/babel@3a11c7d46b5788175c9c1141ff50ed59ce26c40c forward it will be necessary to use `new` until the classes are replaced with regular factory functions.
 I'm using the source solely to get the named exports. Under normal circumstances I would indeed use the compiled distribution file.

But with this PR I can import the source until interoperability with cjs modules becomes unnecessary.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  The documentation mentions the existence of the [`size` property](http://facebook.github.io/immutable-js/docs/#/Collection/size) for `Collection` elements (that I understand as an equivalent to the `length` property of `Array` elements, as discussed on #236), but it doesn't say anything about it.

It also features a [`count()` method](http://facebook.github.io/immutable-js/docs/#/Collection/count) on `Collection` elements and from the documentation I do not understand when one should use `count()` over `size`.

What is the difference between these two? Could the documentation be updated with the answer?
 Thanks @leebyron! Does that mean that, in general, `count()` should be used instead of `size`?

My use case is in tests, when trying to assert how many elements are in my immutable collections should I test against `count()` or `size`?
 @leebyron wouldn't it be better if `Seq`s didn't have `size` property? It can lead to bugs and adds no substantial benefit.
 I agree with @hleumas. Developing a homogeneous API seems to me the best option. Even if the size property in Seq only works as an interface.  For React projects, I'm finding myself wanting to send down a subset of a record to a child component to avoid re-rendering when an unused attribute of that record is changed. Right now I am doing this like:

``` javascript
subset() {
    return Immutable.Map({
        prop1 : record.get('prop1'),
        prop2 : record.get('prop2'),
        prop3 : record.get('prop3')
    })
}
```

This is fairly straightforward, and I could probably generalize it further, but I'm curious if there is a more ergonomic way to achieve I want. For example, something similar to slice but for keys:

``` javascript
map.subset("prop1", "prop2", "prop3")
```
 Oh this is lovely!
 It completely slipped my mind that `filter` was applicable. Thanks!
 +1 of vanilla support. This feature is quite commonly used I feel and why should everyone implement their own `keyIn` filter function?
 +1 to @tusharmath's point. Asking everyone to copy and paste `keyIn` for a common use-case like pick violates DRY.
 Hi @leebyron, I was wondering why you won't consider adding vanilla support for this feature? I have seen quite a few people asked for it: https://github.com/facebook/immutable-js/issues/224 and https://github.com/facebook/immutable-js/issues/165

Like @tusharmath and @D1plo1d have said, it is a commonly used feature, and asking everyone to implement their own `keyIn` filter function violates DRY. 

Thanks in advance
 It's worth noting that the above solution (keyIn) only makes sense for _small_ Maps, as it has to iterate the entire thing. 

It is faster on small Maps, by about 50%, so definitely useful in some cases if you know the size of your map.

If you're using this on a large map of (for example) normalized entries, it's way slower than mapping the keys directly to the object. Using BenchmarkJS with a 1000 key map of random string keys (`TEST_MAP`), and an array of 5 random keys in that map (`TEST_SET_OF_KEYS`),  and this code... 

```
var keysToPick = TEST_SET_OF_KEYS;
var data = Immutable.Map(TEST_MAP);
function keyIn() {
  var keySet = Immutable.Set(arguments);
  return function (v, k) {
    return keySet.has(k);
  };
}

function pickUsingKeyIn() {
  return data.filter(keyIn.apply(null, keysToPick));
}

function pickUsingMap() {
  var keySet = Immutable.Set(keysToPick).toMap();
  return keySet.map(function(key) {
    return data.get(key);
  });
}
```

this is the output

```
[ '7ahFz', '69REj', 'ZURMt', '3AZDL', 'EAzmg' ]
Map { "7ahFz": "JPQ66", "69REj": "dUnQb", "ZURMt": "z4OSR", "3AZDL": "EYxkS", "EAzmg": "kEHL5" }
Map { "7ahFz": "JPQ66", "3AZDL": "EYxkS", "69REj": "dUnQb", "EAzmg": "kEHL5", "ZURMt": "z4OSR" }
Using Predicate for Filter to Pick x 3,312 ops/sec Â±1.59% (72 runs sampled)
Using Map to Pick x 81,357 ops/sec Â±2.17% (64 runs sampled)
```
  When using records in TypeScript, it would be nice to define an interface declaring the properties. We can then access those properties, instead of going through the `get` method. This cleans up code and catches typos at compile time.

``` typescript
interface Customer extends Map<string, any> {
  id: string;
  name: string;
}

var CustomerRecord = Immutable.Record<Customer>({ id: "", name: "" });

var customer1 = new CustomerRecord({ id: "1", name: "John" });

alert(customer1.id);
customer1 = customer1.set("name", "Jon"); // Can still use as a Map
alert(customer1.wrong); // Compile-time error here
```

To achieve this, the `Record` function and interface declaration need to be made generic:

``` typescript
export module Record {
  export interface Class<T extends Map<string, any>> {
    new (): T;
    new (values: { [key: string]: any }): T;
    new (values: Iterable<string, any>): T; // deprecated
  }
}

export function Record<T extends Map<string, any>>(
  defaultValues: { [key: string]: any }, name?: string
  ): Record.Class<T>;
```

Thoughts?
 I just realised a problem. Calls to `.set`, etc, return a `Map<string, any>` not the subtype. To fix I created a new interface to extend from.

```
interface TypedMap<T extends Map<string, any>> {
  set(key: string, value: any): T;
  // ...plus all the other methods of Map...
}
```

Then

```
interface Customer extends TypedMap<Customer> {
  ...
}
```

A bit hacky, but seems to work!
 That would be this issue, which would allow functions on a base interface to return the type of its derived interface:
https://github.com/Microsoft/TypeScript/issues/285

However, I think the following issue, which would allow you to extend a generic type, would help the Record interface be defined significantly better than the current approach:
https://github.com/Microsoft/TypeScript/issues/2225

Then you can do:

``` typescript
interface RecordClass<T> extends T, Map<Set, Any> {
}
```

Where RecordClass<T> (excuse the naming) would allow you to call all of the functions you expect on a record (such as .set(), etc) while still allowing you to access all of the properties in T using dot notation. Then the rest of the interface would look as follows:

``` typescript
export module Record {
  export interface Class<T> {
    new (): RecordClass<T>;
    new (values: T): RecordClass<T>;
  }
}

export function Record<T>(
  defaultValues: T, name?: string
  ): Record.Class<T>;
```

This would be nicer than the proposed approach because the defaultValues and values arguments can now be type-checked against T, the 'Customer' interface shown in the first comment no longer needs to extend anything, and the resulting code will be clearer as all Record types are explicitly marked as such.
 @andrewdavey did you end up using typed maps instead of records as in your last post? Using maps kinda gets rid of the benefits of types as you have to use a string with .get and set (too bad javascript can't overload that)
Your first post looks like a nicer solution to me.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 With typescirpt 1.6 and intersection types (see https://github.com/Microsoft/TypeScript/pull/3622) it is possible to significantly improve typings for Records. Here is simple POC:

typings

``` typescript
  export module Record {
    type IRecord<T> = T & TypedMap<T>;

    interface TypedMap<T> extends Map<string, any> {
      set(key: string, value: any): T & TypedMap<T>
    }

    interface Class<T> {
      new (): IRecord<T>;
      new (values: T):  IRecord<T>;

      (): IRecord<T>;
      (values: T): IRecord<T>;
    }
  }

  export function Record<T>(
    defaultValues: T, name?: string
  ): Record.Class<T>;
```

test

``` typescript
import { Record } from 'immutable';

const MyType = Record({a:1, b:2, c:3});

var t1 = new MyType();
const a = t1.a;

// type error
const z = t1.z;

const t2 = t1.set('a', 10);
const a2 = t2.a;

// type error
const z2 = t2.z;

const t3 = t2.clear();
```

Also polymorphic this type will be available in 1.7, it is already in master (see https://github.com/Microsoft/TypeScript/pull/4910)
 @aindlq - That's fantastic! By renaming the "Class" interface to avoid naming conflicts with the existing immutable.d.ts, I was able to include your sample in an "immutable-overrides.d.ts" file without having to modify the provided immutable.d.ts and then maintain my customizations.

``` typescript
/// <reference path='../../node_modules/immutable/dist/immutable.d.ts'/>

declare module Immutable {
    export module Record {
        type IRecord<T> = T & TypedMap<T>;

        interface TypedMap<T> extends Map<string, any> {
            set(key: string, value: any): IRecord<T>
        }

        interface Factory<T> {
            new (): IRecord<T>;
            new (values: T): IRecord<T>;

            (): IRecord<T>;
            (values: T): IRecord<T>;
        }
    }

    export function Record<T>(
        defaultValues: T, name?: string
    ): Record.Factory<T>;
}
```

More importantly, it lets me do incredibly convenient things like this. Thanks!

``` typescript
/// <reference path='../../typings/immutable/immutable-overrides.d.ts'/>
import Immutable = require('immutable');

export interface Todo {
  id?: number;
  text: string;
  completed: boolean;
};

export type TodoList = Immutable.List<Immutable.Record.IRecord<Todo>>;

export const TodoRecord = Immutable.Record<Todo>({ text:'', completed: false, id: -1 }, "Todo");
```
 Could we get these new type definitions for `Record` added and documented?
 This type definitions cause another problem with extending:

```
interface ModelAttrs {
  id: string;
}

class Model extends Record<ModelAttrs>({ id: null }) {
  ...
}
```

Error: `error TS2509:  Base constructor return type 'ModelAttrs & TypedMap<ModelAttrs>' is not a class or interface type.`
 Record inheritance works since TypeScript 1.6 has been released. #166 
 With extending expressions from 1.6 and polymorphic `this` from 1.7 the temporary typings can be:

```
declare module Immutable {
  export function Record<T>(defaultValues: T, name?: string): Record.Factory<T>;

  export module Record {
    interface Base extends Map<string, any> {
      set(key: string, value: any): this;
      // ...
    }

    interface Factory<T> {
      new (): Base;
      new (values: T): Base;
      (): Base;
      (values: T): Base;
    }
  }
}
```

Before:

```
interface BaseAttrs {
  id: string;
}

type BaseRecord = Record.IRecord<BaseAttrs>;

interface TodoAttrs extends TodoAttrs {
  name: string;
}

const TodoRecord = Record<TodoAttrs>({
  id: null,
  name: null
})

type Todo = Record.IRecord<TodoAttrs>;

// no support for custom methods

function foo<T extends BaseRecord>(m: T) {
  // ...
}

function bar(todo: Todo) {
  // ...
}

var m = new TodoRecord(...)

m.name; // ok

foo(m); // ok
bar(m); // ok
```

After: 

```
interface BaseAttrs {
  id: string;
}

type BaseRecord = BaseAttrs & Record.Base;

interface TodoAttrs extends TodoAttrs {
  name: string;
}

class Todo extends Record<TodoAttrs>({ id: null,name: null }) implements TodoAttrs {
  id: string;
  name: string;

  // some additional methods

  lowerName(): string {
    return this.name.toLowerCase();
  }
}

// type alias isn't required for Todo

function foo<T extends BaseRecord>(m: T) {
  // ...
}

function bar(todo: Todo) {
  // ...
}

var m = new Todo(...)

m.name; // ok
m.lowerName(); //works
m = m.set("name", "...");
m.lowerName(); // still works

foo(m); // ok
bar(m); // ok
```

The bad moment in this approach is that we should explicitly declare properties in a record class.
 Should we at least make a PR for an updated .d.ts for use in typescript 1.7 ?
 @Keats - the challenge is that upgrading the type definition it immediately loses backwards compatibility with earlier TypeScript versions pre 1.7. So the version of the type definition that ships with the package will have to be compatible with the earliest version of TypeScript we want to support.

See [this related discussion](https://github.com/typings/typings/issues/49). I'm going to try and get a typings version of the ImmutableJS type definition up and running soon that is appropriate for 1.7 (and another with the changes introduced in 1.8)
 In the proposed Record definition above, one can't supply only some of the  properties to the Record Factory. Records are supposed to fill in missing defaults, so this doesn't seem ideal.

The following line from the definition of `Record.Factory` makes it so that we have to specify all required properties when creating a new with a record factory.

``` typescript
new (values: T): IRecord<T>;
```

For example, the following has a type error of `Property 'b' is missing in argument of type '{a: number}'`

``` typescript
import * as Immutable  from 'immutable';

interface Test {
  a: number,
  b: string
}

const TestFactory = Immutable.Record<Test>({a: 2, b: 'hiya'});
const TestRecord = TestFactory({a: 10});
// There's now an error in the call to TestFactory that says
// "Property 'b' is missing in argument of type '{a: number}'
```

We can make the `Record.Factory` take `{values: any}` and that gets rid of the error, but I'm not sure if that's desired. It does seem that this would fit the actual behavior of Immutable.js, because its record class just discards any undefined properties passed to the constructor. For example:

``` javascript
const Immutable = require('immutable');

const TestRecordFactory = Immutable.Record({apple: 'yum', potato: 'meh'}, 'TestRecord');
const testRecord = TestRecordFactory({somethingElse: 'wah?'});
console.log(testRecord.toJSON())
// => {apple: 'yum', potato: 'meh'}
```

I'm new to typescript and static typing in general, so I have no idea about any of this. Any ideas on how to make the new Record definition support this part of the Immutable Record api?

The new definition with any would be:

``` typescript
/// <reference path='../../node_modules/immutable/dist/immutable.d.ts'/>

declare module Immutable {
    export module Record {
        type IRecord<T> = T & TypedMap<T>;

        interface TypedMap<T> extends Map<string, any> {
            set(key: string, value: any): IRecord<T>
        }

        interface Factory<T> {
            new (): IRecord<T>;
            new (values: any): IRecord<T>;

            (): IRecord<T>;
            (values: any): IRecord<T>;
        }
    }

    export function Record<T>(
        defaultValues: T, name?: string
    ): Record.Factory<T>;
}
```
 Is it possible to have something like a TypeScript interface but using immutable-js? I don't think `Record` is exactly the same because it requires default values. I don't want default values, I just want an immutable object defined by an interface. At least I think that's what I want.
 @OliverJAsh - we use code generation of classes that are backed by ImmutableJS data structures to achieve what I believe you're referring to. i.e. we first define the structure we want (what you're referring to as an interface), then we code generate the actual implementation. 
 I'm not sure I understand. Do you have an example?

On Tue, 12 Jan 2016, 16:32 Paul Jolly notifications@github.com wrote:

> @OliverJAsh https://github.com/OliverJAsh - we use code generation of
> classes that are backed by ImmutableJS data structures to achieve what I
> believe you're referring to. i.e. we first define the structure we want
> (what you're referring to as an interface), then we code generate the
> actual implementation.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/issues/341#issuecomment-170966230
> .
 @OliverJAsh yes, thats exactly what I'm looking for as well. @myitcv can you explain what you mean? I can't imagine how you generate classes with ImmutableJS as the base.
 @SH4DY I'm assuming @myitcv uses something like [s-panferov/tsimmutable](https://github.com/s-panferov/tsimmutable)
 @jmreidy thanks for the link, I'll give that a closer look.

@SH4DY from a brief look at `tsimmutable` there is some similarity to our approach. `tsimmutable` uses TypeScript interface definitions as the basis for its code generation (e.g. the `Profile` and `User` interfaces in the [examples](https://github.com/s-panferov/tsimmutable#example)). We use [Protocol Buffers](https://developers.google.com/protocol-buffers/). 

Fundamentally however it doesn't matter what your starting point is, just so long as you can describe the structure of your types.

So let's take the `Profile` example from the `tsimmutable` project:

``` typescript
export interface Profile {
    firstName: string;
    lastName: string;
}
```

From this we code generate a class with the following interface (you can see how we adopt a similar pattern to that used on the ImmutableJS containers):

``` typescript
export declare class Profile implements IUnmarshaler {
    static NewProfile(): Profile;
    static NewFromJSON(json: Object): Profile;
    SetFirstName(vFirstName: string): Profile;
    FirstName(): string;
    SetLastName(vLastName: string): Profile;
    LastName(): string;
    toString(): string;
    AsMutable(): Profile;
    AsImmutable(): Profile;
    WithMutations(cb: (a: Profile) => void): Profile;
}
```

_Notice that with the merging of https://github.com/Microsoft/TypeScript/pull/6532 it is possible to translate the accessor methods to readonly getters_

The underlying implementation behind each such class uses an ImmutableJS `Map<string, Object>` to store the value of each field (`firstName` and `lastName` in this example). We did this principally for reasons of efficiency (memory and CPU) but to be honest we never got round to quantifying this statement so take it with a large pinch of salt!

The simplest underlying implementation however would be a plain object based approach, e.g. ([playground link](http://www.typescriptlang.org/Playground#src=class%20Profile%20%7B%0A%09private%20firstName%3A%20string%3B%0A%09private%20lastName%3A%20string%3B%0A%09%0A%09FirstName%28%29%3A%20string%20%7B%0A%09%09return%20this.firstName%3B%0A%09%7D%0A%09%0A%09SetFirstName%28vFirstName%3A%20string%29%3A%20Profile%20%7B%0A%09%09let%20res%3A%20Profile%20%3D%20shallowCopy%28this%29%3B%20%0A%09%09res.firstName%20%3D%20vFirstName%3B%0A%09%09return%20res%3B%0A%09%7D%0A%0A%09LastName%28%29%3A%20string%20%7B%0A%09%09return%20this.lastName%3B%0A%09%7D%0A%09%0A%09SetLastName%28vLastName%3A%20string%29%3A%20Profile%20%7B%0A%09%09let%20res%3A%20Profile%20%3D%20shallowCopy%28this%29%3B%20%0A%09%09res.lastName%20%3D%20vLastName%3B%0A%09%09return%20res%3B%0A%09%7D%09%0A%7D%0A%0Afunction%20shallowCopy%3CT%3E%28v%3A%20T%29%3A%20T%20%7B%0A%09let%20res%20%3D%20new%20Object%28%29%3B%0A%09for%20%28let%20i%20in%20v%29%20%7B%0A%09%09res%5Bi%5D%20%3D%20v%5Bi%5D%3B%0A%09%7D%0A%09return%20%3CT%3Eres%3B%0A%7D%0A%0Alet%20p1%20%3D%20new%20Profile%28%29%3B%0Alet%20p2%20%3D%20p1.SetFirstName%28%22Paul%22%29%3B%0Alet%20p3%20%3D%20p2.SetLastName%28%22Jolly%22%29%3B%0Aconsole.log%28p1%2C%20p2%2C%20p3%2C%20p1%20%3D%3D%3D%20p2%2C%20p1%20%3D%3D%3D%20p3%29%3B):

``` typescript
class Profile {
    private firstName: string;
    private lastName: string;

    FirstName(): string {
        return this.firstName;
    }

    SetFirstName(vFirstName: string): Profile {
        let res: Profile = shallowCopy(this); 
        res.firstName = vFirstName;
        return res;
    }

    LastName(): string {
        return this.lastName;
    }

    SetLastName(vLastName: string): Profile {
        let res: Profile = shallowCopy(this); 
        res.lastName = vLastName;
        return res;
    }   
}

function shallowCopy<T>(v: T): T {
    let res = new Object();
    for (let i in v) {
        res[i] = v[i];
    }
    return <T>res;
}

let p1 = new Profile();
let p2 = p1.SetFirstName("Paul");
let p3 = p2.SetLastName("Jolly");
console.log(p1, p2, p3, p1 === p2, p1 === p3);
```

The efficiency of this plain and simple approach vs an ImmutableJS approach will depend on many factors: how many mutations you perform, size (in terms of number of fields) of classes.... the list goes on. Again, measuring would be the only concrete way to demonstrate efficiency one way or the other.

We'll likely be sharing some of our tooling around this in the next couple of months, so I'll try to remember to update this thread in case anyone is interested.
 @jessep - to make your properties optional, change your interface declaration:

``` typescript
interface Test {
  a?: number,
  b?: string
}
```
 @silhouettes I've done something very similar that handles the usage of Immutable records with TypeScript interfaces
@andrewdavey @OliverJAsh this works in a clean way while we don't have immutable Records working smoothly with typescript
https://github.com/rangle/typed-immutable-record
the repo has code with examples, it's a very tiny library and the only downside since I'm just wrapping around immutable is that you need two interfaces, but I'm using it everywhere and it provides a huge benefit.
 I found a class to get prop name as string array, then implemented a SetValue Method this has some rough edges.

``` typescript
export class NavigableObject<T>{
    constructor(private obj: T, private path: string[] = []) { }

    To<R>(p: (x: T) => R): NavigableObject<R> {

        let propName = this.getPropName(p)

        if (propName) {
            return new NavigableObject<R>(
                p(this.obj),
                this.path.concat(propName)
            );
        } else {
            return new NavigableObject<R>(
                p(this.obj),
                this.path
            );
        }
    }

    getPath() {
        return this.path;
    }


    private static propertyRegEx = /\.([^\.;]+);?\s*\}$/;

    private getPropName(propertyFunction: Function) {
        let value = NavigableObject.propertyRegEx.exec(propertyFunction.toString())
        if (value)
            return value[1];
    }
}

function NavigatableRecordFactory<X>(defaultValues: X, name?: string) {
    abstract class NavigatableRecord<P extends NavigatableRecord<P>> extends Record(defaultValues, name) {
        SetValue<T>(fn: (x: NavigableObject<P>) => NavigableObject<T>, value: T) {
            return this.setIn(fn(new NavigableObject<any>(this)).getPath(), value)
        }
    }
    return NavigatableRecord;
}

interface IUSER {
    Name: string;
    Age: number;
}

export class USER extends NavigatableRecordFactory<IUSER>({
    Name: "Simy the bothless",
    Age: 27,
})<USER> implements IUSER {
    Name: string;
    Age: number;
}
```

and then use it like 

``` typescript

state.Name // works

state.SetValue(t => t.To(q => q.Name), "test string") // typecheks
state.SetValue(t => t.To(q => q.Name), 123) // error
```

it also works with nested properties 

``` typescript
somenestedImmutable.SetValue(t =>t.To(q => q.Date).To(q => q.Time), 213213123)
```

but cant get it work without needing to implement method in child class ,
little help would be nice if it is possible :)

[Typescript v.2.1.0-dev20160805](https://libraries.io/npm/typescript/2.1.0-dev.20160805)
 @aalpgiray looks like a syntax error in `somenestedImmutable.(t => ...` ?
 fyi I tried with latest release immutable beta rc and no luck
```

interface ITimelineState {
    zoom: number;
    duration: number;
    channels: Array<IChannels>;
    outputs: Array<IOutputs>;
    items: Array<IItem>;
}

let state: Map<any, ITimelineState> = Map({ // <<<< ERROR
        zoom: 1,
        duration: 500,
        channels: [],
        outputs: [],
        items: []
    });
``` 4.0.0-rc.2 as issues in itself atm, e.g.

> ERROR in .../node_modules/immutable/dist/immutable-nonambient.d.ts (2331,22): Interface 'Keyed<K, V>' cannot simultaneously extend types 'Seq<K, V>' and 'Keyed<K, V>'.
>  Named property 'size' of types 'Seq<K, V>' and 'Keyed<K, V>' are not identical.

> ERROR in .../node_modules/immutable/dist/immutable-nonambient.d.ts (2441,22): Interface 'Indexed<T>' cannot simultaneously extend types 'Seq<number,T>' and 'Indexed<T>'. Named property 'size' of types 'Seq<number, T>' and 'Indexed<T>' are not identical.

etc.

3.8.1 also has issues with types on Records for .set

````ts
const SectionRecord = Record(createInitialState());
export class Section extends SectionRecord implements ISectionState {
    defaultHypo: DefaultHypo;
...
}
...
const newSection = section.set('defaultHypo', newDefault);
````
`newSection` here is actually not a new instance of `SectionRecord`, but a `Map<string, any>`. Same issue for all my typed Records.  Should `withMutations()` offer a `context` parameter, so that `this` can be set in the context of the `mutator`?
i.e.

```
  withMutations(mutator: (mutable: Map<K, V>) => any): Map<K, V>
```

becomes:

```
  withMutations(mutator: (mutable: Map<K, V>) => any, context?: any): Map<K, V>
```

to match signatures such as `Map:map()`

```
map<M>(
mapper: (value?: V, key?: K, iter?: Iterable<K, V>) => M,
context?: any
): Iterable<K, M>
```

Thanks
 I guess in the context of a React component's method, `this` is set to `window` inside `withMutations()`, preventing any other component's method from being called?  But reading more about the arrow function it appears its biggest benefit is that it does not alter `this`. Sorry, not completely used to ES6. Thanks for the pointer. Maybe for consistency with the sequence methods, it would a useful addition...
 :+1:  to this. I'm building a complex structure using `withMutations` and I have some generation code in helper methods. Having to use `bind(this)` everywhere when the rest of the Immutable.js methods take a context seems like it should be fixed.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  When creating a `Immutable.Map` and passing a object-map of integer keys it transforms the keys to strings, but when calling `map.set`, it does not transform the integer to string and instead creates a duplicate..

```
var items = Immutable.Map({ 1: "hi" })
console.log(typeof(items._root.entries[0][0]) === "string"); //= true (should be a number?)
items = items.set(2, "hello");
console.log(typeof(items._root.entries[1][0]) === "string"); //= false
```

Is this a issue? A solution is to use .toString() when calling `set` or `get`, but I think it is weird that it choose change the type in the first place..
  Wondering about the possibility of this. For now I am just doing data processing on the webworker, but seems like I need to pass back the raw JSON because immutable objects aren't stringify-able. Wondering, whats the feasibility of pushing all of the immutable stuff into a webworker given it needs to be able to be passed back as a string?
 I think one could use transit-js as mechanism to serialize/deserialize:
https://github.com/cognitect/transit-js
https://gist.github.com/Tvaroh/52efbe8f4541ca537908
 I thought the main problem would be that immutable collections have functions attached to them, which don't seem to be serializable. But typing that out makes me think that can't be right, you should be able to have the functions held separately. In the end it's all data.

@pedroteixeira that gist looks really interesting. Have you gotten it working? I already have webpack compiling requests inside webworkers working nicely, and immutable.js with flux (but not split into workers). If I could get the final piece (webworkers + immutable) I'd love to release a complete package that encompassed flux + immutable + webworkers + requests as a sort of super-data package for React.
 I was wondering today whether or not because of Relay/GraphQL there could be a increased need to serialize immutable data structures between client and server (as well as other use cases such as between webworkers mentioned here).   What would be interesting is to sync content between client and server, similar to how git does it.  Would there be a way to compares hashes between a local immutable structure and remote one and if they are different exchange content until they are the same.  With this approach the render immutable equality check for a component would essentially become *has any content changed in the graph I am interested in, locally or on the server".  I realize that the concern of Immutable.js is in memory persistent data structures in JavaScript but it's hard not to think about how fetching/syncing components, like those introduced with Relay, can radically change to be content aware when using immutable data.
 +1 for serialization/deserialization API, I guess I'll go with type+JSON dump of toJS() for now.
 +1 from me as well.
transit-js still uses JSON for the js implementation, so I'm not sure how well it would work.

Also, one big problem is that as soon as you serialise immutable data, you immediately lose all the benefits of structural sharing. I don't know nearly enough to be able to actually implement this, but the ideal way to pass data between the main thread and a web worker should work something like this:
1. Use SharedArrayBuffers to store all the data of an immutable data structure. (easier said than done. These array buffers are typed, and it will be really hard to store variable sized string etc.)
2. the immutable 'object' is just an object which stores the basic structures and indexes to the SharedArrayBuffer to know where to read what.
3. When passing data to a web worker, you can give it access to the sharedArrayBuffer and serialise and pass the immutable data structure that points to it.

Now, as long as no one directly tries to mutate the values on the Array Buffer, and uses the library, data will only be appended to Array Buffer and never mutated.

This would be essentially the same semantics as multi-threading in clojure. The one big difference here being that we pretty much need to manage memory manually. (because any shared memory needs to be in SharedArrayBuffers) Maybe there are implementations of immutable data in C/C++ that can be compiled using emscripten and a more strict version can be created. 

So I'm not sure if this is possible/feasible at all. But I wanted to write it down, just in case someone smart like @leebyron thinks its easy!

---

Some other ideas:
build an extension on top of JSON that has some sort of structural sharing built-in. (Falcor seems to be doing something similar) gzip takes care of duplicate data to a big extent, but it would be nice, never to have to generate a huge string in the first place
- TC39 should be pressured into accepting the proposal for immutable data in Javascript. Then we can put pressure to make passing these data structures to web-workers fast using memory sharing, since immutable data is read only, and hence, safe for multi-threading.

---

EDIT:
just to clarify why I want something like this so bad: when using immutable data to store undo history in a large app, it should be possible to save, transfer that undo history for later use. That is currently impossible, as there is no structural sharing when not in memory.
 I've just published an early version of a module which provides the transit integration https://github.com/glenjamin/transit-immutable-js

I believe transit does make it possible to support internal structural sharing when serialising, but I haven't attempted to look into this yet.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 +1
 > Today there is not a clear way to serialize and deserialize Immutable collections.

I'm actually looking to be able to write Immutable JS structures to disk, from an Electron app (in particular, the Jupyter/IPython notebook). This means I have a combined need of both streaming and serializing.

> I'm also considering adding a very simple serialization API to the library

@leebyron Is this still in the works to target for what I'm working on (release for us won't be a while).
 @rgbkrk Technically speaking you CAN serialize immutable data. You just can't serialize the structural sharing that you get with immutable. That is an extremely hard problem to solve and I wouldn't expect any resolution on that in the near future.
 As mentioned above, https://github.com/glenjamin/transit-immutable-js will take care of the glue code between this and transit.
 Transit looks like the right case for webworkers, though the format is not the raw JSON I need to write out. I actually want to keep the `toJS()` structure and write to disk with json.

Currently it looks like this:

``` javascript
fs.writeFile('plots.ipynb', JSON.stringify(notebook.toJS()), 'utf8', errCallback);
```

`notebook` above will end up being 10-25 MB at times
 Feel a little silly now that I've noticed that immutable objects can be passed straight to `JSON.stringify`. Thanks for bearing with me. It would be nice for me to be able to stream these directly to a file while being stringified; this will do though.
 Hm. I was hit by this recently :(

It's sad that immutable objects are hard to put to webworkers, when immutable objects (in principle) should be *easier* to share - no need to copy, deal with write access, etc.

What's funny is that I cannot even mark it as Transferable - in principle, immutable object should be Transferable by default :)

Yeah, I can serialize and deserialize, but that triples the memory. I have a large immutable.js object, I cannot afford to serialize and deserialize again, it takes a long time and too much memory. Again it's ironic, since immutability should *help* to run things in parallel. But in this case, it makes things go more complex :(

Maybe if immutable became first-class citizen in browser :D haha, probably not. ....and it seems @nmn had exactly the same ideas, in 2015. :D ok wontfix? :( ok then I don't think it is fixable with today's technology.  ``` javascript
let {Map} = require("immutable");

let data = Map({
  model: Map({
    username: "foo"
  })
});

console.log(data.get("model"));                            // Map { username: "foo" }
console.log(Map({username: "foo"}));                       // Map { username: "foo" }
console.log(data.get("model") === Map({username: "foo"})); // false
```
 This kinda defeat the whole principle...no? We already have _two different objects_ mantra in native JS. 
Why replicate the same clunky behavior in this library? I was sure immutability is about **values**, not **objects**.
 Ok, so if `===` doesn't work in all cases (and it's impossible to alias this currently), why it's presented in documentation along with `.is`. Why not just `.is` everywhere? I also saw `.equals` somewhere... 
I still think multiple ways to compare "immutable" objects, yielding different results, strongly go against the fundamentals. 
 It would be great, thanks!
  Is there a way to extend record classes? I do have a record class as a base and want to add more keys.

``` js
var MyRecord = Record({a: 1, b: 2});
var MyExtendedRecord = MyRecord({c: 3});
```
 Ok, good to know. Thanks!
 I was doing this:

``` js
var BaseRecord = function (defaultValues) {
  return Record(Object.assign({
      a: 1,
      b: 2
    }, defaultValues))
}

var ExtendedRecord = BaseRecord({ c: 3 })
```

I think that works.
 ``` javascript
import { Record } from 'immutable'

const Base = defaultValues => class extends Record({
  id: undefined,
  links: {},
  errors: {},
  ...defaultValues
}) {

}

class User extends Base({
  firstName: undefined,
  lastName: undefined
}) {
  fullName() {
    return this.firstName + ' ' + this.lastName 
  }
}
```
 What about this approach?

```
    const PersonMixin = Base => class extends Base {
        grew(years) {
            return this.set("age", this.age + years);  //returns a new Person, which is fine
        }
    };

    const PersonRecord = new Immutable.Record({name: null, age: null});
    class Person extends PersonMixin(PersonRecord) {}

    const AcademicanRecord = new Immutable.Record({name: null, age: null, title: null});
    class Academician extends PersonMixin(AcademicanRecord) {
        constructor({name, age, title}) {
            super({name, age, title});
        }
    }

    var a = new Academician({name: "Bob", age: 50, title: "Assoc. Prof"});
    console.log(a);
    console.log(a.grew(10).age); //grew works
    a.title = "Prof";   //the error "Cannot set on an immutable record" received.
```

We do not extend PersonRecord, but use a PersonMixin to define base methods.
 @justinko very late question but im using your suggestion and it works very well except i CANNOT test a method in that thing to save my life? have you found a way around it by chance? what i've got atm https://gist.github.com/th3fallen/92491b889485961cc97938c306f0836c#file-model-spec-js-L28
  [This ticket](https://github.com/moreartyjs/moreartyjs/issues/58#issuecomment-74389910) was raised over in Morearty.js regarding an incorrect example of using transit with OrderedMaps.

I was looking through the tickets and didn't see any questions raised so I figured I'd ask, is the API of `toArray` on Map / OrderedMap not preserving the map entries as k/v tuples intentional?
 An easy way to iterate over a `Map` as a list of tuples would be really useful in some situations. Am I correct in thinking the way to do it currently is:

``` javascript
// map.asTuples()
map.map((v, k) => [ k, v ]).valueSeq()
// -- or --
map.map((v, k) => { key:k, value:v }).valueSeq()
```

Of course, this might be useful for all the datatypes, not just `Map`. Eg:

``` javascript
// [list|set|seq|...].asTuples()
list.map((v, i) => [ i, v ])
// -- or --
list.map((v, i) => { key:i, value:v })
```

On a side note, this kind of thing is what you would think `keySeq()` is for, but you run into all kinds of issues because `Seq.Keyed` is treated specially by just about everything. For example, you can't transform the keys via `map()` because `map()` only effects values. You can use `mapEntries()` instead, but it's only available if your original structure was a `Map` to begin with. Using `flatten()` on a sequence of `Map` produces a `Map` instead of a sequence of their values as you'd expect (it's basically `_.extend()`). Etc., etc., etc.

I wonder if this would be a good time to take a look at everything from an API level and see if there isn't a more generic solution that is more consistent.
 That's exactly what I was looking for, thanks. It's interesting that `list.entrySeq()` works, but `list.mapEntries()` does not.
 It would be useful for the same reasons it's useful for `Map`: You can defined your own keys using `mapEntries()`. But, I suppose it comes back to the concrete datatype thing again. `mapEntries()` really should produce a `Map` or an `Iterable.Keyed`, but that wouldn't match the rest of the Api.
  The documentation [shows](http://facebook.github.io/immutable-js/docs/#/Stack/map) that `Stack` has a `map` method. However, calling the method throws a `TypeError`.

Here is a minimalist example run on the command line through Node.js: 

``` bash
$ node --version
v0.10.25
$ npm --version
2.3.0
$ npm list immutable
[...]
â””â”€â”€ immutable@3.6.2 

$ node
> function double (x) { return 2 * x; }
> var Immutable = require('immutable');

> Immutable.List.of(1, 2, 3).map(double);
List [ 2, 4, 6 ]

> Immutable.Stack.of(1, 2, 3).map(double);
TypeError: Object function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  } has no method '__iterate'
    at Stack.__iterate ([...]/node_modules/immutable/dist/immutable.js:3421:41)
    at IndexedIterable.mappedSequence.__iterateUncached ([...]/node_modules/immutable/dist/immutable.js:1138:23)
    at seqIterate ([...]/node_modules/immutable/dist/immutable.js:601:16)
    at IndexedIterable.IndexedSeq.__iterate ([...]/node_modules/immutable/dist/immutable.js:315:14)
    at IndexedIterable.reversedSequence.__iterate ([...]/node_modules/immutable/dist/immutable.js:1183:23)
    at IndexedIterable.mixin.forEach ([...]/node_modules/immutable/dist/immutable.js:4265:19)
    at Stack.pushAll ([...]/node_modules/immutable/dist/immutable.js:3331:22)
    at Stack.unshiftAll ([...]/node_modules/immutable/dist/immutable.js:3357:19)
    at new Stack ([...]/node_modules/immutable/dist/immutable.js:3274:22)
    at reify ([...]/node_modules/immutable/dist/immutable.js:1673:37)
```

I haven't tried other methods of `Stack` or the `map` method on other data types.
 I am experiencing this problem also
  Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 Has something been done for that issue?
 bump  Could there possibly be a "force" parameter for fromJS. I'm running into an issue using it alongside jsdom, where the === Object test is failing because the object was created in a different context (thus value.constructor === outside_context's Object). I could implement my own fromJS, but I'd prefer to then not have to track the official implementation, and I feel like its a somewhat common case to just want to unconditionally convert things to Map as well.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Changed discrepancy where map2 had b set to 20 but a comment that b was equal to 50.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 If you entered the numbers on a numeric keypad the 5 and 2 are next to each
other...

On Fri, Feb 13, 2015 at 11:29 PM, Lee Byron notifications@github.com
wrote:

> Thanks. I must have has a dyslexic moment.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/pull/328#issuecomment-74362741.

## 

[image: Christos Jonathan Seth Hayward] http://jonathanscorner.com/
Jonathan S. Hayward, a full stack web developer with Python/Django and
AngularJS/jQuery.

Articles on Technology http://jonathanscorner.com/technology/ â€¢ Book: _Django
JavaScript Integration_
http://www.packtpub.com/django-javascript-integration-ajax-and-jquery/book
 â€¢ _Email jsh@jsh.name_ â€¢ Github http://github.com/JonathanHayward â€¢
LinkedIn http://www.linkedin.com/in/jonathanhayward â€¢ Main Website
http://jonathanscorner.com/ â€¢ _Professional Site http://jsh.name/_

I invite you to visit my professional site! http://jsh.name/
  I know there is built in support for using typescript for doing this, but it would be great if there was an idiomatic javascript api for defining types, maybe something like 

```
var CustomList = Immutable.List.ofType(Number);
var immutableStuff = CustomList([1,2,3]);
var changedStuff = immutableStuff.push('6'); // Throws an Error with informative message
```

or 

```
var CustomMap = Immutable.Map.ofType(String, Immutable.List.ofType(String));
var moreStuff = CustomMap({
    a: Immutable.List(['q','w','e']),
    b: Immutable.List(['t','y'])
})
```

or

```
/*
  this is admittedly sort of wonky, maybe could join
  type and default in a tuple like [Number, 4]
*/
var CustomRecord = Immutable.Record.ofType({
    thing: Number, 
    other: String
})({
    thing: 0,
    other: ""
});
var evenMoreStuff = CustomRecord({thing: 6})
```

This gets to be really powerful when you add the idea of union types 
`Immutable.Seq.ofType([String, Number])`
and fromJS-ing-with-type (also wonky)
`Immutable.fromJS.withType({f: ['z','x','v'], l: ['i','o','p']}, CustomMap)`

it would also be nice if we could somehow set up the typescript compiler to use this api so that the javascript generated could be safe if used by other non-typescript javascript code, but i dont know if thats possible.
  ``` js
const Thing1 = {};
const Thing2 = {};

const x = {
    "key1": Thing1,
    "key2": Thing1,
    "key3": Thing2
}

// This doesn't give the expected result!
const result = Immutable.Map(x).groupBy(x => x);
```

This results in a strange object containing only a single key.  Note that changing the `Thing1` and `Thing2` values in `x` to their string equivalents gives the expected result.

``` js
const Thing1 = {};
const Thing2 = {};

const x = {
    "key1": "Thing1",
    "key2": "Thing1",
    "key3": "Thing2"
}

// This works as expected
const result = Immutable.Map(x).groupBy(x => x);
```
 Wow, what a quick response :)

You are absolutely right.  Given that it seems that the problem was actually that I was using `toJS()` in order to debug this in the Chrome dev tools, and `toJS` concatenates it into an object with a single key causing me lots of confusion.
 Got it.  In general is an explicit `toString()` the best way to see what is going on inside a collection?
 Thanks again!
  Hi,

I'm experimenting a bit with immutables and I'm not sure what I'm doing is actually correct or if there is a better way to do it.

So let's say I have a Store like this

``` javascript
var store = Map({
  customers: Map({
    count: 0,
    total: 0,
    results: List()
  })
})
```

Now when I get new customer data I want to update the store and dump the new data in it

``` javascript
var newData = {
  count: 2,
  total: 2,
  results: [
    {id: 1, name: 'Alice'},
    {id: 2, name: 'Bob'}
  ]
}

store = store.setIn(['customers'], fromJS(newData))
```

Any help would be much appreciated, thanks :)
 Hey, thanks for the quick answer!

Yes, it does what I expect, just wondering if it's the right way to do it ;)

Because if I just pass the JS object and don't convert it back with `fromJS` then `customers` is not an immutable map anymore

``` javascript
console.log(store.set('customers', newData).get('customers'))
// => Object {count: 2, total: 2, results: Array[2]}

console.log(store.set('customers', fromJS(newData)).get('customers'))
// => Object {size: 3, _root: ArrayMapNode, __ownerID: undefined, __hash: undefined, __altered: falseâ€¦}
```

I thought it would be implicitly converted on `set`, so I just wanted to make sure :)
 Cool, then I can close this. Thanks for the help and your time :+1: 
  Hello, I'm wondering what is the computational complexity of doing Set intersection and union under the special circumstances where the two sets are almost equal?

I'm asking this because I'd like to perform fast set-difference operations on large sets, where I know beforehand that the sets are almost equal. In my case, both operands are derived from the same large set, but one of the operands has undergone some (small number of) mutations.

It seems to me that this should be implementable using functional data-structures, but I'm not sure if immutable-js actually implements it such that this is fast.
 Hi Lee, I don't have any pointers to actual research. But I imagine if the Set is implemented by, for instance, a red-black tree, then a computation of the intersection of two sets (two red-black trees) could simply walk through both trees, and look for nodes which are identical (have the same address), and skip the subtrees rooted at those nodes. Those identical nodes could be found by looking up the keys, I suppose. Anyway, I realize this is not an algorithm nor a proof, just a sketch of how this could work :)
 Well actually I'm looking for something that is more like O(M) or O(M log N), where M is the number of mutations between the operands set1 and set2. Thinking a little deeper, the algorithm I would consider (based on red-black trees) goes through set1 and set2 simultaneously, and whenever there is a difference in set2 wrt set1, it looks up the mismatching node of set1 in set2 (this costs O(log N)). If found, then that subtree can be added to the current intersection using the fast-union. If not found, continue comparing along the tree. It seems that this algorithm is O(f*M log N), where f is a factor that takes into account the time for the fast-union.

I suspect that the union of the common subtrees can be fast, because by design, they don't intersect. But not quite sure about the computational complexity.

I'm also not sure how this would apply to the HAMT structure.

A similar algorithm could be used to perform set-difference directly (perhaps this is even simpler).
 Hi (sorry for replying so late, I haven't been at my computer for about a week),

The idea is that there _is_ structural sharing, because both sets are considered to be coming from the same source, although the sets might have both changed (slightly). To see this, consider that since an update to a set has computational complexity far smaller than O(N), both sets _must_ have structural sharing (if only a relatively few updates have taken place).

And indeed, using the fact that there is structural sharing, you can identify identical nodes, and eliminate complete subtrees. That was already an assumption I made in my previous posts, but I should have been more clear about it.

By the way, this form of doing set-operations is important for "diffing" of data structures, so that updates can be efficiently performed by determining which parts of a data-structure have changed with respect to a reference version. So I really hope these fast operations become part of the library :)
  Likely easier to accomplish as a plugin or similar with any changes that may come from #301, but this would be a super nice to have.

Currently I'm using a custom metadata API on my fork to signal specific properties on a map used in triggering a change at a path (sort of an observable cursor type deal). Other cases I'm using are to store temporary info related to the data but which shouldn't change the actual shape of underlying value - the "type" of a filtered result, whether a map has been "validated", etc.

Setting metadata on an Immutable object would return a new value which would be considered value equal but not referential equal.
 @leebyron the only real pitfall for metadata is accidentally losing it, internally most Clojure(Script) data structures preserve metadata across all operations that make sense. The other problem is how to transit metadata over the wire. Got no ideas about that.

The benefits are many in Clojure(Script), people use it for all kinds of things - everything from annotating Clojure(Script) source code itself to providing provenance information on runtime data.
 I would also appreciate some kind of metadata API. I don't know where to store state (such as loading, error, ok) and error messages in react app using immutable.js now.

I have implemented my own "library" which wraps immutable.js structures and provides method like updateDataAndMetada, getErrors, getState (+ shortcuts isLoading, isOk, ...). It also has methods like get, getIn, set, setIn which behaves the same way like immutable.js methods. So if you call set on "my" object, it returns a new instance with value set on the inner immutable.js object. But I don't think it is a best approach.
 Metadata would be super easy to add to mutable data structures. Adding a field to an object would done the thing. However with immutable objects we need to be sure it is copied with every object change.
 Yeah, I'm using it in a custom collection of models (records with ids and client ids), where you can have metadata as @janmarek mentioned for setting if that collection is currently being fetched. Anyway, I implemented it by making my custom collection have a record of metadata attributes. Would be really great to see how an API for metadata attributes could look like
 :+1: on metadata for all immutable objects. We need a flag to indicate if our record object is only partially fetched (= only the identifier field is set). Right now we work around this by checking if all values are `undefined` (= default values) except the identifier field(s).
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Only made 1 change:
1) Update LICENSE to include up-to-date year as a range

No other changes were made.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 No worries, glad I could help!
  I'm new to your library, and may be using it incorrectly, but when use Map.merge with a integer-indexed object, I do not get expected results. Map.toJS works as expected however.

``` javascript
var m = Immutable.Map();
m = m.merge({2: 'foo', 3: 'bar'});
m.has(2); // false
m.get(2); // undefined
m.toJS(); // {2: 'foo, 3: 'bar'}
```
 @adamschoenemann 
try this:
m.has('2');
m.get('2'); 

javascript object's keys are always strings.
 Of course! 
  Fira Sans / Mono family has rendering problems on Linux in Firefox and Chrome, so some users will see blank code blocks instead of examples. Even though there are some workarounds, I think it's easier to just switch to the font that works out of the box on all platforms.
 On ArchLinux installing Fira font package on the system solves the problem, but the issue here is that most people won't try to check what font is used and will just consider website broken.
 It's on ArchLinux, Firefox 35 and all 3 current Chrome channels.
 Just fyi: works well on ubuntu (14.04)
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 Seems to work fine for a while now, so I'll close.
  ``` js
var data = Immutable.fromJS({ a: [1, 2, 3] });
var cursor = Cursor.from(data);
var deepCursor = cursor.cursor('a');
```

deepCursor will be KeyedCursor, not IndexedCursor, due to the way `subCursor()` calls `makeCursor()` and how `makeCursor()` checks for optional arguments.
#297 fixes this issue.
 Awesome! Thanks.
 I've being bitten by this as, well. I hope it will make into a release soon!
 Just ran into this, looking forward to the fix.
 +1
 I posted a slightly revised fix here #381 which uses argument length since undefined might be a legitimate value. 
  Without going off the deep-end with modularity, it might be nice to have a way of incrementally building the library. For instance to specify which types are included when building in the grunt cli.

Not sure how this would look, or whether including a separately built directory for grabbing absolute `require` paths might be preferable, e.g..

``` js
var Map = require('immutable/type/map')
```

You'd lose out a bit on the bytes shaved by compiling the library as a single file, but I'd imagine omitting entire types would make up for it depending on the case.
 Wouldn't this break `immutable.fromJS`?
 :+1: here. I love this library but 56kb is a tough pill to swallow.
 Oh I certainly didn't mean it as a petty attack, I apologize if I came across that way. 

In the grand scheme of things, 15kb is _nothing_ compared to the value you get out of this library. But I did to express my interest in exploring ways to reduce this weight. It just feels like there's an easy win here.
 +1
 +1!
 I would love a modular approach as well, now that `immutable` v3 comes with so much goodness built-in it's overwhelming sometimes (just to go through doc and remember those API).

Or maybe a `immutable-core` module offering low level API? There is a https://github.com/mattbierner/hamt but unfortunately didn't get expanded upon. https://github.com/rtfeldman/seamless-immutable is much closer to native data structure but doesn't use hamt underneath.

Still, many thx to your hard work. 
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 > Deprecate all methods like `toMap()` in favor of passing instances to `Map()` constructors.

I would just like to point out some issues around getting rid of toMap(). Take a look at #600 and #697. Ideally, this sort of behavior would fit better under the map() function, but you cannot specify keys via map() currently.
 [RxJS](https://github.com/ReactiveX/rxjs) has great structure that allows to add operators and typings to prototype at runtime (e.g. [add/map](https://github.com/ReactiveX/rxjs/blob/master/src/add/operator/map.ts#L5) and [map](https://github.com/ReactiveX/rxjs/blob/master/src/operator/map.ts#L38)).

But as @leebyron said in https://github.com/facebook/immutable-js/issues/1044#issuecomment-282842312

> However I don't actually think you would shave much from the ~15kb build already. That's roughly split into thirds: Map, List, and everything else.

It would be overkill for current implementation. To make profit from it - we totally should add another dozen of methods to operate on collections

Also from https://github.com/facebook/immutable-js/issues/1044#issuecomment-282842312

> Specifically right now all types have a toList() and toMap() etc methods which convert between various collection types. That ties all of the library together and tree shaking typically isn't smart enough to trim prototype methods as well.

This can be solved with `babel-plugin` e.g. [babel-plugin-lodash](https://github.com/lodash/babel-plugin-lodash), [babel-plugin-material-ui](https://github.com/umidbekkarimov/babel-plugin-material-ui).
 I know my team uses just fromJS, merge, mergeIn, set, get, setIn, getIn. That's basically it. 

Perhaps groups of prototype methods could be added on demand. So I'm going from the naming in the docs here, these groups could be optionally loaded:
- transient changes
- sequence algorithms
- combination
- creating subsets
- reducing a value

The other method groups would probably not be optional, but don't seem necessary for a "lite" version of immutablejs.

Also curious you say it's just Map and List, but there is also OrderedMap, Set, OrderedSet, Stack, Range, Repeat, Record, Seq. Those data types should also be optional. Yeah we also use basically fromJS, merge, mergeIn, set, get, setIn, getIn.

Looking forward to this.

I will note the main issue is not with the actually size of immutable, its just when you add all the other deps in a normal project they really add up. 20-30% off each library adds up to *allot*  :+1:   Running immutable dist/ with io.js:

```
> var Immutable = require('immutable');
undefined
> var x = new Immutable.Set().add(Symbol('hi'))
undefined
> x
TypeError: Cannot convert a Symbol value to a string
    at D:\opt\NodeModules\immutable\dist\immutable.js:4267:55
    at D:\opt\NodeModules\immutable\dist\immutable.js:1131:36
    at D:\opt\NodeModules\immutable\dist\immutable.js:1018:56
    at D:\opt\NodeModules\immutable\dist\immutable.js:3590:58
    at D:\opt\NodeModules\immutable\dist\immutable.js:1864:16
    at ArrayMapNode.iterate.HashCollisionNode.iterate [as iterate] (D:\opt\NodeModules\immutable\dist\immutable.js:2213:11)
    at Map.__iterate (D:\opt\NodeModules\immutable\dist\immutable.js:1862:32)
    at Set.__iterate (D:\opt\NodeModules\immutable\dist\immutable.js:3590:24)
    at ToSetSequence.__iterate (D:\opt\NodeModules\immutable\dist\immutable.js:1018:25)
    at SetIterable.mappedSequence.__iterateUncached (D:\opt\NodeModules\immutable\dist\immutable.js:1130:23)
```

Running immutable src/ with io.js and 6to5:

```
> var Immutable = require('immutable');
undefined
> var x = new Immutable.Set().add(Symbol('hi'))
undefined
> x
TypeError: Cannot convert a Symbol value to a string
    at D:/opt/NodeModules/immutable/src/IterableImpl.js:203:53
    at D:/opt/NodeModules/immutable/src/Operations.js:238:20
    at D:/opt/NodeModules/immutable/src/Operations.js:125:38
    at D:/opt/NodeModules/immutable/src/Set.js:136:42
    at D:/opt/NodeModules/immutable/src/Map.js:168:14
    at ArrayMapNode.iterate.HashCollisionNode.iterate [as iterate] (D:/opt/NodeModules/immutable/src/Map.js:517:9)
    at Map.__iterate (D:/opt/NodeModules/immutable/src/Map.js:166:30)
    at Set.__iterate (D:/opt/NodeModules/immutable/src/Set.js:136:22)
    at ToSetSequence.__iterate (D:/opt/NodeModules/immutable/src/Operations.js:125:23)
    at SetSeq.mappedSequence.__iterateUncached (D:/opt/NodeModules/immutable/src/Operations.js:237:21)
```

The same thing happens in Chrome 40, though you have to do `x.toString()` instead of `x` in the console.

Line 203 is

``` javascript
  join(separator) {
    assertNotInfinite(this.size);
    separator = separator !== undefined ? '' + separator : ',';
    var joined = '';
    var isFirst = true;
    this.__iterate(v => {
      isFirst ? (isFirst = false) : (joined += separator);
      joined += v !== null && v !== undefined ? v : '';    ///////////////////
    });
    return joined;
  },
```
 Changing
`joined += v !== null && v !== undefined ? v : '';`
to
`joined += v !== null && v !== undefined ? String(v) : '';`
seems to fix the problem.
  immutable-js instantiates a lot of classes without `new`, which is no longer legal.  As per ES6 February 2, 2015 Draft Rev 32, "Constructors defined using class definition syntax throw when called as functions" https://www.mail-archive.com/es-discuss@mozilla.org/msg34104.html

6to5 implemented the new behavior in  https://github.com/6to5/6to5/commit/3a11c7d46b5788175c9c1141ff50ed59ce26c40c, and I couldn't run immutable-js/src/ with 6to5 until making these changes.

I extracted the list of classes with

``` bash
grep --no-filename -o -P '^(export )?class .*? ' src/**/*.js
```

and generated the diff with this shell program:

``` bash
for i in Collection KeyedCollection IndexedCollection SetCollection Iterable KeyedIterable IndexedIterable SetIterable Iterator List VNode Map ArrayMapNode BitmapIndexedNode HashArrayMapNode HashCollisionNode ValueNode MapIterator ToKeyedSequence ToIndexedSequence ToSetSequence FromEntriesSequence OrderedMap OrderedSet Range Record Repeat Seq KeyedSeq IndexedSeq SetSeq ArraySeq ObjectSeq IterableSeq IteratorSeq Set Stack; do echo; echo $i; perl -p -i -e "s,(?<\!new|ion|nds)([\( ])(\\b$i\\(),\\1new \\2,g" src/**/*.js __tests__/**/*.js contrib/**/*.js; done
```

I've signed the CLA as ivan@ludios.org
 Ah, thanks, after reading the code I see what you mean.
 I think the word you were looking for is "factories". "Constructor function" still implies it modifies `this` ;)
 Tangential, but noting anyway: you still can't use `immutable-js/src/` directly with webpack+6to5 even with this PR, because of a circular dependency between `src/Seq.js` and `src/Iterable.js`.  Seq requires Iterable which requires Seq; thus Iterable gets `undefined` for Seq, KeyedSeq, IndexedSeq, and SetSeq.

I noticed this problem in Safari and IE11 but not Firefox and Chrome, because Firefox and Chrome have native Array iterators and thus didn't call the `new Iterable` in `forceIterator.js`.
 I just ran into this. I am trying to subclass classes generated by Immutable.Record to add my own methods and I'd like to use it in the immutable way. But babel (formerly 6to5) complains that I cannot instantiate my classes without "new".

If you are going to move away from the class semantic with Immutable.js, is subclassing still supported? Or is subclassing the wrong approach for this use case?
  Because [of the way a Record class is built](https://github.com/facebook/immutable-js/blob/master/src/Record.js#L21-L26), the constructor name is always "Record":

``` js
var MyRecord = new Immutable.Record({ foo: null });
var rec = new MyRecord();
console.log(rec.constructor.name);
//=> Record
```

This is unfortunate for systems that try to type-check given the constructor name. There are two solutions that could fix that:
1. Declare custom records with good ol' constructors
2. Use a similar technique to what is [described in on this stackoverflow answer](http://stackoverflow.com/a/22880379/941001).

Example of how it could look like for (1), in ES6:

``` js
class MyRecord extends Immutable.Record {
  constructor(values) {
    super({ foo: null }, values);
  }
}

var rec = new MyRecord({ foo: 'bar' });
```

But I'm not totally sure of the technical feasibility, and that's bulkier. On the other hand, that's more of what we expect in the ES6 world, and that would allow people to customize the constructor arguments. I know there have been other discussions about improving `Record` as well. I think I'll give it a try.

What do you think about the higher-level issue, anyway?

EDIT: I forgot quite a drawback about (2): it's not backward compatible, meaning a version-major change.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
   Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Is this expected behavior?

``` javascript
var a = Immutable.Map();
var b = a.clear()
a === b // true
```

I was not expecting this in a similar situation: `Immutable.Map() === Immutable.Map()` and certainly not in the `clear` situation (or any other persistent api call) since the api does indicate the behavior I'd expect: "Returns a new Map containing no keys or values."

Though I see there's some special case for `emptyMap()`
 Ok, hmm. Guess I need to manually force a change in react when replacing an immutable object with another; I was expecting the new immutable object to be picked up as different than the old one when changing that property in state.

FWIW, a child had received the original immutable object, ended up with a different one in its state after modifications, and I'm trying to pass the new immutable object via props to put it back into its initial state.
  In my current project I have to do a lot of deep lookups. At the moment immutable-js aids this usecase by using the `Iterable#getIn(...)` method like this:

``` js
var nested2 = nested.mergeDeep({a:{b:{d:6}}});
nested2.getIn(['a', 'b', 'd']); // 6
```

Instead of passing an array to the `getIn` method, I personally find passing a string more convenient, like:

``` js
nested2.getPath('a.b.d'); // 6
```

where the implementation of `Iterable#getPath(...)` might look like this:

``` js
mixin(Iterable, {
    ...
    getPath: function(searchKeyPathStr, notSetValue) {
      return this.getIn(searchKeyPathStr.split('.'), notSetValue);
    },
    ...
}
```

How do you feel about adding a function like `getPath` to the library? I am happy to create a PR in case there is enough support for this idea.

PS: The idea for `getPath(...)` originates from my experience with the SproutCore library and their SC.Observable object: http://docs.sproutcore.com/symbols/SC.Observable.html
 Unlikely this would be in the library. This has been suggested before.

See: https://github.com/facebook/immutable-js/issues/237
 Thanks for the detailed replay @leebyron and @Dashed - make totally sense to me.
  Manually applied fix to dist since building created a lot of changes.
  Being write JavaScript which only uses Array, I'm not quite into types of ES7 and TypeScript. Is there any tutorials that guide people like me to types in immutable-js ?
 @leebyron I've read that one. But is there any plan adding some more examples in JavaScript?

I mean, although I can understand most part of that documentation, there's still some barriers when I want to use it, due to my weakness in static typed languages.
 Good news for me :+1: 
  Previous link doesn't work
  The type definition for `setIn()` is 

``` typescript
setIn(keyPath: Array<any>, value: T): List<T>;
```

which states that `value` should be of type `T`. I humbly suggest that it should be of type `any`.

Forcing `value` to be of type `T` makes little sense because it says that you can have as deeply nested structures as you like, as long as everything is of type `T`.

The point of `setIn()`, as I see it, is that it can reach inside a structure and change a specific value - very useful when using immutable objects. Lets say that I have an interface called `Block` and a `List` of blocks. I want to change the property `comment` of block on index 3 in the list. 

``` typescript
interface Block {
    comment: string;
}

var list: List<Block>;
list.setIn(List.of<any>(3, "comment"), "new comment");
```

This is a useful pattern in javascript, but it is not possible in typescript because the type definition says that `comment` must be of type `T`.

The workaround is to use `updateIn()` which use `any`, but at the cost of having to supply a function.
  I'm actually not sure if this is or should be a desired goal of the library, but I've run into the following:

``` javascript
var r = I.Map();
var l = I.List([r, r])
l.get(0) === l.get(1) // return true
```

Given this, the following is a bit unfortunate:

``` javascript
var obj = fromJS(r)
obj[0] === obj[1] // return false
```

The same holds with toJS (where [x,y] given x===y results in a List where [0] not equal to [1]).

I could see arguments for ignoring this. My particular use case is that there is data that is out of my control, that I am then converting to immutable.js for my use in the view layer. As such, sometimes this data has multiple internal references like this, and its important for me to know this (to be able to display this fact). I'm building my own from/toJS's that handle this, but was curious if its something that was wanted in the library as well.
 I think the idea with immutable data structures is that they should be treated as identical by value equality for most intents and purposes. Compare immutable's behaviour with that of built-in immutable types like the various primitives.

By that logic, your code is already broken if it distinguishes between value equality and identity in immutable structures and the toJS behaviour is just a symptom of that.
 @pluma right but one of the points of having those be essentially the same is to be able to do a === check and not pay the price of an expensive deep equality check (that's one of the main sells of using immutable values in react, having very quick and simple shouldCompknentUpdates). If we were really ambitious we could have as a goal that List.if(1.2.3).push(4) should === List.of(1.2.3.4) (the same way "123"+"4" === "1234" thanks to immutable string in JavaScript). Properties such as these would make memoized_func(list) trivial to write (thus getting similar benefits as react). Of course, that is difficult to enforce and merely an example but maintaining existing equalities seems doable.

I'll push my implementations later this week (not sure if I can get them integrated into the library itself but hopefully be able to do some perf comparison).
  I'm new to Immutable JS and not an expert on immutable programming by any means so I may be confused here, but I would expect calling OrderedMap#setIn to create a new _OrderedMap_ at the given keyPath if a key does not exist - however, according to the documentation and my testing, it instead creates a plain Map.

(From the docs: "Returns a new Map having set value at this keyPath. If any keys in keyPath do not exist, a new immutable Map will be created at that key.")

My concern here is that the order of key/value pairs within these child Maps (that are created when calling setIn with a non-existent key path) will not be preserved in all cases, which is important for my use case - or is this a non-issue as the top level data structure is an OrderedMap?
 Sure... I'm happy to explain what I am trying to do in more detail if it's helpful, but for now I've created a fiddle which shows basically what I am seeing in a simplified form: http://jsfiddle.net/8hdbrhdd/1/

Note that this has not caused me any actual issues so far (except when I was trying to construct an "expected" OrderedMap object to compare the actual result's equality to in a Jasmine test, which is how I came across this), but my concern is that the child maps I am constructing using setIn() are not guaranteed to maintain the iteration order of their entries as they were set(), as they are Map objects rather than OrderedMap, and for my application, the order of entries is important (I am constructing this map one entry at a time while looping over lines of an input file).

Would this be the case, or have I misunderstood something? As long as the order of all my nested maps is preserved, I'm not concerned with the implementation - however I would also be interested to know how you would suggest going about comparing a (Ordered)Map returned from a function with the expected result in a unit test - at the minute, I am manually constructing the "expected" Map object, but another option would be to just compare the JSON version of each...

Hope this makes some sense, I am new to the library so please let me know if not and I'll endeavour to explain better :)
 Sorry, wrong Fiddle, one sec
 Correct URL: http://jsfiddle.net/8hdbrhdd/1/
 Actually, no harm in posting my actual code either I guess, feel free to ignore if not useful :)

The idea is that it can take an input like:

```
[Section 2]
[[Subsection 1]]
Key 3 = Value 3
[Section 1]
[[Subsection 1]]
Key 2 = Value 2
Key 1 = Value 1
```

and convert it into a nested data structure which maintains the order of the entries in the file

```
import splitLines from 'split-lines';
import im from 'immutable';

class ConfigParser {
    constructor() {
        this.SECTION_REGEX = /^\s*(\[+)([^\]]*)\]+$/;
    }

    parse(file) {
        // The parsed config (as nested OrderedMap objects)
        var parsed = im.OrderedMap();
        // Keep track of the current section we are in as we read through the file
        // as an array of keys, e.g. ['Section 1', 'Sub Section 2']
        var sectionPath = im.List();

        splitLines(file).forEach(line => {
            // Check if the current line is the start of a (sub-)section
            var sectionMatches = line.match(this.SECTION_REGEX);
            if(sectionMatches) {
                // If so, update the section path accordingly
                var sectionDepth = sectionMatches[1].length - 1;
                sectionPath = sectionPath.slice(0, sectionDepth);
                sectionPath = sectionPath.set(sectionDepth, sectionMatches[2]);
            } else {
                // Otherwise check if this is a config setting, and if so, store it as a key/value
                // in the current section
                var split = line.split('=');
                if(split.length > 1) {
                    parsed = parsed.setIn(sectionPath.push(split[0].trim()), split[1].trim());
                }
            }
        });

        return parsed;
    }
}

export default new ConfigParser();
```
 And an extract of the corresponding test code that made me notice this:

```
...
  it("should parse a config with one level of sections", () => {
        var result = cfg.parse(`key1 = value1
[section1]
s1k1 = s1v1`);

        var expected = im.OrderedMap({
            "key1": "value1",
            "section1": im.OrderedMap([[
                "s1k1", "s1v1"
            ]]),
        });

        // This fails because the child is actually a Map
        expect(im.is(result, expected)).toBe(true);
    });
...
```
 Any thoughts on this? I've not noticed any problems with child maps being out of order in my work so far, but not sure if I have just got lucky so far, or if I can depend on this order
 Great, thanks for confirming that Lee.

Explicitly creating the OrderedMaps is definitely an option, but would make the code a bit more complex - in fact, what made me try out ImmutableJs for this project was the ability to replace several lines of code with one setIn ;)

I might look at patching the OrderedMap to create OrderedMaps at each depth for my purposes, if I do so I will raise a PR and let you decide if it's a good idea or not :)

Cheers,
Tom
 +1
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 +1
 +1
  NOTE: this changeset contains an unfortunate amount of unrelated changes to the built files. That means a previous commit was done without running `grunt`.

NOTE: the positioning of the function in the file is to be discussed, I'm not too sure if we want to create a new pragma section or not. The documentation will probably need a little update as well (https://facebook.github.io/immutable-js/docs/#/Map/map)

---

The point is to keep the referential equality when no value changed. This let
one call `Map#map` without afterthoughts about optimization. For example, let's
imagine that we trigger an interface render when a `Map` changed; we want to
avoid the cost of re-rendering when no value changed. Without referential
equality, we'd have a write some kind of custom algorithm to compare the values
returned by `mapper`.

The performance of this function is no worse, as the generalized
`IterableImpl#map` always reifies the mapped sequence anyway. On the other hand,
the fact we're applying modifications to the existing `Map` mean we're
benefiting from the internal structure optimizations.

As a side note, I find it interesting to see how a custom `map` function looks
significantly simpler than going through the generalized operation on `Seq`.
Granted, we lose the unification of sequence transformation algorithms, but
the original problem this changeset addresses proves it's hardly possible to
totally abstract a `Map` as a `Seq`: a `Seq` loses the concept of concreteness.

A similar fix can be used for `filter`, at least.

See #285.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Seems like require("immutable").fromJS(Object.create(null)) should return Map{} not the original {}. I'm thinking this because Object.create(null) is used for maps (since it has no properties).
 I ran into this same problem while testing with jest which does some stuff with vm context that makes checking the constructor unreliable: facebook/jest#228
  I figured a separate ticket would be a better place to discuss what an API for this feature might look like, since the potential implementation approach depends on this heavily. So here are some things I've been thinking about. While the syntax:

``` js
class User extends Immutable.Map {
}
```

is kind of neat/simple and initially looks idiomatic ES6, it comes with a lot of baggage. First, it's always necessary to define a custom constructor to pass along the return value from the `super` call as this isn't done implicitly in js classes. 

``` js
class User extends Immutable.Map {
   constructor(val) {
      return super(val)
   }
}
```

Further, as the constructor doesn't really act like a normal constructor there end up being a lot of additional checks necessary to ensure that another Map passed into the custom type is [coerced correctly](https://github.com/tgriesser/immutable-js/blob/10deaf40f829bd81dc7a58afe861bbe9d518cb18/src/Map.js#L34).

So I'm wondering whether there should be something more like:

``` js
var User = Immutable.make(Immutable.Map, {

   fullName() {
     return this.get('firstName') + ' ' + this.get('lastName')
   }

})
```

would be better suited. It would allow for having a dedicated constructor type for a custom immutable type. It might still come with a perf-hit but it would be better isolated from the core implementation.

Also, it might be worth examining at what the equivalent would have looked like in [mori](https://github.com/swannodette/mori/pull/108) when implemented with cljs protocols.
 @tgriesser are there any problems with extending Map or List (except the return super in constructor)? Can I extend them safely now? 
 No  - it's not possible currently unless you use [my fork](https://github.com/facebook/immutable-js/pull/227) - which I know has its own minor issues depending on the type and isn't well tested. Might be better to wait and see if there's something more official.
 +1
 I've gotten pretty far on this lately, I've been working on a [version](https://github.com/tgriesser/immutable-js/commit/d17e00595677c50f28e1a374d4ab5e917ac9f4a4) which has the entire suite passing, maintains factory functionality (`instanceof` checks on types) while still allowing for extending into custom types and with a 50-100% perf improvement over master on `npm run perf`.

@leebyron would love to catch up on IRC sometime about some questions/ ideas I have for v4 based on some of these findings. Mainly around the less-common api surface area (Seq / Collection / Iterables) organization and guarantees. Also around some of the "Clowntown" stuff in declassify.

I think there's some huge room for improvements while keeping stuff true to the JavaScript-y ideals for Immutable.
 Just wanted to +1 this as well... I'm working on an Immutable Graph class and running into these problems.

@tgriesser to clarify your "it's not possible currently" comments above - are you saying it's not possible at all currently to write a class which extends Immutable.Map? I tried your syntax from above:

```
class User extends Immutable.Map {
   constructor(val) {
      return super(val)
   }
}
```

However, in this case it seems `new User() instanceOf User == false`
 @dandelany Yes, I'm saying it's not possible at all... the syntax above works on my [other fork](https://github.com/facebook/immutable-js/pull/227).

The Immutable classes are not actually implemented as classes but factory functions (intentionally so you don't need to call them with `new`), but this ends up being terribly inefficient performance wise, which is where the 50-100% perf gains I've seen in my latest attempts at this are coming from.

So it'll eventually be possible but I don't really want to spend any significant time on it past what I already have until I get a chance to talk to @leebyron a bit more.
 @tgriesser @leebyron thank you for your work guys
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 Would love to be able to extend the core types
 +1
 +1 
 +1
 +1
 +1
 +1
 +1
 +1 
@dandelany I would also love to see an Immutable Graph lib!
 +1 this would be enormously helpful. Is there any established way for creating immutables with class methods?
 Yeah I'm actually no longer using this fork myself, fully agree with the concern about anti-patterns.
 @leebyron I just need an Immutable graph interface. Something like: 
`state.getIn(['users', 'bob']).edge('likes').map( contentObj => state.setIn(['content', contentObj, 'isLiked'], true));`

`state.getIn(['content', 'firefly']).edge('likedBy').map( user => state.setIn(['users', user, 'scifiLover'], true) );`

I'm tempted to write my own library, but I was hoping to use Immutable as a base. Would it would be better for me to open source something that has a similar interface as Immutable with graph methods, and it just uses Im under the hood for operations (instead of extending Im)?
 +1. 

@leebyron as for a useCase. I am building an app with a pretty complex datastructure. Totally possible with native Immutable collections (Im using Maps) but some things will be 4 or 5 levels deep.

For example, users can vote multiple times on a voteSlide in a certain presentation, and getting a single vote could look like this:

```
var specificVote = state.getIn([presentationId,slideNumber,participantId,voteId]);
```

The problem with this is that when there will be other developers working this code later, they will need to know the order of indices / the structure of the app. Ofcourse comments and state inspection can get them there in the end, but what I was thinking about is to create a Presentation which extends Map, which holds Slides which extend Map, which hold Participants, etc ... This way I can make extra methods like:

```
var presentation = state.get(presentationId);
var specificVote = presentation.getSlide(slideNumber).getParticipant(participantId).getVote(voteId);
```

more code, perhaps less performant(?), but much easier to work with for them, with code completion.
 This has been tagged needs-decision for over six months. Any closer to making a decision?
 +1
 +1
 +1
 +1
 +1
 I'd like to have a simple way of overriding List.toString()
 @leebyron thank you for this update

do you think it would be possible to document everything we need to do properly to make custom data structures using composition?
 For future readers, I created a little package that more or less is an "inheritable" Immutable.Map type https://github.com/jdfreder/inheritable-map 
 For anyone who's still interested in this, I wrote an `extendable-immutable` package, similar to @jdfreder's one, but with complete expected behavior: it can be extended multiple layers deep, it doesn't break the prototype chain at all (f.e. Map.isMap and x instanceof Map would pass), it doesn't break mutable operations etc.

https://github.com/philpl/extendable-immutable
  Pretty much all collections have a static method to check if an object is that particular type. AFAIK, there's no official way to do this `Cursor.isCursor(maybeCursor)`.

This is needed for a `shouldComponentUpdate` in React whose props/state may hold cursors.

At the moment, this is used to identify cursors:

``` js
function isCursor (maybeCursor) {
  return maybeCursor && typeof maybeCursor.deref === 'function';
}
```

Is there a better way to do this externally? Or if it can be baked in as a static function? :smile: 
 +1
 > This is a bit counter to the purpose of Cursors, which seek to be invisible and act as the types they wrap.
> 
> For shouldComponentUpdate, I recommend using Immutable.is() which will automatically handle Cursor unwrapping for comparisons.

Given the discussion here https://github.com/omniscientjs/omniscient/issues/76 I agree with @leebyron that it would make more sense to defer comparison to immutable type implementation or cursor implementation than try to handle each individual type in a custom way.
 Deleted my response as I realised I posted it to a wrong thread.
 @leebyron when you do `Immutable.is(cursor, nextCursor)` and the cursors are pointing to undefined parts of a tree, Immutable.is will throw because it runs `valueOf()` and then typeof valueA.equals.
Does that mean:
- you shouldn't point cursors past the data structure
- Immutable.is should be careful about undefined returns
- cursors should return cursors on undefined valueOf?
- there should be a Cursor.is?

Is this a separate issue?
Pointing past the tree is nice because set() will fill in the missing parts...
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Noticed a missing semicolon when I was converting this file to a format that [Flow](https://github.com/facebook/flow) can understand
  Certain code paths call makeCursor with four arguments, with 'value' undefined. Since arguments.length is still four in this case, the value is not retrieved from rootData, and an incorrect cursor type may be generated.

Fixes #318 

(As a side effect, this change may also make makeCursor [eligible for VM optimizations](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#31-reassigning-a-defined-parameter-while-also-mentioning-arguments-in-the-body-typical-example).)
 Any updates on this?
 +1
 I created an alternate PR for this #381 which continues to use `argument.length` as the condition since I think it might be valid for value to be `undefined` in some circumstances. `subCursor()` simply needs to do an argument.length check as well and call makeCursor appropriately. I reused @jeroencranendonk-wf  's test.
  Can big numbers, int64, Integers fit into Immutable js ?

So we can have

```
var i = Immutable.Bignum(Number.MAX_SAFE_INTEGER).add(Number.MAX_SAFE_INTEGER);

var i = Immutable.Long(Number.MAX_SAFE_INTEGER), 
     end = i.add(Number.MAX_SAFE_INTEGER);
while( /* i < end */ i.lt(end)) {
  i = i.add(1);
}
```

Can it fit into Immutable JS ? 
 Hey, I would love to give it a try, as part of its own lib as suggests @leebyron. Can I have more details about the conventions it has to respect? :)
  I'm seeing cases where Object.keys({x:1, y:2}) is yielding ['y'].
  The is mostly a request for comment as I understand moving to 6to5 might have other implications. But tests all pass and performance improves in some cases. Thoughts?

The rest params transform looks a lot like your `arrCopy` (minus the leaking of args because it is inline):

```
for (var _len4 = arguments.length, values = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    values[_key4] = arguments[_key4];
}
```

```
Running "stats" task
  Raw: 142,546 bytes         +4,050 bytes
  Min:  58,247 bytes 59.13%  +2,215 bytes
  Zip:  15,823 bytes 88.89%    +122 bytes
```

```
List > builds from array of 2
  Old:   691,602   699,059   706,679 ops/sec
  New:   808,152   815,852   823,701 ops/sec
  compare: 1 1
  diff: 16.7%
  rme: 1.01%
List > builds from array of 8
  Old:   640,498   645,867   651,326 ops/sec
  New:   740,372   746,932   753,609 ops/sec
  compare: 1 1
  diff: 15.64%
  rme: 0.86%
List > builds from array of 32
  Old:   254,254   256,676   259,145 ops/sec
  New:   272,485   274,272   276,083 ops/sec
  compare: 1 1
  diff: 6.85%
  rme: 0.81%
List > builds from array of 1024
  Old:     9,785     9,870     9,957 ops/sec
  New:     9,848     9,930    10,012 ops/sec
  compare: 1 1
  diff: 0.6%
  rme: 0.85%
List > pushes into 2 times
  Old:   839,622   844,886   850,217 ops/sec
  New:   877,473   885,676   894,033 ops/sec
  compare: 1 1
  diff: 4.82%
  rme: 0.79%
List > pushes into 8 times
  Old:   189,652   191,290   192,956 ops/sec
  New:   191,637   196,253   201,097 ops/sec
  compare: 1 1
  diff: 2.59%
  rme: 1.8%
List > pushes into 32 times
  Old:    45,151    45,543    45,941 ops/sec
  New:    45,781    46,111    46,446 ops/sec
  compare: 1 1
  diff: 1.24%
  rme: 0.79%
List > pushes into 1024 times
  Old:     1,394     1,406     1,419 ops/sec
  New:     1,475     1,487     1,499 ops/sec
  compare: 1 1
  diff: 5.7%
  rme: 0.84%
List > pushes into transient 2 times
  Old: 1,328,763 1,341,117 1,353,704 ops/sec
  New: 1,478,902 1,489,587 1,500,428 ops/sec
  compare: 1 1
  diff: 11.07%
  rme: 0.83%
List > pushes into transient 8 times
  Old:   525,532   530,718   536,007 ops/sec
  New:   534,015   538,823   543,719 ops/sec
  compare: 1 1
  diff: 1.52%
  rme: 0.94%
List > pushes into transient 32 times
  Old:   162,114   163,528   164,967 ops/sec
  New:   162,803   164,121   165,460 ops/sec
  compare: 0 0
  diff: 0.36%
  rme: 0.84%
List > pushes into transient 1024 times
  Old:     5,002     5,130     5,265 ops/sec
  New:     5,281     5,329     5,379 ops/sec
  compare: 1 1
  diff: 3.88%
  rme: 1.92%
Map builds from an object of 2
  Old:   531,265   536,883   542,622 ops/sec
  New:   480,687   485,541   490,495 ops/sec
  compare: 1 1
  diff: -9.57%
  rme: 1.03%
Map builds from an object of 8
  Old:   105,747   106,688   107,646 ops/sec
  New:   101,170   102,090   103,026 ops/sec
  compare: 1 1
  diff: -4.32%
  rme: 0.89%
Map builds from an object of 32
  Old:    37,285    37,653    38,028 ops/sec
  New:    37,252    37,552    37,856 ops/sec
  compare: 0 0
  diff: -0.27%
  rme: 0.9%
Map builds from an object of 1024
  Old:     1,836     1,852     1,868 ops/sec
  New:     1,758     1,801     1,845 ops/sec
  compare: 1 1
  diff: -2.76%
  rme: 1.81%
all done
```
 Would be interested to find out the cases that 6to5 has actually made slower. Looks like definite areas for improvement.
 @sebmck just speculating, but I think that it is the conversion from the array-like `arguments` to array. This is good as it avoids leaking args, but it isn't without cost.

https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
 @camspiers As @leebyron said engines optimise for `fn.apply(this, arguments);` and doesn't leak so most of the changes aren't necessary.
 A lot of the changes don't use `apply`, but yes you are definitely right that some of the changes are unnecessary (and should be changed). Thanks heaps for the information :+1: 
 @camspiers Ah right sorry, I just skimmed over the changes. Looks good though! Let me know if you find any transformation output that can be optimised. Might be worth taking a look at [loose mode](http://6to5.org/docs/usage/loose/) too if immutable uses any of the features specified on that page.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  In the intro text there are a couple of links whose `href` is invalid. I.e. `<a href="(http://en.wikipedia.org/wiki/Hash_array_mapped_trie)">hash maps tries</a>`. Clicking on these links results in the browser redirecting to https://code.facebook.com/
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  This can be my misunderstanding about the toJS. Based on the documentation I thought that the toJS would change the structure deeply to corresponding native JS objects.

However, if I put immutable record, that itself contains immutable record into immutable list and call .toJS(); to the immutable list I get list and object as I expected but the nested immutable record in the parent immutable record doesn't get converted.

Something like this

ImmutableList[ Record{x:Record{y:1}}]

The list and the first record gets converted nicely.
 I'm really sorry. This is my mistake. My case was more like this:

var R = Immutable.Record({ x: null, y: null });
var data = Immutable.List.of( R({ x: [R({ y: 1 })] }) );

As you can see, it was purely my mistake. I had put a normal list inside the Record and not a immutable list. Sorry for taking your time.
   oh, I just ran `npm test` before I made my change and then `npm test` again after making my change. Thanks.
  https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts#L2289

> DISCUSSION
> Like zipWith, but using the default zipper: creating an Array.

zipWith is like zipWith? this is duplicated from the zip discussion.
  Using Node.js version 0.10.22, with Immutable-js version 3.6.2, I found an odd bug:

```
var immutablejs = require("immutable");

var obj = {};

for (var i = 0; i < 10000; ++i) {
  obj["foo" + i] = i;
}

var Foo = immutablejs.Record(obj);

var foo = new Foo(obj);

foo.get("foo0");
```

_Sometimes_ when running the above code, I get this error:

```
TypeError: Cannot call method 'hasOwnProperty' of undefined
    at Record.has (/home/pauan/Programming/JavaScript/immutable/node_modules/immutable/dist/immutable.js:3760:34)
    at Record.get (/home/pauan/Programming/JavaScript/immutable/node_modules/immutable/dist/immutable.js:3764:17)
    at repl:1:5
    at REPLServer.self.eval (repl.js:110:21)
    at repl.js:249:20
    at REPLServer.self.eval (repl.js:122:7)
    at Interface.<anonymous> (repl.js:239:12)
    at Interface.EventEmitter.emit (events.js:95:17)
    at Interface._onLine (readline.js:202:10)
    at Interface._line (readline.js:531:8)
```

Other times I don't. It seems to be random whether the error triggers or not.

I'm only able to reproduce this with very large Records (e.g. 10,000 keys). Using 1,000 keys does not trigger the error.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Is it possible to have better output in the Chrome dev tools when looking at immutable objects? For example, when `console.log`ging a Record, it shows the raw internal state:

```
Record {_map: Object, constructor: function, _defaultValues: Object, _keys: Array[3], size: 3â€¦}
```

It does look like `toString` shows useful debug info though:

```
Record { id: "6012624015168", loadState: "LOADED", name: "awesome2" }
```

I wonder if Chrome's dev tools support a custom debug view for objects (ie. automatically do the `toString` when `console.log`ging it)?
 I was about to chime in with a +1 complaining about this, but then realized you can just replace console.log:

``` javascript
(function () {
    var _log = console.log;
    console.log = function () {
        var args = Array.prototype.map.call(arguments, function (arg) {
            return typeof arg.toJS === "function" ? arg.toJS() : arg;
        });
        return _log.apply(console, args);
    };
})();
```

Might be worth dropping in during development.
 The future is bright. You can write a similar library for immutable.js:
https://github.com/binaryage/cljs-devtools
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 I'd love to have this. The logging disparity between Node and the browser is... unpleasant.
 @andrewdavey just released https://github.com/andrewdavey/immutable-devtools!
 The formatter is a pretty small amount of code, I wonder if this could just be bundled with immutable-js directly. 

https://github.com/andrewdavey/immutable-devtools/blob/master/src/index.js
https://github.com/andrewdavey/immutable-devtools/blob/master/src/createFormatter.js
 I'm happy for it to be bundled â€“Â perhaps wait until the formatter API is mainline Chrome?
Also, I suppose you could still have to explicitly `require('immutable/devtools')`, to avoid bloating the main immutable library in production builds.
 > perhaps wait until the formatter API is mainline Chrome?

This is a good idea, especially since the API may change between now and then.
 Update: The custom formatters are live Chrome in 52 so this can move forward.
 Hm? Custom formatters have been around for months - I've been using a Chrome extension (https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog) since earlier this year and it's been working well. What has changed in Chrome 52?
 Looks like it's been around since Chrome 47, judging by the [README history](https://github.com/andrewdavey/immutable-devtools/commit/47a3a8d9f205afca02b7f4f0d7645b013f1cad11#diff-04c6e90faac2675aa89e2176d2eec7d8) for that project.  

Does it even make sense to build this into the immutable library?
  Record is currently implemented with a Map. But because it has a fixed size, and because the keys are always strings, it's possible to use a much simpler and faster implementation.

Each Record would have two properties, `_keys` and `_values`. `_keys` is a mutable JavaScript object mapping string keys to indexes, and `_values` is a mutable JavaScript array that contains the actual values.

To lookup a key in the Record, you first look it up in `_keys` which gives you an index, and then you lookup that index in `_values`.

To set a key in a Record, you first look it up in `_keys`, which gives you an index. You then make a copy of the `_values` array, mutate the index to be the new value, then return a new Record with the new `_values` array.

There are a few reasons this is fast:
- You don't need to mutate or copy `_keys` at all: you can simply pass it as-is to the new Record, because it never changes.
- Copying an array is _super_ fast in JavaScript, because of various VM optimizations.
- Looking up a string key in a JavaScript object is faster than doing the equivalent lookup in a Map, and you get to take advantage of the various VM optimizations for objects.

I have implemented this technique in my library, and you can find the benchmarks here:

https://github.com/Pauan/Immutable/blob/javascript/benchmarks/Record/2015-01-16

Getting is always super fast. Setting is fast until you reach around 1,000 keys or so, and it's _extremely_ rare to have Records with 1,000+ keys in them, so that isn't a problem.
 I'm also interested in this.

Under the hood, when you create many objects with the same properties, v8 makes the same optimization as suggested. I think it would perform best if we just use an normal JavaScript object for storage. I'm not sure about the copying cost though. Here's a good introduction to the topic: http://vimeo.com/43334972
 @copy Making a copy of an object is _very_ slow: https://github.com/facebook/immutable-js/issues/174#issuecomment-62253272

As shown in [these benchmarks](https://github.com/Pauan/Immutable/blob/javascript/benchmarks/Record/2015-01-16), making a copy of an array is much faster than making a copy of an object. This isn't surprising, since arrays are much simpler data structures than objects.
 @Pauan The copy function in that benchmark is pretty bad, using [for-in](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#5-for-in) instead of a function specific to the structure of the Record. Optimally, a Record with three properties `x`, `y`, `z` would create a function like: 

``` javascript
function copy(p)
{
    return {
        x: p.x,
        y: p.y,
        z: p.z,
    };
}
```

It probably doesn't matter too much, but your solution has an indirection on every get/set.
 @copy Using `eval` or `new Function` lets you create a custom function for each Record, however certain systems (like Google Chrome Extensions) forbids `eval`.

You are right that there is a (very minor) indirection, but you'll note that _even with_ the indirection, it blows the pants off of the other immutable data structures, and is close to mutable object speed for `get`.

I re-ran the benchmarks, this time adding in a custom function as you suggested:

https://github.com/Pauan/Immutable/blob/javascript/benchmarks/Record/2015-01-22
- `JavaScript Object Copying (eval)` is your idea. 
- `Immutable-js Record` is the current implementation in Immutable-js, and it does not use array copying: it uses trees.
- `Immutable Record` is the array copying idea, which is discussed in this bug report.

As you can see, your idea is _slower_ for `set` than copying an array. Copying an array is _really really_ fast. Objects are fundamentally more complex than arrays.

In any case, thanks for the idea (and the video), even if it didn't pan out in the end. I'm always willing to learn new techniques to make these data structures faster.
 After I posted that, I remembered that V8 has optimizations for constructors, so I added in `JavaScript Object Copying (constructor)`. Unfortunately, it ended up being significantly slower than `eval`.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 @leebyron this is in the 4.0 releases now, yeah? Is it something that you've seen big enough performance gains with that it should be added to the release history? Others might be interested if so ðŸ˜„  thanks!  Consider the following piece of code:

``` js
(function () {
  var m = new Immutable.Map({foo: 1});
  var n = m.map(function (e) { return e; });
  console.log(n === m);
})()
```

It prints `false`. However, the map data hasn't changed, meaning we loose the benefit of immutability here. If no element changes, perhaps it would make sense to return the same `Map`. What do you think?
 So apparently `withMutations` correctly returns the same object if nothing changes. So one idea could be to use `withMutations` to map all the values. I'll give it a try.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  I'm experiencing a performance degradation with 3.6.x.

It seems to be caused by the following function:

```
function newKeyPath(head, tail) {
    return Seq(head).concat(tail).toArray();
}
```

If I replace it with:

```
function newKeyPath(head, tail) {
    return head.concat(tail);
}
```

performances are back to normal.
 ```
var Immutable = require("immutable");

var a = [1, 2, 3, 5, 6, 7, 8, 9, 10],
    fns = {
        js: function (a) {
            return a.concat(a);
        },
        im: function (a) {
            return Immutable.Seq(a).concat(a).toArray();
        }
    },
    score = {};

for (var name in fns) {
    var fn = fns[name],
        before = Date.now();
    for (var i = 0; i < 3000; i++) {
        fn(a);
    }
    var delta = Date.now() - before;
    score[name] = delta;
}

console.log(score.im/score.js);
```
  The following example:

```
var Immutable = require("immutable"),
    Cursor = require("immutable/contrib/cursor");

var jsData = [{a: 1}, {a: 2}, {a: 3}],
    data = Immutable.fromJS(jsData),
    cursor = Cursor.from(data);

cursor.forEach(function (c) {
    console.log(c);
});
```

works fine with _3.5.0_, but produce the following error with _3.6.0_:

```
RangeError: Maximum call stack size exceeded
```
  I would expect `.fromJS` to preserve key types, at lease for integer. Here is my test case :

``` javascript
var obj = {42: "test"};
var test = Immutable.fromJS(obj);

obj.get(42); // undefined
obj.get("42"); // "test"
```

I might be missing something but I find it odd having to `.toString()` every time I `.get` a value.
 Damn, of course.. Thanks !
 So I understand how this happens but what is everybody doing to deal with it?

It's very easy to get into a situation with a mix of string keys (`fromJS({1: "a"})`) and number keys (`set(2, "b")` or even `set(1, "c")) and I'm just curious where people are normalizing the keys.

It's insidious that the method of population (perhaps unknown to you) leads to you not knowing what key to use to retrieve data.

EDIT: In short, why doesn't `Immutable.Map.get` always coerce to a string just like property access does?
 Fair enough, probably best to match the ES6 Map behavior over object property access.

I still have a question of best practices though. Handling numeric ids is very common from a backend, I ran into a problem just now as I started using the very convenient `merge` API to integrate newfound records into a Flux store. Previously I was iterating and then `set`ting.

This leads me to a situation where it seems best to never use numeric keys and to cast them to strings upon receipt from the server. Is that something you've run into?
 FWIW, I'm reverting back to iterating and using `set` `withMutations` to build a Map. I was just surprised by the downstream changes throughout my apps after what appeared to be an innocuous internal change on my part over to `merge(jsObj)`

Not a huge deal though, the side-effects are understandable and I'll keep them in mind if I ever use `fromJS` explicitly or otherwise. 
 Heh, I'm still working at sub-Facebook scale so my needs aren't the same, but I'm glad to hear treating the otherwise numeric ids as strings is a sane move. Maybe I will do that just to avoid the unexpected casting issue I highlighted. Thanks for the insight.
 FWIW, I would strongly recommend against treating IDs as numbers, just as you shouldn't treat ZIPs or phone numbers as numeric values. Even if they are integers, there may be gaps (e.g. if a record was deleted and numbers are assigned via SQL's `auto_increment`) and it's easy to run into conversion problems (e.g. accidentally applying number formatting, resulting in locale-dependent bugs).
 Thanks, I've built a good number of "enterprise" apps and hadn't run into any problems using the Rails default auto-incrementing numeric ids on the client. I never assumed they were sequential or anything, it just happens to be what the framework vends by default when you convert an ActiveRecord model to json.

Thankfully, it's easy enough to change that in the json output, especially with jbuilder templates.
I wouldn't be surprised if Flux developers with Rails backends hit this more frequently given the defaults.

Just annotating with keywords for anybody that comes afterwards; the behavior of immutablejs is as expected.
 Thanks for the discussion so far. Quick follow-up question: let's say I have a collection of users keyed by ID, and as it's generated from JSON, the keys end up being strings (which seems to be good practice from what I've read).

I also have objects for "Teams", and each team contains a list of user IDs that participate in said team. Those IDs are all numbers, and in order to get the actual corresponding user object I need to do `users.get(id.toString())`.

My question is: is it a sane practice to have to run `toString()` this often throughout the code, and is it not a bad idea to have to assume such knowledge about the nature of the data?
 @leebyron Have you considered making a Map.withIndifferentAccess so that you can set and get values using either number _or_ string? That way it would work like JS objects, and it handles serializing and deserializing JSON.
 Ah, sorry for not being clear. I do mean a StringMap. I'd find it very desirable to have an immutable Map that will behave like JS objects and coerce keys to string.

I think it would just make it easier to deal with server responses. Right now whenever I'm taking a value out of my indexed collections I wrap the id with a template string (`${id}`) to make sure it's always a string.
 +1 i'm having the same problem. I think that when converting an object into an immutable, numbers should be preserved as numbers. 

for instance I have an object with a `count` field set to an integer. Once I do a fromJS(), any integer that was stored on `count` field becomes a string. 
 hey @leebyron thanks turns out it was a nasty bug on my end that was coercing it to string. Not immutable's fault. sorry for the false alarm :(
 Thanks for the details in this discussion, got into the same issue recently. Now it does make sense. Maybe it's worth mentioning this gotcha in the docs?
 Sorry to open this thing up again, but I'm working in a very large codebase where a migration from Integers -> Strings could potentially be very painful. Is there a way to extend a Map to a StringMap? Something like:

``` js
import { Map } from 'immutable';

export class StringMap extends Map {
    get(key) {
        key = key.toString();

        return super.get(key);
    }

    set(key, val) {
        key = key.toString();

        return super.set(key, val);
    }
}
```

Any advice on how to approach that? Edge cases I should be aware of?
 Thank you for a great discussion. I learned a lot. I see that the issue is closed, but I'd like to add some points for others to find.

As @leebyron says, consistency is good, i.e. use string-id OR integer-id. If you like me use Immutable with Redux and your data originally comes from a database, you might have integers as both primary and foreign keys. If you need to do lookups in your Redux store by foreign key you'll be best off to **use integers as keys** in your Immutable.Map. This way you never need to "manually coerce" to string when performing lookups.

Here is how I load data into Redux from my API in order to preserve the keys as integers. Part of the reducer:

    case DRAWING_RECEIVE:
      let updatedDrawings = Map(
        action.payload.drawings.map(item => {
          return [item.id, fromJS(item)];
        })
      );  
    return = state.update('items', items => items.merge(updatedDrawings));


N.b. I have an "items" Map for storing the actual data in each slice in the store, hence "items" in the code above. It took me some reading and testing before landing in this key-solution. It really works well and I recommend it. Why is this not work then?
![image](https://cloud.githubusercontent.com/assets/8316282/25061976/2c697acc-21f5-11e7-9578-a2655a31383d.png)
You said that key is evaluated to string but can't get from string version after construct with integer @Altiano read the original discussion again:

* when creating maps from objects, keys are always converted to strings because object property names are already strings

* when creating maps from arrays of key-value pairs, the keys' types are preserved

This is the exact behaviour you're seeing: the keys aren't converted by immutable. The original discussion was the result of a confusion about JavaScript's behaviour (i.e. object keys always being strings), not something immutable does. Must be these lines (http://facebook.github.io/immutable-js/docs/#/Map/Map):

> Keep in mind, when using JS objects to construct Immutable Maps, that JavaScript Object properties are always strings, even if written in a quote-less shorthand, while Immutable Maps accept keys of any type.

-_____-
that is not so straight explanation

anyway Thanks @pluma 

PS: yours should be in the docs:
> - when creating maps from objects, keys are always converted to strings because object property names are already strings
> - when creating maps from arrays of key-value pairs, the keys' types are preserved @Altiano It's not a quirk of immutable.js, it's a "quirk" of JavaScript.

Object keys are property names. Property names are always strings (or symbols, but that's probably not as important). If you use non-string property names when defining properties, the names will be converted to strings. Don't take this as a snark but I strongly recommend you solidify your understanding of the language before moving on.

I strongly recommend the [_You Don't Know JS_ series of books](https://github.com/getify/You-Dont-Know-JS) by getify because they're available online for free and are pretty exhaustive without dwelling too much on the author's personal opinions. If you can't set aside the time to read them from back to back (which is understandable) just use them as a "take what you need" reference and look up the parts of JS you find confusing.

FWIW if you want to observe the behaviour more directly, open your browser's console (F12 or Ctrl+Shift+J/Cmd+Shift+J depending on your platform) and compare the following (assuming Chrome/Edge or a recent version of Firefox):

```js
var obj = {1: 'a', 2: 'b', 3: 'c'};
var map = new Map();
map.set(1, 'a');
map.set(2, 'b');
map.set(3, 'c');

Array.from(map);

Object.entries(obj);
```

The last two lines show you what native maps and objects look like when converted to arrays of key-value pairs. While as you can see it is possible to treat objects like maps, the keys are always strings. There are also some other caveats that make objects unfit as substitutes for proper maps (whether native or immutable.js).

(Another limitation is that some object property names are "special" and may have unintended side-effects, so it's a bad idea to use objects as maps when dealing with potentially malicious or uncontrolled values for keys.)  I'm logging the execution time of a function that receives a _Cursor_ and apply modifications to it via `withMutations`.
Here's the values in milliseconds (executions are triggered by moving a range input):

```
2
1
0
1
1
1
1
1
2
3
2
3
2
3
4
7
4
6
5
6
6
6
6
17
6
6
6
6
7
6
6
7
7
7
8
9
8
8
10
11
13
10
9
14
10
10
10
10
10
12
12
12
13
13
13
14
14
15
16
16
16
18
17
22
18
19
22
20
20
24
28
21
26
25
24
25
26
30
25
26
27
27
27
32
31
33
32
32
35
32
36
34
34
43
36
40
41
44
45
44
43
45
44
43
45
49
45
47
52
47
52
48
56
54
55
60
53
55
59
58
59
64
71
67
62
73
95
66
69
71
74
75
76
83
80
79
75
82
86
82
81
82
90
90
90
89
88
90
96
90
93
97
99
93
102
106
104
109
107
105
115
107
116
114
108
111
114
117
```
 Thanks for asking this: while trying to extract a minimal reproducible example, I realized there was a bug in my code.

It might still be worthwhile to get acquainted with it though:

```
var Immutable = require("immutable"),
    Cursor = require("immutable/contrib/cursor");

var data = Immutable.fromJS({a: {b: {c: {d: 0}}}}),
    cursor = Cursor.from(data, update);

function update (nextData) {
    cursor = Cursor.from(nextData, update);
}

function foo (data) {
    return data.withMutations(function (mutableData) {
        mutableData.setIn(["a", "b", "c"], bar(data.getIn(["a", "b", "c"])));
    });
}

function bar (deep) {
    return deep.withMutations(function (mutableDeep) {
        mutableDeep.set("d", 3);
    });
}

for (var i = 0; i < 1000; i++) {
    var before = Date.now();
    foo(cursor);
    var delta = Date.now() - before;
    console.log(delta);
}
```
 No you won't because you fixed the bug in the simplified case.

The problematic line is the following: `mutableData.setIn(["a", "b", "c"], bar(data.getIn(["a", "b", "c"])));`.

It causes cascading calls to `update`.
 Passing `mutableData.getIn` instead of `data.getIn` to `bar` works for me.

Thanks for your diligence.
  The library is called `immutable-js` but its examples all show mutations:

``` javascript
    var map = Immutable.Map({a:1, b:2, c:3});
    map = map.set('b', 20); // mutation
    map.get('b'); // 20
```

This makes no sense.
 Yes that is much more helpful. This line of code really confusing things:

``` javascript
    var map = Immutable.Map({a:1, b:2, c:3});
    map = map.set('b', 20); // this line here
    map.get('b'); // 20
```

Please consider changing the example to:

``` javascript
  var map1 = Immutable.Map({a:1, b:2, c:3});
  var map2 = map1.set('b', 20);
  map1.get('b'); // 2
  map2.get('b'); // 20
```

That way to copy is clear.
 In retrospect, you could go even harder on this by using the new `const` keyword:

``` javascript
const map1 = Immutable.Map({a:1, b:2, c:3});
const map2 = map1.set('b', 20);
map1.get('b'); // 2
map2.get('b'); // 20
```
  From #264:

> it's also unclear if the correct behavior is to throw or return the unchanged list.

Both of these behaviours are useful in different situations. 

I've encountered this issue in other places in Immutable too, most frequently with `get`. For example, maybe I want to get a value from a map, but throw if it's not present.

Python's dict has a reasonable solution for this, at least for similar case of lookup: `map[key]` and `map.get(key, default)`. As a reader, if you see square brackets, you know the author is asserting the presence of the key. If instead you see `get(key, None)`, you know that the key not being present is an expected outcome.

If I were to apply this to Immutable's API, I'd probably make `get(key)` throw and force people to use `get(key, null)` when they expect the key might not be present. I'm not sure if this kind of breaking change would be appropriate now, but I wonder if you think this kind of "non-nullable" / "presence-asserting" lookup method is useful.

The same idea applies to deleting by key or value and even `set` or `add` (e.g. set/add when key/value is currently unoccupied, throw if new value will unexpectedly overwrite).

I often use helper functions and `update` to make these assertions, but it would be nice if the API had this baked in.
 Ah, good point about flow. I haven't started using that yet but I imagine it will also push in the direction of non-nullability.

Thanks for considering this! Please close this issue unless keeping it open will be helpful to you.
 Somewhat related: https://twitter.com/garybernhardt/status/555503657215488000
 Also related: I starting using this quick implementation of [fetch and fetchIn](https://github.com/dmnd/immutable-sharp/blob/master/index.js) and uncovered 3 bugs in my code
  I wonder how to take advantage of this great library for Event sequences in FRP context.

facebook-react is a great FRP library for UI. That is good.

In addition, I wonder how to take advantage of functional programming aspect, such as map, filter, merge, time-line sequences, that is, Event sequences.

Thanks. Regards.
 Thanks @leebyron 

Actually, yes.

I know RxJS and bacon.js but never liked it.

The fundamental idea is FRP is simply about sequence not in memory, but in time-line.  

Actually, another lazy evaluation stream library:lazy.js
http://danieltao.com/lazy.js/
implemented and try to integrate the pradigm.

Event sequences

``` js
// First we define our "sequence" of events.
var mouseEvents = Lazy(sourceElement).on("mousemove");

// Map the Event objects to their coordinates, relative to the element.
var coordinates = mouseEvents.map(function(e) {
  var elementRect = sourceElement.getBoundingClientRect();
  return [
    Math.floor(e.clientX - elementRect.left),
    Math.floor(e.clientY - elementRect.top)
  ];
});
```

I am not sure if this approach for FRP implementation is the best.

In fact, there's some other approach.

http://falsandtru.github.io/lazychain/

Although I am not big fun of this lazychain, since this uses jQuery, I think this approach is great.

Here's the idea (Google Translate to Jp to En)
https://translate.google.co.jp/translate?sl=ja&tl=en&js=y&prev=_t&hl=ja&ie=UTF-8&u=http%3A%2F%2Ffalsandtru.github.io%2Flazychain%2Fspec%2F&edit-text=&act=url

My own translation for the important point:

> As the default feature, the available feature is merely a little original method and JavaScript Array built-in method, however, this library can be extend by using any other external functional library, such as Undersocre.js or Lo-Dash.
> 
> Since for functional operation, you can take advantage of your familiar methods in those external existing libraries, you can minimize your learning-cost to take advantage of this library.
> 
> This library is not a reproduction of an FRP environment, but a transducer or wrapper by adding function to operate sequence in async way, and messaging feature.

I am not using this lazychain library, but the idea to prepare a transducer or wrapper for the existing library such as Undersocre.js or Lo-Dash sounds great.

So, I wonder if it's possible to apply this approach to Immutable.js, this library can use sequence in lazy way already. 

Thanks. 
 Thanks.

I would call `compute()` :)
and I actually did that, since I have implemented a conceptual lazy evaluation and FRP library by myself; those code is fundamentally opposite, pull and push, in mathematical way. So I agree with you.
https://github.com/kenokabe/spacetimeline

Now, I consider what is the best way to integrate lazy and FRP not re-inventing wheel.
 I understand.

All I know so far is, since event sequences are lazy in that their values are spread out over time instead of being spread out in computation or memory, mathematically, in foundation, in ideal manner, Immutable.js can be somehow connected to FRP seamlessly, or with little gap, other than facebook-react.

One approach is to try to extend the current Immutable.js method, like lazy.js did that.
Another approach is to try to wrap this Immutable.js with another library like lazy-chain.

That is what I am thinking, and wonder how other people think.
I am happy you responded.

Thanks.
 Agreed.
I also think the wrapping approach is smarter.
Probably I will start to study this aspect that can apply to Immutable.js.

Thanks for your thought @leebyron 
 Right, since I hold another project, (like writing functional programming book to publish :)  ), I wonder how much time I can spend, but this looks very important task. 
I might ask question for you about this `Immutable exposes` or other area later. Thanks again.
  `count(infiniteSeq)` obviously doesn't work and I'm not sure how else to check whether it's empty currently. `rest()` keeps returning a valid obj rather than `null` (which I think is right, clojure does this too) but I can't use it to assert emptiness.
 What about `seq.size`?
 @pluma same as count. Also might not exist until you do `count()` for lazy seqs. 
 Ah `some`... Right
  I found this surprising:

```
> Immutable.Map([[1,2]])
Map { 1: 2 }
> Immutable.Map(Immutable.fromJS([[1,2]]))
Map { undefined: undefined }
```

It particular, it's the inside tuples that it needs to be plain arrays:

```
> list
List [ List [ 1, 2 ], List [ 3, 4 ] ]
> Immutable.Map(list.map(x => x.toArray()))
Map { 1: 2, 3: 4 }
> Immutable.Map(list.toArray())
Map { undefined: undefined }
```

A bug, or a misunderstanding on my part? What is the preferred way to form a map from an immutable list of 2-tuples? Thanks!
 :thumbsup:
  Currently all imports exist solely, as far as I can tell, to configure the order in which the files are concatenated (via [smash](https://github.com/mbostock/smash)). In a real ES6 environment instead of this

``` js
import "iterable"
class Collection extends Iterable {}
```

you'd do something like this

``` js
import { Iterable } from "./iterable";
class Collection extends Iterable {}
```

Ideally you'd then combine the files using a smarter version of smash, i.e. the (shameless plug) [es6-module-transpiler's bundle format](https://github.com/esnext/es6-module-transpiler).

I'm working on extracting the bundler from es6-module-transpiler into its own project, and I tried using immutable-js as a test project. I've converted some of the files to the style above and the output is essentially the same as when used with smash.
  ```
var Immutable = require('immutable');
var i = Immutable
  .Range()
  .take(10000)
  .toArray()
  .map(function(x)
  {
    console.log(x);
  });
```

This works to console.log from 0-9999.

```
var i = Immutable
  .Range()
  //.take(10000)
  .toArray()
  .map(function(x)
  {
    console.log(x);
  });
```

This obviously does not work.

> Error: Cannot perform this action with an infinite size.

```
var i = Immutable
  .Range()
  //.take(10000)
  //.toArray()
  .map(function(x)
  {
    console.log(x);
  });
```

This does nothing. Perfectly makes sense.

Everything looks good, and very cool.

However, in some cases, we want to do

```
while(true)
{
   // do something
}
```

and I wonder what kind of method is appropriate to make a thing work like the above in `immutable.js` context.

Using some iterator?

Thanks!
Regards.
 You can get an iterator using `Range().values()`.
 @leebyron 
Thanks for the code! Really appreciated.

Regards.
 @pluma
Thanks! 

Regards.
  ``` javascript
> Immutable = require('immutable')
> Model = Immutable.Record({})
[Function: Record]
> Model.prototype.toJSON = function() { return 'model' }
[Function]
> JSON.stringify({ a: new Model() })
'{"a":"model"}'
> JSON.stringify(Immutable.Map({ a: new Model() }))
'{"a":{}}'
```

I expected the last line to return `'{"a":"model"}'`.

I know `toJSON` on iterables is an alias to `toJS` and calls `toJS` recursively which is why the `Model`'s `toJSON` isn't called at all. Perhaps `toJSON` should instead call `toJSON` recursively which gives us a more familiar way to override the serialization behavior?
  1) declaration in typescript is `import Immutable = require('immutable');`
2) it's not easy work with such `require('../..')` create external browserify bundle with immutable and contrib/cursor both included
 @leebyron 
I have an issue with browserify, for example if i create bundle `browserify -r immutable -r 'immutable/contrib/cursor' > vendor.js`
and try to use it in other bundle `browserify app.js -x immutable -x 'immutable/contrib/cursor' > app_bundle.js`
i've got an error `Cannot find module '../..'`

It looks like in this situation browserify can't detect that require('../..') is the same as require('immutable'),
and as immutable v3 working with cursors need to include additional module, i think this module can be seen as like external library, so it need to have full `require('immutable')` declaration inside

And in typescript definition i  see full require('immutable') but not in js code.
I think it's browserify bug, but it can be easy avoided if you allow this change.
  I constantly seem to make this mistake: `foo.getIn("bar", "baz")`. (note the lack of `[]`)

Often it returns `undefined` but sometimes I end up with a number or something. The annoying thing is that the error is silent. I wish `getIn` would just blow up when I try to do something like that.
 Thank you :+1: 
  ```
seq.flip().map(key => key.toUpperCase()).flip().toObject();
```

`=>` is not available in js. Is coffeescript.
 It's not CoffeeScript but a next revision of ECMAScript â€” ECMAScript 6 which is becoming available in modern browsers and also via ES6 to ES5 compilers like Google's Traceur or Facebook's jstransform.
 Ah, ok then. But don't you think it should be readable for the masses? I think it's too futuristic.
 Just to add when @leebryan say they can be "transpiled", there exists output that already is namely, so you dont have to worry regarding distribution or just to inspected the concatenated source in old style JS.

https://raw.githubusercontent.com/facebook/immutable-js/master/dist/immutable.js
https://raw.githubusercontent.com/facebook/immutable-js/master/dist/immutable.min.js
 Ok, thanks. But remember that there are still many devs that will not use ES6 soon or not using right now. Because of this I think you should keep the examples in ES3 (will make less people go away)
 I'm not sure that the kind of people who run away when they see ES6 are the kind of people who will embrace a library for immutable data structures.
 I don't want to be rude, but IMO you should make the entrance as easy, pleasurable and familiar way. The more familiar is with what the dev already know the more probable is to adopt this lib. Also at first glance I thought was coffeescript... which I don't personally like. And I don't think many devs already looked into ES6. I, for example, don't have any interest for it because I don't plan yet to use in the next year. Because of this I don't know it's syntax.

This lib already has a thought shift, adding another one will not help the adoption. 

But this is just my opinion and you decide whenever you want more users or not. If you are interested in this topic learn more about user experience (apply to this case too).
 I share @pluma's point of view regarding the targeted audience.
 I think it should remain. Instead of saying "remove it because we are not familiar with it", the attitude should be "I should get familiar with this". I think the devs are probably targeting devs that want to embrace new concepts (including ES6) instead of mass adoption.
 Seems to me like this parallell with JSX. It creates needless hurdles for adoption, and as such does a big disservice to React. 

> This lib already has a thought shift, adding another one will not help the adoption.

Indeed.
 @uris77 If you were working in marketing or UX you would understand.

https://lh6.googleusercontent.com/-yEGam36rx5U/UtGTBaPrCCI/AAAAAAAAYOw/r5TjTcrIcHI/w500-h281/UVMV7ZB.gif
 > you decide whenever you want more users or not

While some of my OSS gets decent adoption, I write it for me and my team first--adoption is simply a fun nice-to-have, but not something I optimize for.

I would guess its the same thing for Facebook. They'd rather have their engineers writing `seq.flip().map(key => key.toUpperCase());` not `seq.flip().map(function(key) { key.toUpperCase()});`. This repo serves as both internal and external documentation, and they are going to tailor it to their development, not optimize for adoption.

@bitplanets your assessments of people's understanding of UX make it more difficult for me to take your posts seriously :(

Anecdotally: I have observed, as the front-end infrastructure lead on a team of ~50 engineers, that the use of fat arrows decreases the number of function context bugs our team deals with. For me, this is better UX with the language.
 > Anecdotally: I have observed, as the front-end infrastructure lead on a team of ~50 engineers, that the use of fat arrows decreases the number of function context bugs our team deals with. 

It also prevents a common mistake that you yourself have made in your comment :) 
 YARGH! implicit return!

``` js
seq.flip().map(key => key.toUpperCase());
seq.flip().map(function(key) { return key.toUpperCase()});
```
 Sidenote:

> they can be "transpiled" into ES3

There currently doesn't exist an ES6 compiler that outputs ES3. Every current compiler relies on ES5 syntax or features.
   Small reproducible map, but happened in large/deep/nested many keys map

``` javascript
Immutable.Map({ v: 5503.13 }).hashCode()
317207036

Immutable.Map({ v: 5503.14 }).hashCode()
317207036
```

Shouldnt the hashcode be different?
  I've found myself using this a lot:

``` js
function deleteValue(l, x) {
  var i = l.indexOf(x);
  if (i === -1) {
    throw `Value ${x} not found in ${l}`;
  }
  return l.delete(i);
}
```

It's useful because the shorter `l.delete(l.indexOf(x))` does the wrong thing when the value is not found. Do you think this method (maybe with a better name?) belongs in the lib?
  Edit: Sorry, didn't see the `cacheResult` function, so turning this into a new issue.

Clojure auto caches `seq.get(i)`. I think this is a better solution than to either explicitly call `cacheResult` or never cache, for 2 reasons:
- It's not clear that the last line is always linear:

``` js
var s = I.Range(0, 10);
var c = s.skipWhile(function(v, i) {
  console.log(i);
  return i < 5;
});

c.first(); // logs 0 1 2 3 4 5, each time
```
- `cacheResult` force evaluates the whole seq which kinda defeats the purpose of lazy evaluation (I can't use it, my stream is infinite). I think clojure's "cache as you go" approach is much better, whether we make the caching explicit or not (I'm for the latter).
 @leebyron what do you mean by

> I think default to no cache is still best to make chaining operations easier to build, but a cacheGets could be pretty interesting

How does it make chaining operations easier?

Also, what is the difference between calling `cacheResult` and `toList` ? Is there any particular reason why should I prefer the former?

Would you be interested in pull request doing auto-cache of Seq as it gets lazy evaluated?
 Great! I will work on it.
 Just spent the better part of an hour scratching my head with a Heisenbug caused by this... or rather, by my assumption that it worked the same as in Clojure. :)

:+1: for auto-caching Seq's!

I also don't quite get this part [in the docs](https://facebook.github.io/immutable-js/docs/#/IndexedSeq/cacheResult):

> Because Sequences are lazy and designed to be chained together, they do not cache their results.
 @lacker Is there a follow-up discussion somewhere? Implicit auto-caching is still a missing feature.  Related Closed (solved) Issue:
https://github.com/facebook/immutable-js/issues/254

For instance, when we have a code like below:

``` js
var _ = require('lodash');
var __ = require('immutable');

var __natural = __.Range(); //infinite natural numbers sequence 
var fibF = _.memoize(function(n) {
  return n <= 1 ? 1 : fibF(n - 2) + fibF(n - 1); //as the math definition of fibonacci
});
var __fib = __natural.map(fibF);
```

Is it possible to obtain an iterator from  sequences like `__natural` or `__fib`?
such as to obtain a value like `a = it.next();` with a certain event in a gradual manner?

Regards.
 @leebyron

Thanks for your answer.

I tried as below:

``` js
var getIterator = function(Symbol)
{

   var iterator = iterable[typeof Symbol === "function" && Symbol.iterator ? Symbol.iterator : "@@iterator"]();
   return iterator
};

var it = getIterator(__natural);

console.log(it.next());

```

However, got an error:

```
ReferenceError: iterable is not defined

```

I must be confused. Please modify the code. Thanks.

Regards.
 @leebyron

Thanks for your answer. It works flawlessly now.

For future references for the others, here's the full code:

``` js

var __natural = __.Range(); //infinite natural numbers sequence

var getIterator = function(iterable)
{
  var iter = iterable[typeof Symbol === "function" && Symbol.iterator ? Symbol.iterator : "@@iterator"]();
  return iter;
};

var it = getIterator(__natural);

console.log(it.next());  //{ value: 0, done: false }
console.log(it.next());  //{ value: 1, done: false }

```
 Probably, it's cool to have getIterator API somewhere.
 Understood. Thanks again.

Regards.
 I post some other question,
https://github.com/facebook/immutable-js/issues/272

and coincidently, I had an answer

pluma commented 6 hours ago

> You can get an iterator using Range().values().

So I tried.

```
var _ = require('lodash');
var __ = require('immutable');

var __natural = __.Range();
//infinite natural numbers sequence

var __narural10 = __natural.take(10);
//the first 10 sequence (still no calculation)

console.log(__narural10.toArray());//calculate and output

var fibF = _.memoize(function(n) {
  return n <= 1 ? 1 : fibF(n - 2) + fibF(n - 1);
  //as the math definition of fibonacci
});

var __fib = __natural.map(fibF);
//infinite Fibonacci sequence

var __fib100 = __fib.take(100);
//the first 100 sequence (still no calculation)

console.log(__fib100.toArray()); //calculate and output

var it = __fib.values();

console.log(it.next());  //{ value: 1, done: false }
console.log(it.next());  //{ value: 1, done: false }
console.log(it.next());  //{ value: 2, done: false }
console.log(it.next());  //{ value: 3, done: false }
console.log(it.next());  //{ value: 5, done: false }
```

Very cool.

Perhaps, does `.values()` implemented recently?
 @leebyron 
I see!
Thanks you. Very informative to study.
Regards.
  I am trying to get a map inside another map by using the `get` method. My expectation was that this would have returned an immutable Map, but it returns just an object literal. Is this normal behavior?

``` javascript
  var nested = Immutable.fromJS({a: {b: {c: 1}}})
  nested.get('a') //=> returns {b: {c: 1}}
```
 Looks like the it was getting cast to object literal by my own code. Sorry about the trouble! (The above sample was a simplified example of my original code. I should have tested it in isolation before opening this issue.)
  For all my use cases so far, using an Immutable Map to represent `this.state` on a component has worked without a hitch (used according to the [wiki](https://github.com/facebook/immutable-js/wiki/Immutable-as-React-state)). However, for React components that use multiple mixins that define `getInitialState`, I'm running into issues:

```
Error: Invariant Violation: mergeObjectsWithNoDuplicateKeys(): Tried to merge two objects with the same key: `size`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.
```

I had a feeling something like this would arise because React merges state when building up a component's state, however I'm unclear on how to proceed short of abandoning Immutable Map as `this.state`. Thanks for any help! 
 Certainly, thanks for the quick reply. As you could guess, it's a fairly straightforward reproduction:

```
var A = {
  getInitialState: function() {
    return Immutable.Map();
  }
};

var B = {
  getInitialState: function() {
    return Immutable.Map();
  }
};

var App = React.createClass({
  mixins: [A, B],

  render: function() {
    return <div></div>;
  }
});

React.render(<App />, document.body);
```

I think what I'll do is make the state properties Immutable but keep `this.state` a regular JS object. It means that I can't use `this.replaceState`.  Agreed, this note seems worth putting in the wiki. Much appreciated.
  I've been going through and trying to replace my mutable structures with immutable ones, the thing I've run into though is recursive structures. As a simple example:

``` javascript
x = { }
x.x = x;
```

How would I do something similar with I.Map? x.set("a", x) doesn't work because it stores the old one. (I'm converting a JS value, and as such fromJS doesn't work, but I can handle the conversion myself as long as I can figure out some way of getting a self reference to begin with)
 From what I can tell, it seems that other languages solve this with lazy values (see: http://stackoverflow.com/questions/8374010/scala-circular-references-in-immutable-data-types ). immutable could do something like this:

``` javascript
function Lazy(aFunction)
{
    this.get = memoize(aFunction);
}
```

Then, in Map/List/etc's .get():

``` javascript
get = function(key)
{
    value = /*current*/get(x);
    if (value.constructor === Lazy)
         return value.get();
    return value;
}
```

Now, we can do the following:

``` javascript
var recursive = I.Map().set("x", Lazy(() => recursive));
console.log(recursive === recursive.get("x")) // prints true

//We can also use it to make doubly linked lists:

var node0 = I.Map({ prev: null, next: Lazy(() => node1) })
var node1 = I.Map({ prev:  Lazy(() => node0), next: Lazy(() => node2) })
var node2 = I.Map({ prev: Lazy(() => node1), next: Lazy(() => node3) })
var node3 = I.Map({ prev: Lazy(() => node2), next: null })
```
 Yeah I suppose the hope is to have some sort of built in support for
either, since if not it will never work with other people's code (they
can't know that some internal value is an atom or lazy, whereas with the
lazy example I gave they don't need to know). Similarly in my own code I'd
have to check for .value/lazy everywhere I make an access, and thus
effectively break getin/etc. For example, if someone had implemented
oneMore(object, keypath) { return object.getIn(keyPath) + 1; }, this will
break with my circular structure : x= Map { a: 1, b: self }, oneMore(x,
[â€œbâ€,â€bâ€,â€bâ€,â€bâ€,â€aâ€™]), but would work with built in support for lazies.

On Monday, December 22, 2014, Lee Byron notifications@github.com wrote:

> There is no way (intentionally) for immutable persistent data structures
> to contain circular references. Immutable structures can contain circular
> references, but in order to be persistent and take advantage of structural
> sharing, they need to be acyclic. The stack-overflow you link to
> illustrates this well - showing how a double-linked list needs to make a
> complete copy in order to perform an append operation.
> 
> There are some other problems that emerge from circular references in
> values, such as deep equality checking and hash-value computation.
> 
> Languages based on immutable structures handle this in different ways:
> 
> Scala has lazy var which is pretty much what you wrote up here. A
> deferred memoized function.
> 
> Clojure has atom which is a bit different (and easier to understand
> IMHO). Atom is an atomically locked mutable wrapper. Since JavaScript is
> single threaded, no locks are necessary so it's only a mutable wrapper. In
> other words: { value: "foobar" }.
> 
> For equality and hashing, Atoms are treated as Objects not as Values. So {
> value: "A" } !== { value: "A" }.
> 
> So you might treat this like:
> 
> var node0 = I.Map({ prev: null, next: {} })var node1 = I.Map({ prev:  {value: node0}, next: {} })
> node0.get('next').value = node1;var node2 = I.Map({ prev: {value: node1}, next: {} })
> node1.get('next').value = node2;var node3 = I.Map({ prev: {value: node2}, next: null })
> node2.get('next').value = node3;
> 
> ---
> 
> However, both approaches: lazy function or atom object are totally fine!
> This data structure library has no opinion on either, you just need to be
> aware of their use so you can treat them appropriately:
> 
> // Lazy function
> node3.get('prev').get();// Atom object
> node3.get('prev').value;
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/issues/259#issuecomment-67899036
> .
 So, interestingly enough, I was able to accomplish this using withMutations: https://gist.github.com/tolmasky/8a91af5ac1e0a949b423

Now the only issue is that toString borks and toJS bork (these are much easier to fix). Would you be opposed to having an implementation of toString and toJS that account for circular references (just like log you'd see something like Map { a: [Circular] }). I'm happy to just have them in my code of course, but given that this is "possible", I figured you might want it in mainline as well.
 I've filed this related issue which deals with the same reference in objects (not necessarily circular): #305 
  I personally much preferred to pass the arguments as a splat rather than a list. Using it myself so figured why not submit a PR!
 Makes sense! Thanks so much for the comprehensive explanation, I really appreciate it! Learned something, too =)
  I'm writing a small bit of infrastructure to cache values derived from keys of `Immutable.Record` objects, which for invalidation relies on the fact that mutation results in a distinct object. These cached values are actually getters on the prototype of objects that inherit from `Immutable.Record`, so they're accessed just like non-derived properties. I'd like to ensure, though, that the cached values aren't accidentally updated while mutating such an object using `withMutations`. In order to do this, I need a reliable way to determine whether the object is either currently mutable, or has been somehow altered. Currently, I'm doing this with the `wasAltered`, which works fine for my purposes, but I noticed that it isn't officially documented anywhere. Could this become part of the official API? Or, alternatively, could something like `isMutable` be added to `Immutable.Record` objects?
 Thanks for the quick reply, @leebyron! Here's a contrived example that hopefully illustrates what I'm trying to do: https://gist.github.com/iwehrman/040efd0a39920c09df87

I'm looking for a simple, fool-proof way to define models based on `Immutable.Record` that have lazily computed and cached properties which are derived from the record's keys. In the example above, the `length` property of `LineSegment` is lazily computed and cached from the `left` and `right` keys. Ensuring that `length` can be used safely while mutating the object is the main goal.

The obvious workaround to my problem is an intermediate prototype that inherits from `Immutable.Record` and that wraps `withMutations` to set an `isMutable` flag while mutating. I'm also not opposed to restricting what can be done with mutable objects using a "builder" API to prevent errors like the one outlined in the above example. Of course, if I can find a way to make use of cached values in  a way that's both transparent and safe, I would prefer that. But, if not, I'll of course vote for a mechanism that is merely safe!
 Yes, in this contrived example it is clearly faster to simply perform the single arithmetic operation. Our use cases are not so contrived :) We're building models that are trees with many interesting subsets of nodes, and we'd rather not always calculate those up front. Of course, when it is possible to just use the lazy quality of `Seq` that is preferred. But using `Seq` is not always possible or preferable, and I think caching remains worthwhile in some of these cases.
  If `m` is a map, `m.getIn(undefined)` returns `m`.

I was expecting `undefined` as return value.
 I think `undefined` should be considered an illegal input since it's neither an `Array` nor an `Iterable`.
 @leebyron I conceived a bad analogy between `get(undefined)` and `getIn(undefined)`: indeed `undefined` isn't a valid input for `getIn`. 
 It seems that `hasIn` is still affected.
  Is there a way to change the state in a consistent way while using more than one cursor?

Let's suppose we have 2 points and we want to vertically align both of them. The initial state is represented like this:

  var state = Immutable.fromJS(
    {points: [{x: 3, y: 0}, {x: 7, y: 0}]}
  );

Reading the x coordinates from both of them using 2 cursors is simple:

  var points = Cursor.from(state, 'points', function(newState) {
    state = newState;
  });

  var p1 = points.cursor(0);
  var p2 = points.cursor(1);

  var newX = (p1.get('x') + p2.get('x')) / 2; // newX -> 5

But updating both objects leaves us an inconsistent state:

  p1 = p1.set('x', newX); //state: "Map { points: List [ Map { x: 5, y: 0 }, Map { x: 7, y: 0 } ] }"
  p2 = p2.set('x', newX); //state: "Map { points: List [ Map { x: 3, y: 0 }, Map { x: 5, y: 0 } ] }"

This example is trivial and there are some workarounds for this particular case. But things get ugly with a deeper state and complex operations.

What am I missing? Is there a way to 'synchronize' the cursors?

Thanks!
 The pattern you recommended is definitely protecting against miss usages and most likely I'm going to use it. Thanks!

But is there a clean way of recreating the `p2` based on the new `p1` and the old and obsolete `p2` only? In my case, I'm trying to avoid recreating the `p2` by hand because I'm going to recursively traverse a deep structure so I want to keep the things as simple as possible.

I think that passing a getter function to the Cursor.from() can "synchronize" all the cursors that perform basic operations. Something like this:

```
  var STATE = ...;

  var points = Cursor.from(
    function () {
      RETURN STATE;
    },
    'points',
    function (NEWSTATE) {
      STATE = NEWSTATE;
    });
```

Probably all the `get`, `getIn` and `set` will work. But I can't imagine any simple implementation of keeping other cursors on track while another one inserts or deletes.
 Based on your advice I've created some helper functions that help me dig into a deep hierarchy, make some changes and update all the required parents. They can be used like this:

``` js
var state = Immutable.fromJS({
  diagram: {
    components: [
      {
        legs: [{}, {}, {}]
      },
      {
        legs: [{}, {}]
      }
    ]
  }
});

// ...

state = dissect(state,
  select('diagram',
    select('components',
      select('legs', function (leg) {
        if (/* this is the object I'm looking for */) {
          // then do some things here
        }
        return leg;
      })
    )
  )
);
```

The `select` function is looking to the data type of the current container and if it's a collection then it will call the inner function for each value.

Do you know if there is already support in the immutable library that do the same thing?

There are some problems with this approach because if the top container changes then all the `dissect-select` calls/usages will have to be update to reflect the new structure of the state. So most likely the `dissect` function should be better operating on a cursor object which is the first common ancestor of all the objects to be changed. For this example that the diagram is the first common ancestor:

``` js
// 1. get the current diagram to operate on as a cursor
var diagramCursor = getTheDiagramToOperateOn(state);

// 2. operate 'under' the cursor
diagramCursor = dissect(diagramCursor,
  select('components',
    select('legs', function (leg) {
      if (/* this is the object I'm looking for */) {
        // then do some things here
      }
      return leg;
    })
  )
);
```

With this new approach the `dissect-select` and the actual operation are a bit more isolated by the global state and the code more maintainable.
 This is a silly implementation of the helper functions mentioned in the previous comment:

``` js
  dissect = function (root, fn) {
    if (Immutable.List.isList(root) || Immutable.Seq.isSeq(root) || Immutable.Map.isMap(root)) {
      return fn(root);
    }
    return fn(root.state();
  };

  select = function (key, fn) {
    return function (parent) {
      var value = parent.get(key);
      if (value !== undefined) {
        if (Immutable.List.isList(value) || Immutable.Seq.isSeq(value)) {
          value = value.map(fn);
        } else {
          value = fn(value);
        }
        return parent.set(key, value);
      }
      return parent;
    };
  };

  filter = function (key, fn) {
    return function (parent) {
      var value = parent.get(key);
      value = value.filter(fn);
      return parent.set(key, value);
    };
  };
```
 Sorry for not mentioning the purpose of the `dissect` and `select` functions.
The project I'm working on is in the experimental phase and I needed a way to fast prototype and mitigate the risks of dealing with bugs.

Maybe at some point the underlying implementation will be changed to perform faster or even dropped and replace the initial calls with the `updateIn` and `map` functions. But at this point the beauty is preferred over performance :)

In the previous example the legs and components are both lists and the `updateIn` needs an exact path and it doesn't iterate over an array. So the `updateIn` usages need to be alternated with `map` calls something like this:

``` js
// 2. operate 'under' the cursor
diagramCursor = diagramCursor.updateIn(['components'], function (components) {
  return components.map(function (component) {
    return component.updateIn(['legs'], function (legs) {
      return legs.map(function (leg) { /* ... */ });
    });
  };
});
```

The usages of the `updateIn` and `map` are also compact and probably fast but they are just a little bit more difficult to be maintained (but it's just a matter of taste). The `dissect` and `select` functions were a nice exercise to help me learn how to change the state when 1 cursor is not enough.
  I'd like to know how much ability to manage sequence this library has.

For instance,  Fibonacci sequence.

Here's a sample code of 
lazy.js with `memoize` feature of underscore.js or lodash.

```
var _ = require('lodash');
var __ = require('lazy.js');

var fibF = _.memoize(function(n)
{
  return n <= 1 ? 1 : fibF(n - 2) + fibF(n - 1);  //as the math definition of fibonacci 
});

var __fib = __.generate(fibF); //infinite fibonacci sequence

var __fib100 = __fib.take(100); //first 100 sequence (still no calculation)

console.log(__fib100.toArray()); //calculate and output
```

I 've read the API doc, but can't be sure about this.

Please let me know. thanks.
 @leebyron Thanks for the detailed answer. Extremely informative to study.

> Would you like to see something more specific in the Seq API?

Actually yes. I wonder if there's a generator API to generate a sequence from a function (like `lazy.js` example I presented above).

Personally, I love to see the simplicity to generate a sequence from a function.

For another example,

**natural numbers**

```
var __ = require('lazy.js');

var naturalF = function(n)
{
    return n;  // the #0 is 0, #1 is 1, #2 is 2, ......    the math definition of natural numbers sequence 
};

var __natural = __.generate(naturalF); //infinite natural numbers sequence

```

I understand the usability of `iterate`, however, it would be great if this library has a generator method like `lazy.js`. I would like to add this to the feature request.

Regards.
 Thanks @leebyron 

> From lazy.js's docs, here is lazy.js generator:

Yes, the example in the doc is not that appropriate I think, and in fact, I suggested another which is identical code of the first post in this thread.

https://github.com/dtao/lazy.js/issues/79

After all, what I'd like to ask is, is it hard to add some API like
`generator` or whatever you might want to call, to be able to write a code below:

```
var _ = require('lodash');
var Immutable = require('immutable');

var fibF = _.memoize(function(n)
{
  return n <= 1 ? 1 : fibF(n - 2) + fibF(n - 1);  //as the math definition of fibonacci 
});

var fibonacciSequence = Immutable.generate(fibF);   //infinite fibonacci sequence

```

PS. your code for Iterator Seq is extremely useful for me to study close. 

> Here's an Iterator Seq which will have the same behavior as the lazy generator above.

Thanks a lot to show me that.

Regards.

PS. wait....

var fibonacciSequence = Immutable.Seq(fibF);

is the code?? I need to verify from now. 
 I tested the code below, expecting it work. As the result, unfortunately, not.

```
var _ = require('lodash');
var Immutable = require('immutable');

var fibF = _.memoize(function(n) {
  return n <= 1 ? 1 : fibF(n - 2) + fibF(n - 1); //as the math definition of fibonacci
});

var __fib = Immutable.Seq(fibF); //infinite fibonacci sequence

var __fib100 = __fib.take(100); //the first 100 sequence (still no calculation)

console.log(__fib100.toArray()); //calculate and output

//resut  is an empty array 
// []
```

What do I miss?

Regards.
 Also, I tested for natural numbers:

```

var Immutable = require('immutable');

var naturalF = function(n) {
  return n; // the #0 is 0, #1 is 1, #2 is 2, ......    the math definition of natural numbers sequence
};

var __natural = Immutable.Seq(naturalF); //infinite natural numbers sequence

var __narural10 = __natural.take(10);

console.log(__narural10.toArray());

//[ undefined ]


```
 Thanks @leebyron

COOOool. It works. I love you.

For future reference for other geeks, here's the full working code that I intended, and it does work under Immutable-js!

``` js

var _ = require('lodash');
var Immutable = require('immutable');

var fibF = _.memoize(function(n) {
  return n <= 1 ? 1 : fibF(n - 2) + fibF(n - 1); //as the math definition of fibonacci
});

var __fib = Immutable.Range().map(fibF); //infinite fibonacci sequence 

var __fib100 = __fib.take(100); //the first 100 sequence (still no calculation)

console.log(__fib100.toArray()); //calculate and output


var naturalF = function(n) {
  return n; // the #0 is 0, #1 is 1, #2 is 2, ......    the math definition of natural numbers sequence
};

var __natural = Immutable.Range().map(naturalF); //infinite natural numbers sequence

var __narural10 = __natural.take(10);

console.log(__narural10.toArray());
```

This library is extremely promising project under facebook solid foundation.

I will study and would like to commit.

Thanks a lot for your detailed explanation. 

Regards.
 How about this?  This works in Chrome (should work in FF and Opera, too).

``` js
function* fib(prev, n){
    var result = prev + n;
    yield result;
    yield* fib(n, result);
}
var s = new Immutable.Seq(fib(0, 1));
```
  If `Cursor.update` acted like an identity function, should `onChange` handlers of `Cursor.from` ever be called?
 It was something that came up when I was using a library that uses Cursors. I PR'd the library to skip updates externally. 

Unsure why, but It may be useful to someone to detect all 'signals' of update calls. I no longer really need this internally in the `Cursors`. But at this point, it may seem like a semantic issue for others. 
  A possibly suggestion

Just thinking it would make my code simplier if a predicate function could be accept as a part of a path spec for getIn, updateIn, setIn etc..

e.g.
Immutable.fromJS({a: { b: [{n: 5},{n:6}] } }).updateIn(["a","b", function(arrItem) { return arrItem.get("n") == 5}], function(state) { return state; });
  The documentation says that `deleteIn()` is an alias of `removeIn()` but it is not defined in the current version (3.4.0):

``` js
var map = Immutable.Map();
console.log(map.deleteIn, map.removeIn);
```

Test: http://jsbin.com/kiqibumavi/1/
  Hi,
I'd like to perform operations on lazy Seq's with JS and found the Immutable.js library.
From the homepage I gather that this should work:

```
var Immutable = require("immutable");
Immutable.Range(1, Infinity).map(function(n){-n}).take(10);
```

But I get the following error:

```
/Users/encho/Desktop/react/node_modules/immutable/dist/immutable.js:58
throw new Error(error);
      ^ 
```

   Error: Cannot perform this action with an infinite size.
    at invariant (/Users/encho/Desktop/react/node_modules/immutable/dist/immutable.js:58:11)
    at assertNotInfinite (/Users/encho/Desktop/react/node_modules/immutable/dist/immutable.js:85:3)
    at seqIterate (/Users/encho/Desktop/react/node_modules/immutable/dist/immutable.js:1166:3)
    at IndexedIterable.__iterate     (/Users/encho/Desktop/react/node_modules/immutable/dist/immutable.js:955:12)
    at IndexedIterable.takeSequence.__iterateUncached (/Users/encho/Desktop/react/node_modules/immutable/dist/immutable.js:2245:14)
    at seqIterate (/Users/encho/Desktop/react/node_modules/immutable/dist/immutable.js:1178:14)
    at IndexedIterable.__iterate (/Users/encho/Desktop/react/node_modules/immutable/dist/immutable.js:955:12)
    at IndexedIterable.mappedSequence.__iterateUncached (/Users/encho/Desktop/react/node_modules/immutable/dist/immutable.js:2107:21)
    at seqIterate (/Users/encho/Desktop/react/node_modules/immutable/dist/immutable.js:1% 

Is this a bug?

Thanks for writing this library,

Lorenzo
 Great!
Thanks ;-)
  This may be a dumb question, but afaik, I don't think there's an API for this. It'd be great if there is `Iterable.hasIn()` can take in an array to check if a key path exists. 

`Iterable.has()` can't be patched since an array is a valid key.

At the moment, I'm doing something like this:

``` js
function pathExists(iterable, path) {

  if(iterable.getIn(path)) {
    return true;
  }
  var notSetValue = true;
  return !(iterable.getIn(path, notSetValue) === notSetValue);
}
```
 Thanks for fast response!
  The `Map.updateIn(...)` with an identity function will always result in no change; due to https://github.com/facebook/immutable-js/commit/335b312c3e80ed2051b62ae4f29ba34f2734d3e9.  Relax this constraint to allow modifications only when `notSetValue` is not iterable and key path isn't set.

If the updater function returns `undefined` (even if `notSetValue` is `undefined`), then that's the value to explicitly set at the key path.

Closes https://github.com/facebook/immutable-js/issues/245
 Originally, I was going to use this as conditional base case check:

``` js
return newValue === existingValue && !isNotSet ? existing : newValue;
```

But then the following cases were failing: 

```
updateIn â€º mergeIn â€º it does not create empty maps for a no-op merge
updateIn â€º mergeDeepIn â€º it does not create empty maps for a no-op merge
```

Which prompted me to change to:

``` js
return newValue === existingValue && (isIterable(newValue) || !isNotSet) ? existing : newValue;
```

At this point, I didn't want to change the behaviour too much.

---

According to `Map.updateIn()` docs (I assumed `List.updateIn()` is similar):

> If any keys in keyPath do not exist, a new immutable Map will be created at that key. If the keyPath was not previously set, updater is called with notSetValue (if provided).

I'm thinking that we set values at non-existent key paths as long as values aren't iterables, so as to respect behaviour of `mergeIn` and `mergeDeepIn`.
 I think it's good to ensure `set` and `setIn` works when setting `undefined`; I haven't looked into too much into the test cases for these yet.

---

I haven't into other use cases of `updateIn` when the `updater` function returns `undefined`. I think doing so is that the user intended to create "uninitialised" keys.

At the moment, my biggest grip is when `notSetValue !== void 0`: 

``` js
function pathExists(iterable, path) {

  if(iterable.getIn(path)) {
    return true;
  }
  var notSetValue = true;
  return !(iterable.getIn(path, notSetValue) === notSetValue);
}

assert(pathExists(cursor, path) === false);

// notSetValue is anything but void 0
notSetValue = 'default';
cursor.update(path, notSetValue, id => id);

assert(pathExists(cursor, path) === false);
```
 When `notSetValue !== void 0`, the expected result is that these should be equivalent:

``` js
cursor.update(path, notSetValue, id => id);
cursor.update(path, undefined => notSetValue);
```

A cursor (or iterable) would have `notSetValue` set at key path `path` when it doesn't exist.
 Hmm. It probably is a confusion of the API on my part; treating `update`/`updateIn` as `set`/`setIn` on certain edge cases.

It still feels weird though. Since to me, intuitively it's "If a value was not set here, set it to this". I think that any user should be responsible for what the `updater` returns; and any value returned is an intention to set that value at the key path (whether it exists or not). 

What's more, I think it's surprising that nothing gets set when a path doesn't exist. 

---

Overall, I can live with this subtle behaviour. I think this needs to be carefully documented, especially on how it behaves when the `updater` function is an identity function with respect to `notSetValue`.

---

Will close this PR.
  Using `Cursor.update()`, I can set existing key path to `void 0` on a cursor. But I cannot add a new key path with value `void 0`.

However, setting `notSetValue` to anything but `void 0`, works.

See:

``` js
var
Immutable = require('immutable'),
Cursor = require('immutable/contrib/cursor');

var map1 = Immutable.Map({a: true});

var cursor1 = Cursor.from(map1, function(newRoot, oldRoot, path) {
    console.log('newRoot', newRoot.toJS());
    console.log('oldRoot', oldRoot.toJS());
    console.log('path', path);
});

// works; can set existing key path to void 0.
//
// output:
// newRoot { a: undefined }
// oldRoot { a: true }
// path [ 'a' ]
cursor1.update('a',function() {
    return void 0;
});

// unable to add a new key path with value void 0
//
// output:
// newRoot { a: true }
// oldRoot { a: true }
// path [ 'b' ]
cursor1.update('b', function() {
    return void 0;
});

// works, if notSetValue is anything but void 0.
//
// output:
// newRoot { a: true, b: undefined }
// oldRoot { a: true }
// path [ 'b' ]
cursor1.update('b', true, function() {
    return void 0;
});
```
 Narrowed the issue down to something like:

``` js
var
Immutable = require('immutable'),
Cursor = require('immutable/contrib/cursor');


function run(notSetValue) {
    var map1 = Immutable.Map({a: true});

    var
    updater = function() {
        return void 0;
    },
    key = 'b';

    var map2 = map1.update(key, notSetValue, updater);

    // From: https://github.com/facebook/immutable-js/blob/ffc212450e497ef0df6dd247634312b1a4460d5b/type-definitions/Immutable.d.ts#L423
    var map3 = map1.set(key, updater(map1.get(key, notSetValue)));

    var map4 = map1.updateIn([key], notSetValue, updater);

    console.log(map2.toJS());
    console.log(map3.toJS());
    console.log(map4.toJS());
}

run(void 0);
//output:
// { a: true }
// { a: true, b: undefined }
// { a: true }

run('anything but void 0');
// output:
// { a: true, b: undefined }
// { a: true, b: undefined }
// { a: true, b: undefined }
```

I'm suspecting issue is in `updateInDeepMap()` in `src/Map.js`.
 It seems that if `notSetValue` is equal to the return value of `updater`, then setting new value at non-existent key path ever occurs.

``` js
var
Immutable = require('immutable');

var map1 = Immutable.Map({a: true});

var
notSetValue = 'red',
updater = function() {
    return notSetValue;
},
key = 'b'

var map2 = map1.update(key, notSetValue, updater);

console.log(map2.toJS());
// { a: true } <-- wrong?
```
 Oh interesting... this seems to be desired behaviour: https://github.com/facebook/immutable-js/commit/335b312c3e80ed2051b62ae4f29ba34f2734d3e9
 Thanks. I think the fix is fine for me.
  Just to keep silly people like me from going crazy.  Also helps for people who checkout the project.
 #243 
  It would be extremely helpful if each release was accompanied with a changelog update so we can understand how to take advantage of each update.
 Derp, I am so sorry.  I looked all over in issues and pull reqs and the repo and branches and I didn't even think to check releases.  My mistake.
  I usually find it useful to know the origin path for a cursor via `this._keyPath`. I usually don't want to keep track of both of them external to the cursor. 

I know they're meant to be private: https://github.com/facebook/immutable-js/blob/52db807330bb7786fbe20156aca80fbae47491c5/contrib/cursor/index.js#L43-L44

Can `rootData` and/or `keyPath` be officially public?
 There was a reason I needed it for flux/react; but can't seem to recall.

Though, one other application is something like https://github.com/facebook/immutable-js/issues/249
 +1

I think that this is very important to provide access to the keyPath, it enables a variety of great uses.

One use case is so that you can serialize the keyPath and updateValue in one piece of code, transmit it to another (possibly on the server), then apply the changes there. Full stack flux could use this approach.

``` javascript
var structure = Immutable.fromJS({ a: { b: { c: 'hello' } } });
// somewhere deep in your code, you have a cursor that was passed down to you, maybe through
// subcursors, etc.
// var cursor = ...;  // _keyPath = ['a', 'b', 'c']
// I want to communicate to the server via web socket or ajax that data at cursor keyPath needs to be updated
socket.send({ update: { keyPath: cursor.keyPath, data: 'world' }});

// serialized keyPath and sent to server

// server validates and applies update to db or its own immutable structures and sends update to client
// validate and update server db at keyPath with data
// after all stores have updated, send notification with changed data to client

// client receives the update and applies to local structure
socket.on('update', (obj) => {
  var cursor = Cursor.from(structure, obj.keyPath);
  cursor.update(x => obj.data)
});
```

In the above use case, we did not want to update our local structure directly since we wanted it to be done in a central location after validation, then only if validation succeeds, server would indicate to client to update local cache and views.
 If I didn't get this wrong, another use case could be in traversing a tree-like structure. So through the cursor you could access the parent, siblings, etc. I was actually wondering as to why cursors weren't exposing that kind of functionality and until I found this issue I thought maybe I was trying to misuse them?
 I'm working on an app where I need to edit parts of a document and using a cursor for the document part makes for a nicely modular approach.

So two use cases while traversing a tree:
- You may want to render a part of the tree differently depending on the path taken
- You may want to query location-specific calculated document metadata

In the first case you either have to pass the path along with the cursor or move the rendering decisions to the document viewer and have it pass flags to the editor. Neither option seems nice.

In the second case it would cool if the metadata were calculated by the document object itself, which means subclassing Map and proxying the methods via the cursor. Is that feasible?
 +1

Hey! I'm recursively rendering a tree in React, and need each element to provide a unique ID.

``` js
const tree = [
    [
        [
            [],
            [], // <a href="app.html#0.0.1">tree[0][0][1]</a>
            [
                []
            ]
        ]
    ],
    [
        [],
        []
    ]
];

...

const Node = React.createClass({
    render: function () {
        const { cursor } = this.props;

        // Return a path string
        const path = cursor => cursor._keyPath.join(".");

        // Recurse
        const instantiateChild = child => <Node cursor={child} key={path(child)} />;

        // Code to end at leaf nodes goes here

        return <div id={path(cursor)}>
            { cursor.toArray().map(instantiateChild) }
        </div>;
    }
});
```

`_keyPath` works great, and doesn't require baked-in UUID's for each node, or a partial path that gets built & passed down as a prop (`const childPath = [ ...path, step ];`).
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Same rationale as https://github.com/facebook/immutable-js/pull/199
  ```
> Immutable.List([1,2,3]).remove(0).keys().next()
{ value: -1, done: false }
```
 Only `remove(0)` leads to that, `remove(n)` where `n != 0` works just fine.
  It would be nice if it was possible to create custom Map 'strategies' that are sent into the Map constructor.

So that you can choose what kind of Map implementation you want i.e. a Hash Map, Red-Black Tree, Splay Tree, etc...
  Instead of (or in addition to):

``` javascript
var cursor = Cursor.from(data, ['a', 'b'], newData => {
  data = newData;
});
```

Support:

``` javascript
var cursor = Cursor.from(data, '/a/b', newData => {
  data = newData;
});
```

See http://tools.ietf.org/html/rfc6901 and https://github.com/manuelstofer/json-pointer as an example.
 Probably disagree. You can decorate Cursor much like https://github.com/omniscientjs/immstruct
 Solid case. Thank you.
 What about using https://www.npmjs.com/package/lodash.topath (https://lodash.com/docs#toPath)?

It is a tiny dependency and could be used to convert string value to an array path. This convention is already broadly used within lodash, e.g. https://lodash.com/docs#get
  I was at first commenting on #225 because I think the `size`/`length` argument is related but I noticed afterwards that I am having more trouble than that.

I agree with @tgriesser's comment on the issue regarding compatibility between `Array`s and `List`s when possible.

Here is the use case I stumbled upon. I was playing (using NodeJS) with the [promise](https://www.npmjs.org/package/promise) package and wrote something that could be simplified like the following:

``` javascript
var Promise = require('promise')
,   List = require('immutable').List

function f(ps) {
  return Promise.all(ps);
}

var l = List.of(Promise.resolve(1), Promise.resolve(2));
var a = [Promise.resolve(3), Promise.resolve(4)];

f(l);
f(a);
```

but of course, in the console, I get the following:

```
iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. Error
    at List.Object.defineProperty.get ([...]/node_modules/immutable/dist/immutable.js:621:19)
    at Function.Promise.all ([...]/node_modules/promise/lib/es6-extensions.js:62:36)
    at f ([...]:6:18)
    [...]
```

To solve this, one needs to convert lists to arrays with `toArray()`, which can be very repetitive when the called function cannot be modified. I wonder the following: would it be possible to have a similar interface between `List`s and `Array`s for cases where there is no mutation? If there is one, it's another story (and then it makes sense to throw an error)...
 -1

Another example of the array-like "interface" are strings. Without subscript notation (also: please keep immutable ES3 compatible, some people are stuck with IE8), there's no real point in pretending lists are array-like.
 Hum, you guys have thought though this way more than me apparently... Thanks for your thorough answers!

Feel free to close my issue or to keep it open for further discussion. I just feel sad to have to convert a `List` to an `Array` when I pass it to a function that deals with `Array`s only, when I know the work being done there is read-only.
 Wondering about this pattern I just ran into. Before I used immutable I had some code like this, but given that Promise.all() doesn't work with immutable data structures I had to convert to JS to support it.

``` js
Promise.all(
  kids.map(item => API.get(`item/${item}.json`).then(getAllKids)).toJS()
)
.then(res => item.set('kids', Immutable.fromJS(res)).set('kidsLoaded', true));
```

Notice the conversion before and then after. What's the status on promises + immutable?
 @leebyron I am using Promises and Immutable in NodeJS and this is where my snippet given above failed. I should have been more explicit from the beginning.

Weird that it fails considering all collections are actually iterables... Any idea?
 Argh! Well I guess I have to stick with my workaround (same as @natew's) then... :(
    When using `List<T>.update`, it really feels like this method has the same use case than Scala's `updated method, which has the following signature:

``` scala
def updated(index: Int, elem: A): List[A]
```

> [use case] A copy of this list with one single replaced element.
> index: the position of the replacement
> elem: the replacing element
> returns: a copy of this list with the element at position index replaced by elem.

However, the current signature of the `update` method being the following:

``` typescript
update(index: number, updater: (value: T) => T): List<T>;
```

if I want to simply change a value in a list, I have to do the following:

``` javascript
List.of(1, 2, 3).update(1, function () { return 20 }); // == List.of(1, 20, 3)
```

where it would be simpler and more readable to do the following:

``` javascript
List.of(1, 2, 3).update(1, 20); // == List.of(1, 20, 3)
```

Therefore, would it be possible to add the following signature support?

``` typescript
update(index: number, value: T): List<T>;
```

I would be happy to help if I can and if you like the idea (I do! :p).
 Ooops, it's when I decide to send the issue that I realize I am wrong...

I overlooked `set`, which seems to do the job I mentioned:

``` typescript
set(index: number, value: T): List<T>;
```

Sorry for the noise!
  It does not behave as expected:

```
Immutable.List.of(1, NaN).min() !=  Immutable.List.of(NaN, 1).min()
```

It would be really handy if NaN/null/undefined be ignored by max/min.

thanks.
 100% agree that `NaN` should not be ignored. The max and min of a list containing `NaN` should be `NaN`, which is how `Math.max` and `Math.min` behave.
  While it is certainly obvious why it isn't necessary or even inconvenient to have the innards of contrib/cursor exposed to the client, it would be nice to have at least the basic cursor types available for evaluation.  

React scenario:
Imagine a global state represented by _Immutable_ data structures that gets passed to a set of nested components using cursors. For testing purposes it would be helpful to define the property that represents the cursor on the component as explicitly as possible:

```
var React = require('react'), 
     Cursor = require('immutable/contrib/cursor');

var MyComponent = React.createClass({
    propTypes: {
        cursor: React.PropTypes.instanceOf(Cursor.KeyedCursor).isRequired
    }
    // ... component definitions.
});
```

What y'all think on that? 
Regards, Lukas
 Wondering about this too.
 As a note for other people who end up here, this is the updated link to React's own PropTypes: https://github.com/facebook/react/blob/master/src/classic/types/ReactPropTypes.js
 @leebyron 
Thanks for keeping this alive. I have to admit that I'm much more familiar with ImmutableJS and the whole [tl;dr](https://en.wikipedia.org/wiki/Immutable_object) behind persistent data structures in general than I was like 7 months ago (me coming from ActionScript  Ã  la 98 and all :dancers:). It just took me some time to digest the approach and apply it on a safe, small scale daily basis.
From my today's point of view, your [answer](https://github.com/facebook/immutable-js/issues/231#issuecomment-66509771) to my original question was 200% legit and right.
But IMHO it still would make sense to expose the complete contrib/cursor API to the public domain. Let's face it, people who even appreciate the possibility of having cursors on immutables are probably somehow involved with at least designing some kind of low level state. I think it is safe to assume that most of these people have a technical background and can handle this additional responsibility of having everything accessible for extending. I had my own go at it and [this is what JS devs have been using](https://github.com/lukasbuenger/immutable-cursors/) at my company for the last couple of months. What do you think?
  Point to http://facebook.github.io/immutable-js/docs/ for docs instead of the raw `Immutable.d.ts`file.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Oh, so these are actually generated files. Declining pull request.
  @brentburg has converted the [Immutable.d.ts docs](https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts) using [TypeDoc](http://typedoc.io).

The documentation link on http://facebook.github.io/immutable-js/ could instead point to something like http://brentburg.github.io/immutable-docs/api/index.html to be more accessible. 
 @leebyron seems to be working on a custom solution to this in the gh-pages branch. See cceae7352e92bd0b928208b495b849eea7d66e84
 Love it, thanks!
  Just like in the example on the doc about .withMutations(), the immutable returned that end of the multiple .push() mutations on the list works great. However, .remove() mutations diminish the mutable copy inside the function down to an empty immutable object, and not a mutable copy after being mutated.

Do you know why this might be happening?
 Okay I realize this question may be semi-flawed CS-ically because we probably want to go with a whitelist approach of building a new list using .filter() or something rather than chaining removals, as positions change after every single remove mutation.
 I think the issue is repro'ed by this:

```
I.List.of(1,2,3).concat(I.List.of(4,5)).withMutations(function(l) {
    l.remove(3); console.log(l.toString());
});
prints: List []
```

I haven't taken a look at what might be causing the issue yet, but the issue is def with the concat.
 After further investigation it seems to be caused by calling remove with a non-zero index:

```
I.List.of(1,2,3).concat(I.List.of(2,3)).withMutations(function(l) { l.delete(2); })
Object {size: 0, _origin: 0, _capacity: 0, _level: 5, _root: nullâ€¦}
I.List.of(1,2,3).concat(I.List.of(2,3)).withMutations(function(l) { l.delete(0); })
Object {size: 4, _origin: 1, _capacity: 5, _level: 5, _root: nullâ€¦}
```
 Thanks, @carlsverre, for picking up where I dropped off.

@leebyron :+1: I guess one of the things we could do is adding a note on the docs :) It would just make the user think about this issue before going down a hole like I did.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 @leebyron Why does `delete(2)` result in all the elements being removed while `delete(0)` works as expected?  (see code example above)
 I have same issue.  List.delete() work only on first and last index. inside withMutation().
  Here's a first pass at making it possible to inherit from `Map`, `List`, `Set`, `OrderedMap`, etc.

Mostly putting this here for discussion, as there are probably a few ways to attack this one, but this seems to be working quite well in my preliminary use. It also has the benefit of eliminating `Object.create(MapPrototype)` in favor of `new Ctor`, which gives better inspection in the chrome console (and [potentially perf?](http://jsperf.com/obj-create-vs-new/4))

The inherited types must initially be constructed with `new`, and when inheriting via class style, it's necessary to return from the constructor:

``` js
class User extends Immutable.Map {

  constructor(value) {
    return super(value)
  }

  fullName() {
    return this.get('firstName') + ' ' + this.get('lastName');
  }

}
```

If you think this looks good, I could beef up the tests a bit.
 Updated to expose `__empty` and `__make` methods on the prototypes, as well as a `__emptyMap` for `OrderedMap` / `Set` / `OrderedSet`. This should make it possible preserve the type that should be created when doing an `updateInDeep`, haven't tested it though.

If you like the implementation I can start to get it tested a bit, I'm also curious if there are any implications you may have thought of that I might not be considering.
 Something neat I was just able to do with this:

``` js
class MapWithMeta extends Immutable.Map {

  constructor(val) {
    return super(val)
  }

  setMeta(key, value) {
    return updateMeta(this, key, value);
  }

  getMeta(key, notSetValue) {
    return this.__meta.get(key, notSetValue);
  }

  __make(size, root, ownerID, hash) {
    var map = super(size, root, ownerID, hash);
    map.__meta = this.__meta || new Immutable.Map();
    return map;
  }

}

function updateMeta(map, key, value) {
  var meta = map.__meta;
  var newMeta = meta.set(key, value);
  if (newMeta === meta) return map;
  var newMap = map.__make(map.size, map._root, map.__ownerID, map.__hash)
  newMap.__meta = newMeta;
  return newMap
}
```

Allows for specifying Immutable "metadata" on a Map object. Each new map contains the same metadata as the previous, setting a new value will return a new `Map` value which will still be equal to the last, just not `===`.
 So I updated this to latest and ran that new `perf` suite, looks like this branch takes a pretty substantial hit ~50% or more on each of the tests. 

So unfortunately this doesn't look like it's the best approach, though figuring out some way to do this eventually would be really cool - the ability to have custom types for `Maps`/`OrderedMaps` has proved quite convenient in our application.
 > Yeah, I'm really sorry for not keeping you apprised, Tim.

No worries at all! I've been getting along great with my fork, just wanted to get things up to date and give an update with my findings. I'm excited there's a benchmarking suite to be able to test as I go - I'll probably play around with a few different ideas here.

It also might be neat to explore how cljs handles analogous behavior with protocols, etc.
 Superseded by #368
  I have a nested structure like this:

``` js
var Immutable = require('immutable');
var Record = Immutable.Record;
var Map = Immutable.Map;

var State = Record({
  records: Map()
});
var Item = Record({
  name: null
});
var state = new State();
var notSetValue = new Item({name: 'foo'});
```

I try to set the name of the item at the key `records.foo` to "foo". If the key does not exist, it's first initialized to `notSetValue`. Looks like `updateIn` doesn't update the state record, if the return value of `updater` fn would be equal to `notSetValue`?

``` js
state.updateIn(['records', 'foo'], notSetValue,
               function (value) { return value.set('name', 'foo'); });
// => Record { newRecord: null, records: Map {} }
//                                            ^ no 'foo' here!
```

If I use a different `name` so it's not equal to `notSetValue`, it works correctly, however:

``` js
state.updateIn(['records', 'foo'], notSetValue,
               function (value) { return value.set('name', 'foobar'); });
// => Record { newRecord: null, records: Map { foo: Record { name: "foobar" } } }
```

I'd like to know if this is a bug in `updateIn` or if I'm using it wrong. It seems like an unexpected behavior.

EDIT: fixed `defaultItem` -> `notSetValue` in the example.
 In the example above it seems like `notSetValue` and `defaultItem` are the same thing. by changing `notSetValue` to `defaultItem` I can reproduce this behavior.
 https://github.com/facebook/immutable-js/blob/master/src/Map.js#L752-L754

```
    var existingValue = isNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
```

I believe the bug is here. `existingValue` is actually the `notSetValue`, but when comparing the new value to the old value it finds them to be the same, so it returns `existing`. I don't understand why this wouldn't just always return `newValue`. If they're `===` it seems safe to return.
 I see it in the [docs](http://facebook.github.io/immutable-js/docs/#/Map/updateIn) now. This seems like a strange behavior to me.  Â¯\_(ãƒ„)_/Â¯

> If the updater function returns the same value it was called with, then no change will occur. This is still true if notSetValue is provided.
 Mind also updating the docs for `Map.update`. It currently says

> Equivalent to: map.set(key, updater(map.get(key, notSetValue))).

Which is misleading for the same reason as `updateIn` was:

``` javascript
var map = Immutable.Map();
!Immutable.is(
  map.update('x', 1, function(x) { return x; }),
  map.set('x', map.get('x', 1))
)
```
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 I've just come across this as well. Quite surprising, especially as @voltprime mentions the documentation says that it's equivalent to **map.set.** 
  While the `size` API definitely makes sense for objects such as `Map`, `Set` as there isn't an explicit order, `size` rather than `length` definitely feels clunky for `List` (and perhaps `Stack`?) - especially when working in situations where the input may either be an Array or list.

Would it make sense to have `size` as the property for Keyed collections and `length` for Indexed collections?
 I think it'd be reasonable you'd typically know what the type of data structure is you're operating on... that just as in JS you can't expect `.size` to work on an array but it does for ES6 map, and you can't expect `.length` to work on Map but it does on an Array.

I guess my gut feeling is that keeping parity with vanilla JS analogues would require less overall thought, rather than how I've found myself thinking now... "well, I know I can call concat on this thing coming in because it's either a List or an Array, but if it is a List I have to remember to check the size property, not length".
 Another use case of this (shared with #236) would be the following. When using [Chai](http://chaijs.com/), one could use the [length assertion](http://chaijs.com/api/bdd/#-length-value-) to do the following:

``` javascript
expect(list).to.be.an.instanceOf(List).of.length(5);
```

This currently fails with:

```
TypeError: Property 'length' of object [object Function] is not a function
```

The working solution is not catastrophic, I know, but just less natural:

``` javascript
expect(content).to.be.an.instanceOf(List).of.property('size', 5);
```
 You can define your own matchers, can't you? You'll need custom matchers to compare value equality, anyway.
 @pluma, that's a good point, although I would prefer to avoid it for `size`/`length`.
For value equality, right now I am using an awkward:

``` js
expect(Immutable.is(list1, list2)).to.be.true;
```

In that case I agree a custom matcher makes sense.

@leebyron, this probably deserves its own issue, but do you think we could have a set of matchers for Chai? Maybe in the `contrib` folder or another third-party intended folder? That could help those who use Immutable and Chai and want to have nice looking tests.
If you agree with this I can work on it.
 > Otherwise, I fear that Immutable.js Lists would suffer from incompatibility with code that expects a non-zero length to imply that bracket access will work, which I think will be surprising in the worst way

Yep, agreed :+1: 
 Just to note, due to type coercion when someone uses an immutable List and expects it to work like vanilla js they can pretty easily end up with the following bug:

```
if (myList.length > 0) {
  // I'm going to handle the empty list situation, but my list isn't actually empty!
}
```

Wouldn't it be wise to at the very least log a warning when someone tries to access length on a `List`?  Perhaps there's an alternate way to do this, but basically I'd like to be able to do something like this:

myMap.pick(aSetOfKeys) -> map that only has the keys in aSetOfKeys
 (From here: http://ramda.github.io/ramdocs/docs/R.html#pick )
  I'm probably just missing something but didn't see this in the docs.
 Ah, `valueSeq` is what I wanted. I didn't really get what an `iterator` was so was confused why `toJS` wasn't working on it. Thanks!
  From the wiki it states List is a dense homogeneous collection, so should this be a valid list ?

```
a = Immutable.List([2,false,"3","bcd",1]) => creates a list
Immutable.List.isList(a) => true
```

am i misunderstanding something here..
 cool thanks :+1: 
  So I'm experimenting with some things around custom Collections and such, and I was thinking it'd be nice if there were a way to be able to create Maps and Lists of custom "types". Objects which inherit directly from `Map` and `List`, potentially adding new/custom methods while retaining the immutable behavior - that somehow the prototype of the constructor would be used in place of the `ListPrototype` and `MapPrototype` in `makeList` and `makeMap` respectively.

At first glance it seems that this might already be somewhat possible by overriding the `__ensureOwner` on both of these objects, and by specifying a custom `List#set`, but this doesn't account for using the correct constructor/prototype in the `emptyMap` (which is used throughout). 

I guess I wanted to see if this was something you had considered or would be interested in supporting, or if there are any difficulties I haven't considered yet when it comes to deep merging, etc.
 Awesome!
 If you're interested at all, I took a quick stab at this. Some of it is a little clunky due to the constructor returning a value (the jsx-harmony transform doesn't return the value in implicit `super` calls), but it's definitely possible to do custom Map / List types and the tests pass.

https://github.com/tgriesser/immutable-js/commit/d8f241398d3c12429bb4bce5cc8df0327da85ab3
  ```
> var Immutable = require('immutable')
undefined
> var R = Immutable.Record({x: null, y: null})
undefined
> var r = new R()
undefined
> r.filter(function(v) { return v !== null; });
undefined
```

Accidentally stumbled upon this, though I understand that `filter` probably doesn't make sense for `Record` at all.
 Or that it returns a type Map?
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 This issue is still occurring in v3.8.1
 Even warnings didnt show in v3.8.1  If I write code like this I can mutate an 'immutable' object:

```
var map = Immutable.Map({ a:1, b:{ d:4 }, c:3 }), map2;

map2 = map.updateIn(['b'], function (val) {
    val.d = 5;
    return val;
});

console.log(map2.toJS()); // {"a":1,"b":{"d":5},"c":3} :)
console.log(map.toJS()); // {"a":1,"b":{"d":5},"c":3} :(
```

Obviously this code is contrived, and there is always a way to avoid mutating the input to the updater function, but it would be nice if updateIn didn't have this pitfall.

If the input was deep cloned.. or Object.freeze'd it would be ok - but I'm guessing these were avoided for perf reasons?

If there isn't a solution, would it make sense to document the issue?
  This is probably a super dumb question, but from what I see they both are indexed data structure, is there particular difference and use cases for each one? Thanks. 
 Yes, it does help a lot, might even worth adding it to document for later reference?

btw, please feel free to close this issue, thanks. 
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Hey,
I'm using [node-postgres](https://github.com/brianc/node-postgres) and it's row parser is using a custom built constructor to boost performance. Problem is when i query i get this psuedo-object which Immutable.fromJS rejects because it has a constructor.
you can see the discussion: [https://github.com/brianc/node-postgres/issues/685](https://github.com/brianc/node-postgres/issues/685)
now I realize this is expected behavior but i was hoping maybe someone has an idea how can i keep both the performance and get an Immutable in fromJS
 cool!
i guess for a shallow object it should be quite performant?
 Just realized there's a problem with the method. since `typeof null === 'object'`, null values are parsed into an empty Map.
changed the condition to `typeof js ~== 'object' || js === null`
 wouldn't you know `Date` is also `typeof object`. this is getting somewhat cumbersome. there must be an easy way
  I've got the root of the problem we had here: https://github.com/facebook/immutable-js/issues/335

I was reading through ImmutableJS documentation and observing a lot of examples with === so it somehow clicked in my head that it is recommended way to compare objects... I actually knew that JS has no operator overloading but I somehow decided that you've implemented this on some memoization technique that same args would always result in the same `Map` object.

But you were describing quite the opposite â€“ how you optimized memory (as much reuse of the same object as possible). You described Implementation and I took that for API...

I I think it's better to shift accents a bit in documentation or add some comments to make it obvious even for fast-readers.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 any progress on writing up documentation for `valueOf`, `equals` and `hashCode`?  Thanks for the library - I've been playing around with it, but for my use case I need the ability to use complex types as keys for maps, i.e. to use a Map as a key for another Map. 

[ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) does this, as does [Mori](http://swannodette.github.io/mori/#hash_map). Do you know if this is on the roadmap?

Thanks 
 Thanks - I wasn't sure from the documentation, but working great now. 
  A pattern I use to ensure I have a List is List.of().concat(object). This succeeds at keeping object unchanged if its already a list, turning an array [] into a list, and turning a single item into a 1-item list:

List.of().concat(list) === list
List.of().concat([1,2,3]) === list[1,2,3]
List.of().concat(1) === list[1]

I am trying to accomplish something similar to this with Stack.of().unshiftAll(object). Unfortunately, Stack.of().unshiftAll(string) creates a stack with each character in the string a member. Perhaps this is correct behavior, but I think beyond not matching concat's behavior, its also strange that Stack.of(string) doesn't also create a stack with each character.
  This is a small change that makes the cursor's onChange function more useful.

The cursor's `update` method's callback can currently return arbitrary data. This data is always passed to the onChange function, but then the cursor chokes on invalid data when it tries to return a new cursor.

This change adjusts the behaviour of the onChange function so it can optionally return new rootData for the cursor that should be used instead of what the update method's callback returned.

For an example where this change would allow a nicer application structure see [this issue](https://github.com/foss-haas/fynx/issues/6). Allowing cursors to receive arbitrary data that is then transformed into the correct format "upstream" (e.g. simply calling `Immutable.fromJS` on it) can be useful in React.

Example:

Old sadness:

``` js
var cursor = Cursor.from(someData, function (newData) {
  magic(newData); // some side-effect
});

// elsewhere

cursor.update(() => Immutable.fromJS({some: {raw: 'data'}}));
```

New hotness:

``` js
var cursor = Cursor.from(someData, function (rawNewData) {
  var newData = Immutable.fromJS(rawNewData);
  magic(newData); // some side-effect
  return newData;
});

// elsewhere

cursor.update(() => {some: {raw: 'data'}}); // no need to require('immutable')
```
 I didn't want to break backwards-compatibility. I guess it could check for undefined instead of false-iness, though. That only leaves the edge case of explicitly returning undefined.

I think having the current behaviour (just use the new value) is useful and not returning anything or explicitly returning undefined should still trigger that.

Anyway, non-Immutable (root) values currently throw in makeCursor, so it's probably more of a hypothetical problem than a practical one.
 I've adjusted the PR to only exclude `undefined` as return value. This maintains backwards-compatibility (otherwise all `onChange` functions would have to explicitly return their input if they don't want to alter the value).

If `makeCursor` should be able to wrap non-Immutable values (might be useful so we can have cursors that simply wrap an arbitrary value as a "leaf"), I'd suggest taking that to a separate PR or Gitter/IRC.
 Any input/comments?
 :+1: on this, would appreciate the functionality.
  I am grouping a sorted list, and want the map created by groupBy to reflect the order in the list.
Locally i just switched the map to a OrderedMap and the behavior was working as expected.

I am typing this out directly in GitHub so it might contains bugs. My local modifications were naive and always did OrderedMap, which might not be as lean/performant as you want.

Any thoughts?
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  faster vms, less wait time, more ram and cpu, free 2-4-1 coffee at your favourite coffee

docs coming soon
 shaved a minute off the build time
  ...d around.

Closes #208.
 I'm assuming that the intention isn't that it _should_ be value, key and the code is wrong vs the docs (although that is certainly an ordering used in other placed in the code (which I actually prefer))
  In Immutable.d.ts the following is listed as an example for using fromJS:

``` javascript
Immutable.fromJS({a: {b: [10, 20, 30]}, c: 40}, function (value, key) {
var isIndexed = Immutable.Iterable.isIndexed(value);
return isIndexed ? value.toList() : value.toOrderedMap();
});
```

If you try running this however, you get:

```
return isIndexed ? value.toList() : value.toOrderedMap();
                                          ^
TypeError: Object  has no method 'toOrderedMap'
```

In my own dealings with fromJS I also experience this. For arrays I'm getting a Seq that responds false with isIndexed.
  List.of(1,2,3).setIn(List.of(0), 0) -->

iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. Error...
  zip would be a nice addition, namely because when I do underscore's _.zip(aList, anotherList) I get that iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version.
  Just as a performance thing, this happens to happen in my code in a few places, seems like it could be special cased instead of creating a new one (currently List.of().concat(x) !== x)
 Awesome thanks!
   @leebyron Curious, I can only assume you knew about flow before us haha, why did you go with TS anyways? Flow just wasn't/isn't as mature?
 @leebyron sweet
 @leebyron We had a discusson on #flowtype â€“ wanted to add the definitions file I was working on, which can be found in [my fork here](https://github.com/lambdahands/immutable-js/blob/master/type-definitions/Immutable.js).

Would love some feedback and tips on how to treat something like this. I'm really excited to begin implementing Flow into javascript projects that utilize immutable data.

Cheers!
 Hey, no problem! There are some snags I've run into. I'm not fully acquainted with optional function arguments and how to operate on them in Flow.

Immutable's `map` and `reduce` functions use optionals that produce Flow errors; this is the type of code I would typically write as well: https://gist.github.com/lambdahands/3a1caaec0a9eb967b60e
 > Once I get the Flow type definition files, the TypeScript ones will remain in the repository and up to date as well!

Are you planning on updating the two manually, or is there some Flow/TypeScript syncing/conversion magic that you can employ?
 I'm also very excited about being able to combine Flow and Immutable, but I'm in a similar place with [this guy](http://stackoverflow.com/questions/27392777/static-type-checking-with-immutable-js-and-facebook-flow).

Do _you_ guys have opinions on how - if at all - this could work out?

Thanks a lot!
 I find I use a very small subset of the functionality in this library, so it's not too onerous to maintain my own declaration library, all gratuitously copied from @lambdahands. 
 Any progress on this? I've started with @lambdahands's file (thanks!) but would be great if it was an officially supported thing
 +1
 +2
 +n
 +11
 I have taken a stab at trying to improve the work by @lambdahands. Mainly I added support for the static methods to construct immutables. I also addressed an issue with the static `of` method on `Seq`, for some reason it seems to conflict with flow that the return type of the method changes in the classes: `Seq`, `IndexedSeq` and `KeyedSeq`.

I have not tested the definition too much so far, but would love some feedback for fixes. I know I have omitted the usual constructor definitions, but it should be easy to add them back in if wanted.

https://gist.github.com/kastermester/ad79da3e48064effd82e
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 :+1: for using _Flow_ with _Immutable.js_ :smile: 
 It's dangerous to go alone! This is the version we have internally at Facebook right now but it is experimental and we don't support it officially yet: https://gist.github.com/cpojer/2dd5e3f4ce41b91a6bd8

The flow team is currently working on improving support for projects like immutable JS so we should have an officially support version of the definition file "soon".

Feel free to fork and contribute to the gist above and let me know how it works out for you. If it is valuable to a lot of people, even if it is not perfect, we might consider making it more official. Personally, the way I see it, having a basic definition file is better than not having one at all. In a project of mine I've successfully adopted the file from above and it is _good enough_. I had to make some modifications to it and I copy-pasted some type definitions: For example, the return value of a List's filter call is `Iterable` because that is the type it is inherited from based on the library file above. This means that doing `list.filter(fn)` will return an `Iterable<K, V>` instead of a `List<T>`. To fix this I copied the definitions from Iterable to List (and Map etc.) and turned the return values into `List` instead of `Iterable`. I haven't included these local modifications in the gist above but I can add them if it is useful.

Put the file in a `lib` folder and add it to your `.flowconfig` like this to make sure Flow doesn't visit your node_modules version of immutable and accidentally types it as `any`:

```
[libs] 
lib/

[ignore]
.*/node_modules/immutable/.*
```

To sanity check if it works, try:

``` js
var a: List<number> = List.of('string');
```

and run Flow â€“ it should yell at you :)
 @cpojer very nice, I'll try it out when I get the time :)
 WOOOOOO @cpojer Thanks for sharing!!
 @cpojer I'm attempting to start something like [Typescript's Definitely Typed](https://github.com/borisyankov/DefinitelyTyped) over here: https://github.com/splodingsocks/FlowTyped

I was on my way to add the file you linked, but I noticed that the copyright notice at the top says Facebook, all rights reserved. Does that mean I shouldn't put it in that repo?
 I've updated @cpojer 's gist to use flow interfaces (flow complained about multiple class inheritance for me otherwise): https://gist.github.com/bouk/d29a6cafab0b9b3b1ec6

The lack of dynamic classes in flow such as those generated by Immutable.Record is unfortunate, but would probably require a big overhaul to support
 Am I'm doing something wrong or is it fine that flow is _not_ detecting an error with this code:

```
var b: Map<string, number> = Map({'key': 'value'});
```

/cc @bouk 
 Your value isn't a number. That should be an error, so if flow is yelling at you that seems right.
 I'm using @bouk's [interface file](https://gist.github.com/bouk/d29a6cafab0b9b3b1ec6) and the following config:

```
[ignore]
.*/node_modules/immutable/.*

[libs]
.*/src/main/javascript/lib/interfaces/.*
```

Given this JS file:

```
/* @flow */
import {List} from "immutable";
var a: List<number> = List.of(666);
```

I get this Flow error:

```
/Users/<...>/foo.js:2:9,12: List
This type is incompatible with
/Users/<...>/foo.js:2:9,12: List

/Users/<...>/foo.js:4:23,34: call of method of
Error:
/Users/<...>/foo.js:2:9,12: List
This type is incompatible with
/Users/<...>/foo.js:2:9,12: List
```

Any idea what's going on?
 @jergason sorry, I got the text wrong and corrected it above. In the case above Flow didn't point out an error.
 @msolli I am unable to reproduce your error. The following typechecks for me:

``` js
const a : List<number> = List.of(666)
```

@bouk Thanks, I experienced the same problem and your version seems to work at least initially. I do not know enough about Flow yet to understand what the significance between `class` and `interface` is right now.

@jergason @nikgraf I was able to reproduce your issue. I do not understand enough Flow to have a solution. Perhaps of interest however is that this works as expected:

``` js
const dict1 : Map<string, string> = Map()
const dict2 = dict1.set('k1', 1) // call of method set Error: number This type is incompatible with string
```
 @jasonkuhrt @jergason @nikgraf weirdly this seems to be a problem where flow chooses to use the empty constructor signature instead of the right one, fixed here: https://gist.github.com/bouk/d29a6cafab0b9b3b1ec6/revisions which now makes

``` javascript
let b: Immutable.Map<string, number> = Immutable.Map({a: 'a'});
```

fail with 'string This type is incompatible with number'
 Maybe someone more familiar with flow (@int3, @mroch) could help us out with understanding why this happens? Flow seems to be picking the empty constructor signature unless I explicitely reorder them, you can see the change here: https://gist.github.com/bouk/d29a6cafab0b9b3b1ec6/revisions
 @bouk Much appreciated but even with the revised Immutable Type File I receive the same behaviour as before. What version of Flow / Immutable are you seeing your successful results on?
 @bouk Flow represents the overloaded constructor signature as an intersection type, where each branch of the intersection is a function type. When checking for errors, Flow will try each branch of the intersection type in turn, until either a suitable type is found or, if no suitable type is found, will add an error.

Because it is not a runtime error to pass overmany arguments to a function, it seems that Flow considers the empty constructor a suitable type and continues. In general, it's important to define overrides from more specific to less specific, but to do so it helps be familiar with the type checking rules. Does that make sense?
 @samwgoldman yep that's a great explanation, thanks!
 > Because it is not a runtime error to pass overmany arguments to a function, it seems that Flow considers the empty constructor a suitable type and continues

@samwgoldman @bouk Clear yes, but the answer is quite disconcerting if it means that a constructor type that specifies no arguments effectively allows `any` number arguments of `any` type... Am I misunderstanding something? And if not, is this rationalized as an intended design or a feature gap in Flowtype?

And then regarding this problem (`Map({ blah: 'blah' }`) where does that leave it?

â€“â€“ Edit: Sorry this conversation is basically off-topic now.
 @jasonkuhrt It's not a bug in Flow, just a nuance with how intersection types work (by design) and function types ([documented](http://flowtype.org/docs/functions.html#too-few-arguments) behavior). @bouk's revision seems to fix the libdef, although I haven't tested it myself. Can you provide a complete and minimal repro for the problem you referenced, with expected and actual output?
 @samwgoldman Thanks for the patience and clarification.

Regarding repro: This should not type check but it does (for me, that's the issue):

`lib/test.js`

``` js
/* @flow */

import { Map } from 'immutable'



const b : Map<string, number> = Map({ a : 'a' }) // Should not typecheck
console.log(b)
```

`.flowconfig`

```
[ignore]
.*/node_modules/immutable/.*

[include]

[libs]
types/

[options]
```

`types/immutable.js`

``` js
...

declare class Map<K, V> extends KeyedCollection<K, V> {

    static <K, V>(iter: KeyedIterable<K, V>): Map<K, V>;
    static <K, V>(iter: Iterable<any, /*[K,V]*/Array<any>>): Map<K, V>;
    static <K, V>(array: Array</*[K,V]*/Array<any>>): Map<K, V>;
    static <V>(obj: {[key: string]: V}): Map<string, V>;
    static <K, V>(iterator: Iterator</*[K,V]*/Array<any>>): Map<K, V>;
    static <K, V>(iterable: /*Iterable<[K,V]>*/Object): Map<K, V>;
    static <K, V>(): Map<K, V>;

...
```
 OK, so I was able to test this, and the issue is with the last two overloads:

```
static <K, V>(iterable: /*Iterable<[K,V]>*/Object): Map<K, V>;
```

This is allowing the object through because the declaration is just wrongâ€”the comment hints at what it should be. If you take this by itself, the declaration says "give me any object, and I'll give you a Map with the key/value types you want" which will allow the invalid call & cast from your example. We can easily fix this by replacing `Object` with the correct type that is in the comment. Perhaps TypeScript doesn't support that type, but Flow does.

```
static <K, V>(): Map<K, V>;
```

This one is trickier. By itself, the "extra arguments to functions are OK" rule is reasonable, and reflects JavaScripts actual runtime semantics. (In fact, without this rule, it wouldn't be possible to write code like `xs.map(x => x * 2)`, because the argument to `Array.map` has two parameters.) However, here this rule is biting us. Because the call from your example didn't match the `Map(obj)` constructor, Flow moved on, trying the rest of the overloads until it hit that one. Flow considers any argument as "extra" but at runtime, Immutable will treat the argument as an object and construct a map with initial valuesâ€”not what we want from a type declaration.

I was able to fix the declaration to work by being clever, but I think this is a usability bug (not a correctness bug), so I'm also thinking about other ways to fix.

``` javascript
    static <K, V>(iter?: KeyedIterable<K, V>): Map<K, V>;
    static <V>(obj?: {[key: string]: V}): Map<string, V>;
    static <K, V>(iterator?: Iterator<[K,V]>): Map<K, V>;
    static <K, V>(iterable?: Iterable<[K,V]>): Map<K, V>;
```

I replaced the `any` and `Object` declarations with the actual, intended type annotations. I also replaced the "empty" constructor by making every argument optionalâ€”this achieves the same outcome, allowing empty Map construction, without allowing mis-typed object/array/keyed-iter arguments. (I also removed the `Map(array)` constructor, because Flow understands that `Array<x>` is also `Iterable<x>`.)

I was able to do this because I have a pretty good understanding of how the type checker works, but we shouldn't expect everyone to have that knowledge. That's why I consider this a usability bug. Will bring this up with the Flow team to see what they think.

Edit: I removed the `Iterable<any, [K,V]>` signature as well, because I'm not sure what that's supposed to mean. Even in TypeScript, Iterable only has a single type arg. (Edit 2: It seems that Immutable defines its own `Iterable` interfaceâ€”which does further muddy the waters here...)
 @samwgoldman Thanks so much for this round of feedback. I can see that I need to spend some due time with Flowtype before racing ahead with it. So as it stands you mostly solved this particular case save for some remaining uncertainty/ambiguity as noted in the edits? @bouk Thoughts?
 @samwgoldman great feedback, I think the core issues stem from basically copy and pasting the type script definitions in immutablejs and using those instead of rewriting them to be appropriate for flow. I might spend some time going through all the definitions and 'flowifying' them

The iterable thing is definitely an issue, I just noticed that the type interface file also contains a redefinition for Iterator, which is not needed because it can just use the standard Javascript one. Is there any way to specify explicitly that we accept anything with the global Iterable interface or is that impossible because of name shadowing? Could be fixed by renaming the immutabe iterable to IIterable or something but that's pretty ugly.

Another issue currently is that Record is essentialy untyped. In immutable you can create a new class by using Record, but right now Flow doesn't have the concept of dynamic classes (I believe). Probably a thougher nut to crack.

Thanks for the help
 Sorry @jasonkuhrt, I'd stupidly excluded every package.json file in my project, which created a whole bunch of strange problems. All solved now. Thanks for looking into it. Excited to see where this discussion is going!
 @msolli No problem! Glad you worked it out.
 The way that Immutable Maps work is with Array types, are there any plans to change it or is that the way it is designed internally?

Also, any updates? Using it right now and it seems pretty good :)
 With movement of interfaces from IndexedSeq to Seq.Indexed, etc... the type definition files provided here by @cpojer are completely broken.  Can't for the life of me figure out how to update the file either.  How do you nest interfaces that way?  
 Looks like Facebook either doesn't use immutable-js, flow, or both ? :P
 This is the latest version that we are using: https://gist.github.com/cpojer/3a2aad89499c37fbb2db cc @gabelevi @jeffmo
 Nice
 @cpojer @AlexGalays @jeffmo @gabelevi I made a small modification to make `Record` a bunch more useful. It now returns `typeof Map<string, any>` instead of `any` so that flow will actually check that you're calling methods that exist. The modified version can be found here: https://gist.github.com/bouk/911b8d4993c19de3f98f

One side effect is that flow now will also check that all the properties exist, so you will need to define those manually through extending the `Record`, like so:

``` js
class ABRecord extends Record({a: 1, b: 'etc.'}) {
  a: number;
  b: string;
}
```

Seems to work almost perfectly, except that because it extends `Map<string, any>` the return type of any of the methods is also `Map<string, any>`. This means that the returned value is missing the properties and methods of the extended class, so it breaks down pretty clearly.

This could be fixed by having some sort of `Self` type name in interface files that refers to the extended class. So that if the definition of `set` on `Record$Class` was `set(key: string, value: any): Self` then `new ABRecord().set('a', 1)` would still have the type `ABRecord` instead of `Record$Class`.
 @bouk Thanks for providing the flow definitions for immutable !

For the following code

``` javascript
import type {List} from "immutable";
const a : List<number> = List.of(666);
```

I'm getting

```
 39: const a : List<number> = List.of(666);
                              ^^^^ List. type referenced from value position
 15: import type {List} from "immutable";
                  ^^^^ type List
```

Relevant parts of .flowconfig are

```
[ignore]
.*/node_modules/immutable/.*

[libs]
lib/
```

where lib has the immutable.js from the gist.

I can see the definition of 'of' in the definitions, so I'm wondering why flow can't see that List.of is the use of the 'of' method.
 You need to import the actual module whereas in your code you're just
importing the type. Try this

```
import { List } from 'immutable';
```

On Sat, Dec 12, 2015, 12:41 Arunabha Ghosh notifications@github.com wrote:

> @bouk https://github.com/bouk Thanks for providing the flow definitions
> for immutable !
> 
> For the following code
> 
> import type {List} from "immutable";const a : List<number> = List.of(666);
> 
> I'm getting
> 
>  39: const a : List<number> = List.of(666);
>                               ^^^^ List. type referenced from value position
>  15: import type {List} from "immutable";
>                   ^^^^ type List
> 
> Relevant parts of .flowconfig are
> 
> [ignore]
> ._/node_modules/immutable/._
> 
> [libs]
> lib/
> 
> where lib has the immutable.js from the gist.
> 
> I can see the definition of 'of' in the definitions, so I'm wondering why
> flow can't see that List.of is the use of the 'of' method.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/issues/203#issuecomment-164140531
> .
 @mhagmajer Thanks !

That was stupid of me :-). I did have a 

``` javascript
const Immutable = require('immutable');
```

Doing the equivalent i.e

``` javascript
const a : List<number> = Immutable.List.of(666);
```

made the error go away. 
 I've updated the definition for flow [0.20.0](https://github.com/facebook/flow/blob/master/Changelog.md#v0200), and because of the new `this` return type for class methods we can now have properly typed Records! https://gist.github.com/bouk/911b8d4993c19de3f98f

There is one error that happens now though, and it looks like this (it happens multiple times in the definition file)

```
848:   declare class Stack<T> extends IndexedCollection<T> {
                                      ^^^^^^^^^^^^^^^^^ Library type error:
848:   declare class Stack<T> extends IndexedCollection<T> {
                                      ^^^^^^^^^^^^^^^^^ IndexedCollection. type referenced from value position
2378:   declare interface IndexedCollection<T> extends Collection<number, T>, IndexedIterable<T> {
                ^ type IndexedCollection
```

These didn't happen in 0.19.1 and I'm unsure what changed between the two releases to cause this
 Hello. I am trying to understand how to use Redux and Immutable together with Flow.

I realized I cannot, even with this definition file, describe my application state. 

As an example, I have this state (very primitive)

```
{
    items: ["a", "b", "c", "d"],
    selectedItem: "a"
}
```

If this is a mutable object, I can describe it easily. For example:

```
type state = {
    items: Array<string>;
    selectedItem?: string;
}
```

However, when it is an immutable Map, I cannot describe it in any way! I can do for example

```
type state = Map<string, Array<string> | ?string>;
```

but that doesn't describe it correctly at all. Is there any way I can combine Immutable app state, which is a Map, but very complex, with Flow?
 Oh, now I noticed this comment in this thread

https://github.com/facebook/immutable-js/issues/203#issuecomment-163066987

OK, it might _just_ work. I will definitely try that and see what happens and how much will things explode. Thanks!
 Hm, what explodes immediately is indeed the last comment

https://github.com/facebook/immutable-js/issues/203#issuecomment-165790502

It seems to be related to this

https://github.com/facebook/flow/issues/1189 
 @bouk @runn1ng: IndexedCollection is an interface -- which is not a value (it's a type). You can't extend interfaces, they can only be 'implement'ed

If this worked in 0.19, this would've been a bug before -- sorry about that!
 @jeffmo I'm using @bouk's interface file and hitting those same errors. Based on your comment I tried replacing `extends` with `implements`, but it looks like that isn't actually a keyword in Flow. Is there an easy way to deal with those errors?
 @bouk when using your / @cpojer  type defs I get an error on this code when I later try and call the Map  `remove` method on the return value:

```
function subsetToPersist(thing: Map): Iterable {
  return thing.filter((value, key) => persistKeys.has(key));
}
```

Reading your comment above about `this` (and the comments in the code) led me to modify the function declaration of filter to this:

```
filter(
  predicate: (value: V, key: K, iter: /*this*/Iterable<K, V>) => any,
  context?: any
): this;
```

I just wanted to check that this is correct? If you would like to move your gist to github I could make a pull request.
 Flow [0.21.0](https://github.com/facebook/flow/releases/tag/v0.21.0) is out. Does anyone know if any changes are relevant to getting immutable.js working with flow?
 I'm wondering what enhancements to Flow would best support checking the structure of Immutables.  My first thoughts (I have no idea if the following are possible though):
- Make it possible to "overload" the type definitions of methods.  For instance for each property you could have an overload of the `get` method with the key and the type of the value for that key
- Make it possible to return types from functions, so that these overloads could be generated from an object type literal passed into a function

Of course, with all the different ways of accessing properties, especially `getIn`, `updateIn`, `withMutations`, etc, I'd think full Flow support for checking the structure is a tall order...
 @jedwards1211 Thanks for that comment. I think your head is in the right place. We definitely have our work cut out for us to get Flow type definitions for Immutable.js to be as good as possible. The perspective of "what can we add to Flow" is a good one.

As far as overloading function signatures, we can do that with intersection of function types. Generating these overloads given an object type would be a killer feature (and one I have already drafted up, actually...)

For `getIn`, `updateIn`, etc., there's some hope. As long as we know the literal accessor information statically (i.e., `getIn(["foo", "bar"])` instead of `getIn([userInputA, userInputB])`), we can get pretty far. There's room for a "best effort" here.
 @samwgoldman wow, I hadn't thought of using intersections of function types, great point!  So should `getIn` work automatically if it just calls `get` internally and all the overloads for `get` are present at each level of the business logic's type hierarchy?
 Well, there are two related, but separable problems here.

1) Can we declare types for immutable? Probably, most of it, barring some overly dynamic patterns. It's also likely that some of this stuff is theoretically possible, but Flow is missing some key intelligence to make it work in practice. In particular, static, literal information can easily be "lost" in all but the simplest cases. Also, complex types tend to report complex errors, which limits the utility of the tool.

2) Can we machine verify an implementation against a type? This part can be a lot harder than (1). Need to nail down the first bit first, but I'm not super optimistic. Thankfully, that doesn't really apply in this case, because we're declaring types anywayâ€”unless Immutable.js starts using Flow internally, but the value prop is unclear there since it's already mature and battle tested.

Maybe I misunderstood your question, though. Regardless of the specific mechanism, we'll need some custom, specific (read: hardcoded) support for `getIn` et al., but hopefully we can decompose that into reusable primitives, because that kind of dynamic property access is a common JS idiom. You also see it in Falcor, for example.

OK, probably doing more harm than good pontificating wildly in a public forum. I need to pop a few things off my stack before I can even look into this stuff.
 Is this a case that perhaps making some changes to immutable might be easier to work with? Maybe even a type safe subset (import TypedImmutable from 'immutable').
Or maybe its just a case of when we consume immutable, we abstract it and type our abstractions 
 Hello folks; I am another person interested in type definitions for Immutable. I have put some work into this previously. After reading the discussion here, I was able to put together a file that I have high hopes for:

https://github.com/hallettj/immutable-js/blob/flow-types/type-definitions/immutable.js.flow

I want to do a bit more testing before opening a pull request.

I have a lot of notes here, so I am going to break them into sections.

### .js.flow file

I chose to add a .js.flow file to the Immutable package instead of creating an interface file. This way, anyone who pulls in Immutable as a dependency will pick up the type definitions automatically (if they use Flow).

### dynamic behavior

I tried to make the definitions flexible, to reflect possible real-world, dynamic use. For example, when pushing a value onto a List, the type of the new value might not match types of values already in the list. I wrote a signature that permits the type of the resulting list to "broaden":

``` js
push<U>(...values: U[]): List<T|U>;
```

Where `T` is the type of values already in the list. In practice, if you have a list of numbers and push a string, then Flow will treat values in the resulting list as being either numbers or strings.

I was very pleased to learn from @samwgoldman about overload syntax for methods. That let me write signatures like this, which I find to be very convenient:

``` js
declare class Iterable<K,V> {
  // ...
  get<V_>(key: K, notSetValue: V_): V|V_;
  get(key: K): ?V;
  // ...
}
```

If you use the `get` method, this signature says that the result might be undefined if you do not provide a `notSetValue`. But if you do provide a `notSetValue`, then the result will not be undefined (unless the iterable actually contains `undefined` values).

### interaction with ES2015 Iterable

I noticed that a lot of Immutable methods can operate an any Iterable value - that being the ECMAScript 2015 Iterable type, as opposed to the Immutable Iterable type. So I made heavy use of this type alias:

``` js
/*
 * Alias for ECMAScript `Iterable` type, declared in
 * https://github.com/facebook/flow/blob/master/lib/core.js
 *
 * Note that Immutable values implement the `ESIterable` interface.
 */
type ESIterable<T> = $Iterable<T,void,void>;
```

This allows many of the constructor signatures to be simplified. The constructor signature that I wrote for Map, for example, is:

``` js
declare class Map<K,V> extends KeyedCollection<K,V> {
  static <V>(obj?: {[key: string]: V}): Map<string, V>;
  static <K, V>(iterable?: ESIterable<[K,V]>): Map<K, V>;

  // ...
}
```

This builds on the feature that all Immutable types implement the ECMAScript 2015 Iterable interface. When iterating over Keyed iterable types you get map entries (key-value pairs) - which happens to be compatible with the Map constructor overload for creating a map based on an existing Keyed iterable.

### the problem with subclasses as static properties

The biggest problem that I have not been able to solve is expressing that `Iterable` has the static properties `Keyed`, `Indexed`, and `Set`; and that `Collection` and `Seq` have the same static properties, but with different types. `Collection` and `Seq` are subclasses of `Iterable`, so Flow thinks that static properties with the same name as the superclass should have the same type. (That does seem like a reasonable constraint to me, actually).

It also seems that there might be a recursion issue with a class holding a reference to its subclasses.

For the moment I put in this cop-out:

``` js
declare class Iterable<K,V> {
  static Keyed:   Class<Object>;
  static Indexed: Class<Object>;
  static Set:     Class<Object>;
  // ...
}
```

`Collection` and `Seq` declare the same properties.

I export `KeyedIterable`, `IndexedIterable`, `SetIterable`, and the related `Collection` and `Seq` types, even though those names do not exist in the top-level namespace anymore. That way users can import those names as types, since using `Iterable.Keyed` and friends in type expressions will not produce satisfactory results with the above cop-out.

### Records

I made some headway on nice type-checking for Records. The most useful approach that I have found so far is to declare Record types in this fashion:

``` js
type ConversationSpec = {
  id:            string,
  activities:    List<Object>,
  allActivities: List<Object>,
  subject:       ?string,
}

type Conversation = ConversationSpec & Record<$Keys<ConversationSpec>>

const ConversationRecord = Record({
  id:            '',
  activities:    List(),
  allActivities: List(),
  subject:       null,
})
```

That gives you a type, `Conversation` that has these features:
- Flow infers that Conversation has the `Record` methods, `get`, `set`, etc.
- When creating a record, Flow verifies that keys and types given to the constructor match with `ConstructorSpec`.
- Flow is also able to check types of Record fields when they are accessed using dot notation.
- Flow will check that keys are valid for the record when using `get` and `set`, but will not check the types of values.

### interfaces vs mixins

@bouk: One important change that I made from your declaration file is to use classes for everything instead of interfaces. My examination of Immutable's implementation indicates that everything is a class under the hood. But in the actual type hierarchy, some relations are subclasses and some are mixins. For example, `IndexedCollection` is properly a subclass of `Collection` and `Iterable` - but it is not a subclass of `IndexedIterable`. Instead, it appears that the `IndexedIterable` methods are copied onto the `IndexedCollection` prototype.

I used the Flow `mixin` keyword which, if I understand correctly, captures that relationship:

``` js
declare class IndexedCollection<T> extends Collection<number,T> mixins IndexedIterable<T> {
  toSeq(): IndexedSeq<T>;
}
```

It seems that Flow requires mixins to be values (such as classes). Interfaces do not work.

### dealing with ambiguity in overloaded functions

@bouk, @samwgoldman: I also ran into issues with Flow choosing the wrong signature in an overloaded function. After some experimentation, I saw nice results with null-terminated argument lists. Here is a compose function that has been working well for me:

``` js
declare var compose: (<A,B,C,D,E>( fn3: (d: D) => E
                                 , fn2: (c: C) => D
                                 , fn1: (b: B) => C
                                 , fn0: (a: A) => B
                                 , $?: null
                                 ) => (a: A) => E)
                   & (<A,B,C,D>( fn2: (c: C) => D
                               , fn1: (b: B) => C
                               , fn0: (a: A) => B
                               , $?: null
                               ) => (a: A) => D)
                   & (<A,B,C>( fn1: (b: B) => C
                             , fn0: (a: A) => B
                             , $?: null
                             ) => (a: A) => C)
                   & (<A,B>( fn0: (a: A) => B
                           , $?: null
                           ) => (a: A) => B)

function compose(...functions) {
  return functions.reduceRight((accum, fn) => x => fn(accum(x)))
}
```

Oddly, when I try to extend this type with one more signature that accepts five function arguments, I stop getting type errors for incorrect uses. At least that was the case with Flow 0.21.

I used a similar type for `IndexedIterable#zip`.
 @jedwards1211, @samwgoldman, @leebyron: I am not inclined to put effort into making `getIn`, `updateIn`, etc. type-check correctly because I think that would be hard, and lenses are an existing solution that provides the same functionality, but with type safety.

In particular, I want to plug my own library: [safety-lens](https://github.com/hallettj/safety-lens). If you consider this code using Immutable:

``` js
import { List, Map } from 'immutable'

let calendar = List.of(
  Map({ date: new Date, title: 'get coffee' }),
  Map({ date: new Date, title: 'plan day' })
)

assert( calendar.getIn([0, 'title']) === 'get coffee' )
```

The equivalent code using lenses looks this:

``` js
import { compose, lookup } from 'safety-lens'
import { index, key } from 'safety-lens/immutable'

const firstTitleLens = compose(index(0), key('title'))

assert( lookup(firstTitleLens, calendar) === 'get coffee' )
```

But lenses also work on non-Immutable values. In my testing, this works with lenses, but does not work with `getIn`:

``` js
import { prop } from 'safety-lens/es2015'

calendar = List.of(
  { date: new Date, title: 'get coffee' },  // vanilla objects
  { date: new Date, title: 'plan day' }
)

firstTitleLens = compose(index(0), prop('title'))

assert( lookup(firstTitleLens, calendar) === 'get coffee' )
```

And lenses keep track of types through multiple layers of data structure nesting:

``` js
const badLens = compose(index(0), prop('title_mispelled'))

lookup(badLens, calendar)

// flow error:
// 
//  42: badLens = compose(index(0), prop('title_misspelled'))
//                                       ^^^^^^^^^^^^^^^^^^ string literal `title_misspelled`. Property not found in
//  39:   { date: new Date, title: 'plan day' }
//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ object literal
```
 @hallettj the type definition looks awesome to me. Also thanks for plugging lenses, I haven't used them before but it looks like an interesting concept.
 @hallettj hey, this looks awesome. I will definitely start experimenting with immutable + your lenses + flow. Will tell you if there are some bugs!
 @hallettj you don't have issues on your repo, so I am writing here

How is the Record working now? Your code from this thread doesn't work now, but `type Conversation = ConversationSpec & Record<ConversationSpec>` works.

Is the `ConversationSpec & Record<ConversationSpec>` still needed?
 @runn1ng Check out this comment from the linked PR https://github.com/facebook/immutable-js/pull/805#issuecomment-198112162
 Hm, no, it's not working, it doesn't seem to check anything and lets anything through.

What would happen, if I rewrite this

```
static <T: Object>(spec: T, name?: string): /*T & Record<T>*/any;
```

to this

```
static <T: Object>(spec: T, name?: string): T & Record<T>;
```

? It seems to check correctly; however it's probably commented out for some reason.
 @Chrisui ha! didn't see that PR! awesome
 In case anyone is interested, I'm using this approach for records, which is working pretty well: https://gist.github.com/glenjamin/75a96b45f4bb5c6ac221815d28c548dd

Although the errors it generates when something is wrong are not ideal.
 I've run into some issues when using `OrderedMap`. It seems that since the type definition for OrderedMap simply extends that of Map calling methods on an OrderedMap instance will return the wrong type. Namely `Map` instead of `OrderedMap`.

An example:

``` js
/* @flow */
import * as Immutable from 'immutable';
import type { OrderedMap } from 'immutable';

const oMap: OrderedMap = Immutable.OrderedMap({ a: 'b' });
const oMap2: OrderedMap = oMap.set('c', 'd');
```

The above code has two errors when I run it through Flow:

```
src/app/modules/alerts/stores.js:5
  5: const oMap: OrderedMap = Immutable.OrderedMap({ a: 'b' });
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map. This type is incompatible with
  5: const oMap: OrderedMap = Immutable.OrderedMap({ a: 'b' });
                 ^^^^^^^^^^ OrderedMap

src/app/modules/alerts/stores.js:6
  6: const oMap2: OrderedMap = oMap.set('c', 'd');
                               ^^^^^^^^^^^^^^^^^^ Map. This type is incompatible with
  6: const oMap2: OrderedMap = oMap.set('c', 'd');
                  ^^^^^^^^^^ OrderedMap
```

It seems that both the constructor and the `set` method are returning a `Map` in Flow's eyes, and not an `OrderedMap` as would be expected.

Looking at the type definitions file ([immutable.js.flow](https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow#L466)) it looks like this is happening because every method of Map returns a Map type. I'm not sure if there is an elegant way to write "return the same type as this object". Something like `typeof this`.
 immutable-js@noreply.github.com

ðŸ€

2016/06/23 5:22ã€Ian Sinnott notifications@github.com ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸:

> I've run into some issues when using OrderedMap. It seems that since the type definition for OrderedMap simply extends that of Map calling methods on an OrderedMap instance will return the wrong type. Namely Map instead of OrderedMap.
> 
> An example:
> 
> /\* @flow */
> import \* as Immutable from 'immutable';
> import type { OrderedMap } from 'immutable';
> 
> const oMap: OrderedMap = Immutable.OrderedMap({ a: 'b' });
> const oMap2: OrderedMap = oMap.set('c', 'd');
> The above code has two errors when I run it through Flow:
> 
> src/app/modules/alerts/stores.js:5
>   5: const oMap: OrderedMap = Immutable.OrderedMap({ a: 'b' });
>                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Map. This type is incompatible with
>   5: const oMap: OrderedMap = Immutable.OrderedMap({ a: 'b' });
>                  ^^^^^^^^^^ OrderedMap
> 
> src/app/modules/alerts/stores.js:6
>   6: const oMap2: OrderedMap = oMap.set('c', 'd');
>                                ^^^^^^^^^^^^^^^^^^ Map. This type is incompatible with
>   6: const oMap2: OrderedMap = oMap.set('c', 'd');
>                   ^^^^^^^^^^ OrderedMap
> It seems that both the constructor and the set method are returning a Map in Flow's eyes, and not an OrderedMap as would be expected.
> 
> Looking at the type definitions file (immutable.js.flow) it looks like this is happening because every method of Map returns a Map type. I'm not sure if there is an elegant way to write "return the same type as this object". Something like typeof this.
> 
> â€”
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub, or mute the thread.
 @leebyron, I wish that Immutable.js ships with official flowtype definitions one day given how popular the library is... :)
 How do I actually write a type definition using this?

``` js
const State : ??? = Immutable.fromJS({ name: 'chet', age: 25, tags: ['something']})
```

That is, how do I say something is an Immutable Map with a certain schema?
 I'm still unable to consume the definition added with Flow v0.31.0. I have added `node_modules/immutable/dist/immutable.js.flow` to my `[libs]`, but when I import with `import * as Immutable from 'immutable';`, I get the error:

```
3: import * as Immutable from 'immutable';
                                ^^^^^^^^^^^ immutable. Required module not found
```

Any idea what I'm missing? For reference, here is my .flowconfig:

```
[ignore]
<PROJECT_ROOT>/node_modules/.+\.json$
<PROJECT_ROOT>/node_modules/.+/node_modules/.+$
<PROJECT_ROOT>/node_modules/fbjs/.+$

[libs]
src/main/public/interfaces
src/main/javascript/js/bootstrap.js.flow
node_modules/iflow-react-router-redux/index.js.flow
node_modules/immutable/dist/immutable.js.flow

[options]
module.system=haste

module.file_ext=.js
module.file_ext=.less

module.name_mapper.extension='less' -> 'LessModule'

```
 @kayneb I had the same issue. I wrapped the whole file content with `declare module 'immutable' { ... }` and then it seemed to work. Don't know why that is necessary, though :-?
 @kayneb I used your configuration file and through some trial and error discovered that this line is causing Flow to ignore immutable library for whatever reason. If anyone knows why, I'd be interested to find out.

``` ini
<PROJECT_ROOT>/node_modules/.+\.json$
```
 I'll answer my own question. This is because the line above also excludes `package.json` and without it Flow doesn't know where to find the entrypoint of the module.
 @leebyron Any chance the recent 0.34 of flowtype can improve on the support for Record annotations?
 Why is it that even though this issue is closed because definitions for Immutable exist now, I don't see definitions for Immutable at https://github.com/flowtype/flow-typed/tree/master/definitions/npm? The definitions are bundled with this package.

> On 24 Nov 2016, at 16:15, Mark Volkmann <notifications@github.com> wrote:
> 
> Why is it that even though this issue is closed because definitions for Immutable exist now, I don't see definitions for Immutable at https://github.com/flowtype/flow-typed/tree/master/definitions/npm?
> 
> â€”
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 
 There's also a work in progress PR out to add the definitions to flow typed: https://github.com/flowtype/flow-typed/pull/401 Just for interest. I have made for myself a Record class wrapper, that checks Records for me (works better - for me - than the definitions in here). It's not complete, but it checks the types of the parameters, which is what I wanted; I don't use `getIn`/ `get`/`set`/`setIn`.

The small wrapper looks like this
````javascript
/* @flow */

import {Record as ImmutableRecord} from 'immutable';

export type Record<Def: Object> = {
  merge: (o?: $Shape<Def>) => Record<Def>;
} & Def;

type $RecordCreator<Def: Object> = (def?: $Shape<Def>) => Record<Def>;

export function RecordC<Def: Object>(definition: Def): $RecordCreator<Def> {
  const RecordClass = ImmutableRecord(definition);
  return (newDef) => {
      return new RecordClass(newDef);
  };
}
````

You can only use the "default" getters, but it checks them correctly; you cannot use set, you can only use `merge`, but it checks the types correctly (unlike using `set` with this definition). I use it like this

````javascript
/* @flow */

import type {Record} from './record'
import {RecordC} from './record'

const ABRecordC = RecordC({a: 3, b:3});
const recW = ABRecordC({b: 2});
recW.merge(); //works
recW.c; // throws error
recW.a; 

// or explicitly
type CDRecord = Record<{c: number, d: number}> 
const CDRecordC = RecordC({c: 3, d:3});
const rec: CDRecord = CDRecordC();
rec.merge();
rec.merge({c: 3});
rec.merge({c: 'foo'}); // throws error
rec.c;
rec.a; // throws error
````

I have to do the dance with `new` because of this - https://github.com/facebook/flow/issues/2930

It works as I want to. You can use it if you want  At the moment I'm fiddling with (re)flux, react and immutableJS; just to see how it works. I'm currently encountering an issue with ImmutubleJS which seems to related to its initialization.  

Right now the store is notified of new/initial data using _onLoadResourceSuccess_ which creates an Immutable map and triggers a change. The view listens to this store, checks if it's empty and if not, iterates over the map. 

This iterating throws an error the first time, however, on subsequent attempts it works fine. It seems to have to do with lazy/init behaviour. 

**Store**

```
var QuestionStore = Reflux.createStore({
  data: Immutable.List([]),
  listenables: restActions,
  onLoadResourceSuccess: function(data) {
    console.log("resource loading success: ", data);
    store.data = Immutable.List(data);
    store.trigger(store.data);
  },
  getDefaultData: function() {
    return this.data;
  }
  ....
});
```

**React element**

```
var Questions = React.createClass({
  getInitialState: function() {
    return questionStore.getDefaultData();
  },
  mixins: [reflux.connect(questionStore), ImmutableRenderMixin],
  render: function() {
    var questions = "Loading..";    
    if (this.state.size > 0) {
      // This, of course, won't do anything now, just testing the 'forEach' function here
      this.state.forEach(function(test) { console.log(test) })
    }    
    console.log("rendering questions..", this.state, questions);

    return (
      <div>
        <ul id="todo-list">
          {questions}
        </ul>
      </div>
    );
  }
});
```

I can see that the methods available the first time the Map is non-empty are not the ones available later on (when loading the view again, the store remains loaded). The first time 'forEach' is undefined here.
**First time**
![Incorrect](http://i.imgur.com/MTwjK8i.png)

**Second time**
![Correct](http://i.imgur.com/ZPYymxE.png)

I suppose my approach is not valid here, however, I can't figure out what the problem exactly is.
 @leebyron nice catch! That solved my issues indeed. 
  Basically a shorthand for:

``` javascript
x.updateIn([a,b,c], function(value)
{
return value.merge(something);
})
```

==>

``` javascript
x.mergeIn([a,b,c], something)
```
 Got my vote.
 I guess for lack of a better "generalization" I'll just tell you one specific use case. I'm writing a scope analyzer for javascript where the scope is a Map with 3 keys: free, function and block (for the different levels a variable name can be identified on). So for example "x = 5; r(); function r() { y = 10 }" would be Map { free : Map({ x: node_path, y: node_path }), function: Map({ r: node_path }), block: Map{}}"

As you encounter var definitions/function defs, you need to transfer previously considered free variables to function level. So for example, upon reaching the first r() call, you'd think that was a free variable, but then when you get to the function definition, you know it has function level scope. I do this using merge in as so: scope.mergeIn(["function", var_name], scope.getIn(["free", var_name])).removeIn(["free", var_name]). There are a couple other times when combining scopes that I use it.
  Perhaps this already exists or there is a better way to do this, but I'd love some sort of `.tee()` function to help examining intermediate results in chained expressions. Something like:

```
Immutable.List([1,2,3,4,5]).map( x=> x + 1 ).tee( x => { console.log( x ); } ).map( x=> x + 1 ); // outputs List [ 2, 3, 4, 5, 6 ]
```

`.tee()` would just pass through the data structure without changes (regardless of the return value of the function). The primary use I have for it is debugging chained expressions with `console.log()`, though I expect there are other uses as well.

Thoughts?
 Awesome, thanks! I'd missed the `update()` functionâ€¦that'll do fine. :+1: 
  The `setIn` method added in #28 is very useful and I was surprised it didn't exist in Records.

I have added it to `Record.prototype` the same way as `updateIn` currently works.
  The docs for fromJS specify that it will only work on raw objects:

> `Immutable.fromJS` is conservative in it's conversion. It will only convert
> - arrays which pass `Array.isArray` to Lists, and only raw objects (no custom
> - prototype) to Map.

I have a non-raw object that I want to convert, is there any way to override this behavior?
 Yes this worked perfectly, thanks! (Should I close this bug?)
  Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  I'm not sure if this is a bug, or if I'm doing something wrong. But when I try to `splice` one item into a List inside a `withMutations` block, I'm getting an empty list as a result.
For example:

``` javascript
var list = Immutable.fromJS([1,2,3]);
list.splice(1,0,10).toJS() // List [1, 10, 2, 3]
```

But, if I try to do the same thing, but using `withMutations`, it returns an empty list:

``` javascript
var list = Immutable.fromJS([1,2,3]);
list.withMutations(function(l){
  l.splice(1,0,10);
}).toJS() //List []
```

I've also tried this, but it gives the same result.

``` javascript
var list = Immutable.fromJS([1,2,3]);
list.withMutations(function(s){
  s.updateIn([], function(l){return s.splice(1,0,10); });
}).toJS() //List []
```
 I was using splice to insert elements at specific indices on a list. Is there a mutative method I can use to perform this operation?
 Am I having the same issue?

``` js
var menuItems = Immutable.List.of(
  { parent_id: 0, id: 1 },
  { parent_id: 1, id: 2 },
  { parent_id: 1, id: 3 }
);

var results1 = menuItems
  .filter(function(menuItem) { return menuItem.parent_id === 1; }) // Filter out items with parent_id = 1
  .sort(function(childA, childB) { return childA.sort_order - childB.sort_order; }); // Sort them by sort_order

var results2 = menuItems.withMutations(function(list) {
  list
    .filter(function(menuItem) { return menuItem.parent_id === 1; }) // Filter out items with parent_id = 1
    .sort(function(childA, childB) { return childA.sort_order - childB.sort_order; }); // Sort them by sort_order
});

console.log(results1.size); // 2
console.log(results2.size); // 3
```

I'm not so well-versed in the immutable jargon, so I'm not sure if `sort`/`filter` are mutative.
 Thank you for your explanation!

Yeah, I know, they're just mutable for illustrating the problem. I have an issue on stackoverflow with the same question, so I'll squash that with a quote from you, if that's alright. Might help someone.
 Never mind, someone just answered my question instead: http://stackoverflow.com/questions/28361512/why-do-i-get-different-results-using-withmutations/28474618#28474618
 I've run into same issue, took me a while to figure out what was going on. I think it's ok to not support splice in mutable version, but throwing errors there would be nice. Also how about adding some immutable method that would let user insert / remove items into arbitrary position of the collection ?
 I had the same issue described above and definitely not in the withMutations documentation here: http://facebook.github.io/immutable-js/docs/#/OrderedMap/withMutations

```
> var toSort = Immutable.OrderedMap({a:1, b:2, c:5, d:3});
undefined
> toSort.sort().toJS()
Object {a: 1, b: 2, d: 3, c: 5}
> toSort.withMutations(function(unorderedMap) { unorderedMap.sort();}).toJS()
Object {a: 1, b: 2, c: 5, d: 3}
```
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 It is now documented that only `set()` and `merge()` work within a withMutations block:  http://facebook.github.io/immutable-js/docs/#/OrderedMap/withMutations. It'd be nice if the documentation called out that methods besides `set()` and `merge()`, such as `sort()`, fail silently.
 Could I ask _why_ `splice()` is not considered mutative (and thus usable within `withMutations()`)? For example, I am trying to write functions to insert items into a list while maintaining order using a binary search. Inserting one item is fine, and I just use `splice()`, but if I wanted to insert N items at once, it seems inefficient to be creating N - 1 immutable intermediaries.

`Array.prototype.splice` mutates the array, so surely `List.prototype.splice()` should also be considered mutative.
 Without specifying the documentation this behavior very confusing ðŸ˜•
 What about `setIn` and the like?

I just wrote some working code that uses `deleteIn` in a `withMutations` scope. Confusing...

Also I think the documentation should state that not supported methods fail silently.
 @leebyron I'm also struggling to understand if/how deep operations like `setIn` operate inside `withMutations`, could you please clarify?
  3.0.3:

```
> Immutable.is(Immutable.Map({x: 1, y: 2}), Immutable.Map({y: 2, x: 1}))
true
```

3.1.0:

```
> Immutable.is(Immutable.Map({x: 1, y: 2}), Immutable.Map({y: 2, x: 1}))
false
```

I think this is wrong as I'd expect `Map`'s equality not to depend on order of keys.
  ``` js
var m = Immutable.OrderedMap().set('a',1).remove('a').set('b',2).remove('b');
m._list.size // 2 !
```
 Ah, I see. I was just wondering because before [the recent change](https://github.com/facebook/immutable-js/commit/b23a81d) from `list.remove(i)` to `list.set(i, undefined)` `OrderedMap#remove` behaved differently memory-wise (`m._list.size` stayed limited). Is there an equivalent of `replaceAndPackBackingStore` (in WebKit source you linked to) in Immutable?
  Sometimes, I have complex paths with maps and lists when using updateIn, and noticed something weird if passing a string instead of a number for a List index:

```
Immutable.List([]).setIn(['a'], 2).toJS()
```

returns []

```
Immutable.List([]).setIn(['123'], 2).toJS()
```

returns Array of size [1231] 

Not sure best solution, buy perhaps way to go would be to try coerce string to number or only accept number for the indices and throw an exception.
 great!

Perhaps, could coerce for the case of integer keys in Map as well :)

```
Immutable.Map({3:10}).get(3)
```

=> undefined
  Sorting Map returns an unsorted Map but should probably return an OrderedMap instead of a Map, otherwise it doesn't make much sense.
 Encountered this degradation some time ago too (probably in 3.0 or below). Previously it was working correctly. So, I now do `.toOrderedMap()` before sort.
  I have a map with lots of nested data structures that I want to pretty print (using tabs for indentation). Is this possible? E.g.

```
Map {
    data: Map {}
}
```
 Something like this would probably work:

``` javascript
JSON.stringify(yourMap, null, " ");
```

You can control the pretty printer through the last parameter, check out the docs [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#space_argument). 
 I was hoping to pretty print the immutable structure instead of the JSON equivalent, such as my example.
 I ran into this recently, and decided to throw together a little pretty-print lib for it

https://github.com/glenjamin/pretty-immutable
 Is it worth me sending in a PR to have this behaviour in core?  Non-allowed keys from the initial values are being allowed by `record.get()`.
 Rebased to include the built files.

I didn't include them at first so we wouldn't have a merge conflict again. But I just noticed that `CONTRIBUTING.md` explicitly says "Be sure to commit the generated JS in /dist."
  fixes #187

should probably rename the test
  ``` js
Immutable.OrderedMap({ a: 'aardvark', z: 'zebra' }).remove('a').get('z');
// Uncaught TypeError: Cannot read property '1' of undefined immutable.js:3221
```

Updated [Vector#remove](https://github.com/facebook/immutable-js/commit/8ca365ef045f86254978c08bf05a68ef3c55ebc8) behavior breaks [OrderedMap#remove](https://github.com/facebook/immutable-js/blob/280c5e4105922fafaf50236379e33c0e37af6939/src/OrderedMap.js#L138)
  Test included.
  Changed some implicit any types so people with the noImplicitAny flag can use it without warnings.
  You can reproduce in 3.0.2 with:

``` js
Immutable.fromJS({length: 21}).toJS()
```

This bug is quite critical, because any object having 'length' as key will result in an incorrect representation. Looking forward 3.0.3 :)
 hm, didn't realize ocurred with Map constructor as well. Right now, I'm trying to rename this property name in current project for something like 'extent'. But I believe the expected (and correct) behaviour is indeed that 'fromJS( plain js).toJS()' returns the same 'plain js'.

thanks for replying.
  In v2, I could do this:

```
var map = Immutable.Map(somethingSomething);
map = map.set("stuff", stuff);
var MyRecord = Immutable.Record(map, "MyRecord");
var someRecord = new MyRecord({});
```

In v3, calling `someRecord.has(...)` always returns false when I do this, because it assumes that the default values are a JS object and not an immutable map. As a result, `set(...)` also doesn't work.

A workaround is to change it to:

```
var MyRecord = Immutable.Record(map.toJS(), "MyRecord");
```

What's the best way to fix it? Update the documentation to specify the the default values _must_ be a vanilla JS object, or fix the code to allow any KeyedIterable? I can submit a pull request if you want.
 Great, thanks!
  A nicer package manager: http://spmjs.io
Documentation: http://spmjs.io/documentation

http://spmjs.io/package/immutable

---

It is a package manager based on [Sea.js](https://github.com/seajs/seajs) which is a popular module loader in China.

spmjs focus in browser side. We supply a complete lifecycle managment of package by using [spm](https://github.com/spmjs/spm/tree/master).

> If you need ownership of immutable in spmjs, I can add it for your account after signing in http://spmjs.io.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  This briefly tripped me up.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Just signed license agreement :)
  Just ran into this, seems it'd be useful to support `List` alongside `Array` in keyPath arguments.
 Got it up to date with master and seems to be passing the suite, though @leebyron I know you mentioned wanting to refactor some things to support this - what else do you think might need to be changed?
 Awesome, no worries! I'm fine working off a fork for now, just was looking to see anyway I could help out.
 :+1: Thanks!
  From #84 I get that we can provide a `hashCode(): int` method in objects we want to put in sets, or simply wherever we need to have a hashable property for this object.

It would be nice however to have this behaviour documented somewhere. For instance, is any integer viable? What are the limits? How does that affect perf, etc?

Moreoever, is it conceivable to have something more "friendly" than 'hashCode(): int`? For instance providing a property of the object itself which is hashable (string, number, etc) and having a generic hash function for these would be nice.

The reason I'm asking this is that I consider putting objects in a Set. To differentiate them from one another I plan to provide a 'sha256'. I'm not sure what would be the best way to do that. The `sha256` is already a hash and converting it to an integer seems to be convoluted to me.
 If you do this, you should also export and document some methods from `Hash.js`, so that they can be used as a helper to hash our own objects.
  The entire library is currently 51KB unzipped. It would be nice if it were possible to only build a part of it. For example, asmCrypto accomplishes this via the Gruntfile, which lets you do `grunt --with=$components`.

https://github.com/vibornoff/asmcrypto.js/blob/master/Gruntfile.js
 Pull and fork will help me 
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 Not just Firefox Mobile - desktop Firefox (44.0, now that it's 2016) looks exactly the same.
  Fixes #172 
Not sure if using a `Map` for `this._defaultValues` is the optimal way to go here.
Should it be cached and update accordingly on changes?
 Nice! :+1: 
  Hi Lee (& contributors), as I wrote on Hacker News, I'd like to discuss some ideas about Records with you. I'm looking for your opinion most of all, at this point. If there is consensus, I'd be happy to help implementing things as well.

I use Records a lot in my codebases - usually I have Map<string, SomeRecordClass>, possibly nested in another map or two, all over the place.

I like the concept of generating a Record class at runtime. It doesn't mesh well with TypeScript, but it's very powerful and really leverages some of the things JavaScript can do better than many other languages.

What I'm not so sure about, is the very large set of methods a Record has. I don't often iterate over all the keys in a Record. I don't usually want to build a map of all fields in a record except those that are more than 5. Maybe, somehow, it's not very useful that Record derives from Map. I'm not even sure it needs to implement Iterable.

As long as you can convert it into something that does.

So, how about this:
- Record does not implement Map or anything like that
- Record has only two methods, `set` and `toMap`.
- The rest of a Record's namespace is nicely saved for fields. It means you can easily access fields called anything other than 'set' and 'toMap'. You'd need to do `record.toMap().get('set')` if your Record has a field called 'set'. Feels controversial, but really in practice this seems like an edge case.
- Note that you don't really need `update`: You can just do `var newRecord = oldRecord.set('someSet', oldRecord.someSet.add(5));` which is hardly more verbose, and even shorter when you don't have TypeScript / ES6 lambda syntax.

This approach has a number of advantages. First of all, it becomes feasible to simply implement it with a vanilla JS object and `Object.freeze`. I'm not sure what the performance characteristics are, but I suspect that the structures underlying `Map` (and thus, the current `Record`) aren't _that_ much more efficient than a simple shallow clone for very small amounts of fields (like is typical for records). `set` would just shallow-clone the object, overwrite one value (or more, maybe), then freeze the new object.

That, in turn has a number of tangible advantages:
- First, shorthand field access (`record.fieldName`) works on ES3 too (currently it is implemented with defineProperty so only ES5 browsers and up will manage)
- Second, I suspect that there's more chances for leveraging TypeScript - Immutable.Record could simply be a base class (with `set` and `toMap` implementations) that people can derive their own classes from. I haven't completely worked this out yet, but I feel like there's ways here to at least make it _somewhat_ better from the TypeScript perspective.

Finally, somewhat offtopic, but why did you choose `obj.set('field', value)` over `obj.set({field: value})`?

I know that all this totally breaks backward compatibility. At this stage I'm more interested in discussing the concept, and then if more people think it's a good idea, we can see if/how to implement it. 
 Slightly related, you can get TypeScript safety for updating record fields with a syntax like `record.set(obj => obj.field = 6)`. 

In this implementation, `set()` passes `{}` to `obj` in the callback, but in TypeScript-o-world we say that it's actually an instance of the record's class or interface. This way, typing `record.set(obj => obj.` in a fancy IDE gets you autocomplete with the available fields and all that. The return value of the callback will contain all fields that need to be updated.

Problem with this approach is that the syntax feels quite unnatural. A single `set` implementation can support both syntaxes of course, so it's no biggie, but still, a bit odd. Just wanted to share, in case this approach hadn't been considered yet.
 I'm interested in this conversation, commenting so that I get updates :+1: 
 @abergs You can subscribe to GitHub issues by clicking the subscribe button on the right. No need to comment.
 I really like that proposal @leebyron! Would be very nice with a sound Record API. :)
 Woops, I forgot all the deep access things. I see why those are necessary. Not entirely sure about `update`: you'd not typically need to call it directly, and lacking it could probably be worked around from above in the object hierarchy. But even then, consistency is good, I guess. In general, great proposal.

One other strong advantage of backing `Record` by a plain ES3 object, is that you can simply pass a Record to any library that expects an object (including when it uses hasOwnProperty or Object.keys and so on), and it'll just work. Sure, `toObject` isn't far away, but it's nice if it doesn't matter.

One thing about `freeze` and enforcing immutability: this is JavaScript. Even if we try, it's a dynamically typed language that allows a lot of stuff, way too much probably. As such, I'm not entirely sure that it's necessary to enforce immutability _in production code_. Would it be interesting to ship two builds of the library, one for development, and one for production? Much like React, the development library would do all kinds of checks and Object.freeze and all that (skipping it if not available), and the production library would just back Record with a plain old object, end of story. I guess we can assume that even if Object.freeze does not work on every browser, it works on every _developer's_ most commonly used browser. 

If all development and automated testing uses a version that enforces immutability, then maybe it's no disaster if production code doesn't.

(I just realized that the React way might not be good enough; we'd want to be able to run automated tests against production code, but still have it fail if it breaks immutability. Users may expect harder guarantees here than f.ex. React's PropTypes).

Finally, good point with the signature of `set`. I like the idea of `assign` (as long as it lives on `Record` and not the prototype).
 I see your point. You can't expect all users of Immutable.js to have the same testing discipline.

However, in practice, what happens when code tries to mutate an immutable object?
- Immutability enforced: throw error, execution stops. End-user experiences "it doesn't work when I click this button". (at Facebook, developers get a big red bar in their face and some styrofoam USB rocket launcher fires at the wrong guy)
- Immutability not enforced: something weird goes wrong, errors later down the line. End-user experiences "it doesn't work when I click this button and then that one".

In my personal opinion, a warning with the Record documentation that the minified build does not by default enforce immutability, is good enough. The advantages are pretty big. 

I don't know about how these ES7/8 VM tricks work, but I assume it'll mean telling the VM "we promise, this won't go wrong"? In that case, it's still a userland promise so there's no real difference to passing an Immutable.Map or a plain old JS object.
 > I actually think Object.freeze's behavior of silently failing on mutation attempt is actually bad.

It throws in strict mode, but unfortunately depending on mutation attempt context, not on creation context, so it easily goes silent.

As an aside, [immutable](https://github.com/facebook/react/tree/master/src/vendor/immutable) in React source tree uses `Object.freeze` followed by `Object.seal` for some reason.
 How about using an plain object to store the properties internally, then using getters to proxy from the record to the internal object. We could use setters to throw an error on a mutation attempt. 

For browsers that don't support ES5, we can fall back to putting the properties directly on the record object, meaning they are mutable, but any attempt to mutate them would be caught by the developer because it would throw an error in their modern development browser.
 Ignoring whether this is a good idea or not, I would just like to point out that the performance of making a copy of an object is not as good as you might think.

Here is a benchmark I ran (using Node.js and Benchmark.js). It tests the performance of changing a key in an object that has 1 key:

```
Mutable object         x 12,002,295 ops/sec Â±0.31% (98 runs sampled)
Mutable object copying x  7,729,702 ops/sec Â±0.58% (102 runs sampled)
Frozen object copying  x    223,040 ops/sec Â±1.52% (93 runs sampled)
Immutable-js Map       x  2,979,875 ops/sec Â±0.50% (99 runs sampled)
```

As you can see, frozen objects take a [huge performance hit in V8](https://code.google.com/p/chromium/issues/detail?id=115960).

With 4 keys, the performance of Map started to be better than object copying:

```
Mutable object         x 12,002,520 ops/sec Â±0.33% (102 runs sampled)
Mutable object copying x  1,464,477 ops/sec Â±0.90% (98 runs sampled)
Frozen object copying  x    117,928 ops/sec Â±1.61% (91 runs sampled)
Immutable-js Map       x  1,847,183 ops/sec Â±1.46% (95 runs sampled)
```

And as the number of keys increased, the performance of object copying degraded. Here's 10 keys:

```
Mutable object         x 11,323,007 ops/sec Â±1.51% (95 runs sampled)
Mutable object copying x    697,039 ops/sec Â±1.35% (100 runs sampled)
Frozen object copying  x     58,053 ops/sec Â±2.99% (96 runs sampled)
Immutable-js Map       x  1,883,083 ops/sec Â±2.06% (89 runs sampled)
```

For any object that has more than 3 keys, it is clear that there is no performance benefit to object copying. So if you change Records, you should do so for reasons _other_ than performance.
 Thanks for those numbers. I didn't realize Maps were quite that fast. 
 Nice numbers indeed! I had blatantly assumed that it wouldn't be so bad, so it's good to stand corrected.

My goal, however, wasn't performance, but _simplicity_. It looks like the solution we're converging to isn't much simpler - it appears that the current implementation (backed by a Map) is maybe just fine. 

One goal I had was being able to pass a Record to any function that expects a plain old JS object, but it appears that that's nearly impossible to achieve.

Because of all this, I still stand by the API changes as @leebyron proposed (fewer methods, don't derive from Map), but not by any of the "how this could be done" ideas I proposed.

Btw, Lee, I do believe the proposal of methods lacks a `toMap` or `toKeyedIterable` or something like that. `Immutable.Map(myRecord.toObject())` would do the trick, but feels like a waste.
 If we do choose to leave Map as a the backing implementation, do we still get the structural sharing in the new implementation of Record? Because that... would be nice:)

By the way, I was just thinking of ways to further use structural sharing. Would it be possible to have a data structure that would represent a Collection of Records, where all records have structural sharing between one another? Say I have a large Collection where alot of data is similiar. A record may have 10-15 properties and we have 1000 Records in our Collection.

Wouldn't it be very swell if we could share similiar properties between Records? :)

I'm very new to the world of immutability so what I say might just be crazy talk. Would appreciate any feedback regardless :)
 @leebyron Sure: https://gist.github.com/Pauan/ea872c10d32d8d11ebd0

I just ran the benchmarks again with Immutable-js version 3.4.1 (installed using npm), and I got the same results.
 I am ignorant as to the whole of the motivation for `Record`, so I'm probably way off target here... but I discovered `Record` and this thread while looking for some way to make something like an immutable monadic Bean, if you know what I am saying. I am backing a model object with a `Map`, and providing setters that return a new model object backed by a new map that is the result of `set()`ting on the original map. But what I really want is to not use `Object` objects at all.
  ``` js
var Point = Record({ x: 0, y: 0});

var p1 = new Point({ x: 1 });
var p2 = new Point({ x: 1 });
p1.equals(p2)  // false

var p3 = new Point({ x: 1, y: 1 });
var p4 = new Point({ x: 1, y: 1 });
p3.equals(p4)  // true
```
 this tripped me up today! Spent a good time F8'ing through deepequality to discover it messes up the ordering.

p1 and p2 get mismatch because order on key-pairs are different.
  Seems like this is completely wrong?
 Oops looks like I was actually loading an old version of immutable. Sorry about that so it does actually work as the docs say. Just the use of the word "vector" is out of date then.
 v3 seems **way** better too btw so thanks for getting it out
 I wasn't sure whether I should create a new issue or not, but it seems the docs are wrong:

https://github.com/facebook/immutable-js/blob/19ebae805ccb3d81cf4d66ebcef9377d32a0d79a/type-definitions/Immutable.d.ts#L1716

They say that it behaves like `delete array[i]`, but it actually behaves like `array.splice(i, 1)`.
 Great, thank you!
  Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  I would expect that nulling a property would work in deep trees also, even if the value is currently a List?

``` js
var a = Immutable.fromJS({p: [1]});
var b = Immutable.fromJS({p: null});
a.merge(b).toJS(); // {p: null}
a.mergeDeep(b).toJS(); // {p: [1]} !
```

Generally I would expect that one could overwrite properties with different type, so that the last one wins (deleting the whole subtree), for example

``` js
var a = Immutable.fromJS({p: [1]});
var b = Immutable.fromJS({p: 2});
a.merge(b).toJS(); // {p: 2}
a.mergeDeep(b).toJS(); // TypeError: Expected iterable: 2 !
```

You can find similar situations with Maps etc. (Immutable 3.0.1)
 Thanks!
  Not sure if this is already covered: I'd like a memory safe method for pushing and pulling data into and out of typed arrays. They're a bit more efficient than simply serializing as JSON.
 Is there a way to get immutable to still use typed arrays internally? Otherwise we loose the perf benefits of native types.
 Referring back to the inquiry from @louisremi : there are lots of reasons for which it would be cool to keep stuff as a typed array, way beyond the non-trivial avoidance of conversion costs. In certain situations, your only option is to use typed arrays. To name two: transferring ownership to a web worker (avoids the need of copying) and WebGL. Conceptually, the idea of immutability and the idea of typed arrays are orthogonal, and in certain use cases, you can't not use typed arrays. 
  I were struggling with converting a model of ours to a Immutable.Map and found Record, which is perfect because we need to implement some functions.

But It doesn't seem to be possible to use the example syntax i Typescript?

```
import Immutable = require("immutable");

class ABRecord extends Immutable.Record({ a: 1, b: 2 }) {
    getAB() {
        return this.a + this.b;
    }
}

var myRecord = new ABRecord(b:3);
myRecord.getAB();// 4
```

Doesn't compile at all, "The property 'Record' does not exist on value of type 'Immutable'."
Any tips?
 Are you able to compile the code above? I'm running TS 1.0.3.0. Wondering if TS requires a an actual `class` to allow extending. The documentation however says `extends  classType`: 8.1.1 http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf
 Unfortunately not; TypesScript is struggling a lot with this.
![ts01](https://cloud.githubusercontent.com/assets/357283/4880314/aad34f5a-6339-11e4-93e8-4689ab0faf93.png)
 Hey @leebyron I see you have added a 4.0 label on that issue.
Any indication on how the records are going to be changed in regards to typescript (also regarding https://github.com/facebook/immutable-js/issues/341)
 I'll play with it hopefully around next week and will report
 After looking around a bit, I think adding generics to some of the types like Record would solve at least the typing issues in #341 and #564 .

As for inheriting, I'm not _entirely_ sure how that'd work since https://github.com/Microsoft/TypeScript/issues/2225 doesn't seem to be worked on. So maybe inheritance for a future version and just make it generic for now?

Let me know if you need to add generics tests for the next version
 Is this related to the present inability to type alias, e.g. `type MyRecord = Record({foo: ""})`? And, consequently, the inability to use a `Record` as a type in other ways: `List<MyRecord>`. Assigning to a `var` and attempting the latter scenario results in a similar error message: `Cannot find name 'MyRecord'`.
 I wonder if it is possible to do this with https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#extending-expressions,  https://github.com/Microsoft/TypeScript/pull/4910 and intersection types (see https://github.com/facebook/immutable-js/issues/341#issuecomment-147523795). All of the above is available in nightly ts build.

Any ideas?
 Works fine like below, with Typescript 1.6.

```
import Immutable = require("immutable");

const defaultValue = { a: 1, b: 2 }

class ABRecord extends Immutable.Record(defaultValue) {
    getAB() {
        return this.a + this.b;
    }
}

var myRecord = new ABRecord(b:3);
myRecord.getAB();// 4
```
 The subclassing works now (1.6) but the compiler will put off errors about properties not existing if you don't explicitly declare them:

```
const defaultValue = { a: 1, b: 2 }

class ABRecord extends Immutable.Record(defaultValue) {
    a: number;
    b: number;

    getAB() {
        return this.a + this.b;
    }
}
```
 Back to not working with 1.7. Argh.
 I spent a long time trying to the same issue, but at the end of the day, I can't answer the most simple question (maybe someone here can help): Why bother using `Immutable.Record` in Typescript?
- does a class with no `setter` method can be considered as immutable?
- should we only use ImmutableJS for collections?
 @zhenwenc Such a class would be immutable, but would not have the `set` functionality, nor default values support. That said, I'm personally inclined towards custom native-TS classes, considering how much hassle it is trying to use `Immutable.Record`â€”especially if a solution is liable to break with future versions of TS.
 This "workaround" works for me (functionality and code completion wise without errors):

``` javascript
import { Record, Map } from 'immutable';

export interface IModel {
    a?: number;
    b?: number;
}

interface IModelBase extends IModel, Map<string, any> {}

interface ModelBase extends IModel {
    new (values: {[key: string]: any}): IModelBase;
    getAB?: () => number;
}

export type Model = Record.IRecord<ModelBase>;

const ModelBaseRecord: ModelBase = Record({
    a: 1,
    b: 2,
});

class ModelRecord extends ModelBaseRecord {
    public getAB = () => this.a + this.b;
}

export default ModelRecord;
```
 @leonuh @abergs  I've created this library that has an interface called TypedRecord that extends from Immutable.Map and changes all return types to the generic provided type.
It has a function called makeTypedFactory that will create Immutable.Record of the type you specify, it's a just a utility but allows you to have typed Record all over the place and is a very very small library.
https://github.com/rangle/typed-immutable-record
 I found a class to get prop name as string array, then implemented a SetValue Method this has some rough edges.

``` typescript
export class NavigableObject<T>{
    constructor(private obj: T, private path: string[] = []) { }

    To<R>(p: (x: T) => R): NavigableObject<R> {

        let propName = this.getPropName(p)

        if (propName) {
            return new NavigableObject<R>(
                p(this.obj),
                this.path.concat(propName)
            );
        } else {
            return new NavigableObject<R>(
                p(this.obj),
                this.path
            );
        }
    }

    getPath() {
        return this.path;
    }


    private static propertyRegEx = /\.([^\.;]+);?\s*\}$/;

    private getPropName(propertyFunction: Function) {
        let value = NavigableObject.propertyRegEx.exec(propertyFunction.toString())
        if (value)
            return value[1];
    }
}

function NavigatableRecordFactory<X>(defaultValues: X, name?: string) {
    abstract class NavigatableRecord<P extends NavigatableRecord<P>> extends Record(defaultValues, name) {
        SetValue<T>(fn: (x: NavigableObject<P>) => NavigableObject<T>, value: T) {
            return this.setIn(fn(new NavigableObject<any>(this)).getPath(), value)
        }
    }
    return NavigatableRecord;
}

interface IUSER {
    Name: string;
    Age: number;
}

export class USER extends NavigatableRecordFactory<IUSER>({
    Name: "Simy the bothless",
    Age: 27,
})<USER> implements IUSER {
    Name: string;
    Age: number;
}
```

and then use it like 

``` typescript

state.Name // works

state.SetValue(t => t.To(q => q.Name), "test string") // typecheks
state.SetValue(t => t.To(q => q.Name), 123) // error
```

it also works with nested properties 

``` typescript
somenestedImmutable.SetValue(t =>t.To(q => q.Date).To(q => q.Time), 213213123)
```

but cant get it work without needing to implement method in child class ,
little help would be nice if it is possible :)

[Typescript v.2.1.0-dev20160805](https://libraries.io/npm/typescript/2.1.0-dev.20160805)
 I created simple typescript lib to create immutable.js record classes with full inheritance support - https://github.com/MrDegriz/immutable-record-class. Maybe it helps to someone. fyi I tried with latest release immutable beta rc and no luck
```

interface ITimelineState {
    zoom: number;
    duration: number;
    channels: Array<IChannels>;
    outputs: Array<IOutputs>;
    items: Array<IItem>;
}

let state: Map<any, ITimelineState> = Map({ // <<<< ERROR
        zoom: 1,
        duration: 500,
        channels: [],
        outputs: [],
        items: []
    });
``` Why is this closed. The problem persists.  I believe I want something like [Clojureâ€™s `select-keys`](https://clojuredocs.org/clojure.core/select-keys).

The mutable JS equivalent (using Lodash):

``` js
var foo = { bar: 0, baz: 0 };
_.pick(foo, 'bar'); // => { bar: 0 }
```

I can't see anything like this on `Immutable.Map`, but I could be mislead â€“ this is my first time using immutable data structures.
 Check out https://github.com/facebook/immutable-js/wiki/Predicates#pick--omit
 Personally I think this is common enough to be a first-class API.

Especially as when picking keys from an existing object, we should only need to iterate over the keys to pick.
 +1 to making it first-class.
  I think the 3.0.0 release is missing a compile step?

`contrib/cursor/index.js` is full of ES6 code.
 If I do `require('immutable/contrib/cursor')` node complains about the arrow functions.

Arrow functions are an ES6 feature.
 Any update on the release? I would like to update my projects to 3.x ASAP.
 Awesome. Thanks! :tada: 
  Might be the same as #97 

```
var Immutable = require('immutable');
var structure = Immutable.fromJS({ foo: [1, 2, 3] });

structure.inspect(); // 'Map { foo: Vector [ 1, 2, 3 ] }'

structure.cursor().inspect(); // 'Seq { foo: Seq [ 1, 2, 3 ] }'
```

 Immutable.js 2.1.6

Edit: for the record, 2.6.1, not 2.1.6
 @torgeir Seq is a lazy type that cursor uses to wrap the actual values. If you want the actual value from a cursor, use `deref()`.
 Fair enough, thanks
  When filtering a Vector I got back an IndexedSequence. Not sure if IndexedSequence is supposed to be an abstract class and therefore not be returned by filter or if it is just missing a `set` method?

``` js
Vector([1,2,3]).filter(function(x){return x == 2}).set === undefined
```
 Oh yup well I don't think laziness is the problem as such, its just a bit of a leaky abstraction when the lazy versions of things have a different API. Taking lazyness away is probably a good call still though IMO. Cheers for the answer.
   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Thought it'd be nice to mention in the readme's Browser section that `immutable` is browserify-ready for those that would like to use it. Let me know if you'd like different wording.
 A bit of love for `component(1)` would also be appreciated! :smile:
  Hi there, I'm Peter from cdnjs, I just accept @leebyron 's PR to add this lib on cdnjs, seems it's keep changing the file name under dist folder, a little bit strange, and will make cdn auto-update service broken, hope you can keep a correct name without keep changing, thanks.

```
./2.5.0/Immutable.js
./2.5.0/Immutable.min.js
./2.5.1
./2.5.1/immutable.js
./2.5.1/immutable.min.js
./2.6.0
./2.6.0/Immutable.js
./2.6.0/Immutable.min.js
./2.6.1
./2.6.1/immutable.js
./2.6.1/immutable.min.js
```
 Got it, thanks!
  Will immutable.js have an immutable list implementation in the future? Something similar to a vector, but always dense and probably with different performance characteristics.
 I would like a data structure, that grows and shrinks when elements are added and removed and does not have `undefined` "holes" in it. My current problem is, that I am communicating with an API. When I receive an Array `["a"]`, I read it with `immutable.fromJS` and get a vector. Now I would like to remove `"a"` and add `"b"`. I would like to send `["b"]` to the server, but the vector serializes to `[undefined, "b"]`. My current solution is, to walk the structure after serializing to JSON and filtering `undefined`s from all arrays, but I'd rather have a list structure, that directly generates `["b"]`.
 You can use `splice(idx)` instead of `remove(idx)`. Also `splice(idx, numToRemove, newItem, ...)` can add items in-place:

```
Immutable.fromJS(['a']).splice(0, 1, 'b').toVector()
```
 Oh, thanks.

@leebyron Could you generate an HTML version of the documentation and host it somewhere? Exploring the library is a bit hard, if you can only read through a 2000 line file on github. I think a lot of people would appreciate that.
 @CQQL see #137 related to better docs

Though I don't really understand `Vector.remove()` behaviour but never noticed that as I didn't use it yet. Shouldn't it behave the same as `splice(idx)`,  @leebyron ?
 Yes, it does. I think, I will have to refresh my definitions of dense and sparse.
 Yes, I think so. What is the advantage of the current behavior of `remove`? The data structures are persistent, so you do not benefit from not having to copy things around, as far as I understand.
  Fixes #153. The files were likely not renamed correctly while rebuilding on OSX.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 I've signed the CLA. It would be awesome if this could get merged and published as 2.6.1 soon.
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Awesome. Thanks! :tada: 
   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Browserify isn't able to resolve require("immutable") with version 2.6.0, but I can't find the reason for that. Am I the only one having this problem?

`Error: Cannot find module 'immutable' from '...'`
 I'm having the same problem with node:

```
$ npm install immutable@2.6
immutable@2.6.0 node_modules/immutable
$ node
> require('immutable')
Error: Cannot find module 'immutable'
    at Function.Module._resolveFilename (module.js:338:15)
    at Function.Module._load (module.js:280:25)
    at Module.require (module.js:364:17)
    at require (module.js:380:17)
    at repl:1:2
    at REPLServer.self.eval (repl.js:110:21)
    at Interface.<anonymous> (repl.js:239:12)
    at Interface.EventEmitter.emit (events.js:95:17)
    at Interface._onLine (readline.js:202:10)
    at Interface._line (readline.js:531:8)
> 
```
 This may not be a problem on case-insensitive file systems, but broke support for everybody else.

At some point the dist filenames were renamed to lowercase, but the actual files were not re-generated before 2.6.0 was published.
 @kraf Could you rename this issue to "2.6.0 is broken on Linux"? Apparently node can work with case insensitive file names on OSX (though maybe browserify can't), but this is simply broken everywhere else.
 :+1:
  Kinda like http://underscorejs.org/#pick and http://underscorejs.org/#omit.

I'm really iffy about the `pick` implementation. It feels really gross. I'm at a loss for a better implementation that can properly handle `OrderedMap` and cases when the `Map` is mutable. Any thoughts?
 That works for me, thanks! What do you think about adding a `/recipes` directory? Your solution could be `picking-omitting-keys.md`. Or maybe a `/contrib` directory with a `predicates.js` for things like these?
 @leebyron: It's looking great! Thanks!
  Sweet!
  This makes `NOT_SET` local throughout the lib for consistency, removing the need for it in the `remove` method. This meant adding an extra parameter `removed` to the internal update, updateMap, updateNode, etc.

The only place where I'd imagine an issue would have occurred is with [this line](https://github.com/tgriesser/immutable-js/blob/1e23be8869221ab4e2db2ac738a8404393a412da/dist/Immutable.js#L1947) as it's the only case dealing with `NOT_SET` where the function isn't called in the containing lib's scope. Probably better to be safe though.

Should be helpful in moving toward the goal of #117.
  According to the documentation the Map.has() function should return true once i set a key on it. _True if a key exists within this Sequence._ 

Sometime I have an empty Sequence within a map which Map.has() returns false for. Is this intended and consistent in the future - or a bug? 

Some example code:

```
var data = Immutable.Map.empty();

var someIds = [1,2,3,4,5];
var noIds = [];

data = data.update("a", Immutable.Set.empty(), function(oldSet) {
   return oldSet.union(someIds) 
});

data = data.update("b", Immutable.Set.empty(), function(oldSet) {
   return oldSet.union(noIds) 
});

data.has("a"); // returns true
data.has("b"); // returns false
```

By the way, thanks for that awesome library. I truly enjoy writing immutable "flux stores" with it. 
  ...equence

This might result in a performance hit when using toArray but I think this is not a case that the users should handle. It would mean leaking implementation details to users of immutable-js.
 I'm not sure what you mean by base implementations but I guess you mean the base class, `Sequence`? For my part I used `toArray` as an escape hatch from immutable to work around bugs (they are patched now) so returning immutable package types would not meet those needs.
  This is a bit wierd...

``` javascript
// Somewhere
this.actions = immutable.Map();
this.actions = this.actions.set('NEXT', true);
this.actions = this.actions.set('SKIP', true);

setInterval(function() {
   var canSkip = foo() === true;
   this.actions = this.actions.set('NEXT', canSkip);
   this.actions = this.actions.set('SKIP', canSkip);
}, 20);
```

Note that the above example is not a repro but a simplification of what I am basically doing.

Below is however exactly what I am doing and the prints I get.

``` javascript
console.log(this.actions); // Map { NEXT: true, SKIP: true }
console.log(this.actions.get('NEXT')); // undefined
console.log(this.actions.get('NEXT')); // true
```

I do not have the problem if there is only 1 value in the map.
 Can't reproduce with immutable 2.5.0.
 I'm using 2.5.0. Haven't managed to create a minimal example that has the problem.
 I'm just copy-pasted your code... I understand that you might have something in between these two snippets...
 Yes, however there is nothing happening between the 2 log statements. Same call twice but produces different results? How is that possible?
 The workaround for now is to always `get` every value twice.

``` javascript
var value = map.get('key') || map.get('key');
```

I only get the problem in special cases and I haven't managed to create a small repro sample... not sure what is going on...
 Using nodejs version 0.10.32.

Sorry, but I haven't been able to create a simple reproducible example. It only occurs in our production code.
  There's the example in the section "Lazy Sequences":

``` js
var oddSquares = Immutable.Sequence(1,2,3,4,5,6,7,8)
  .filter(x => x % 2).map(x => x * x);
console.log(oddSquares.last()); // 49
```

Documentation says that "filter is only called twice, and map is only called once". But actually filter is called 8 times.
I can't even contemplate how it could be called twice because you need to know the last element after filter.
  Proposing something making the following more easily available:

```
    var result = cursor.get("values").toJS().map(function(_, i){
      var subCursor = cursor.get("values").get(i);
      return <Element className="foo" initial={subCursor}/>
    });
```
 Re-reading that it really doesn't explain what I meant at all, sorry about that.

Cursor.map doesn't return cursors. So using the cursor onChange callback for nested elements created by Cursor.map isn't possible unless they're mapped and then converted back into Cursors and then those are passed into the child elements.

In contrast if you use instanceCursor.get("mapValue") and pass that into a child element, updates to that value using set will call onChange.

I intended to propose maybe some available function that would map while returning cursors?
 You're correct. I seem to have made a mistake concerning the map being lazily evaluated as well as the return value from the map being not an array but an Immutable object. Thank you for your responsiveness and assistance.
  I've tried example from readme:

``` js
var oddSquares = Immutable.Sequence(1,2,3,4,5,6,7,8)
  .filter(x => x % 2).map(x => x * x);
console.log(oddSquares.last()); // 49
```

I've got `1` instead of `49`.

Is there something wrong?
  Hi!

Just starting with `immutable-js`, so please let me know if I'm missing something simple.

I would have expected the following `node` snippet to return `3`:

```
var Immutable = require( "immutable" );
Immutable.Vector( 1, 2, 3, 4 )
  .filter( function( x ) { return x === 3; } )
  .last(); // undefined
```

It returns `undefined`. Is this due to the lazy nature of sequences?

If I use `toVector()` in the chain, it returns `3` as expected.

```
var Immutable = require( "immutable" );
Immutable.Vector( 1, 2, 3, 4 )
  .filter( function( x ) { return x === 3; } )
  .toVector()
  .last(); // 3
```
 That's awesomeâ€”thanks!
  ...equence

Minor bug when using reversed IndexedSequences.
  In version 2.0.17 i could call `first` on the sequence returned from `keySeq` and it worked as expected. With the new version I always get undefined.

Doesn't work:

``` javascript
var m = Immutable.fromJS({a: 1, b: 2});
console.log(m.keysSeq().first()) // undefined
```

Works:

``` javascript
var s = Immutable.Sequence(1,2,3);
console.log(s.first()) // 1
```
  Hello, as discussed on IRC earlier - I think cursors are more useful when they act like a wrapping reference type, rather than as immutable values that callback to the root. 

Here's an example of something that I expected to work, but behaves oddly:

http://jsbin.com/boropodo/4/edit?js,output

I think this is because the cursor ends up "stale", and sends an update based on an old version of the root.
 Shouldn't your shouldComponentUpdate return !Immutable.is(this.props.data, newProps.data) instead? Works fine with PURE_RENDER = true; after changing that.
 Oh wow, completely missed that - I'd seen similar behaviour before, but didn't click that in this scenario I'd just done it wrong!

Updated the jsbin, as you say - it works fine now! http://jsbin.com/boropodo/9/edit?js,output

:octopus: 
 The problem is when you have multiple layers of components with intelligent `shouldComponentUpdate`. It prevents cursors from propagating into branches which are unaffected by updates and thus making the cursors there stale.

Open http://jsbin.com/jiyenuyemo/2/edit when you update one counter another branch becomes stale and refer to the old root data, when you update another counter it forgets the previous update to the first counter.
 Aha, that's the issue I thought I was demonstrating!

@leebyron - can we re-open this?
 A related discussion: https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!topic/reactjs/IMCme4SRnnU
 Yep - I think I agree with @glenjamin, in the sense that cursors should be originally derived from a set-in-place wrapper for an immutable value (like an atom) rather than directly from an immutable value. The implementation @andreypopp linked looks promising as well.
 I've been experimenting with an implementation of these and was wondering - do you think it'd be possible to expose `IndexedSequence` on the Immutable object?
 Awesome!
 Awesome, definitely will. I've got a bunch of plants to extend / wrap the library in a centralized data management piece I'm working on, so anything like that I come across I'll let you know.
 @tgriesser I'm interested to see what you've done to wrap cursors. Got any code on GitHub? :smile: 
 @leebyron if the existing contrib/cursor implementation is still experimental, can a note of that be made in its readme? (should I open this as a separate issue?)
 Haha guess I didn't catch on =) thanks!
 @tgriesser or @leebyron guys could you please share some documentation and gist to solve stale cursor issue, I end up in same issues.
  My friend @brentburg used http://typedoc.io/ to generate these docs for Immutable:

http://brentburg.github.io/immutable-docs/api/index.html (repo link: https://github.com/brentburg/immutable-docs)

These are much easier to read than the declaration file. Please consider doing something like this? 

Thanks for all you do!
 What are your plans on this? This is one of my biggest pain points with learning the API, and I'd be glad to help where I'm able.
 +1 to typedoc
 I'm looking forward to this, too. If you are able to support the [Dash documentation viewer](http://kapeli.com/dash)â€”and it looks like [there are good instructions for generating their docsets](http://kapeli.com/docsets)â€”that'd be really awesome. I believe the same format is used by the [Velocity](http://velocity.silverlakesoftware.com/) doc viewer for Windows and [Zeal](http://zealdocs.org/) for Linux.

Either way, _any_ easier way to browse and read the documentation would be greatly appreciated!
 Can't wait to see a nice documentation! It's nice to see how much this lib is documented, but kind of hard to browse at the moment. Best wishes on this!
 +1 as well, I've been using the generated ones from this and my only feedback is the sidebar is crazy long and hard to search through. Some sort of search/filter or collapsable sidebar would be a big improvement.
 :+1: awesome :) Btw just want to say I'm having a great time working with immutable. Just today I noticed my app was behaving nicely in an edge case I hadn't even considered, thanks to immutable / Flux / React.

Only thing I can see clicking around is to make sections closable after they are opened, and maybe add a filter search, but that would be a nice-to-have.
 In the name of our team, thank you, Santa "@leebyron" Claus @_@ 
 @leebyron Not a big deal. But can Cursors docs also be on the official docs site?

Also, amazing job :smile: 
 @leebyron That is an awesome looking doc, definitely worth the wait! For for this and your amazing job here!
 @leebyron Glad to hear. Like I said, not a big deal. Since the type definition file for Cursors is small and readable compared to the main one :smile: 
  This was more of a traceur bug. Funny thing: `_empty` was leaking onto `Immutable.Record` after the first `clear` on an instance.

``` js
var MyRec = Immutable.Record({a:1});
var myRec = new MyRec();
myRec.clear();
Immutable.Record._empty._map === myRec._map
// => true
```
 Seems like the minified file causing a merge conflict. Should I rebase master and re-build?
 Too late heh
  My application has been using updateIn to update objects in arrays in other objects (the structure provided initially by `.fromJS()` from a native object. Right now I'm seeing a big in the application caused by the array being an IndexedSequence object and thus it doesn't have a `set` function exposed, and so it falls into the "Invalid keyPath" invariant.

In the meantime I'll work around this by explicitly doing the filter/map or .set, but I'm wondering whether `updateIn` should be able to support Sequences
 Ah - thanks. Took me a while to realize that `.filter` and `.map` return Sequences rather than Vectors and that's how my data was switching types, causing this hiccup. Just had to throw a few `.toVector()` calls in there and we're good. Thanks!
  I was using immutable with toJS() and I got a result that I thought was unexpected:

```
> var Immutable = require('immutable')
undefined
> var x = { y: { a: 1}};
undefined
> x
{ y: { a: 1 } }
> var iX = Immutable.Map(x)
undefined
> iX.toJS()
{ y: { a: 1 } }
> iX.toJS().y.a = 2
2
> x
{ y: { a: 2 } }
> var iX2 = iX
undefined
> iX2.toJS().y.a = 3
3
> iX2.toJS()
{ y: { a: 3 } }
> x
{ y: { a: 3 } }
```

Why is the original object changed here? Is this normal behavior?
 Thanks. That didn't connect when I read the docs. It's still early :-)
  It would be nice to have the version number included in built lib?
 The dist file is copied around in different build systems (and possibly later CDNs), so version number would just be nice to know (in somebody's build, in CDN, in old builds etc). I guess it is just something I have been used to find in popular libs (underscore etc), at least as a comment block, but I understand that there are often different versioning schemes internally vs open source etc.
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  ...x

When skipping you should add the number of skipped slots to return a derived collection's
values not subtract.
  ```
npm ERR! shasum check failed for /var/folders/84/rkrrsx917cq5slv7c0jg92lm0000gn/T/npm-16766-Tk7nWb6U/registry.npmjs.org/immutable/-/immutable-2.3.0.tgz
npm ERR! Expected: 2737e0ae520343cbb89bc98a7d76597aff1dfb67
npm ERR! Actual:   da39a3ee5e6b4b0d3255bfef95601890afd80709
npm ERR! From:     https://registry.npmjs.org/immutable/-/immutable-2.3.0.tgz
```

Could be a corrupted build? I'll keep trying.
 Confirmed it's working ok from another machine. I'll try it again on the original machine that was having problems, hopefully it's gone away.
  Add a full stop at the end of paragraph.
  I'm not sure if this is an actual bug or if there is a decision behind this behavior.

Nonetheless, I would argue that it would be better for `getIn()` to return `undefined` in the case of an intermediary key not existing, because it would make for easier to read code. And it would also make sense since the value is "not defined" for all intents and purposes.

I have run into this issue with code like this:

``` javascript
var data = immutable.fromJS({
    items: [ { name: 'Test' }, null, { name: 'Another test' } ]
});
var selectedItems = immutable.Set();

// Select all items
selectedItems = data.get('items').keySeq().toSet();

// Somewhere else:
selectedItems.map(function(id) {
    var item = data.getIn(['items', id, 'name']); // Throws TypeError because of the null item
    // [...]
});
```
 Wow, thanks so much for the quick response! You are doing a really impressive job with this project!
  Is there any particular reason for Immutable Sequences not having `min` and `max` operations defined? I know they can easily be implemented using the `reduce` function, but both of them are easier to read.
 Understood! Thanks for clarifying it.
 Thanks :)
If the demand for these functions become high one day, I'd be happy to send a PR.
 Cool, thank you!
  Being completely new to immutable data structures I've ventured my way in and ran into a problem for which I can't seem to find what's going wrong. It's most likely me missing something completely obvious and I'm making a big fool out of myself, but on the off chance that I've actually found a bug, I thought I'd share it.

I'm using `immutable@2.1.0` to represent state in my React components, using the following mixin:

``` js
var _ = require('lodash'),
    Immutable = require('immutable');

// Immutable mixin for React components to optimise rendering. Adapted from [mattsenior's `react-bacon-mori`][1] 
// experiment to work with Immutable.js instead of Mori. 
// 
// [1]: https://github.com/mattsenior/react-bacon-mori/



function hasChanged(current, next) {
    // check all own properties
    return _.some(current, function(currentValue, key) {
        var nextValue = next[key];

        // default to true if we're not dealing with an immutable sequence
        if (!(currentValue instanceof Immutable.Sequence) || !(nextValue instanceof Immutable.Sequence)) {
            return true;
        }


        // check for equality
        return Immutable.is(currentValue, nextValue);
    });
}


module.exports = {
    shouldComponentUpdate: function(nextProps, nextState) {
        // If both the props and state haven't changed, there is no need to update.
        return _.some([
            [this.props, nextProps],
            [this.state, nextState]
        ], function(currentAndNext) {
            return hasChanged.apply(this, currentAndNext);
        });
    }
};
```

I'm trying to be defensive and only let Immutable handle the equality check when both the new and old  vaue are Sequences, yet the code above triggers the following error in some cases:

```
Uncaught TypeError: Cannot read property '0' of undefined 

(anonymous function) (Immutable.js:246)
(anonymous function) (Immutable.js:388)
(anonymous function) (Immutable.js:1090)
(anonymous function) (Immutable.js:477)
valueSeq.valuesSequence.__iterateUncached.predicate (Immutable.js:341)
(anonymous function) (Immutable.js:723)
valueSeq.valuesSequence.__iterateUncached.predicate (Immutable.js:341)
(anonymous function) (Immutable.js:723)
__iterate (Immutable.js:1022)
fromEntrySeq.fromEntriesSequence.__iterateUncached (Immutable.js:722)
__iterate (Immutable.js:655)
valueSeq.valuesSequence.__iterateUncached (Immutable.js:344)
__iterate (Immutable.js:655)
fromEntrySeq.fromEntriesSequence.__iterateUncached (Immutable.js:722)
__iterate (Immutable.js:655)
valueSeq.valuesSequence.__iterateUncached (Immutable.js:344)
__iterate (Immutable.js:655)
map.mappedSequence.__iterateUncached (Immutable.js:476)
__iterate (Immutable.js:655)
filterSequence.__iterateUncached (Immutable.js:1088)
__iterate (Immutable.js:655)
forEach (Immutable.js:361)
every (Immutable.js:387)
__deepEquals (Immutable.js:244)
equals (Immutable.js:239)
is (Immutable.js:1217)
(anonymous function) (index.js:23)
(anonymous function) (lodash.js:3961)
forOwn (lodash.js:2105)
some (lodash.js:3960)
hasChanged (index.js:13)
(anonymous function) (index.js:35)
some (lodash.js:3955)
module.exports.shouldComponentUpdate (index.js:31)
ReactCompositeComponentMixin.performUpdateIfNecessary (ReactCompositeComponent.js:1048)
runBatchedUpdates (ReactUpdates.js:152)
Mixin.perform (Transaction.js:141)
Mixin.perform (Transaction.js:141)
mixInto.perform (ReactUpdates.js:98)
(anonymous function) (ReactUpdates.js:176)
ReactPerf.measure (ReactPerf.js:57)
Mixin.closeAll (Transaction.js:214)
Mixin.perform (Transaction.js:155)
ReactDefaultBatchingStrategy.batchedUpdates (ReactDefaultBatchingStrategy.js:70)
batchedUpdates (ReactUpdates.js:113)
ReactEventListener.dispatchEvent (ReactEventListener.js:182)
```

The only clue I have is that DevTools recognises `currentValue` as `Object[3]` and `nextValue` as `IndexedSequence`, although I know too little about Immutable and it's internals to be able to judge whether that's of any consequence. 

The actual project is a port of Faceboook's flux-chat example and can be found [here](https://github.com/JaapRood/flux-experiments-chat/tree/11bd8baaf8f07f4f611ce11058943a7f0d86bf3f).
 Thanks for the lightning response! You can reproduce by 

```
npm install
npm start
open index.html
```

and by adding a new message using the text area. 

I'll work on isolating it with a proper test, which should have been there in the first place, but that's just me mucking around with new stuff :smile: 
 Managed to isolate the problem a bit, see this requirebin:

http://requirebin.com/?gist=31e91cd9e766652322c3

Also available as a Gist

https://gist.github.com/JaapRood/31e91cd9e766652322c3
 Sweet, thanks! I'll be on it as well, although I'm pretty sure I'm just going to be pointed to having done something stupid. As a side note: I am aware that there are probably way better ways to implement that example, but in my mind it _should_ work. It's mostly me trying to stay close to the thing I'm porting.
 Awesome, thanks!
  I noticed than flatten was returning a basic sequence, rather than an indexed sequence, which contradicted the type definition, so I made a little tweak to clear that up. The __iterate method of flattened sequences was returning the wrong count too, which was causing some subtle bugs.

I've added tests for the stuff I changed.
  This should probably get the question tag. I was wondering if anyone had any thoughts on using immutable-js as a way to create very simple immutable object-oriented API's, like this arbitrary example:

``` js
// First define the data structure: all Immutable stuff wrapped in a plain object.
var gameWorld = {
  rooms: Immutable.Map()
}

// Then put some functions into the object. These serve as methods.
api.createRoom = function(name, desc) {
  // For every method that would traditionally mutate the object, instead do a shallow clone.
  var self = Object.create(this) 
  self.rooms = self.rooms.set(name, desc)
  self.doAnythingElse()
  return self // returns the new object with a new reference
}

var myGame = gameWorld
firstGame = myGame.createRoom('palace', 'cold and dark')
secondGame = firstGame.createRoom('arboretum', 'sunny and warm')
thirdGame = firstGame.createRoom('ballroom', 'light and airy')
```

In the above example, firstGame has the 'palace', secondGame has the 'palace' & 'arboretum', and thirdGame has the 'palace' & 'ballroom'.

The benefit is that it becomes very trivial to inherit/expand/compose/extend objects.

Of course it's even easier to separate the data structure completely and just use it as a value to pass around with plain functions, but the above could be an alternative if you like seeing OO-style syntax.

Any thoughts/feedback?
 Ah, interesting, I hadn't seen Record. Do you see red flags in the strategy that I cited? I think I'm still favoring it because it feels very simple to the end user and is perhaps easier to make arbitrarily named methods that take any number of arbitrary parameters and update any arbitrary amount of entries in the record

One thing I did notice in mine is that I probably shouldn't use Object.create(), because that will create endless nests of **proto** -- instead I'll use just a simple shallow clone func
 Cool, thanks, will check out /Record.js
  FWIW, this is how it works in mori: 

![screen shot 2014-10-03 at 7 58 10 pm](https://cloud.githubusercontent.com/assets/154748/4514000/7ffb3006-4b59-11e4-85b1-1922cdd430f4.png)

Since `undefined` isn't a value in Clojure(script), and in JavaScript it's not terribly useful as a value, when converting from JS, any undefined values are coerced into `nil`, which are just `null` values.

I've enjoyed this behavior as it's consistent and removes any checks for both `null` and `undefined`, but I could understand wanting to preserve JavaScripty semantics in this library - just figured I'd mention it as related prior art.
 I would support this. I don't think the performance of the most common case (dense vectors) should be compromised to allow for sparse vectors, which are rarely needed.

As you pointed out, the biggest problem with using a Map to represent a sparse list is the unordered iteration, but it is trivial to implement a sorted iteration function, something like this:

``` javascript
function forEachOrdered(col, fn) {
    col.keySeq().sort().forEach(function (key) {
        fn(col.get(key), key, col);
    });
}
```
 :+1: I'd echo both @DavidTimms and @tgriesser sentiments. The noted consequences are spot on and are true in most other languages with said datatypes, so in fact I've been programming against that mindset already (with extra sorted datatypes added in a private lib). I assume monads are a path not wanting to be taken, which helps address this in Scala/Haskell?
 Specifically the "option" monad: https://en.wikipedia.org/wiki/Option_type#The_option_monad
 @leebyron Yep, Maybe/Option. It can be done with JavaScript's type system, checkout how @puffnfresh did it in bilby: https://github.com/puffnfresh/bilby.js and @fantasyland in fantasy-option: https://github.com/fantasyland/fantasy-options
  I am creating a Vector and eventually all values will be removed at some time. Beyond this point I am not able to `push` any values into my Vector:

>  TypeError: undefined is not a function

As it turns out it isn't a Vector anymore but a Sequence. As far as I understand a Vector extends from a Sequence, and the method `splice` does Sequence stuff, but shouldn't the type be preserved?
Sorry if I misunderstood some concept here, I am still a novice.

```
v = Immutable.Vector()
>>> []
v.push('test')
>>> [undefined Ã— 1]
v = v.splice(0, 1)
>>> []
v.push('test')
>>> TypeError: undefined is not a function
v.inspect()
>>> "Seq []"
```
 See #37, #23, #85 for some discussion on this.
 I was also confused by this, as the `push`seems to "go missing" if I `splice` what already is a Vector (as I end up with a Seq)
 :+1: 
  If you `map` or `filter` a sequence, then iterate over the result using `forEach`, `map`, `reduce`, etc., the final argument passed to the iteration function is the original sequence, rather than the mapped/filtered one.

For example, this prints `Vector [ 1, 2, 3 ]`, rather than the correct `Vector [ 1 ]`:

```
Vector(1, 2, 3)
    .filter(function (val) { return val < 2 })
    .forEach(function (val, index, seq) { console.log(seq.toString()) });
```

For `map`, I think the bug comes from [this line](https://github.com/facebook/immutable-js/blob/master/src/Sequence.js#L366), where the last argument to `fn` should be `mappedSequence`, instead of `c`. I assume there is a similar problem in filter, and possibly some other methods. 
 I very rarely use the final argument, as the collection is usually captured by the closure anyway. In this case, I was writing a function to convert roman numerals to numbers.

It works correctly using a JS array:

``` javascript
var numeralValues = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000,
};
function decodeNumeral(str) {
    return str.split("")
        .reverse()
        .map(function (char) { return numeralValues[char] })
        .reduce(function (total, value, i, values) {
            return (i < 1 || value >= values[i - 1]) ?
                total + value : total - value;
        }, 0);
}
```

The Immutable version throws an error though:

``` javascript
function decodeNumeralImmutable(str) {
    return Sequence.from(str.split(""))
        .reverse()
        .map(function (char) { return numeralValues[char] })
        .reduce(function (total, value, i, values) {
            return (i < 1 || value >= values.get(i - 1)) ?
                total + value : total - value;
        }, 0);
}
```

Of course, you can rewrite it to make it work using an intermediate variable:

``` javascript
function decodeNumeralImmutable(str) {
    var values = Sequence.from(str.split(""))
        .reverse()
        .map(function (char) { return numeralValues[char] });
    return values.reduce(function (total, value, i) {
        return (i < 1 || value >= values.get(i - 1)) ?
            total + value : total - value;
    }, 0);
}
```

I think it is best to try to stick as closely as possible to the JS array API, as that is what people will be used to. The reason I never liked Mori was that the API feels so foreign in JS.
 I just checked the new build and this is working as expected now. Thanks.
  I find it inconsistent that calling `map.updateIn(['foo', 123], ...)` allows for the creation of a numeric key.

This is inconsistent from doing:

``` js
var map = Immutable.Map({
  'foo': {
    123: 'bar'
  }
})
```

which produces `{"foo": {"123": "bar" } }`

Was this a conscious design decision?  I assume that coercing all maps into string keys was. 
 Ah, thanks for clarification, I suppose I never ran into this issue before as doing a numeric lookup on a JS object will also coerce the key to a string.  I will have to rethink some previous design decisions.
 ~~Also with that format of constructing maps, how do you nest an Immutable.Map as a value of another map?~~ 

nvm i was doing it wrong
  These were the stumbling blocks that were a bit annoying to get going
with, having never used grunt before. I was also ensure as to whether or
not I needed to commit the built JS/interface; inspection of previous
commits indicated that was expected.

I'd understand if this may be superfluous, but if not, merge away!
  fixes #106
 Who doesn't love the vagaries of JavaScript? Looks like some reasonable choices of behavior.  :) I'll have to pick another issue to work on, now. 
  I was wondering if it would be possible to rely internally on some duck-type checks rather than `instanceof`, making it possible for two reasonably-compatible copies of Immutable.js to communicate/consume objects without any issues.

I guess there might be an issue with collisions if two copies of the library have independent `UID_HASH_COUNT` values... I'm sure there could be a workaround for this case.

Anyway, just wanted to see if this seemed like something that was possible, or if I was overlooking something obvious.
 Ah of course, forgot to look for any identity checks... looks like that's also the case in a lot of spots where you have `Obj.constructor === Obj ? ... : ...`

It was just more of a more general question... I'm looking into using Immutable as the underlying data structures for an ORM I have for Node, Bookshelf, and more generally in a lot of places.

I was thinking it'd be great if there were something of an adaptation of underscore/lodash which also supported Immutable's structures, which would likely require a local copy of the library. I'm currently using mori in a project because of the hof's and more generally cljs' protocols, but it would be great if there were more functional options in js land.

In Node, if you're not careful it's very easy to wind up with multiple copies of a library throughout the dependency graph. With many libraries this isn't an issue at all, but with your library I can foresee a lot of cases where it becomes a big issue. As immutability gains more momentum in JavaScript and libraries start popping up like transducers.js etc, sooner or later they'll start requiring Immutable as a dependency, and this issue will likely start to pop up (and it's really a headache the first time you run into it).

I'd imagine it'd be possible to work around the identity issues by adding the objects to prototypes as needed... you probably have a better idea than I do though, and I understand if the extra complexity isn't worth it at this time.
 I too have also run into this problem when doing `map instanceof Immutable.Map` to deal with interoperability between native JS objects and ImmutableJS Maps.  It was a very hard bug to find and the cause was accidently including two copies of ImmutableJS in my dependency graph.

A utility/helper library similar to underscore would be very nice for these, as I have an `immutable-helpers` file in my current framework I am building on top of ImmutableJS
 If this is going to be an eventual goal, what do you think about exposing a set of predicates on the immutable instance - `isMap`, `isVector`, `isSequence`, `isRecord`, `isIndexed` etc. to eliminate the need for hard `instanceof` checks (even if that's what actually happens internally until this is something that is reasonable to support).
 The big problem with this right now is that it means that immutable objects can't cross module boundaries. An immutable object produced in module A, can't be passed to an immutable object produced in module B because they have different node_modules directories (although if the immutable versions are the same, browserify will unify `A/node_modules/immutable` and `B/node_modules/immutable`, which is even more confusing).

I have a few projects which I would like to work on which would involve passing immutable objects between modules, and that simply isn't possible right now, due to the dependency on object identity in the implementation of immutable.
 Here's an example of confusing behavior:

``` js
var x = Immutable1.Map({a: 1, b: 2});
var y = Immutable2.Map({a: 1, b: 2});
var z = x.set({c: y});
z.toString() // Map { a: 1, b: 2, c: Map { a: 1, b: 2 } }
z.get('c').get('a') // 1
z.toJS()
// {
//   a: 1,
//   b: 2,
//   c: {
//   __altered: false,
//   __hash: undefined,
//   __ownerID: undefined,
//   _root: BitmapIndexedNode: {
//        length: 2
//   }
// }
```
 Here's another:

``` js
var x = Immutable1.Map({a: 1});
var y = Immutable2.Map({a: 1});
Immutable.is(x, y); // false
```

Obvious here, but becomes confusing when you start deep mixing values and assume the value they represent should be considered equal.
 Awesome! Will take a look at some point and see if there are any other I can come up with.
  To resolve issue #113 and provide a nicer interface, I've implemented negative indexing in the `get` method of IndexedSequence, ArraySequence and Vector. This counts from the end of the sequence, so -1 returns the last value. I reimplemented `get` for ArraySequence, because it didn't appear to be working before. Accessing an index which is negative and beyond the bounds of the sequence now returns the notSetValue, rather than throwing an error.

Tests have been added for the new feature, and all the old tests and the linter pass. I've updated the type definitions to document the new feature.
  Creating a map has an unexpected result when called with an array.
`immutable.Map.from([1, 2, 3]) => Map { undefined: undefined }`

Contrast this to other values:
`immutable.Map.from(immutable.Vector(1, 2, 3)) => Map { 0: 1, 1: 2, 2: 3 }`
`immutable.Sequence.from([1, 2, 3]) => Seq [ 1, 2, 3 ]`

Expected value: `Map { 0: 1, 1: 2, 2: 3 }`
  If a sequence is repeatedly concatenated with other sequences, calling any method which realises the lazy sequence causes the infamous RangeError: Maximum call stack size exceeded.

For Example:

```
var vec = Vector();
for (var i = 0; i < 5000; i++) {
    vec = vec.concat(Vector(i));
}
vec.reduce(sum, 0);
```

I know that `.push` would be more sensible in this case, but still, concatenation should never lead to a stack overflow.
 Using RRB trees would be great. I look forward to it!
  This seems like it should either be specified in documentation that the key given to `has` must be positive, or it should return `false`: http://mistakes.io/#bb5a86b8372adc8a8479
 I think it would be really nice if both `.get` and `.has` indexed from the end of the vector when passed a negative value, as Python's lists do. If nobody has a strong objection to this, I might try implementing it.
 I'd like to point out that this is a horrible behavior! (imo) Coming from CoffeeScript the fact that its ranges go both ways and so does iteration always caused me pain (and I don't think I have used it as a feature once). Having has(-1) return true is extremely counter intuitive. I guess this boils down to the fact that having an index and wanting to know whether it is valid happens more frequently than the situation where I want to know whether index is valid or it is a negative index which is valid... Adding another method which is strict will pollute the API and keeping it this way will lead to hard to debug/surprising errors down the line. Just my 2 cents.

P.S.: 1. Although people asked for negative indexing, this was rejected for performance reasons mainly in CS.
2. Although I think negative indexing is evil, has(-1) is much worse (especially since has is polymorphic over all Iterables including Maps).
  I'm confused about the best way to use Lazy Seqs in this library.

Is a user of this library meant to be able to construct them? For example, is it possible to make a lazy sequence of random strings?

Is there documentation or code examples somewhere of how it could be done?

The stuff in Sequence.js is pretty dense and I'm not sure where to get started, though it looks like Range.js and others just extend IndexedSequence.

If this is the case are there particular core methods to implement?
Is it possible to have something like `Sequence.create({ /* methods */ })` in the vein of `Object.create`?

-- Thanks,
Thomas Omans
 I am also hoping for an answer to this questionâ€¦Â looking for something akin to Clojure's `iterate`  or Lazy.js' `generate` wherein lazy sequences may be constructed.
  I like updateIn very much, but in case you need to update keys in all or some matching a predicate nested collections you need to build 2 levels of nested updateIn's. It would be nice to have an possibility to do it one step:

``` javascript
var m = Immutable.fromJS({
  books: { name: 'Somename', price: 15},
  magazines: { name: 'Anothername', price: 8},
})
var predicate = function(key) { return true};
var n = m.updateIn([predicate, 'price'], function(price) {return v + 0.95})
//  books: { name: 'Somename', price: 15.95},
//  magazines: { name: 'Anothername', price: 8.95},
```

It seems quite easy to implement too, something like

``` javascript
function updateInDeepMap(collection, keyPath, notSetValue, updater, pathOffset) {
  var pathLen = keyPath.length;
  if (pathOffset === pathLen) {
    return updater(collection);
  }
  invariant(collection.set, 'updateIn with invalid keyPath');
  var notSet = pathOffset === pathLen - 1 ? notSetValue : Map.empty();
  var key = keyPath[pathOffset];
  if (typeof key == 'function') {
    collection.map(function(k, existing) {
       if (key(k)) {
         return updateInDeepMap(existing, keyPath, notSetValue, updater, pathOffset + 1);
       } else {
          return existing;
       }
    })
  } else {
    var existing = collection.get(key, notSet);
    var value = updateInDeepMap(existing, keyPath, notSetValue, updater, pathOffset + 1);
    return value === existing ? collection : collection.set(key, value);
  }
}
```
 It's quite hard for me to imagine real use case for function as key, but if we absolutely need to support it then I think only possibility is to introduce special object wrapper, like `Immutable.predicate(function..)`. It's not bad too, because it allows creation of common filtering patterns, like `predicate.all` to update all elements, which is frankly the only thing I need now, maybe `predicate.startWith(prefix)` to check if key starts with given prefix, and so on. But this requires much more code and more thorough thinking, and is more feature-creepy, usually I prefer smaller steps to validate them early.
 It would suffice my example, but the example is a greatly simplified real case, in which I have 4 levels deep map in which in need to updateIn all at level 2, just wanted to keep the example clean and removed extra complexity. Actual call would be like this:

``` javascript
largehash.updateIn(['a', All, 'b', All], fx)
```

I can do it without the proposed change (and have done), but the code is ugly, and doesn't reveal the intent, while with it it's clean and concise. Wanted to monkey-path this function but it turned out to be not so easy.
 Implementing updateIn(predicate, ...) for Immutable.List would be awesome and much less 'creepy'
 So it means no chances for updateIn as proposed in first post to get into mainstream? I don't see a nice way to rewrite the `largehash.updateIn(['a', All, 'b', All], fx)` with `map` and `mapIf`. Or it still under evaluation for Maps, but not for Lists?
 An example from my app,  I have a deep/large appstate object that dictates how whole appview. 

``` javascript

    var dealIndex = appstate.getState().getIn(['contact','item','deals']).findIndex(function (deal) {
      return deal.get("id") == cmd.dealId;
    });


    appstate.updateIn(['contact','item','deals',dealIndex,'breakdown'], function(breakdown) {
      return breakdown.push(immutable.Map({
        type: '000_Manufacturer Fitted Option',
..

```

I suspect I may benefit from cursors so perhaps this is not as bad as it is. 

Regarding functions as keys I suspect this is a very rare scenario, one where the usability of the predicates in path specs outweights the benefits of supporting such edge case.  Perhaps a flag Immutable.treatFunctionsAsKey ?
 I think easiest to implement, and to check against for good performance and to keep functions as keys possible is to wrap functions that we want to work as a predicates with something like `Immutable.predicate(function(key) { return check_key(key) })`. Whats the problem with this idea?
 @stiff that sounds very reasonable, so presumable this would wrap the function in an instance of say ImmPredicate, immutable would just check if item is an instance of that, or some hidden attribute off the fn such as  .__useAsPredicate = true? 
 I think wrapping is better than modifying the passed arguments.
  I understand that this might be intended behavior or outside the scope of the library, but I found this frustrating, so I'm going to report it anyway; consider it a feature request.

As far as I can tell, Immutable considers all empty collections to be equal. For example, the following code returns `true`:

```
Immutable.is(Immutable.Map.empty(), Immutable.Vector.empty())
```

This makes it impossible, or at least error-prone, to represent JSON in Immutable objects. `{}` and `[]` are separate objects in JSON, but it seems like Immutable considers them identical. Is it possible to add a clear distinction between "array-like" and "object-like" sequences?
 The use case is actually fairly complex: I'm developing an interpreter for a programming language in which all data is immutable (except for ML-style mutable cells) and all data is representable as JSON. I've been trying to use Immutable as the backend, and I ran into this problem.

Arrays and objects are distinct datatypes in my language, but I can't find a good way to distinguish between them in Immutable. Sequences seem to lose their type information whenever modified copies are made, and, as I demonstrated above, even empty sequences have no type information.
 Constructor checking would work for the empty sequences, though not for populated ones. As far as type information: from what I've seen, doing `Map.set(foo, bar)` returns a `Seq`, though I haven't tested that in isolation to be sure. I can still check types of nonempty Sequences by checking if keys are strings or numbers; it's slow, but the implementation I'm writing is just a proof-of-concept, so it probably doesn't matter.

As far as the language: it's essentially JSON Lisp, with a Clojure-like focus on immutability. I made a modified YAML-like JSON syntax that it's intended to be written in, which can be found [here](https://github.com/ar-nelson/lcon). I don't have a repo up for the language interpreter itself yet.
 Looking at my code again, the cases where I saw that happening, it was probably being run through a reduction function like that, so you're right.
 I will, and thank you for addressing this. :)
  I would like a way to test if my React Property is an instance of an Immutable Cursor:

```
prop instanceof Cursor
```

However, since the library does not attach Cursor to the Immutable object there is a disconnect for me on how to do this.

I'd like to do something like the following:

```
Immutable = require('Immutable');

React.createClass({
  propTypes: {
    appState: React.PropTypes.instanceOf(Immutable.Cursor)
  },
  /*....*/
```

Can we expose the Cursor object in some way? Or is there another way around this?
 Thanks for the insight.

This works well:

```
  propTypes: {
    appState: function(value) {
      return value instanceof Immutable.Map;
    }
  }
```

But the following has an error: 

```
Warning: Invalid prop `appState` supplied to `<<anonymous>>`, expected instance of `Map`.

  propTypes: {
     appState: React.PropTypes.instanceOf(Immutable.Map)
  }
```
 Will do. Thanks.
  The .reduce function does not use the first value of the collection as the initial accumulator if no start value is supplied. This is the common case for Array.reduce, lodash.reduce, mori.reduce, etc.

Some sample code (tested with immutable 1.0.0 and mori 0.2.9):

```
var Immutable = require('immutable');
var mori = require('mori');

var plus = function (a, b) {
    return a + b;
};

function check(a) {
    var v = Immutable.fromJS(a);
    var r1 = v.reduce(plus);
    console.log("Immutable reduce: ", r1);
    var r1f = v.skip(1).reduce(plus, v.first());
    console.log("Immutable reduce fix ", r1f);
    var r2 = a.reduce(plus);
    console.log("Normal Array reduce: ", r2);
    var mv = mori.vector.apply(null, a);
    var mr = mori.reduce(plus, mv);
    console.log("Mori res: ", mr);
}

check([1, 2, 3, 4]);
check([1]);
```

Output

```
Immutable reduce:  NaN
Immutable reduce fix  10
Normal Array reduce:  10
Mori res:  10
Immutable reduce:  NaN
Immutable reduce fix  1
Normal Array reduce:  1
Mori res:  1
```
 null is a valid value. Your problem in the example is type coercion. `console.log(null + 1 + 2 + 3)` => 6. 
 You can look in the ECMAScript standard http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.21
  I've come across an issue when using Map.from and the Map constructor. The library uses `value.constructor === Object` to test whether to create a map from the object, which means you can only really pass it object literals.

For example:

```
Map({x: 3, y: 6}); // works

var point = Object.create(null);
point.x = 3;
point.y = 6;
Map(point); // incorrectly maps 0 to the point, rather than x and y to their values

function Point(x, y) {
     this.x = x;
     this.y = y;
}
Map(new Point(3, 6)); // also fails to map x and y to their values
```

This also causes problems if the library and the object are from different contexts (such as from an iframe), as the Object constructor is local to the context.

Perhaps the test could be changed to `typeof value === "object"`, to allow it to work in these cases?
 OK, I can understand that line of reasoning. The problem I was actually having was because the Object was from a different context, because I was using `vm.runInContext` in a node REPL implementation. It's a very very niche problem which I doubt will affect anybody else. I got around it by running the REPL code in the same context. Thanks for the response anyway.
  Hello,

I'm not sure if I've missed something in the documentation or in my experimenting with the library - but is it possible to join a sequence with the empty string? It looks like the implementation defaults to ',' when the argument is falsy, so no, but maybe I'm wrong?

Thanks!
M
  Any chance you will push releases to fb.me or other cdn? 
  Fix typo.
 The original is "the following performs no work". I'm not sure if "performs" should stay, but the "no work" seems like it should be "now work" (if you keep "performs"), or "now works" if you get rid of "performs".
 "performs no work" means "does not perform any work", here. See #48, #49.
  to match the Immutable.js implementation
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  fixed typo in documentation
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  ```
> var data = [{id:2},{id:3},{id:1}];
> var v = Immutable.fromJS(data);
> var comparator = function(prev, next) { 
  var b = next.get('id'); 
  var a = prev.get('id'); 
  return a > b ? 1 : a < b ? -1 : 0;
 }
> JSON.stringify(v.sort(comparator).toJS());
< "[{"id":1},{"id":2},{"id":3}]"
> JSON.stringify(v.cursor().sort(comparator).toJS());
< "{"0":{"id":2},"1":{"id":3},"2":{"id":1}}"
```
 Thanks!
  **Summary:**
When I am pushing to a vector and making sure it has a max size using slice, it eventually causes an error after a certain period of time.

**Environments:**
Browser, and Node.

**Error:**

```
TypeError: Cannot read property '0' of undefined
    at Q (/Users/mjaquish/test/node_modules/immutable/dist/Immutable.js:11:1716)
    at n.toVector (/Users/mjaquish/test/node_modules/immutable/dist/Immutable.js:21:30)
```

**Contrived Example that causes the same error as my code:**

``` JavaScript
var max = 20;
var len = 100;
var v1 = Immutable.Vector();

while (len) {
    console.log('len ' + len);

    v1 = v1.push(len);

    console.log('l1 ' + v1.length);

    if (v1.length > max) {
        v1 = v1.slice(v1.length - max).toVector();
        console.log('l2 ' + v1.length);
    }
    len--;
}
```
 Please note that this error never occurs when using `skip()` instead of `slice()`:

**Working contrived example:**

``` JavaScript
var max = 20;
var len = 100;
var v1 = Immutable.Vector();

while (len) {
    console.log('len ' + len);

    v1 = v1.push(len);

    console.log('l1 ' + v1.length);

    if (v1.length > max) {
        v1 = v1.skip(v1.length - max).toVector();
        console.log('l2 ' + v1.length);
    }
    len--;
}
```
 Running your example, for some reason `newRoot.array` becomes undefined after only 50 iterations at https://github.com/facebook/immutable-js/blob/1c07d99/dist/Immutable.js#L2296 
  `Immutable.fromJS({}).cursor().get()` returns `undefined`. Technically it should return back a `Map`
 I am getting this weird behavior when either `get` or `deref` method is available while the other isn't.
 > Technically it should return back a Map

Should it? I thought `.get()` requires a key argument, which is `undefined` in your case (so `Immutable.Map().set(undefined,1).cursor().get(undefined) === 1`).
  Hello,

I don't see any support for this very useful operation?
 :+1: 
 :+1:

@leebyron I think all the flatMap method would need to be is a lazy-operation-optimized sugar method for `.map(myFunc).flatten()` which is all flatMap is.

i.e. something like `lines.flatMap(x => x.split(/regexforparsingintotokens/g))` is what I'd use it for.
 @leebyron the main thing behind `flatMap` is Monad. `flatMap` or `bind` is common operation in functional languages (like Haskell, Scala). Immutable API should have it IMO.
 @Tvaroh why do you think it is needed since JavaScript doesn't really support monads and 

Edit: I hate this github app on my phone...

And promises interop wouldn't get supported in the flagMap implementation anyway
 I must have missed flatten(), where is it defined? 
 @AlexGalays I believe .concat performs flattening in some way... I wrote .flatten as pseudo-code assuming there was flatten or flatten-like behavior. I cannot confirm yet since I'm on my phone though.
 @L8D I'm not sure what you mean by "JavaScript doesn't really support monads". Any language can support this concept. Google for "Douglas Crockford Monads and Gonads".
 I'd also like to see flatMap implemented. Since I discovered it, I keep finding more and more uses for it.

Here is a quick monkey-patched implementation, although it isn't lazy:

```
(function () {
    function concatReducer(acc, val) {
        return acc.concat(val);
    }

    Immutable.Sequence.prototype.flatMap = function (mapper, thisArg) {
        return this
            .map(mapper, thisArg)
            .reduce(concatReducer, Immutable.Sequence());
    }
})();
```
 But it's not doesn't follow conventions found elsewhere: flatMap != map.flatten.

Look at this example:

``` coffeescript
a = (x) -> [x, x]
[[1,2,3], [4,5,6]].map(a) = [[[1,2,3],[1,2,3]], [[4,5,6],[4,5,6]]]

[[1,2,3], [4,5,6]].map(a).flatten() = [1,2,3,1,2,3,4,5,6,4,5,6]

[[1,2,3], [4,5,6]].flatMap(a) = [[1,2,3],[1,2,3],[4,5,6],[4,5,6]]
```

Which is very important difference.
 oh god. Now that I've discovered that .flatten() does nested flattening my heart is starting to crumble. I would really like this to be fixed.
 By looking at https://github.com/facebook/immutable-js/commit/0ce334238975aac17a2e9b87abd8525bf4a4f995#diff-78da5e9dc4304667bdc01c405e775348R864 it seems it's doesn't flatten nested collections, but the name `flatten` usually implies it does: http://rosettacode.org/wiki/Flatten_a_list (also [lo-dash](https://lodash.com/docs#flatten), [underscore.js](http://underscorejs.org/#flatten), [erlang](http://www.erlang.org/doc/man/lists.html#flatten-1), [ruby](http://www.ruby-doc.org/core-2.1.3/Array.html#method-i-flatten))
 I have no experience in Scala, but quick search shows that they are not the same too: http://stackoverflow.com/questions/20215518/scala-map-flatten-and-flatmap-not-equivalent . I expect `flatten` to return flat collection. To suit everyone's needs some implementations accept argument like level=1,2,3 in ruby or just shallow=true/false in underscore.js.

UPD: the example I posted above is what I expect, sorry, forgot to answer that question.
 Looks great for me, thanks!
 Looks good now :)
  Test case:

``` js
var i = Immutable.fromJS({a: [1], b: {}}); 
i.toJS() // Object {a: Array[1], b: Object}

var i = Immutable.fromJS({a: [1], b: {}}).cursor(); 
i.toJS() // Object {a: Object, b: Object}
```

Seems as though you'd want to have two different types, MapCursor and VectorCursor, so they preserve their own distinct methods - and from that you could just wrap most of the necessary methods (along the lines of my thoughts in the other ticket) such that they proxy to the `super` methods (Map / Vector) but just wrap the return value as a cursor where necessary.
 I'm also seeing this one.
 :+1: ran into this as well
 Alright, two immediate questions:

> Now only Immutable collections return a Cursor.

```
var data = Immutable.fromJS({ items: [1, 2, 3] });
```

Then `data.cursor('items')` is not a cursor, rather a Vector [1, 2, 3]?

> Also, Immutable.Map({x: 'X'}).cursor('x') now returns 'X' instead of a Cursor object

Why would you call `cursor()` and not get a cursor back?
 I'm most likely missing something, but if this is a breaking API change (which it looks like to me), shouldn't be this v3.0.0 if your'e following semver?
 I was thinking the exact same thing :cry: 
 Hi! It looks good that it now preserves the underlying type! :+1: But is it now no longer possible to make a cursor for a value? So I can't make a sub-cursor that points to a value and using this cursor to update that value?

``` js
> Immutable.fromJS({ a: [1, 2, 3] }).cursor(['a', 0]) === 1
true
```

and 

``` js
> Immutable.fromJS({ a: 1 }).cursor('a').update
undefined
```

This means, for instance, that we can't do proper top-down render in something like React, as we can't pass real cursors with certainty.

(edited: See example of what I mean here https://gist.github.com/mikaelbr/72571151ca0d96aff867 )
 @leebyron Thanks for your reply! Sure, I can circumvent the problem by either adding an additional level to my data or simply passing in a cursor of a higher level to a component or where ever, but then I'd have the choice of altering my data or having parts of code with more information than I'd want them to have. It seems to me that `.cursor` is gone and it is replaced with `.get` and `.getIn`, as `.cursor` is no longer a method that solely returns cursors, it is a `.maybeCursor` method. Previous API defined `.cursor` as a method which could always get a cursor, and `.get` and `.getIn` could get cursors or it could get scalars if it were scalars. This makes for getting values, but not if you actually need a cursor. 

Consider the following example: https://gist.github.com/mikaelbr/ce5632d8243688cb5bd7

Here I have a set of tags, and if I were to have a code that should only have access to a single tag I would have to have the overhead of having each tag in a map â€“ or I could let each code handling the tag know more than it's tag and rather all the tags and it's tag-id, making it no longer single responsibility.

I really think `.cursor` should always return a Cursor. By having a path I should be able to point to a specific place where a value (be it immutable collection or scalar) is stored in the data structure. A cursor is just that; a pointer to a value. In any case a really nice feature has been removed, especially with self-contained components with something like React.
 Brilliant. Thanks for making the revertion and a great library!
  In `src/Set.js#equals()`, `return this._map.equals(other._map);` should also check if `other === null`, or whatever the preferred style for this codebase is.

I don't have enough time right now to write a test or pull request myself, but I thought I'd send in the issue report anyway.
  Please use [semver](http://semver.org/).
1. When you have `"immutable": "^2.0.15"` in `package.json` (npm puts `^` by default with `install --save`).
2. When you run `npm install` on fresh project clone.
3. Then you will have `2.0.16` installed.
4. When you write some code using `keySeq`.
5. Then you will fail, because other co-workers most likely doesn't have `keySeq` because they have `2.0.15` and `2.0.15` doesn't have `keySeq`.
 :+1: thanks for great library!
  Hi,

This adds a manifest file which will enable the [bower package manager](http://bower.io/) to introspect the immutable-js repo.

Bower's the most common solution for the packaging of front-end assets, so adding the `bower.json` file will massively reduce the overhead on integrating immutable-js into front-end projects.

If you merge the commit, you will probably want to also register the repo with the bower library, via...

`bower register immutable git://github.com/facebook/immutable-js.git`

If you don't have `bower` installed, you can install it with `npm install -g bower`.

Registering the repo will allow users to run `bower install immutable` and have the project fetched in a style akin to npm's.

Cheers,
Mark.
  Exemple :

```
var data = [0, 1, 2, 3, 4];
var sequence = Immutable.Sequence(data).take(3);
sequence.first();
sequence.forEach(function (v) {
    console.log(v);
    return true;
});
```

Output :

```
0
1
```

Expected :

```
0
1
2
```
 But maybe take() returns some kinds of mutable structure. In this case, is it possible to have this information in the API doc ? Thanks.
  I am getting a very weird error when running in iOS (only on actual hardware, not the simulator). You can see [this example](http://codepen.io/conradz/pen/bKClx) for a test case. Basically after a certain number of sets/gets the `Map.get` function stops working entirely, even though `Map.toJS()` includes the correct data.

In Firefox, Chrome, IE, Safari on desktop, and the iOS simulator [this page](http://codepen.io/conradz/full/bKClx/) will display "done". On actual hardware (tested on iPhone and iPad Mini running iOS 7.1.2) it will display:

```
failed
at 25
'undefined' is not an object (evaluating 'doc.get('state').set')
done
```

This means that it failed on the 25th iteration, while succeeding on all previous iterations. It also seems that once it does this, `Map.get` will be broken forever after, until a page reload.
 Nicely spotted. 

Fails in MobileSafari on iOS 7.1.2, works in Chrome for iOS.  

Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53
 Yup, at least on a first gen iPad Mini.
 If it works for you on 7.1.2, it might be related to the architecture. iPhone 5s is 64-bit, my 4s and @conradz iPad are 32-bit. Either way, blunt-object-throwing is probably appropriate. 
 I was able to reproduce on iPad mini first gen iOS 7.1.2 and iPhone 5 iOS 7.1.2 (37 iteration)
 The iPhone that I tested it on is an iPhone 4, so it looks like it's only older models.
 Try Weinre?

-- Brandon

On Wed, Sep 3, 2014 at 2:43 PM, Lee Byron notifications@github.com wrote:

> TIL about the iOS JS debugger. If you hook it up to your laptop and open
> Safari's debugging tools, this error disappears. Going into debugger mode
> probably means your laptop's JSVM is running instead of iOS's. Heisenbug!
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/immutable-js/issues/92#issuecomment-54345785
> .
 The JS still runs on device when you're using the debugger.
 My guess is that the debugger forces the JS VM into the same mode as an embedded WebView in an app (since the problem also doesn't occur when running in Chrome for iOS or any other app that uses a WebView). Probably disabling some sort of JIT optimizations.
 Might be good to file on https://bugs.webkit.org as well if you haven't yet
 This sounds like it might be the same issue, or at least somewhat related: http://dev.clojure.org/jira/browse/CLJS-839
 Yes we encountered this as well, the MDN recommended Math.imul polyfill uses `N >>> 0` - this normally works fine but if the Math.imul polyfill code goes through Google Closure Advanced compilation ClojureScript hashing will break under the versions of Safari documented here. We worked around this by simply preambling the polyfill for Closure advanced builds.
  We're pretty excited to start using immutable in our next node-webkit app. By passing cursors all the way down and using the callback to notify of changes, we have a pretty good architecture in place to implement an undo feature. The withMutations API on Cursor allows a UI component to make a set of changes inside a cursor and only create one frame on the undo stack.

The functionality of cursor.withMutations was already achievable, but I feel that this makes for a more consistent API.

This commit also fixes some grammar and adds a test of Map.withMutations.
 I might have something to share in a few months.

The next step for us is to do some benchmarking to see how immutable-js behaves if I have an undo history in the hundreds as a result of small changes in an IndexedSequence of about 9000 Maps.
  Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  A map that inserts new items in the correct position, providing a custom sort function on the keys.

Would be nice. Otherwise, I can do fine with keeping a key array for the sorting, and a map myself.
 +100
 Just figured out I need this.

+1 from me.
 +1 indeed :shipit: 
 :+1: 
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
 Sorted map would be great! :+1: 
 Also, an `OrderedMap` can be implemented atop of a `SortedMap` without amortization.
 That would be so useful!
 Agreed. If I understand correctly `.sort()` creates a copy every time (even when called in `withMutations`). So if I want to insert sorted, I have to duplicate the `OrderedMap` twice. eg:

``` js
const map = OrdererMap({a: 'a', c: 'c'});
const sorted = map.set('b', 'b').sort(); // Creates two copies.
```
 For prior art on this issue, Clojure(script)'s sorted-map implementation uses a persistent red-black tree:
- Java: https://github.com/clojure/clojure/blob/010864f8ed828f8d261807b7345f1a539c5b20df/src/jvm/clojure/lang/PersistentTreeMap.java
- Clojure (used in Clojurescript): https://github.com/clojure/clojurescript/blob/609400910e983849e5b7932a4b7d0b0dda465df6/src/main/cljs/cljs/core.cljs#L7066

There's a JavaScript implementation of the same data structure [here](https://github.com/mikolalysenko/functional-red-black-tree) that might be useful, too.

Clojure's sorted-set uses the same data structure, slightly wrapped: https://github.com/clojure/clojure/blob/clojure-1.7.0/src/jvm/clojure/lang/PersistentTreeSet.java
 Have not used yet but this [SortedMap](https://github.com/frptools/collectable/tree/master/packages/sorted-map#collectablejs-immutable-sorted-map) seems promising. @akagomez Want to take a crack at RB Tree implementation? Tempting @crodriguez1a. 

I've done a bunch of work with Red-Black Binary Tree's for CanJS (https://github.com/canjs/can-binarytree), based on a fork of this repo: https://github.com/vadimg/js_bintrees

Leveraging that RB Tree implementation again should make this a less daunting task. 

If nobody disagrees with this approach I don't mind taking a crack at it with @crodriguez1a's help.  @akagomez feel free to steal from my toy SortedMap (api not fully implemented) that I started for a side project: https://github.com/rongierlach/immutable-sorted-map/

It is using a regular BST under the hood, am intending to convert it to RB later on. The long wait is over. Have a look at our immutable-js fork with highly optimized implementation of **SortedMap** and **SortedSet**. Current version is using classic B-trees. https://github.com/applitopia/immutable-sorted Darn, I was looking forward to playing with this myself. 

Maybe @crodriguez1a and I can help convert @applitopia's implementation to use RB-trees.   When you define a record type with `Immutable.Record`, you must use the `new` keyword to create an instance. This is inconsistent with the Constructor methods for other collections which work with or without the `new` keyword. For example:

``` javascript
Immutable.Map({test: 1}).toString()
// -> "Map { test: 1 }"
new Immutable.Map({test: 1}).toString()
// -> "Map { test: 1 }"
var MyRec = Immutable.Record({test: 1});
// -> undefined
MyRec({test: 2}).toString()
// -> TypeError: Cannot read property 'toString' of undefined
new MyRec({test: 2}).toString()
// -> "Record { test: 2 }"
```

This isn't that big of a deal (maybe there is a good reason) but I've taken to using the `Immutable.Map()` form and I keep trying to do the same with my record types which results in an error.
  Getting strange results when calling splice on a Vector with no arguments, thought you might be interested.

```
vec = Immutable.Vector(1, 2, 3)
// => Vector [ 1, 2, 3 ]
vec.splice()
// => Seq [ 1, 2, 3123 ]
vec.splice().length
// => NaN
```

Also:

```
vec.splice(null, 1)
// => Seq [ 1, 2, 3, 2, 3 ]
```

As reference:

```
arr = [1, 2, 3]
// [ 1, 2, 3 ]
arr.splice()
// []
arr
// => [ 1, 2, 3 ]
arr.splice(null, 1)
// => [ 1 ]
arr
// => [ 2, 3 ]
```
 Awesome work!
  For example, Vector inherits #slice from Sequence and Sequence#slice always returns a sequence. This means that you cant:

```
 var vec2 = vec1.slice(0, 4).push(3);
```

Instead you have to:

```
var vec2 = vec1.slice(0, 4).toVector().push('foo');
```

An idea is to wrap the methods in a method that calls #toX() automaticly.
 Duplicates #23?
 Yeah, you are probably right. Closing this.
 Then why does #push on a vector return a vector? 
 This leads me to another question: would it be more performant to use concat instead of push in a sequence of operations like the one mentioned in the OP? 
 Thanks for the great explanation!

I guess I just assumed the methods to return the same type of thing which lead to a "eh, what?" moment. but I understand the reason now.

In that case, as a user, I would probably like the set,delete,push,etc methods to return sequences as well. I believe that it would be better to always have to cast them than to only have to cast them some times, depending on the method used.

Great work, btw. I feel that this library was a missing link.
 In the end I guess that this is a speed versus usability thing.
  Hi!

I have a problem: I can't create `Set` of raw objects.

Example:

```
Immutable.Set(
    { title: 'rule the world', completed: false },
    { title: 'feed the cat', completed: false}
)
```

This code throws an error:

```
Unable to hash: [object Object]
```

Can `Set` be created only with primitive values or it's a bug?
 Is this behaviour described somewhere? And what about compatibility with [native `Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)?
  Cursor onChange handler should return wrapped results (and preserve original `onChange` handler):

Expected onChange behavior:

```
var data = Immutable.fromJS({ a: { b: { c: 1 } } });
var cursor = data.cursor(['a', 'b', 'c'], newCursor => {
  data = newCursor.deref();
});
```

With this change, the idea of a Root cursor from issue #72 is realized for my needs. 

Now in React I can setup my `onChange` handler once, easily implement undo, and have all sub views be cursors that I can transact against.

```
React.createClass(
  getDefaultProps: function() {
    return {
      data: Immutable.Vector()
    };
  },
  getInitialState: function() {
    return {
      undo: Immutable.Vector()
      data: this.props.data.cursor(this.onChange)
    };
  },
  onChange: function(newCursor, oldCursor) {
    return this.setState({
      undo: this.state.undo.push(oldCursor)
      data: newCursor
    });
  }
  ....
```
  Great work on adding Cursors support!  I've been using them in OM and am very happy to see them as part of this library.

Building on the expectations of `get()` and `getIn()` returning Cursors from issue #72

Performing sequence operations **(map/filter/reduce/forEach/etc)** on a cursor should also return a wrapped cursor. _(or at least the resulting keyPath within the calling cursor.)_

In React a common pattern is mapping over a Vector to create child views. If my Vector is a Cursor and I've setup a change listener on the Cursor I'd like to provide my childViews with wrapped objects so I can receive updates.

_Using the same data as Issue #72_

```
var data = Immutable.fromJS({
  users: [{
    name: 'Test',
    accounts: { /* deep nested data */ }
  }, {
    name: 'User',
    accounts: { /* deep nested data */ }
  }]
});
var c = data.cursor();
```

Expected map behavior:

```
c.get('users').map(function(user, index) {
   return user === c.getIn(['users', index]);
}).every(function(item) {
  return item === true;
});  // true
```

Expected filter behavior:

```
var foundUser = c.get('users').filter(function(user) {
  return user.get('name') === 'User';
}).first()

foundUser === c.getIn(['user', 1]) // these should be equivalent since I'm filtering a cursor
```

Without wrapped results on these operations the user is expected to know the keyPath, for actions like filter the keyPath is lost in the resulting filtered collection.
 Perfect!
 Agreed! That's part of what I was trying to get across with #72, I wasn't clear enough on that point I guess.
 Awesome! Thanks for the quick turnaround. This looks great.
 `props.data.map(subData => <MyComponent data={subData} />)`

Lee, as I know React doesn't accept Immutable structures yet. So you probably meant this:

`props.data.map(subData => <MyComponent data={subData} />).toArray()`

Am I right?
 I've been using `.toJS()` without issue:

`props.data.map(subData => <MyComponent data={subData} />).toJS()`
 Great, Lee. Thank you!
  I've been running tests on `Immutable.Map` using random data sets, and some of them are failing. For example this one does not seem to find key `'z{G_rZ\\#'` even though it is actually added:

```
var map = Immutable.Map();

var testKey1 = 'J;/b';
var testKey2 = 'z{G_rZ\\#';

var random_keys = [
    'yys',
    '8wZLz',
    '4B|{)\\Qw',
    '6cZp(3xX:',
    '3:,j:U',
    '2',
    'O.',
    'cOx_WU2PGG',
    '#9<',
    '3sO',
    '(hwq$Mt5',
    'EBY)qRh',
    '(yyNB',
    'Q[',
    'em@5Z',
    '}R:"!',
    '7]',
    'Y8]KiF',
    'q@oAb!q>K',
    ',kle4j',
    'Nl9',
    '$v4\\/p)',
    '8}jXn-;n}X',
    'Vc\'',
    testKey1,
    testKey2,
    'foo'
];

for ( var i = 0; i < random_keys.length; i++ ) {
    var key = random_keys[i];
    console.log('adding key', key);
    map = map.set(key, i);
}

// this is just for reference (correct output):
console.log(map.has(testKey1)); // true
console.log(map.get(testKey1)); // 24

// actual bug is here:
console.log(map.has(testKey2)); // false (!)
console.log(map.get(testKey2)); // undefined (!)

var testKey2ManualPath = map._root.nodes[3].entry[0];
var testKey2Equals = testKey2 === testKey2ManualPath;

console.log(testKey2ManualPath); // 'z{G_rZ\\#'
console.log(testKey2Equals);     // true
```

This maybe related to hash algorithm, because if I use `testKey2 = 'z_G_rZ\\#'` (changed the `{` character to `_`) then this works.
 I thought that it might be related to unusual ASCII characters in keys, but then I generated only alpha-numeric keys, and this one is also failing:

```
random_keys = [
    "06oZx4lu",
    "I2LN7",
    "Hg1xEasWr",
    "gFv3D21LC",
    "W",
    "eQIR78dx",
    "uVLtV",
    "RHuH6",
    "7f",
    "t2P0nRP5pD",
    "YOmT",
    "uXsb2ansMz",
    "rG",
    "M4Jm",
    "CNrffP",
    "p3GJ",
    "zVz5Ccwzkz",
    "3F1Dp1",
    "ba",
    "LATfR7ad",
    "L50mad07JS",
    "JIWCgW",
    "DRNu1"
];
// ...
console.log(map.has('DRNu1')); // false (!)
console.log(map.get('DRNu1')); // undefined (!)
```
 Yup, that was my guess as well.
 I've noticed that `idx = (hash >>> shift) & MASK` in array node is `7`, but `idx` passed to `expandNodes` is `3` (regarding the `'z{G_rZ\\#'` key).
  Consider this case:

``` javascript
a = imm.Map();
a = a.updateIn([], function (root) { return root.set("bar", "baz"); })
```

This is not a hypothetical for me... I've had a couple of places in my code where I've needed to check to see if the length of my path was 0 and then switch between doing `updateIn` and `set`, which is inconvenient.
 :+1: would be useful for consistency as currently I have to write code which handles the case with `[]` as `keyPath`.
 FWIW, I just wrote this utility function, but I'd rather not have to think about "when do I need to use this?"

``` javascript
    function updateOrSet(treeData, path, setterFunc) {
        if (path.length === 0) {
            return setterFunc(treeData);
        } else {
            return treeData.updateIn(path, setterFunc);
        }
    }
```
 @leebyron Nope, everything works fine, the bug was my in my code and wasn't related to immutable at all. Sorry for the noise.
 My immutable.js was less than two weeks old, but apparently that was too old :grin:

It is indeed fixed in the latest dist version. Thanks!
  I enjoy using immutable a lot and wanted to contribute.

I found the expression in Line 333 of the README.md to be unclear when reading the documentation, so I made the following change:

BEFORE:
There is a performance penalty paid every time you create a new immutable object via applying a mutation.

AFTER:
Applying a mutation to create a new immutable object will result in a performance penalty.

I also added a comma after "a series of mutations" on line 334.

Nothing else was changed besides above.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Done. I made the previous changes on GitHub, so I had to make a new commit to make the additional changes unfortunately. Sorry about that.
  (Sorry, accidentally hit enter while typing the title and it submitted)

If you create grab a cursor and then call `get(0)` it returns the dereferenced collection instead of the value at index/key 0 of the dereferenced collection. This is due to the check on this line in `Cursor.js`:

``` javascript
return optKey ? deref.get(optKey, optNotFoundValue) : deref;
```

optKey should be checked for being undefined or null instead of used directly in the condition.

Example of unexpected results:

``` javascript
var v = Immutable.Vector(1, 2, 3)
v.cursor().get(0)
// [undefined x 3]
v.cursor().get(1)
// 2
```
 I was playing in the Chrome developer console when I hit it.

> On Aug 21, 2014, at 4:28 PM, Lee Byron notifications@github.com wrote:
> 
> Also, just for my interest - what environment are you using? Node, Chrome, Firefox?
> 
> â€”
> Reply to this email directly or view it on GitHub.
  Seems like this should be reasonably easy to do recursively though I haven't thought through many cases.

```
> var map = immutable.Map({key: immutable.Set('x')})
> var map2 = map.mergeDeep({key: immutable.Set('x')})
> immutable.is(map, map2)
true
> map == map2
false  // good if this could be true
```

FWIW `map.key == map2.key` though.
 Hi @leebyron!

I'm still a little confused -- in this case the operation is a no-op so from an outside observer's perspective, nothing has been set/merged into the the target object. In fact, `map2` references the original Set.

Also for mergeDeep specifically, I imagine the changeset argument (and its nested objects) will nearly never be pointer-equal to the merge target. After all, the role of the changeset to specify potentially new values. So if pointer-equality is a requirement to return itself then I think mergeDeep won't be able to take advantage of this optimization very often in practice.
 > It's only when you're dealing with non-mergeable object pointers that you'll lose it. Set doesn't support deep merging currently (another to-do) - but if it did then this should behave as you expect.

OK. This makes sense.
 awesometown
  I have typescript code which compiles fine using:

```
///<reference path='./node_modules/immutable/dist/Immutable.d.ts'/>
import immutable = require('Immutable');
```

But when this code is run via node it fails and complains that it can't find module 'Immutable'.

The problem appears to be related to the use of upper and lowercase 'i' for immutable. If I put a symlink called 'Immutable' inside my node_modules directory and pointing to 'immutable', then my code starts up fine.

I'm using Linux and a case sensitive filesystem. This problem probably won't appear on case insensitive file systems.
 Thanks @leebyron 
  Saw that you've added cursors to the library and were looking for feedback. Very cool.

I've been working on an implementation of om-style cursors based on mori's data structures, using a custom build of mori which allows for extending [vanilla JS objects with cljs protocols](https://github.com/swannodette/mori/pull/108) (thanks to some great tips from @swannodette)

https://github.com/tgriesser/mori-cursors

One of the coolest things about the om-style cursor implementation IMO is the ability to treat them as basic persistent data structures, each time a value is returned (`get`, `get_in`, `assoc`/`dissoc`, any seqable functions, etc.), so long as the value isn't a primitive, you'll receive a new cursor of the appropriate type (`MapCursor` / `VectorCursor`) which continues to keep track of its path in the root object automatically.

As far as I can tell, in the current implementation, you need to explicitly call `cursor` to create sub-cursors, and even then, it's a bit limited in scope with regards to being able to modify the local value of the cursor. 

For example in the implementation I linked above, you could have something like (using immutable's api):

``` js
var data = Immutable.fromJS({
  users: [{
    name: 'Test',
    accounts: { /* deep nested data */ }
  }, {
    name: 'User',
    accounts: { /* deep nested data */ }
  }]
});
var c = data.cursor();
c.get('users') // would return a new VectorCursor, path ['users']
c.getIn(['users', 0]) // would return a new MapCursor, path ['users', 0]
c.getIn(['users', 0, 'name']) // would return 'Test', since name is a primitive

// Returns a new MapCursor, path ['users', 0], just without the 'accounts'
// map. This is useful in cases like React where you want to slice and dice into
// sub-cursors with a limited scope of data for efficient shouldComponentUpdate
c.getIn(['users', 0]).delete('accounts')
```

So the main idea is that the cursors should behave exactly like their respective data-structures from an API standpoint, only differing with the underlying "type" of the cursor, automatically keeping track of their path (which is hugely valuable).

Another main difference between this implementation and the one I mentioned above, is the idea of a "root" cursor, which sub-cursors are created from / updating against. There doesn't seem to be much value of just locating/updating values if they aren't coming from a central "root" object. In OM's case, I believe this is an atom, in the project I linked above it's just a special `RootCursor` which also acts an EventEmitter. My implementation is also pretty basic compared to OM's, nothing about deref'ing / taking into account render states.

Really cool to see that you're adding them to this project though, I've found them invaluable when using persistent data-structures with React, interested to see what you think about these ideas.
 +1

I played around a bit with this together with React in jsfiddle and I was not able to make a component update its own value without passing a callback function as a prop (which is what I was hoping to avoid in the first place). Maybe I'm doing it wrong, but it seems to be the effect of the issues that tgriesser pointed out.
 @nbostrom I've successfully been able to pass sub-cursors to deeply nested sub views and have a single onChange handler at the Root View pickup all changes atomically. Can you provide some code as to how you setup your code so we can provide more assistance.
 @jurassix Thanks, but I managed to get it working. I was totally on the wrong track before. You can ignore my previous comment.

Fiddle for reference: http://jsfiddle.net/459wLw5c/1/
 I'm just getting a chance to look through the cursor stuff a bit closer, a few questions:

Should the behavior should be to notify changes on cursor changes always, or to have them act like normal persistent data structures and only notify if you're explicit, as is OM's behavior. An example would be if you're going from the "root cursor" to a sub-section of that root cursor via `delete`:

``` js
var c = Immutable.fromJS({
   accounts: [1, 2, 3, 4, 5],
   users: [1, 2, 3, 4, 5],
   settings: ['a', 'b', 'c'],
   configured: true
}).cursor(=> console.log(arguments))
```

Now, in OM if I wanted just a sub-section of that cursor, I [should be able to](https://github.com/swannodette/om/blob/fd1d9a4ce97582b10b4b6738da06c9da1cff4e17/src/om/core.cljs#L414) do the equivalent of:

``` js
// (dissoc c 'accounts')
var newCursor = c.delete('accounts')
```

and nothing would be logged, because nothing has ultimately "changed", unless you call [`transact!`](https://github.com/swannodette/om/wiki/Cursors#making-changes-via-cursors) or [`update!`](https://github.com/swannodette/om/blob/fd1d9a4ce97582b10b4b6738da06c9da1cff4e17/src/om/core.cljs#L824)

Now I realize you could `deref` the cursor and set / delete values on the normal persistent data structure, but then you'd lose the behavior of that cursor and therefore the ability to update the `configured: true` primitive value later (in an event handler, etc).

Perhaps it would make sense to follow a similar path as OM and have some methods which exist on cursor:

``` js
cursor.transact([path], fn)
cursor.transact.set([path], value)
```

For example:

``` js
var newCursor = c.delete('users');
// no changes fired - keys for cursor are now:
// ['accounts', 'settings', 'configured']
```

Then later:

``` js
toggleConfigured: function() {
  newCursor.transact(['configured'], function(current) {
    return !current;
  });
}

// alternatively:
newCursor.transact.set('configured', false);
```

API could be polished a bit, but the idea is the it would `deref` the value at the (optional) path and act as an atomic unit of updating the root value of the cursor at that path, notifying as it does now with the returned value (unless notify is explicitly set to false):

``` js
cursor.trx.update([path], fn, [notify]);
cursor.trx.set([path], value, [notify]);
```

BTW, the cursors are looking great, just wanted to throw out more ideas based on my use of them.
 Oh, and since the `trx` based functions would essentially be updating / swapping out the underlying value of the root cursor - I'm not sure what the return value should be... perhaps the new root cursor? Or the new cursor value at the updated path?
 @tgriesser We use Immutable in our new iteration of form library for React and I think we came to the similar solution you just described.

We use our own cursor-like abstraction which is explicit about when to notify about changes (it is actually more than just cursor, it holds data schema and validates data on updates). The API looks like:

```
cursor.update(12).notify()
```

This allows us to make multiple value transformations and only then firing an `onUpdate` callback which is provided at the time of cursor construction.

The `onUpdate` callback receives an updated cursor (on which `notify()` was called), that allows us to know where exactly change happened (we didn't use this feature yet, but I think it could be handy in some cases).
 One other thing that just came to mind is that the construction of cursors might be better handled explicitly as a constructor rather than as a method. The ability to just do `map.cursor(...)` and `vector.cursor(...)` makes it seem like cursors are something you want to create quite often - when in reality you only want one, maybe a couple "root" cursors in your application - which are essentially what are formed when you call those methods.

Seems it'd be better if you had to manually construct them via:

```
Immutable.Cursor((map | vector), onUpdate)
```

@andreypopp nice, that does sound a bit like a customization of the transaction type feature I mentioned. Is any of your implementation available anywhere I can look?
  Really resolves https://github.com/facebook/immutable-js/issues/11 and removes these warnings:
`npm WARN engine immutable@2.0.11: wanted: {"node":"^0.8.0"} (current: {"node":"0.10.30","npm":"1.4.23"})`
  I have an immutable object which I am passing through as state `this.setState(getStateFromStore())`.
However it looses all its prototype functions related to `immutable.js` on trying to access the state.

It works fine when the state is set as:  `this.setState({data: getStateFromStore()})` which is kindof clunky and hackish.

This makes me wonder, what are the best practices on using `Immutable.js` data structures inside React views?
 Sorry to wake up an old issue, but it seems appropriate for my question. I'm using a Immutable.Map as my state object and calling `replaceState`. But since `replaceState` doesn't set the state synchronously (for good reasons), you can find yourself in a difficult spot if you do:

```
this.replaceState(this.state.set('x', 1));
this.replaceState(this.state.set('y', 2));
```

Because the first will get discarded, and the second call to `replaceState` doesn't contain the new value for `x` (since `this.state` hasn't been updated). This simple example can be solved by replacing the two calls with just one, but in a more complex example you might have one call to `replaceState` in a method in component A, and that method sends out an event. The event triggers something which comes back to an event handler in component A, which reads from a data store and calls `replaceState` again. If React doesn't update `this.state` between those calls, the first call to `replaceState` is ignored.

How would you solve this? Make sure that all events are synced with Reacts batching? Or always send out events in a callback that you pass to `replaceState`?
 Looks like this alternate method of setting state from @leebyron himself would help you out: https://github.com/facebook/react/pull/2991
 That looks great, definitely looks like the right way to do it.
 Check my ES6 React Flux webpack gulp om-like isomorphic immutable kÌ¶iÌ¶tÌ¶cÌ¶hÌ¶eÌ¶nÌ¶sÌ¶iÌ¶nÌ¶kÌ¶ tÌ¶wÌ¶eÌ¶eÌ¶tÌ¶yÌ¶bÌ¶iÌ¶rÌ¶dÌ¶sÌ¶ TodoMVC example. https://github.com/steida/este-todomvc
 Any plans on letting you override the merge strategy for setState so you can use an immutable record as state instead of in a property on a regular object? 
  When working in node, you'll typically want to have the unminified source for cases where you might want to inspect / step-through the code with a debugger. Similarly, when referencing the module client-side working with webpack, browserify, or similar the common practice is to provide the unminified build as there will be a separate step to optimize/minify the entire build.
 > The primary reasons to keep it small is an improvement on load and parse time and to provide a decent default behavior if browserify does not sent its results through a minifier.

Generally anyone who is going to be using this library not through a script tag (I'm guessing the majority of people using this library) are going to have build steps for their scripts. Unlike React, you don't even need to set environment variables to cleanup dead code, all that should be needed is a pass through uglify and you're good. Or you could swap out the module path at build time to use the main script rather than the dev...

I've been using this a bit lately just to kick the tires on it a bit, and each time I've been manually going in  and switching the "main" in package.json because I like to be able to step through the code and look around, the common practice is to have a source.js and source.min.js... not the other way around.
  Hi,

I'm not sure it's the right place to ask/tell but I've tried to use `orderedMap.values()` but the result does not seem to have a `done` property nor `next()` method. Is it a bug or am I just misusing it?

Thanks.
 Sorry, I've tried the latest one, 2.0.16
 is there any way to create a lazy Sequence directly from an ES6 generator?
 Should the typings of `Iterable<K, V>` be updated to include the method?

``` typescript
[Symbol.iterator](): Iterator<T>;
```

I'm not sure this is the right way for 2 reasons:
- The Symbol symbol is declared only for TypeScript ES6 target - for backwards compatibility, should SymbolConstructor and Symbol be defined in immutable.d.ts also?
- From source it seems KeyedIterable returns entries() instead of values(), so the type of it is different. Maybe it's enough to override the iterable method in Iterable.Keyed to return the appropriate type instead.
 > From source it seems KeyedIterable returns entries() instead of values()

You hit the nail on the head here. This is the real issue with making the base class iterable. Consider the following function:

```
function f(iter: Iterable<A,B>): Array<?> {
  out = [];
  for (let x of iter) {
    out.push(x);
  }
  return out;
}
```

What type belongs in `?`? If I pass a `KeyedIterable`, it would be `[K,V]`, if I pass anything else, it would be `V`.
 It seems then that `Immutable.Iterable` itself should not be `Iterable` in the ES6 sense (as defined in lib.core.es6.d.ts), because its type is ill-defined. Instead, `Iterable.Indexed` and `Iterable.Keyed` should be ES6-iterable. It's bit of a pain because the Iterable methods like `map` aren't typed as returning `this`, but it would still be better than nothing.
  Hi, I'm using immutable-js for all data structures in a project of mine and am enjoying it very much. The only thing that bothers me is that I lose type safety / information when using Maps as a replacement for JS objects.

Say I use a Map to store information about a Person (like name and age). Is there some way to make it a real Person object and not a Map, so my code can say `instanceof Person`, and maybe even call custom methods on it?

Or is there another way to get some level of type safety when using Maps?
 Wow! :-)
  **Use case:**
Create a subset of a Vector based on max vector length constraint.

**Observation:**
Using different techniques results in different objects. For example, using `vector.shift()` returns a Vector with the first item removed. Using `vector.slice(1, vector.length).toVector()` returns a Vector with the same values, but comparing the two resulting vectors for equality results in `false`.

Is the following the expected behavior even though the values for v2 and v3 came from the same v1 vector?

``` javascript
var v1 = Immutable.Vector(1, 2, 3, 4)
// Vector [ 1, 2, 3, 4 ]

var v2 = v1.shift()
// Vector [ 2, 3, 4 ]

var v3 = v1.slice(1, v1.length).toVector()
// Vector [ 2, 3, 4 ]

v2 === v3
// false
```
 Thank you for the info. Would using `withMutations` and multiple vector-specific operations retain the equality? Also, would the performance be better or worse in that case (compared to using `vector.slice().toVector()`).
 Yes, that makes complete sense. I'm not sure why I was expecting them to be the same. I appreciate your thoughtful response.
  Consider following example

```
function twice(l) {
  var a = Immutable.Range(0, l).toVector();
  return a.unshift.apply(a, a.toArray());
}
```

Now, try to call

```
> twice(12).toArray()
< [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
```

Nice, works as expected.

What about

```
> twice(32).toArray()
< [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
```

Still good.

And now hold the breath:

```
> twice(33).toArray()
< [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, undefined Ã— 32, 32]
```

**Not so cool anymore!**

Look at the lines in `Vector.js` at `_setBounds`:

```
while (newOrigin + offsetShift < 0) {
  // TODO: why only ever shifting over by 1?
  newRoot = new VNode(newRoot.array.length ? [,newRoot] : [], owner);
  offsetShift += 1 << newLevel;
  newLevel += SHIFT;
}
```

You already have the TODO explaining where the problem lies :-)
 @leebyron Actually I am code reviewing your whole codebase and this and yesterday bug reports are results not of having failing code in the first place, but of reading your source and then trying to create conditions that will lead to bug:-)

So, I am pretty sure that the lines above are not correct.
 @leebyron Thanks, I will do later. Currently I am trying to understand the codebase.
  I have noticed that when key with different hash is set to  `HashCollisionNode` new `BitmapIndexedNode` is being created with wrong hashValue for `HashCollisionNode` (hash value of new key is used instead of `collisionHash`).

This piece of code leads to "_Maximum call stack size exceeded_"

``` javascript
var map = Immutable.Map();
map = map.set('@', '')
map = map.set(64, '')
map = map.set(96, '')
```

The bug can be found here: [src/Map.js#L324-325](https://github.com/facebook/immutable-js/blob/95fdfa49b224dac7cc505f8063d6c891a67d7ed7/src/Map.js#L324-325)
  Using `UnorderedMap` for longer time can consume lots of memory.

For example this code: 

``` javascript
var map = Immutable.OrderedMap({'b': 'b'});
for(i = 0; i < operations; i++) {
    map = map.set('a', 'a');
    map = map.delete('a');
}
```

leads to this memory consumption :

| operations | Memory (kb) |
| --- | --- |
| 1000 | 16000 |
| 10000 | 19000 |
| 100000 | 23000 |
| 1000000 | 58000 |
| 10000000 | 160000 |

It is because indexes are created sequentially and calling `Vector.delete(index)` does not free any memory. 

The element `b` is there to ensure that UnorderedMap does not become empty and remove `Vector`.
 I was using Node.
And yes, I found this king of leak only in OrderedMap. 
    I'm trying to use this package in an ES6 package which uses traceur for compilation.
It seems that the `npm` dist of this package includes it's own traceur runtime. It doesn't seem up to date with the latest traceur and is causing issues, can you at least check if traceurRuntime exists before defining your own? Happy to make a simple PR that does that if that's OK.
 Curious â€“ why'd you switch away from jstransform?
  I have noticed the following line of code in method `VNode.removeBefore`

```
if (index === 1 << level || this.array.length === 0) {
  return this;
}
```

For simplicity reasons, assume `level` is 0. In such a case we are dealing with pretty flat array of (max) length 32 containing only leafs. In such a case, calling removeBefore with index = 1 should remove the element with index 0.

However, in this case, it does nothing. Am I missing something?

Also, I have noticed that running 

```
var a  = Immutable.Vector(1, 2, 3); 
var b = a.pop();
var c = b.pop();
```

Leads to strange fact that `a._tail.array.length == 3` but both `b` and `c` tails are same and their length is `2`. This happens only for lengths of tail == 2, it seems weird. Should it behave like this?
   Thought you might have different plans, since it was sitting there and you are quick at moving on items I've submitted thus far (e.g. you'd just do it over yourself knowing the lib intimately). You are, obviously, more than welcome to accept. It won't hurt my feelings if you don't though.
   Nice, better than the if statement :+1: 
  Hello and thank your for the work here. It works like a charm with React and Flux :)

While the documentation is complete, it kinda lacks real life examples, and since I'm new to the immutable world, I have a hard time figuring out which structure I should pick in which case.

I'm not sure it's a good thing I open a new issue each time I struggle with something (that is going to happen) so maybe I could ask them all here and then bundle your answers in a PR so it can help other newbies.

I think my main use case (and many real life use cases) is: I get JSON from the server, it looks like:

``` json

[
  {
    "id": "aze12",
    "someField": "someValue",
    ....
  },
  {
    "id": "67azea",
    "someField": "someValue",
    ....
  }
]
```

I think the natural way of storing with Immutable is using OrderedMap. But what is the best way of building the map with "id" or "someField" as the index?
Currently I create an empty OrderedMap, then iterate over my parsed data, and set them one by one within a `withMutations`. It doesn't feel intuitive, what do you think?

Thank you in advance.
 Thank you for that very details explanations, that is exactly what I was looking for. I'm glad I figured the best option by myself, but I'm very happy to now fully understand why it's the best option. Thank you very much!

One more note about the doc: if we could turn the .d.ts file into an easily browsable website, that'd be great. A ToC would definitely help to see the big picture (available structures, what they are for, what's their properties / methods). A good example of what I mean is backbone website (http://backbonejs.org/).

Cheers!
 That's great, thanks! 

edit: comment in .d.ts file is incorrect though, your copy/paste was too quick ;) (https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts#L426)
 In https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts#L428 you use .map instead of mapKeys, or am I wrong?
 I should have submitted you a PR for that but I'm tired too. Going to bed :) Thank you, I'm going to make a good use of that!
 I'd like to point out (for people that might go through this issue later on) that in your example:

```
Imm.Sequence(data).mapKeys((_, v) => v.id).map(v => Imm.Map(v)).toOrderedMap();
```

`.map` may be useless (based on my test)

```
Imm.Sequence(data).mapKeys((_, v) => v.id).toOrderedMap();
```

Gives me the same result in the end.
 Aaaaah right, got too quick with my .toJS() tests! Thanks.
 This thread was very helpful :+1: 

I adjusted code to use it as reviver, so it automatically detects arrays with objects having id property:

```
var imm = Imm.fromJS(dummyData, function (key, value) {
    var isIndexed = Imm.Iterable.isIndexed(value);
    if (isIndexed) {
        if (value.getIn([0,'id'], null) !== null) {
            return value.toKeyedSeq().mapKeys((_, v) => v.get('id')).toOrderedMap()
        }
        else {
            return value.toList();
        }
   }
    else {
        return value.toMap();
    }
});
```

Its pretty hard see what exactly is going on behind the scene. So if there is better way to do that, please let me know, so I don't waste performance :-).

Thanks!
 @leebyron how the original requirement can be done now. Your one liner, `Imm.Sequence(data).mapKeys((_, v) => v.id).map(v => Imm.Map(v)).toOrderedMap();`, not work now due to api change. I don't see any reference of `mapKeys` in public api, is it supported? Also, `Sequence -> Iterable` ?
 It still exists, but is now part of KeyedIterable: https://facebook.github.io/immutable-js/docs/#/KeyedIterable/mapKeys

That means Map and OrderedMap have it, and maybe others, I don't know the inheritance graph well enough.

Examples are wrong though since they use Seq and not Seq.Keyed (if I understand correctly how it works, correct me if I'm wrong).
 Apologies. I did a ctrl +F and didn't find. Anyway, this what I tried, `Imm.Iterable(data).mapKeys((_, v) => v.id).map(v => Imm.Map(v)).toOrderedMap();`, just changing `Sequence -> Iterable` as per the API upgrade doc. it gave error Iterable doesn't have mapKeys. so,  what is the most efficient way to do what you asked in the functional style? thanks gain for quick response.
 You could try `Imm.KeyedIterable(data).mapKeys((_, v) => v.id).map(v => Imm.Map(v)).toOrderedMap()`
You forgot the "Keyed" of "KeyedIterable".
 thanks. it worked great. the doc says `Note that OrderedMap are more expensive than non-ordered Map and may consume more memory.`. Do you know any numbers on this, and when should I worry using OrderedMap, and consider Map?
 I will let @leebyron answer that since it goes beyond my knowledge. I'm quite interested in the answer too. Also, how does an OrderedMap perform vs a List with a Map kept in sync (where the List maintains the order, and the Map is for quick access by key)?
 Indeed, I was using the same pattern of keeping a separate index prior to the use of immutable.js.
 sorry, my changes didn't reflect, `Imm.**Keyed**Iterable(data).mapKeys((_, v) => v.id).map(v => Imm.Map(v)).toOrderedMap()` didn't really work. probably because KeyedIterable expects a `iterable-likes of [K, V] tuples if not constructed from a KeyedIterable or JS Object.`. so can't use it with a javascript array of input.

the error was `Uncaught TypeError: _immutable2.default.KeyedIterable is not a function`, I am still looking at it. but looks like `KeyedIterable` itself not found!. I use v 3.7.3. 
 Maybe you could create `Imm.OrderedMap` directly. I think, when built from a JS object, it uses "0", "1", ... as index. So you can `mapKeys` afterwards.
 ![screen shot 2015-05-25 at 8 38 34 am](https://cloud.githubusercontent.com/assets/1966521/7797410/a6c1e51e-02b9-11e5-865d-53e23f7d1765.png)

:-) not sure why KeyedIterable not found!
 Resurrecting: isn't something like this more readable and faster:

`Immutable.OrderedMap(data.map(o => [o.id, Immutable.Map(o)]))`

http://jsperf.com/immutable-ordered-map-construction
  Certainly open to any feedback, particularly around if there are more performant ways to do the init/tail methods. I need more time to really dig in and digest the nitty-gritty of how things are implemented in the library. Currently, I have a only have a cursory level of knowledge on said library algorithms/implementations.
 Yep, I sure can (on all accounts).
  Much like first and last on Vector, those of us from other list oriented FP languages might enjoy said convenience methods. :)
 Sounds great here, simply borrowed from Haskell selfishly. I like how you approach naming in the library, if there is a JavaScript equivalent then use it, otherwise look to Clojure for inspiration (huge fan of it and Rich).
  Unless I missed it, it would be great to be able to construct Maps via sequences that contain pairs/2-element tuples adhering to the type signature of the Map to be created.
 Sweet, I did miss it! Thanks :)
  var nested = Immutable.fromJS({a:{b:{c:[3,4,5]}}});
Assume i am having above nested map...so i want  to delete key(c) and its values also..
To update value we have updateIn() method,
like that , is there any method to delete ?
How to do that ? could you please help me 
  I would like to use immutable-js as diff for app state in the same manner as React diffs DOM state. Is this even posible? Can you direct me to the proper/better approach? I would like to store app state diff into localStorage and sync with server. Thank you for the awesome library.
 I think the question is more "can I get and store the diff itself so I can store it locally and sync it with a server". I guess it aims at making an web app available offline while handling synchronization easily.

I.E :

```
vector1 = vector with value a, b
vector2 = vector1.push c
{json formatted} = Immutable.diff vector1, vector2
```

Where diff returns the smallest set of operations to perform to go from vector1 to vector2 in a machine-readable way.
 @steida hi

Have you been successful with json patch?
I'm looking at how json state transitions can be recorded.
This is related to a video I just published: https://www.youtube.com/watch?v=zxN8FYYBcrI
 I've been using: https://github.com/intelie/immutable-js-diff e https://github.com/intelie/immutable-js-patch
 thanks @pedroteixeira I didn't know about these projects
 Another lib for immutable.js diffs: https://github.com/elierotenberg/remutable â€” it's more polished, but currently supports only Map.
 @slorber, you can try [transit-js](https://github.com/cognitect/transit-js). I used it to serialize the history of application state for next transfering over the wire. You can add a cache on top of this library to serialize  immutable data structures efficiently. David Nolan wrote a post about this feature of transit - [Transit-js Caching](http://swannodette.github.io/2015/02/19/transit-js-caching/).
 It's been over a year. Any new resources for this? I have a similar need.
 @granmoe FWIW, I'm using https://github.com/intelie/immutable-js-diff and it works really nicely.
  Sequence zip and zipwithindex a la something like Scala would be delightful: http://www.scala-lang.org/api/2.11.2/#scala.collection.Seq

Have a couple deadlines here, but I'd be happy to knock this out after if no one has gotten to it yet.
 Sweet, I can't speak for anyone else but this one could get me off lazy.js completely. Looking forward to it.
 mori has a neat syntax for this: `mori.map(f, coll0, coll1, ...)` and f is called with arguments from corresponding collections. Though I'd prefer having function as a last parameter, it would be easier to type in CoffeScript `Immutable.map xs, ys, (x, y) -> x + y`
 As a TypeScript user, I am hoping for an interface that would make it simple to zip sequences containing different types and safely destructure the resulting sequence in a type safe way (without any). I think that calls for a specific Tuple type, supporting fst/snd.
 I'm not sure if this implementation would be useful, but it is very general and admits a useful typing. The idea is that a tuple is generally processed into something else at some point, so we don't need to store the tuple as a data structure, just connect the zipping function with the processing function.

``` typescript
function zip<A,B,C>(as:A[], bs:B[], tuple:(a:A, b:B) => C): C[] {
    return as.map((a, i) => tuple(a, bs[i]));
}
```

I imagine the list types presented here would be replaced with immutable sequence types if included in this library. Ignore the part where I didn't attempt to handle edge cases like different lengths.

EDIT: I originally had a more complex version of `zip` that returned a function. The current version, which accepts a function as its third argument, plays a lot nicer with TypeScript's type inference.
 I think just providing zipWith may be sufficient. However, something like zipMap (but with a better name maybe because I think zipMap is taken) could possible accomplish both. If you return a value from the function, it allows you to easily decide how to compose the resultant collection (thus punting the issue). Alternatively, you could just do your work there and then not bother with the resulting list (using it like forEach). Maybe if no function is provided the default is to return it as a tuple-esque thing:

a.zipMap(b, function(x,y) { console.log(x + " with " + y }); // used imperatively (returns an array of undefineds)
a.zipMap(b, function(x,y) { return x + y }) // kind of like zip, only more refined since I get to control the result type (returns an array of the sums)
a.zipMap(b) // defaults to [(x,y) ... ]
 General +1 on this feature, I can't wait to see the `zip` function make it to the library! :)
 Any progress on this?
      I have signed CLA.
 Sorry, re-reading the sentence I realize I am an idiot ;)
  @leebyron dose it means we could have a `hash()` method on any Immutable data like in `mori` ?
And it should speedup equality check also, right ?
  var vect1 = Immutable.Vector(1, 2, 3, 4, 5);

now i want to retrive one by one value from the vector...
so i did : 

vect1.map(function (value) {

});

its not even enter into the inside function....how to get values from vector ...could you please suggest me
 please reply me any one its important to me...please thank you
 var vect1 = Immutable.Vector(1, 2, 3, 4, 5);

from this vector i want to get one by one value by loop...how to do that ?...thank you
 did you got my question leebyron ?
 thank you
  What browsers are you targeting with this library?

One big usage of keywords I saw was `delete`, which won't work in IE8 (not my favorite either...). I have experimented with renaming every instance of `delete` to `remove` and it seems to work fine (though, accessing as a prop would probably work just as well).

Edit: I'm kind of erroneously assuming polyfilling missing things like in React is fine, but may not be fine with people

Edit2: I have implemented this fix in c52b58d. Let me know what you think.
 I was building it in as a CommonJS module. I'll have to test the distribution build.

I'm already using the polyfills on the [React pages](http://facebook.github.io/react/docs/working-with-the-browser.html#polyfills-needed-to-support-older-browsers) and I think a lot of people are using these shims, so I'll be testing my own IE8 usage with this.
 Tested just now on IE8 using a karma setup, IE8 will freak out about a unexpected identifier on Immutable.js somewhere around [here](https://github.com/facebook/immutable-js/blob/master/dist/Immutable.js#L16).

Edit: the `.delete` method calls aren't being converted to safe `['delete']` calls in the build. see: [horrible diff screenshot](http://i.imgur.com/0ybT1m2.png) (left is [`master`](https://github.com/facebook/immutable-js/blob/master/dist/Immutable.js#L16), right is [`IE8-friendly-delete-calls`](https://github.com/kimagure/immutable-js/blob/IE8-friendly-delete-calls/dist/Immutable.js#L16))

Edit2: my test repo, if you want to reproduce/test: https://github.com/kimagure/immutable-js-test

Edit3: maybe this is an Uglify bug, but I feel like something like this should've already been tested for in some way...
 cool, thanks. :thumbsup: 
  Hai all,

Iam having a map like :  var map = Immutable.Map({a:1, b:{d:2}, c:3});

now i want to update value of 'd'...and i tried the following : 
1. map.set(['b','d']),1000)
2.map = map.updateIn(['b', 'd'], function(value) { return 1000; });// i know it is for nested map...

and not able to update ...so could you please suggest me how to update that value 
 and tried like this also :   map.set(['b','d'], function(value) { return 1000; })
  Assume iam having the follwing Map : 

var map = Immutable.fromJS({a:1, b:{d:2}, c:3})

Now i want to update the value of 'd' to 100....so that i tried like this :  

1 .map = map.updateIn(['b','d'], 1000).
2. map = map.updateIn(['b','d'], value => 1000) // giving unexpected token >
3. map = map.updateIn(['b'], map => map.set['d',1000]) // giving unexpected token >

but not able to update the value..

could you please suggest me
 Arrow functions like `value => 1000` are a ES6 or TypeScript feature. If you're using regular JS you should write the function out in its full form instead:

```
map = map.updateIn(['b', 'd'], function(value) { return 1000; });
```
 thank you spicyj
 Hi all 

Assume iam having a Map like :  var map = Immutable.Map({a:1, b:{d:2}, c:3});

now i want to update 'd' value.....

how to update that ?
 Earlier i want to update value inside nested map...but this time i want to update the value inside map only...could you suggest me ?
 Earlier inside 'b'  i have Map,but this time i have object....could you please suggest me 
  I spent the morning trying to add basic Om-style cursor support to the Map, OrderedMap and Vector types. I don't know if this is something that is wanted/needed, but I thought it would be a neat feature.

Read the commit message for d8f408e for info on how it is implemented â€“ I have no idea if I'm going about this the right way so be warned.

(No tests or docs yet â€“ I wanted to see if this is even viable first.)
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Right! When using immutable data structures with a component based view library (such as React), sub components should only be given the data that is relevant to them, but still be able to trigger updates up in the tree without too much hassle. When creating a cursor you create a small "window onto a part of your data structure that can be passed into a component, and that when changed will trigger a callback where the cursor was created. The sub component then does not need to know anything about where it is in the hierarchy, and you don't have to pass around a bunch of callback functions for passing updates back up the tree.

I've written a code sample at this gist: https://gist.github.com/arnemart/c26aeddcb7d719b45529

Hope this makes sense to you. For a deeper explanation of cursors and how they work in Om, read this: https://github.com/swannodette/om/wiki/Cursors

Edit: Also I think the overhead should be minimal, we're talking a single function call and a conditional per mutation in the base case. This could probably be optimized further.
 Yes, that would maybe be a better solution. I am not quite sure how that could be solved technically without the observability I included in this pull request though. Let me think about it a bit more.
 @arnemart I have implemented something similar to cursors called [Binding](https://github.com/Tvaroh/moreartyjs/blob/master/src/Binding.js). And I'm pretty sure it should be out of data structures library by itself.
 I realized that I actually agree, so I wrote this wrapper library that adds cursor support to Immutable. https://github.com/arnemart/immutable-with-cursors
 Hey, thanks for listening to my suggestion and adding cursors! This is awesome.
  Browsers (Chrome, Safari and Firefox) don't pretty print immutable objects when logging them.

For example:

``` javascript
console.log(Immutable.Vector(1, 2, 3, 4, 5));
// => [undefined x 5]
```

I imagine this may prove rather inconvenient as a structure becomes more complex.

Writing a custom logger function like this fixes my issue:

``` javascript
function myLogger() {
  var strings = Array.prototype.slice.call(arguments).map(function (a) { 
    return a.toString();
  });
  console.log.apply(console, strings);
}

myLogger(Immutable.Vector(1, 2, 3, 4, 5));
// => Vector [ 1, 2, 3, 4, 5 ]
```
  I've been playing with the library and missed a functional API instead of a class based method one. To play with it i've made a little wrapper around the library that just adds the static methods to the classes making the last param the object on which the method will be invoked on.

[npm - immutable-fns](https://www.npmjs.org/package/immutable-fns)

That way we can do things like:

``` javascript
// On the immutable-js api
Immutable.Map({}).get('key')
// Added on this library
Immutable.Map.get('key', map)
```

``` javascript
var Immutable = require('immutable-fns');
var get = Immutable.Map.get;

// Create an immutable data structure
var m = Immutable.Map({a: 1});

// We can use the traditional api (obj.method(param)) or use the functional API
// (fn(...params, obj))
assert.equal(m.get('a'), get('a', m));
```

This kind of API is really useful sometimes, and doesn't conflict with the current API (that I have seen). This wrapper may serve to evaluate if this is worth pursuing on the library itself, and it does its job for the moment.

Thanks for your work on the immutable data structures, really hope to see them take off in js-land.
 :+1:
 One approach is that `immutable` contains a bag of functions that are partial-right applied with the respective collection for the method-case. In this way the methods are there but completely optional. This also provides the natural starting point for `immutable` functions anyways. Methods of `immutable` are just partially applied functions:

``` js
mySeq.map = partialRight(map, mySeq)
// or say using using a library like purry https://github.com/jasonkuhrt/purry
mySeq.map = map(___, mySeq)
```

I am planning to begin exploring using `immutable` to be the basis for a library that looks like this, wrapping all functions with `purry` so that they have omnipresent built-in syntax-like currying and partial application support.
 It's probably best to create this as a wrapper library rather than duplicating the entire API inside this module.
 @pluma I don't exactly understand your resistance. The api is arguably simpler as a flat list of functions achieving composability through clear `compose`, `pipe`, `partial`, `curry`, etc. functions. 

Methods are a great way to produce the native JavaScript feel and work around the verboseness of the language (e.g. there are no compose `. / <*> / <$>` infix functions like in Haskell etc.) and I am 100% not against them for these obvious reasons.

Still, I'd be interested to see the API exposed in a pure format that internally produces methods by way of conceptually simple and elegant partial application.
 @leebyron That's totally cool and understandable because of the clear mission statement. Also, to really make it work via e.g. currying would A) be a strange API for vanilla JS users and B) have at least _some_ performance overhead which is a bad combo given A. So yeah, a separate higher-level library on top probably makes more sense.

Question though; I haven't fully baked this thought so maybe its obvious but, is there any technical reason why they have to be methods? I guess what would have to/does happen is that point-free functions would know about the types in `immutable` and how to work with their internal APIs correct?

Further, I wonder how something like bare `map` could be used to work with any complex type like e.g. Monads such as `Maybe`. In Haskell we use its class system for this wherein `Maybe` is taught how to support the methods needed by `map` or in other words we make Monads be Functors etc.

Anyways, now I am definitely beyond the scope of `immutable` : ). `immutable` should remain a rock solid and minimal foundation for all such things.
 @leebyron Thanks for your thoughts and all your work on `immutable`; its got me genuinely excited to build all my upcoming work on it!
 I'd love to see a functional API for immutable js!
 Any progress on this?
 Well this is an interesting option...

https://github.com/paldepind/functionize
 I'd love this. If there any current solution to a more functional API? I miss `pipe` and `compose` so much. 
Would definetly be up to contribute to a project tackling this.  I'm attempting to use vectors to represent the contents of 5-line tiles in Atom, and I'm keeping the groups of lines up to date with repeated applications of `splice`. After not very long, however, performance of iteration seems to degrade. Is this a known issue?

![screenshot 2014-08-05 12 39 59](https://cloud.githubusercontent.com/assets/1789/3816600/0a64fad2-1cd0-11e4-80e7-fc10ec0df5e9.png)
 For now I'm just building a new vector as they're quite small.

Is this inefficiency inherent in the nature of the trie data structure you're using or something implementation-specific? Do the ClojureScript data structures exhibit this issue?
 Yeah, great point. I'll just replace the entire `Vector` for now because it has so few elements. Thanks for your thoughts. Feel free to close this unless you'd like to look into improving `splice` so far as it's possible.
 FWIW efficient splice (and other ops) is supported if you implement RRB-Trees - a variant of bitmapped vector tries (i.e. Vectors) http://infoscience.epfl.ch/record/169879/files/RMTrees.pdf
 BTW, that official paper on RRB trees is lacking many details. I would recommend to look at this [thesis](http://hypirion.com/musings/thesis).
 @hypirion (author of the thesis above): didn't you say you found RRB-trees slower in practice (like, by a constant factor) than the Clojure-style vector for some operations?

I bring this up because if so, that may be an argument for presenting RRB-trees as an alternative implementation rather than replacing the current one.
 There is a lot of additional code required for the RRB-tree cases, but it's designed to switch over to the persistent vector code whenever possible: RRB-tree code can generally detect when the substructure of a node is persistent vector-ish, and will jump to pvec performance at that point in the tree. I did some benchmarks on that, and found no notable performance difference if no slices/concatenations were done on the RRB-tree.

That being said, those were implemented with a lot of twiddling in C with Boehm-GC, and I'd hardly call that equivalent with a javascript engine. I'm not JS expert, but I'd guess the initial implementation of the RRB-tree will be slower than the immutable list for non-slice and concat use, until it's tweaked to the JS engines. I suspect it would be harder to inline and optimise for the optimising compiler. Making it optimisable may take some time (at least based on my own experience), and you probably want to not degrade immutable list performance while you do it.

So If I were you, I would probably start out having the RRB-tree be a different class, and let `slice()` and `concat()` convert the immutable lists to RRB-trees, and delegate the work to the RRB-tree implentation. The only additional change in the immutable list implementation would be that VNodes should have an additional field for RRB-tree size tables, which will by default be `null`.

Again, I don't have much knowledge and experience on how the JS engines optimises and how one would tweak JS code. Perhaps the points I bring up is of no concern at all, and for some reason the performance is equivalent from the get-go.
 @leebyron You hinted about something using `splice` and `withMutations` togetherâ€”is there some speedup to be gained in general, or is that only with repeated calls to `splice`? While I realize you won't get better than O(n), it'd be nice to [get a bit closer to a native array's performance](http://jsperf.com/immutable-list-slice-vs-array-slice-vs-conversions).
 Nevermind. #37 explains. Thanks!
 Another alternative implementation is to use AVL trees (any binary tree will do, really, but AVL trees are fast and easy to implement) where each AVL node contains a JavaScript array. Once the JavaScript array reaches a certain size, it splits it into two AVL nodes. I found through benchmarking that 125 is a good limit for the JavaScript arrays.

I wrote a library that implements immutable lists in the above manner, you can find the benchmarks here:

https://github.com/Pauan/Immutable/blob/javascript/benchmarks/List/2015-01-13

As you can see, they are quite a bit faster than Immutable-js, for most operations. I'm willing to go into more detail on their implementation, if you want.
 @Pauan in the case of Mori you're not measuring what you think you're measuring, there's a pending update to Mori which will permit performance comparisons of the actual data structures from plain JavaScript. Also your AVL tree implementation seems to come in consistently behind for random access/update in these benchmarks which is one of the value propositions for Bitmapped Array Tries. Also you're not benchmarking against transients in the Immutable.js case nor the Mori case.
 @swannodette Those are all excellent points. Once the new version of Mori comes out, I would love to re-run the benchmarks. I was actually quite disappointed when I first benchmarked Mori: I was expecting it to be faster, so an improvement there would make me happy.

Do you have any recommendations for how I can run the benchmarks better? I think my usage is pretty straight-forward: https://github.com/Pauan/Immutable/blob/javascript/src/Benchmark/List.js

I simply load up Mori as a Node.js module and use it in the typical way that I would expect a developer to do. I did the same with the other libraries.

The random access issue is a bit complicated. You are right that it is consistently slower than Immutable-js, but not by that much. In exchange for that, it has _vastly_ better performance for lots of other things, especially random inserts (which is a big part of the reason I wrote the library in the first place, I needed decent-speed random inserts). This could change if Immutable-js gets the aforementioned RRB-tree optimizations.

It's also important to note that the performance of "100 values" is misleading: as an optimization, I use cons cells for O(1) push at the end, but that means that lookup degrades to O(n) for lists with less than 125 values in them. Once it hits the 125 limit, performance jumps up significantly. You can see that with "1000 values".

In the past I have benchmarked transients (in both Immutable-js and Mori), and I found that in some cases they were slower, for bulk inserts they were generally faster, but in general they don't make a huge difference. It wasn't worth the extra time it took to benchmark them, so I took them out. But I can add them back in if you would like to see the results.

P.S. O(1) concat and slice in Mori is insane. I'm curious how that's implemented, and whether it involves some other tradeoffs or not.
 @Pauan: Slice in Mori is O(1) time because it creates a view over the original vector. In essence, it's like

``` js
function slice(vec, start, length) {
  if (isAlreadyASlice(vec)) {
    start += vec.offset;
    vec = vec.originalVector;
  }
  return {
    originalVector: vec,
    offset: start,
    length: length
  };
}
```

Totally made-up pseudocode, but conceptually, that's what is going on. So, as long as the slice lives, nothing in the original vector can be garbage collected.

I copied this behavior in [my immutable-vector implementation](https://github.com/graue/immutable-vector#vslicebegin-end), but warned about it in the docs, since it's a pretty big caveat, and can lead to memory leaks if not understood.
 @swannodette: Correct me if I'm remembering wrong or the above behavior has since changed.

As for concat, I don't remember concat in Mori being O(1), and I'm confused by the notion that it is.
 @graue your assessment of `subvec` aka `slice` in Clojure is correct. `concat` is not O(1) in Mori.
 @graue I see, I was afraid it might be something like that. Thanks for the explanation.

@graue @swannodette I mentioned Mori's concat being O(1) because in the benchmarks I showed, you can clearly see that it has O(1) behavior. I have checked, and my benchmark code appears to be correct.

Since Mori vectors don't seem to have a specialized concat function, I'm using `mori.concat`, which converts its arguments to sequences. So, when you say that Mori _doesn't_ have O(1) concat, do you mean that the concat itself is O(1), but it costs time if you want to convert back to a vector? Or do you mean that the concat itself is O(log32(n))?
 @Pauan `concat` in Mori just produces a lazy sequence so the cost is amortized.
 @swannodette Okay, cool, so it's like a concat over ES6 Iterables. Thanks for answering my many questions.
 With @swannodette's help, I updated the benchmarks to use the latest versions of Immutable-js and Mori. You can find it here:

https://github.com/Pauan/Immutable/blob/javascript/benchmarks/List/2015-01-16

Mori 0.3.2 is significantly faster than 0.2.9. Most of the speed gain comes from using fixed-arity functions in the benchmark code.

My library (_without_ transients) holds up well compared to Mori and Immutable-js (_with_ transients).

My library has _extremely_ fast concat and slice. It does not "cheat": concat and slice are not lazy, they return new Lists, and the old Lists can be garbage collected.

The price for this is a very minor loss of lookup speed: for a list with 1,000,000 elements, my library takes 13 operations to lookup a value. Mori and Immutable-js takes 4 operations.

So, if you only need to insert / remove at the end of a list, then either Mori or Immutable-js are excellent choices.

But if you want good concat / slice performance, or you need to insert at arbitrary indexes, my library offers a much faster alternative. I think the performance of AVL trees + arrays is a lot better than what most people think.

I'm curious to see if RRB-trees improve the performance of splice / concat / slice.
 @leebyron Indeed, real-world examples always trump synthetic benchmarks. But it's also much harder to find and test real-world examples.

Adding in more benchmarks for different scenarios (like interleaving read/write) is a good idea, and I might add them in at some point.

I agree, reads tend to be more frequent than writes, so optimizing for read is a good idea. But when you're trading minor read performance for multiple orders of magnitude of write performance, I think that's a good tradeoff. It will of course depend upon the particular programmer's use-cases, though.

My library also supports Tuples, for the situations where read performance is needed much more so than write performance. I think this is a good idea: a general-purpose List that's good at everything (reading, inserting, concatenating, etc.), and a more specialized data structure that can be faster for a particular operation (like reading).
 @Pauan the speedups do not come primarily from fixed arity invokes. Two things changed in ClojureScript, we no longer leak `arguments` and the standard library is compiled itself with static invokes enabled thus removing any internal overheads. Even without JS static invokes you will see Mori win out in many cases.

@leebyron while I appreciate the conservatism with wrt. micro benchmarking, let's not be disingenuous, Clojure and thus ClojureScript's many optimizations are the direct result of 7 years of observing common usage patterns in production applications.
 @swannodette I'm sure there were plenty of other optimizations, but I ran the Mori 0.3.2 benchmarks both with the `fN` functions and without. There was a speed boost even without the `fN` functions, but it was a lot less than the speed boost from using the `fN` functions.

The results I posted were with the `fN` functions.
 @Pauan btw all your Mori `slice` benches are wrong. `subvec` is the same as Immutable.js `slice`. You should correct this.

Amortization via laziness is a well know strategy it's why Clojure(Script) users have got along fine for so long without needing AVL or RRB trees. Still both are useful and thus have been available to Clojure(Script) as separate contrib libs.
 @swannodette That is intentional: my benchmark code is correct. Mori's `subvec` is lazy, while Immutable-js's `slice` is _not_ lazy: it actually constructs a new List. Comparing a lazy O(1) slice with a non-lazy slice is disingenuous and useless.

I have no problem with laziness, and lazy views are a great idea. Perhaps Immutable-js and Immutable could benefit from a lazy slice. I would probably call it something like `view` rather than `slice`.

But, currently, JavaScript's `slice` is not lazy, Immutable-js's `slice` is not lazy, and Immutable's `slice` is not lazy. So to make the comparison fair, I had to make Mori's `subvec` non-lazy. The same goes for `concat`.

There's also the issue that Mori's `subvec` leaks memory if you throw away the old vector. To prevent that, you must force the slice into an actual concrete collection, just like Immutable-js and Immutable. So it's useful to know how Mori compares to the other libraries, in that situation.

You might ask: why not have a second benchmark, for lazy slice? Because if all the libraries implemented lazy slice, they would _all_ be O(1), and there is no point in benchmarking if all the libraries are O(1).

You might ask: why not put in the benchmark anyways, even though not all the libraries have lazy slice? Because that's not fair. Not only is it not fair, it's heavily misleading to anybody who looks at the benchmarks. They would think that Mori's `subvec` is amazingly fast, but in an actual program where they force the slice, it won't be nearly as fast as on the benchmark.

Lazy slice and non-lazy slice do different things, have different behavior, and have different caveats and tradeoffs. They should be compared separately.
 @Pauab `subvec` is not lazy. Immutable.js uses our same windowing approach. Not sure where you're getting your information from. Your benchmark is wrong.
 Ah apologies it looks like the `slice` implementation has changed since I last looked. But I still think this is the typical useless benchmark that doesn't matter in practice.
 Perhaps benchmarking non-lazy slice is useless, perhaps not.

But benchmarking lazy slice is _definitely_ useless, because it's always O(1).

If you prefer, I can simply remove the `subvec` benchmark for Mori.
 @Pauan my point is that your benchmarking approach doesn't make the least bit of sense. You won't allow lazy views based on principles and then turn around and benchmark a non-equivalent O(n) operation. This is kind of thing that @leebyron was suggesting against :)
 Sounds good
 Thank you for reporting this issue and appreciate your patience. We've  notified the core team for an update on this issue. We're looking for a response within the next 30 days or the issue may be closed.
  Should the following code example log `true`? On 2.0.4 it's logging `false` for me. Am I doing something wrong?

``` coffee
vector = Immutable.Vector(1, 2, 3)
a = vector.splice(1, 1, 'a', 'b')
b = vector.withMutations (v) -> v.splice(1, 1, 'a', 'b')
console.log Immutable.is(a, b)
```
  It would be nice to add some serializable meta-information when `toJS`ing immutable data structure containing sets and ordered maps so that `fromJS` could then create correct types back. For set it's rather trivial - just add some marker like `type: '__set__'` to the object. For ordered map it's harder and the result can take more space (to include indexes somehow). So this stuff probably should be optional (e.g. enable it by passing true as an additional parameter to `toJS`/`fromJS`).
 I was just wondering about this too today. Maybe it makes sense to recommend something like transit-js for serialization though â€“ [@swannodette's blog post](http://swannodette.github.io/2014/07/30/hijacking-json/) serializes into regular JSON objects and arrays but I think it's easy to switch the tags.
 Hi, Ben. I read David's post this morning. While I like this stuff I don't think transit can replace JSON for server communication. One can't just take his REST endpoint and migrate it to another transport. Most people would stay with JSON though.
 @Tvaroh the point of my post was that the endpoint can appear to be a normal JSON even though it's actually Transit JSON. For example you could follow my post exactly and just add read/write handlers for Immutabe Sets and it will just work - Transit represents sets today as `{"~#set": [1,2,3]}` - perfectly valid JSON and no one needs to be the wiser. Ordered collection types don't present any challenges - you can install your own tag `~#orderedSet` and `~#orderedMap`, the wire rep of the data is an array so order on the read side can be preserved.

All that aside I do think this ticket is asking for something that seems outside the scope of Immutable - serialization concerns like this seems best handled elsewhere and if not by Transit by some other means.
 @swannodette sorry, I don't understand. How my Scala backend can start working with transit? Immutable provides `fromJS`/`toJS` - and I don't think it's outside of its scope to do this conversions correctly for supported types.
 @Tvaroh Scala users can use https://github.com/cognitect/transit-java for now. I've expressed the full extent of my opinion here :)
 That's what I'm talking about. Who wants to refactor REST backend to support transit?
 @Tvaroh I guess don't see what refactoring needs to be done - at least in my experience a REST backend often emits response as `.toXML` or `.toJSON` regardless of language. You can add `transit.write` to that list and in fact reuse all of your existing JSON infrastructure.

Of course a backend may not be so be clean warranting front-end _ad-hoc_ solutions as the kind suggested in this thread. That to me is a warning sign.
 Okay guys, I finally agreed. Will give transit-js a try.
  I added immutable-js to my [Javascript persistent map benchmarks ](https://github.com/mattbierner/js-hashtrie-benchmark). My initial results suggest that there is still room for improvement, especially on aggregate operations, at least on these artificial, micro benchmarks. 

Please take a look and let me know if there are any flaws with the immutable benchmarks. 

I also got a few random errors in immutable during benchmarking:

```
js-hashtrie-benchmark/node_modules/immutable/dist/Map.js:195
  BitmapIndexedNode.prototype.set=function(ownerID, shift, hash, key, value, d
                                          ^
RangeError: Maximum call stack size exceeded
```

However I could not reliably repo to collect a more detailed stack. It could be caused by incorrect library usage on my part.
 Understand that my opinion is completely subjective and based only on consuming `Map`, and not the library as a whole or any of the code.

Except for cases that specifically call for object oriented design, I feel that an OO API is a poor conceptual fit for most problems. It can lead to leaky abstractions and may cause API consumers to build code off of faulty assumptions.

It can also limit the usefulness of the library. Consider `reduce`. In Javascript and Immutable, I call reduce like this:

```
my_array.reduce(fn, initial_value);
```

But this argument order does not support common partial application uses, which limits the usefulness of  `reduce` with higher-order functions, such as composition.

```
var sum = function(a) {
     return a.reduce(function(p, c) { return p + c;}, 0);
};
```

If the API were changed to `reduce(fn, initial_value, my_array)`, we could instead write:

```
var sum = reduce.bind(null, function(p, c) { return p + c; }, 0)
```

And with a good binding order, HOFs can be used to compose together simple, partially applied operations into more complex ones:

```
var sumSquares = compose(
     map.bind(null, function(x) { return x * x; }),
    sum);
```

I personally feel that the benefits of partial application and HOFs far outweigh the convenience of method chaining and default arguments. 
 Commenting to follow this more than anything. I'm working on a persistent graph library and am seeing hamt outperform immutable by anywhere from 2 - 3.5x ops/sec. I would love to see immutable improve  - I prefer its API to the hamt API.
 Great! I tested with 2.0.12 and saw a significant speedup on most operations. Thanks!
  Fixes #31.

Previously, grouping a keyed sequence would return each group as an IndexedSequence with nonnumeric keys, which was wrong. This was caused by fromEntries returning an IndexedSequence instead of a keyed sequence. With this, fromEntries always returns a keyed sequence (which matches the type definition) and Sequence's groupBy returns the correct type. (Calling groupBy on an IndexedSequence still gives each group as an IndexedSequence, as before.)

Test Plan: jest
  After I create a IndexedSequence through filtering output, I want to get the length of the sequence such as so:

```
var provider = someObject;
var values = someObject;

var issues = values.get('issues').filter(function(issue) 
  return issue.get('provider').get('id') === provider.get('id');
});

console.log(issues.length); // This outputs undefined

console.log(issues.toJSON().length); // This outputs an actual number
```

It seems to me this has to do with lazy evaluation of sequences where toJSON trigger evaluation.

Is parsing it to JSON the correct way to output the length of this array or is there another way for evaluation to trigger.
 @leebyron Sounds good! Thanks for providing the solution, must've missed that part.
  The library has overall been great to work with but i hit trouble when trying to replace a specific item within a sequence (i have a list of immutable maps and one of the contained maps has changes and needs to be replaced in the list). Nothing quite seems to work, however:

```
> var Immutable = require('immutable');
undefined
> v = Immutable.Vector(1,2,3);
Vector [ 1, 2, 3 ]
> v2 = Immutable.Vector.from(v.splice(0,1,0))
Vector [ , ,  ]
```

v.splice() works on its own but the conversion back to vector fails.

```
> Immutable.Vector.from(v.slice(0,0).concat(v.slice(1)))
Vector [ ,  ]
```

again, works on its own but conversion back to vector fails

```
> v.slice(0,0).concat(v.slice(1))
Seq [ , , , 2, 3 ]
> Immutable.Vector.from(v.slice(0,0).concat(v.slice(1)))
Vector [ ,  ]
> Immutable.Vector(v.slice(0,0).concat(v.slice(1)))
Vector [ Seq [ , , , 2, 3 ] ]
```

same here.
 This is probably the same issue as #22. 
 duh, realized there is `list.set(index, newValue)`. however, the splicing/concat seems like it should work so i'lll leave this open regardless.
 @spicyj my bad, probably the fix just hasn't made it up to npm yet. closing as dup, will reopen if necessary.
  Example:

``` javascript
// having a set of ids
var ids = Immutable.Set('a', 'b', 'c');
// and some data
var data = Immutable.fromJS({a: {foo: 'bar'}, b: {foo: 'bar'}, c: {foo: 'bar'}})
// let's get data items by id
var items = ids.map(function (id) { return data.get(id); });
// and group them by 'foo'
var grouped = items.groupBy(function (o) { return o.get('foo'); })
// let's take the first item
var first = grouped.first();
// and to string it (notice the absence of comma between inner maps)
first.toString() // "Seq [ Map { foo: "bar" }Map { foo: "bar" }Map { foo: "bar" } ]"
// finally convert to array
first.toArray() // [undefined Ã— 3]
// 3 times undefined??? WAT
```

But if we do `items.toVector()` just before `groupBy`, this scenario seems to work correctly.

I apologize for the long description, this thing was driving me crazy...
  Fixes minor typo on line 132.

Before: Designed to inter-operate with your existing JavaScript, `immutable` accepts plain JavaScript [Array] and Objects anywhere a method expects a `Sequence` with no performance penalty.

After: Designed to inter-operate with your existing JavaScript, `immutable` accepts plain JavaScript [Arrays] and Objects anywhere a method expects a `Sequence` with no performance penalty.

This corrects the parallel structure of the clause and slightly improves readability. I'd like to propose additional changes to document grammar and syntax, if desired.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  Scala-like `sort`, `sortBy` (sort by nested value), `sortWith` (sort with custom comparator) methods would be very helpful for appropriate collections.
 @leebyron You're awesome, thanks!
  What is the preferred way to set a nested value? I see that there is `updateIn()`, which kind of does what I want, but it has two problems:
- It doesn't set new keys, it can only update already existing keys.
- It uses an extraneous function for updating. The value I want to set is independent from the original value (undefined), so I don't need any function to determine the new value.

How would you add a new key 'd' with a single line? What's the API for this?

``` js
var mutableObject = {
  test: { test2: { a:1, b:2, c:3 } }
};
var immutableObject = Immutable.fromJS(mutableObject);

// desired mutation:
// {
//   test: { test2: { a:1, b:2, c:3, d:4 } }
// );

// with mutable objects it's very simple:
mutableObject.test.test2.d = 4;

// with immutable objects it doesn't seem to be possible:
immutableObject = immutableObject.setIn(['test', 'test2', 'd'], 4); // TypeError
```
 +1

I needed to implement a wrapper around `updateIn` and `set` myself to get such functionality.
 @leebyron Ohhh, that's neat! Yes, that solves it.

I think that should be in the Readme under the _Nested Structures_ section. It wasn't obvious to me at least.
 It seems like a common enough case that it would be nice to have a convenience method baked in, possibly similar to `assoc-in`, where it would create new maps at any level where they don't already exist.
 I have a case in which I'm trying to do what the original reporter of this issue is doing: replace the value at the end of the object path with a new value. All of the parent objects already exist... I'm just replacing the leaf node. Basically:

``` javascript
newMap = oldMap.updateIn(['test1', 'test2', 'someMap'], x => newChild);
```

This is not terrible, but I'm using JavaScript... so it's really,

``` javascript
newMap = oldMap.updateIn(['test1', 'test2', 'someMap'], function(x) {
    return newChild;
});
```

which is a bit annoying. I've made a utility function for this, but it would be nicer as a built-in.
 > The main reason I haven't add this yet is that I was concerned it would be confusing in the case that one of the keys is numeric - should it create a Vector or a Map? Probably always a Map, but there may be a case where a Vector was intended but there's no way to make that happen.

That could then be handled that the "verbose" way via `updateIn`. 

I think it'd be reasonable to just follow the behavior of [assoc-in](http://clojuredocs.org/clojure_core/clojure.core/assoc-in) and create maps.
 Any updates on this? This is really useful method.
 Thanks!
 Gorgeous, Lee! :clap: 
 Awesome! I love it
 :+1: :+1: :+1: 
 @leebyron do we still need to use `newMap = oldMap.updateIn(['test1', 'test2'], x => x.set('d', 4));` to add a prop to the object or how do you do this in a "cleaner" way? 
  `count` method would be a nice addition. It's easier to read and comprehend than `reduce` used for similar purpose.

Example usage:

``` javascript
var coll = Immutable.Vector(1, 2, 3, 4);
// with count proposed
var numOds = coll.count(function (i) { return i % 2 === 1; });
// with reduce
var numOds2 = coll.reduce(function (acc, i) { return i % 2 === 1 ? acc + 1 : acc; }, 0);
```
 Java collections don't have count, they have `size()`. :) `count` in Scala seems not to create any problems to people with Java background.
 I'm not sure about leaving out the predicate. This makes `count` a duplicate of `length` but as a method. But maybe you have better idea how to reconcile it with #33.
  Adds an 's' to method on line 102 where it should be plural, change adds grammatical clarity and improves flow for the reader. Nothing else is changed:

OLD LINE: The difference for the immutable collections is that method which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection.

NEW LINE: The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
  This adds two artifacts to the build: uncompressed (development) and minimized (production). Both can be loaded with Require.js or similar and used as a global var `Immutable` in browser.

Artifacts names:
- `immutable-x.y.z.js`
- `immutable-x.y.z.min.js`

Placed to `dist/browserify`.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
 Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!
 Agree. Thanks!

Regarding support browser, node, and AMD at the same time - it's possible with uRequire. But it requires some reorganization.
 As I tested the result already works with AMD loaders (at least with require.js).
 I've been using immutable in the browser successfully thanks to this pull request! I'd attempted building it on my own with browserify, but my inexperience with the tool hindered me from getting a working version running.

Quick note: I've noticed browser consoles don't pretty print immutable data. While Node will print a vector like `Vector [ 1, 2, 3, 4, 5 ]`, Chrome prints `[undefined x 5]`.
 I also saw `[undefined x 5]` in browser. But `toString()` worked properly. @lambdahands may be you can fire an issue for that?

@leebyron what's your intent regarding this pull request? Is there something I could do?

BTW, for those interested I put Immutable builds [here](https://github.com/Tvaroh/moreartyjs/tree/master/dist) for now.
 Great!
  Currently `Map.updateIn` method is provided. But it's strange not to also have it's simpler counterpart `update` which wouldn't force to wrap single element into array.

I understand that one can `get` and `set(v)` but this is harder to read and less fluent API.
 Oh, I should say that this is about maps (will update the issue):

``` javascript
var m = Immutable.Map({ key1: 'value1', key2: 'value2', ... });
m.update('key1', function (value) { ... });
```
 Thank you. Alternatively `updateIn` could accept a string as well as an array and behave accordingly.
 Or else `update` could return a lazy seq (rules of #23 apply). This would allow such chaining:

``` javascript
var m = Immutable.Map({ key1: 'value1', key2: 'value2', ... });
var m2 = m.update('key1', function (value) { ... }).update('key1', function (value) { ... });
```

Forgive me if this is too crazy. :D
  Example:

``` javascript
var v = Immutable.Vector(1, 2, 3)
v.toString() // "Vector [ 1, 2, 3 ]"
var v2 = v.map(function (x) { return x + 1; })
v2.toString() // "Seq [ 2, 3, 4 ]"
v2.delete(0) // TypeError: undefined is not a function
```

So, one must issue `toVector()` after the transformation to get original structure type back. This is very inconvenient for a library user.

I understand this is due to laziness so possible options may be:
- provide strict versions of `map/filter/etc`;
- somehow preserve set of methods and observable behavior of the original data structure;
- provide single method replacing `toVector/toMap/etc` and allowing to get original data structure after transformation back, e.g. `force()`;
- ...
 One thing that could work is having methods on Vector always be strict but give a toSeq function for when laziness is desired? Not sure if that makes it easier to accidentally use large amounts of memory though.
 Well, in Python3 you also get generator instead of List when running filter and need to convert it explicitly. I think, explicit is better than implicit.

https://docs.python.org/3.4/library/functions.html#filter
 :+1: 
 It seems the transducer approach will be the prefered approach for transformations
 @leebyron why do you like eager behavior more than lazy? I mean, many  languages out there behave lazy: Python, Dart, Clojure. 
 I see.
  var v = Immutable.Vector(1, 2, 3 )
v.splice(0, 1).toString()
"Seq [ , , , 2, 3 ]" // oops
v.splice(1, 1).toString()
"Seq [ 1, 3 ]" // ok
v.splice(2, 1).toString()
"Seq [ 1, 2 ]" // ok
v.shift().toString()
"Vector [ 2, 3 ]" // ok
 Looks like some muddied logic around treating `seq.length` as booleany in slice or concat.
 Awesome! Thank you, Lee.
  I'm not sure if I'm overlooking something or if this is a stupid question, but... Why not use JavaScript getters?

JavaScript objects have support for getters: (works everywhere except on IE8)
- http://ejohn.org/blog/javascript-getters-and-setters/
- [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters)

Why not use them (optionally) instead of `.get()` and `.getIn()`? Especially for server-side code and for applications that aren't focusing IE8 this could be really helpful.
 @JannesMeyer AFAIK they are terribly slow. I saw a benchmark (can't find the link at the moment) and they were 10 times slower than usual approach.
 @Tvaroh At least with latest Chrome, the method-based getters are actually about 50% slower: http://jsperf.com/getter-setter/8

@leebyron Thank you! That actually makes a lot of sense.

Regarding non-string keys:
I wasn't saying that the `get()` and `getIn()` API should be replaced. I was just proposing an optional, more convenient way of doing things. Of course there should still be a more general fallback, like with JavaScript dot syntax:

``` javascript
var o = {
  'some-key': 1,
  '[another key]': 2
};

o.some-key; // ReferenceError
o['some-key']; // 1

o.[another key]; // SyntaxError
o['[another key]']; // 2
```

Almost everybody is using dot syntax to retrieve properties in the cases where it works (i.e. the key being a valid JavaScript name), because it's just more convenient.

I don't have any solution for the O(n) mutations though.
 Upon a little bit of futher research I found out, that apparently the JavaScript feature that would enable this kind of feature without impacting performance is called ["direct proxies" in ES6](http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies). To my knowledge there is no possibility of a polyfill, though. :-(

**Edit:**
Found V8's and SpiderMonkey's bug reports tracking the implementation:
[Issue 1543 - v8 - Implement Proxy proposal](https://code.google.com/p/v8/issues/detail?id=1543)
[703537 â€“ Implement Harmony direct proxies](https://bugzilla.mozilla.org/show_bug.cgi?id=703537)

Apparently SpiderMonkey almost fully implements direct proxies whereas V8 only implements an old version of the spec behind a flag. Not very useful.
 Unfortunately, without this you can't pass `Map` values to 3-rd party code. 
It breaks all of React mixins, e.g. `linkState`. Same with `List.size` instead of `List.length`...
I thought this library is proved to be compatible with React, but I was wrong. 
Perhaps I overestimate the rate of evolution :(
Any forecasts on when this might change?
 @ivan-kleshnin 

You can use `.toJS()` for most things, since the whole point of Immutable data structures is that they shouldn't be changed by outside methods.

If you want the two-way data binding from `linkState` you can use this library I made for the purpose: [reactlink-immutable](https://www.npmjs.com/package/reactlink-immutable)
 @idolize

> You can use .toJS() for most things, since the whole point of Immutable data structures is that they shouldn't be changed by outside methods. If you want the two-way data binding from linkState you can use this library I made for the purpose: reactlink-immutable

Yeah, I went that road. Then went back. Unfortunately with both ImmutableJS and Mori your datastructures begin to look very messy. The probability of bugs increases, not decreases. 
At least for me. So I switched back to native ones.

@leebyron yes unfortunately that's how it is now.
  Hi,

Could you tag each new version and preferably create a [Github release](https://help.github.com/articles/creating-releases) for it?

Then I can make [WebJars](http://www.webjars.org/documentation) for immutable-js so that JVM-based webapp projects (using Play, Spring, Grails, etc.) can easily add it as dependency without NPM.

[This grunt plugin](https://github.com/geddski/grunt-release) may help you reduce those repetitive tasks.

Thanks.
 Great, thanks!
 Any updates on that WebJar?
 Oh, sorry that I forgot this for a while due to other issues... thanks for reminding!
 And theres' a minor issue; which one do you want as the artifact's name?
1. immutable.js
2. immutable-js
3. immutable
 Created a temporary repo at https://github.com/guersam/webjars-immutable-js and will ask to publish as soon as the artifact id is fixed.
 Agreed, I removed the postfix and submitted a request. (webjars/webjars#652) Thanks for clarifying!
 This is great; I can't wait to pull this WebJar in. Thanks for work, everyone!
 Now it's available!
- Maven Central: http://search.maven.org/#artifactdetails|org.webjars|immutable|2.6.1|jar
- Github repo: https://github.com/webjars/immutable

Now everyone can send a simple pull request to keep it up to date.
 There's a minor mistake in 2.6.1 WebJar release so I opened webjars/immutable/pull/2 to release 2.6.1-1. If you don't use requirejs plugin, 2.6.1 should be fine though.
 Just FYI, you can replicate most of the functionality of `grunt-release` with `npm version`:
1. Make sure the repo is in a clean state (and `git pull` is happy).
2. `npm version` lists the current version of your module (if you forgot).
3. `npm version x.y.z` updates `package.json`, commits it with the comment "x.y.z" and tags it as `vx.y.z`.
4. `git push && git push --tags && npm publish` 

Personally I prefer the slightly more manual approach using `npm version` because it doesn't push or publish anything automatically (I have a bash alias for step 4 named `ggpublish`).
  After considerable amounts of benchmarking we've found that for small maps (<= 8 keys) a specific `PersistentArrayMap` type outperforms a full blown `PersistentHashMap`. A `PersistentArrayMap` type also has the advantage of being quickly constructed from an array a la `Immutable.Vector` - particularly handy in a deserialization context.
 (@leebyron You can see that @swannodette's transit-js does exactly that: https://github.com/cognitect/transit-js/blob/1695ab3/src/com/cognitect/transit/types.js#L490-L909.)
 :+1:
  While I see the advantage of returning a `Seq` this does not conform to the pending ES6 Map/Set proposals. Is there any reason to not return an ES6 style `Iterator` and perhaps provide a different method `keySeq`?
 @leebyron FWIW this makes immutable-js less than ideal in a serialization context as you can't iterate consistently over different map implementations - I actually ran into this today when serializing immutable-js data with transit-js. I've got a blog post forthcoming. My 2 cents, not following the ES6 spec here is just asking for trouble. Note this isn't about the entire spec, just critical operations like iteration.
 Just to demonstrate how ugly this can be :) https://github.com/cognitect/transit-js/blob/master/src/com/cognitect/transit/impl/writer.js#L181

This is a workaround only for Immutable, ES6 native maps, ES6 map shims, ClojureScript maps, and transit-js maps all work.
  Fixes #16.
  Hey, 
Immutable looks pretty cool!

While reading through the doc, I saw your merge example: 

```
var map1 = Immutable.Map({a:1, b:2, c:3, d:4});
var map2 = Immutable.Map({c:10, a:20, t:30});
var obj = {d:100, o:200, g:300};
var map3 = map1.merge(map2, obj);
// Map { a: 20, b: 2, c: 10, d: 1000, t: 30, o: 2000, g: 300 }
```

I think the resultant Map should be:

```
// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }
```

Or is the obj meant to be in thousands?

Cheers, 
Kyle
  Hi, I've noticed you use `.toJSON()` to convert to JavaScript objects. 

JSON is a data serialization format, converting it `toJSON` would have been to also call `.stringify` on it. 

The objects produced by this call are also not always valid JSON or are even encodable/decodable as JSON. 

I would recommend renaming `.toJSON`. I don't have any particularly good ideas on what to though.
 I also don't like this naming convention, but it actually has nothing to do with this library. `toJSON` is a special method that is used by `JSON.stringify` if it is available ([spec](http://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3)). Built-in objects, like `Date` [implement such a method as well](http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.5.44).
 @leebyron : This was actually more of a reply to @benjamingr :) Not sure what you mean by "hiding" in this case. The method should definitely exist to make JSON conversion easier.

I just dislike the choice of the method name in general ;)
 @fkling  but `.toJSON` expects you to return a JSON string, that's what `Date` does in the spec.. this is also what a lot of libraries do with it. Returning an object just happens to work since it'll recursively run the serialization function again.
 @benjamingr: No, `Date.prototype.toJSON` does not return a string containing JSON. It returns the value `null` or the return value of [`toISOString`](http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.5.43), which returns a string, but it doesn't contain JSON.

I'm relatively sure that `.toJSON()` is supposed to return a _JSON encodable_ value, especially given how the spec process the return value. If you were to return JSON, you would get undesired results:

``` js
var foo = [{
  toJSON: function() { return JSON.stringify({bar: 42}); }
}];
JSON.stringify(foo); // "["{\"bar\":42}"]" instead of "[{"bar":42}]"
```

Again, I don't like the naming convention either, but it's not the fault of this library.

---

Other libraries / frameworks such as Backbone.js, do the exact same thing. I was about to create an issue about that, until I realized that `.toJSON` is just messed up from start.
 It appears that you are right @fkling, this is what the proposal page says too. It's a poor naming choice.
 The name `toJSON` is confusing, but I don't think it's so bad that we need a separate method `toJS`.
 Hi, toJS is confusing to me that we are writing in JS already. A class instance with methods is still a JS object, isn't it?
   Fixed, thanks.
  â€¦while Sequence.prototype.join defaults to `','` -- intentional?
 Never mind, I'm an idiot.
  Either I am nit-picking or misunderstand the readme, but these two methods are listed as examples that would normally mutate a collection under "JavaScript-first API".
 I think @mattcasey is noting that native slice() and concat() are non-mutative, so listing them in a section that discusses "every method that would mutate the collection" isn't quite accurate.
 No, I mean .push and .slice are different in that .push modifies the original array:

```
var a = [1,2,3];
var b = a.slice(0,1);
// a = [1,2,3]; b = [1];
```

whereas

```
var a = [0,1,2];
var b = a.push(3);
// a = [1,2,3,4]; b = 4;
```

funny, just realized .push() returns the length of the new array, but I never needed that :)
 Cool, this looks like a pretty awesome library anyway! Thanks for the quick feedback.
  Maybe loosen restriction in package.json to support for Node beta?
Or is there any particular reason to keep these restrictions?
  I know built-in `Math` is an exception to this, but it's a widely accepted convention to only capitalize constructor functions, and nothing else, in user JavaScript (see [the JSHint newcap option](http://www.jshint.com/docs/options/#newcap)).

Have you considered using `immutable` instead of `Immutable` in the [documentation and examples](https://github.com/facebook/immutable-js/blob/master/README.md)?

Eg. This:

``` js
var Immutable = require('immutable');
var map = Immutable.Map({a:1, b:2, c:3});
```

Would become this:

``` js
var immutable = require('immutable');
var map = immutable.Map({a:1, b:2, c:3});
```

(etc)
 At least he didn't name it `$`. I agree that whenever a function cannot be used as a constructor is it usually named in lowercase.

This project probably uses the same naming conventions as React, which also uses this naming convention so I'd rather see this naming stay or it change in both projects together.
  The example code says `evenSquares` when the sequence defined and the given result correspond to `oddSquares`.
 Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  The readme suggest this:

```
import Immutable = require('./node_modules/immutable/dist/Immutable');
```

However, npm doesn't guarantee that the module is at that location (as it doesn't make any guarantees to the relative location of the dependency).

The correct syntax would be

```
import Immutable = require('immutable');
```

This assumes that the compiler is provided with the ambient external declaration file.
 The point is that the readme is wrong. You don't need to type the full filepath with TypeScript 1.0, if there's an ambient external declaration for the module. This is also the reason you can do stuff like

```
import express = require('express');
```

with TypeScript 1.0.

The readme's suggestion is problematic because it leads to bugs, as npm doesn't make the guarantee that you even can reliably write the full path. The reason is that the immutable module might not exist under node_modules, but rather anywhere in the node_modules hierarchy.
 I think the main issue here is that the declaration for immutable.js is not an ambient external declaration. (Although I just skimmed through the .d.ts file).

Ambient external declaration files look like this:

```
declare module 'immutable' {
    class Bar {
        bar(): void;
    }
    export = Bar;
}
```

TypeScript doesn't generate these automatically, but in another project I wrote a small script to convert TypeScript's generated definition files to ambient external declaration files.
 I've hit a similar problem related to this. Because I compile my TS code and output the JS into a subdirectory, the full path works at compile time but fails at run time (i.e. no "./node_modules/..." in my subdir.)
   Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file. In order for us to review and merge your code, please sign up at https://code.facebook.com/cla - and if you have received this in error or have any questions, please drop us a line at cla@fb.com. Thanks!
  Minor typo fix
  It points to...

https://github.com/facebook/immutable-js/blob/master/typescriptlang.org
  hi, `immutable-data` looks great! :)

i'd imagine using this with nested objects (a "store" `Map` that contains many "model" `Map`s that may contain "relational" `Map`s, `Set`s, etc). however, it appears `fromObject` and `toObject` don't support serializing and deserializing these nested objects.

``` js
var x = Im.Map.fromObject({ a: { b: { c: 1 } } });
// Map { "a": [object Object] }
x.getIn(['a','b','c'])
// undefined
x.toObject()
// { a: { b: { c: 1 }}}
```

and in reverse

``` js
var x = Im.Map.fromObject({ a: Im.Map.fromObject({ b: Im.Map.fromObject({ c: 1 }) }) })
// Map {"a": Map { "b": Map { "c": 1 } } }
x.getIn(['a','b','c'])
// 1
x.toObject()
// {a: Map { "b": Map { "c": 1 } } }
```

is this something that might be within scope of `immutable-data`?
 ah cheers!
  `asMutable` and `asImmutable`behaviour aren't immediately obvious. How about `cloneAsMutable` and `cloneAsImmutable`?

`clone` also isn't obvious and is only there to retain API parity with the mutable version of `clone`.

The first point is more than just bikeshedding the wording if, say, `cloneAsMutable` works for mutable collections. This way, you can safely remove `clone` altogether.
 I think `asImmutable` turning the same collection into an immutable one is problematic. What would be even more problematic is if, equivalently, `asMutable` turns the immutable collection into a mutable one in-place (unless you don't mind the asymmetry):

``` is
function ps(a) {return a.asMutable().push(1).push(2).push(3);}
ps(b); // Whether b was immutable or not doesn't matter here! It'll get mutated anyways. No guarantee anymore.
// Cloning would save a lot of boilerplate `is(Im)mutable` checks, and the perf optimization workflow would be literally just adding `.asMutable()` inside functions everywhere. Won't pollute the rest.
```

Clojure transient has the nice mutable vs immutable API distinction with `!`. It throws when you perform a mutable function call to an immutable collection and vice-versa. Since this library doesn't have that distinction, it's hard to tell whether `b` was mutated or not when you do a subsequent `pop` call (`pop` would conveniently throw here in Clojure: should have been `pop!` instead). This would be a non-problem if you _do_ clone on `as(Im)mutable`.

But yes, if `clone()` does stay, I think it should only be used by `as(Im)mutable` internally.
 (See also https://news.ycombinator.com/item?id=8028306.)
